<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/btree.c"><comment type="block">/*
** 2004 April 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file implements an external (disk-based) database using BTrees.
** See the header comment on "btreeInt.h" for additional information.
** Including a description of file format and an overview of operation.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btreeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** The header string that appears at the beginning of every
** SQLite database.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zMagicHeader</name><index>[]</index></name> <init>= <expr><name>SQLITE_FILE_HEADER</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Set this global variable to 1 to enable tracing using the TRACE
** macro.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
int sqlite3BtreeTrace=1;  <comment type="block">/* True to enable tracing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>if(sqlite3BtreeTrace){printf X;fflush(stdout);}</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Extract a 2-byte big-endian integer from an array of unsigned bytes.
** But if the value is zero, make it 65536.
**
** This routine is used to extract the "offset to cell content area" value
** from the header of a btree page.  If the page size is 65536 and the page
** is empty, the offset should be 65536, but the 2-byte value stores zero.
** This routine makes the necessary adjustment to 65536.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get2byteNotZero</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((((int)get2byte(X))-1)&amp;0xffff)+1)</cpp:value></cpp:define>

<comment type="block">/*
** Values passed as the 5th argument to allocateBtreePage()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTALLOC_ANY</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>           <comment type="block">/* Allocate any page */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTALLOC_EXACT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>           <comment type="block">/* Allocate exact page if possible */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTALLOC_LE</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>           <comment type="block">/* Allocate any page &lt;= the parameter */</comment>

<comment type="block">/*
** Macro IfNotOmitAV(x) returns (x) if SQLITE_OMIT_AUTOVACUUM is not 
** defined, or 0 if it is. For example:
**
**   bIncrVacuum = IfNotOmitAV(pBtShared-&gt;incrVacuum);
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IfNotOmitAV</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(expr)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IfNotOmitAV</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** A list of BtShared objects that are eligible for participation
** in shared cache.  This variable has file scope during normal builds,
** but the test harness needs to access it so we make it global for 
** test builds.
**
** Access to this variable is protected by SQLITE_MUTEX_STATIC_MAIN.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier><name>SQLITE_WSD</name></type> <name>sqlite3SharedCacheList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>BtShared</name> <modifier>*</modifier><name>SQLITE_WSD</name></type> <name>sqlite3SharedCacheList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Enable or disable the shared pager and schema features.
**
** This routine has no effect on existing database connections.
** The shared cache setting effects only future calls to
** sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_enable_shared_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>enable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>sharedCacheEnabled</name></name> <operator>=</operator> <name>enable</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifdef>
  <comment type="block">/*
  ** The functions querySharedCacheTableLock(), setSharedCacheTableLock(),
  ** and clearAllSharedCacheTableLocks()
  ** manipulate entries in the BtShared.pLock linked list used to store
  ** shared-cache table level locks. If the library is compiled with the
  ** shared-cache feature disabled, then there is only ever one user
  ** of each BtShared structure and so this locking is not necessary. 
  ** So define the lock related functions as no-ops.
  */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>querySharedCacheTableLock</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setSharedCacheTableLock</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clearAllSharedCacheTableLocks</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>downgradeAllSharedCacheTableLocks</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasSharedCacheTableLock</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasReadConflicts</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Return and reset the seek counter for a Btree object.
*/</comment>
<function><type><name>sqlite3_uint64</name></type> <name>sqlite3BtreeSeekCount</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>n</name> <init>=  <expr><name><name>pBt</name><operator>-&gt;</operator><name>nSeek</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nSeek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Implementation of the SQLITE_CORRUPT_PAGE() macro. Takes a single
** (MemPage*) as an argument. The (MemPage*) must not be NULL.
**
** If SQLITE_DEBUG is not defined, then this macro is equivalent to
** SQLITE_CORRUPT_BKPT. Or, if SQLITE_DEBUG is set, then the log message
** normally produced as a side-effect of SQLITE_CORRUPT_BKPT is augmented
** with the page number and filename associated with the (MemPage*).
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><name>int</name></type> <name>corruptPageError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"database corruption page %d of %s"</literal></expr></argument>,
      <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
</block_content>}</block></function>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_CORRUPT_PAGE</name><parameter_list>(<parameter><type><name>pMemPage</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>corruptPageError(__LINE__, pMemPage)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_CORRUPT_PAGE</name><parameter_list>(<parameter><type><name>pMemPage</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_CORRUPT_PGNO(pMemPage-&gt;pgno)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
**** This function is only used as part of an assert() statement. ***
**
** Check to see if pBtree holds the required locks to read or write to the 
** table with root page iRoot.   Return 1 if it does and 0 if not.
**
** For example, when writing to a table with root-page iRoot via 
** Btree connection pBtree:
**
**    assert( hasSharedCacheTableLock(pBtree, iRoot, 0, WRITE_LOCK) );
**
** When writing to an index that resides in a sharable database, the 
** caller should have first obtained a lock specifying the root page of
** the corresponding table. This makes things a bit more complicated,
** as this module treats each table as a separate structure. To determine
** the table corresponding to the index being written, this
** function has to search through the database schema.
**
** Instead of a lock on the table/index rooted at page iRoot, the caller may
** hold a write-lock on the schema table (root page 1). This is also
** acceptable.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasSharedCacheTableLock</name><parameter_list>(
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl></parameter>,         <comment type="block">/* Handle that must hold lock */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iRoot</name></decl></parameter>,            <comment type="block">/* Root page of b-tree */</comment>
  <parameter><decl><type><name>int</name></type> <name>isIndex</name></decl></parameter>,           <comment type="block">/* True if iRoot is the root of an index b-tree */</comment>
  <parameter><decl><type><name>int</name></type> <name>eLockType</name></decl></parameter>          <comment type="block">/* Required lock type (READ_LOCK or WRITE_LOCK) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><operator>(</operator><name>Schema</name> <operator>*</operator><operator>)</operator><name><name>pBtree</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pLock</name></decl>;</decl_stmt>

  <comment type="block">/* If this database is not shareable, or if the client is reading
  ** and has the read-uncommitted flag set, then no lock is required. 
  ** Return true immediately.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBtree</name><operator>-&gt;</operator><name>sharable</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>eLockType</name><operator>==</operator><name>READ_LOCK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ReadUncommit</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the client is reading  or writing an index and the schema is
  ** not loaded, then it is too difficult to actually check to see if
  ** the correct locks are held.  So do not bother - just return true.
  ** This case does not come up very often anyhow.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isIndex</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>pSchema</name> <operator>||</operator> <operator>(</operator><name><name>pSchema</name><operator>-&gt;</operator><name>schemaFlags</name></name><operator>&amp;</operator><name>DB_SchemaLoaded</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Figure out the root-page that the lock should be held on. For table
  ** b-trees, this is just the root page of the b-tree being read or
  ** written. For index b-trees, it is the root page of the associated
  ** table.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isIndex</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bSeen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name>iRoot</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bSeen</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Two or more indexes share the same root page.  There must
          ** be imposter tables.  So just return true.  The assert is not
          ** useful in that case. */</comment>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>tnum</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bSeen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name>iRoot</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Search for the required lock. Either a write-lock on root-page iTab, a 
  ** write-lock on the schema table, or (if the client is reading) a
  ** read-lock on iTab will suffice. Return 1 if any of these are found.  */</comment>
  <for>for<control>(<init><expr><name>pLock</name><operator>=</operator><name><name>pBtree</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</init> <condition><expr><name>pLock</name></expr>;</condition> <incr><expr><name>pLock</name><operator>=</operator><name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLock</name><operator>-&gt;</operator><name>pBtree</name></name><operator>==</operator><name>pBtree</name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLock</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iTab</name> <operator>||</operator> <operator>(</operator><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>WRITE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pLock</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator>
     <operator>&amp;&amp;</operator> <name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>eLockType</name></expr> 
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Failed to find the required lock. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
**** This function may be used as part of assert() statements only. ****
**
** Return true if it would be illegal for pBtree to write into the
** table or index rooted at iRoot because other shared connections are
** simultaneously reading that same table or index.
**
** It is illegal for pBtree to write if some other Btree object that
** shares the same BtShared object is currently reading or writing
** the iRoot table.  Except, if the other Btree object has the
** read-uncommitted flag set, then it is OK for the other object to
** have a read cursor.
**
** For example, before writing to any part of the table or index
** rooted at page iRoot, one should call:
**
**    assert( !hasReadConflicts(pBtree, iRoot) );
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasReadConflicts</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iRoot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pBtree</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><name>iRoot</name> 
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pBtree</name></name><operator>!=</operator><name>pBtree</name>
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ReadUncommit</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    <comment type="block">/* #ifdef SQLITE_DEBUG */</comment>

<comment type="block">/*
** Query to see if Btree handle p may obtain a lock of type eLock 
** (READ_LOCK or WRITE_LOCK) on the table with root-page iTab. Return
** SQLITE_OK if the lock may be obtained (by calling
** setSharedCacheTableLock()), or SQLITE_LOCKED if not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>querySharedCacheTableLock</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iTab</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <name>eLock</name><operator>==</operator><name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ReadUncommit</name><operator>)</operator><operator>||</operator><name>eLock</name><operator>==</operator><name>WRITE_LOCK</name><operator>||</operator><name>iTab</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If requesting a write-lock, then the Btree must have an open write
  ** transaction on this file. And, obviously, for this to be so there 
  ** must be an open write transaction on the file itself.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <operator>(</operator><name>p</name><operator>==</operator><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* This routine is a no-op if the shared-cache is not enabled */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If some other connection is holding an exclusive lock, the
  ** requested lock may not be obtained.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name><operator>!=</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_EXCLUSIVE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ConnectionBlocked</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_LOCKED_SHAREDCACHE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* The condition (pIter-&gt;eLock!=eLock) in the following if(...) 
    ** statement is a simplification of:
    **
    **   (eLock==WRITE_LOCK || pIter-&gt;eLock==WRITE_LOCK)
    **
    ** since we know that if eLock==WRITE_LOCK, then no other connection
    ** may hold a WRITE_LOCK on any table in this file (since there can
    ** only be a single writer).
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pBtree</name></name><operator>==</operator><name>p</name> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>READ_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>pBtree</name></name><operator>!=</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iTab</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>eLock</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ConnectionBlocked</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eLock</name><operator>==</operator><name>WRITE_LOCK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_PENDING</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_LOCKED_SHAREDCACHE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Add a lock on the table with root-page iTable to the shared-btree used
** by Btree handle p. Parameter eLock must be either READ_LOCK or 
** WRITE_LOCK.
**
** This function assumes the following:
**
**   (a) The specified Btree object p is connected to a sharable
**       database (one with the BtShared.sharable flag set), and
**
**   (b) No other Btree objects hold a lock that conflicts
**       with the requested lock (i.e. querySharedCacheTableLock() has
**       already been called and returned SQLITE_OK).
**
** SQLITE_OK is returned if the lock is added successfully. SQLITE_NOMEM 
** is returned if a malloc attempt fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>setSharedCacheTableLock</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pLock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <name>eLock</name><operator>==</operator><name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A connection with the read-uncommitted flag set will never try to
  ** obtain a read-lock using this function. The only read-lock obtained
  ** by a connection in read-uncommitted mode is on the sqlite_schema 
  ** table, and that lock is obtained in BtreeBeginTrans().  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ReadUncommit</name><operator>)</operator> <operator>||</operator> <name>eLock</name><operator>==</operator><name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This function should only be called on a sharable b-tree after it 
  ** has been determined that no other b-tree holds a conflicting lock.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OK</name><operator>==</operator><call><name>querySharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* First search the list for an existing lock on this table. */</comment>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iTable</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pBtree</name></name><operator>==</operator><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pLock</name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If the above search did not find a BtLock struct associating Btree p
  ** with table iTable, allocate one and link it into the list.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pLock</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pLock</name> <operator>=</operator> <operator>(</operator><name>BtLock</name> <operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtLock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pLock</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>pBtree</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name> <operator>=</operator> <name>pLock</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the BtLock.eLock variable to the maximum of the current lock
  ** and the requested lock. This means if a write-lock was already held
  ** and a read-lock requested, we don't incorrectly downgrade the lock.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WRITE_LOCK</name><operator>&gt;</operator><name>READ_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eLock</name><operator>&gt;</operator><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <name>eLock</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Release all the table locks (locks obtained via calls to
** the setSharedCacheTableLock() procedure) held by Btree object p.
**
** This function assumes that Btree p has an open read or write 
** transaction. If it does not, then the BTS_PENDING flag
** may be incorrectly cleared.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearAllSharedCacheTableLocks</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIter</name> <init>= <expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><operator>*</operator><name>ppIter</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>*</operator><name>ppIter</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pLock</name> <init>= <expr><operator>*</operator><name>ppIter</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_EXCLUSIVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name><operator>==</operator><name><name>pLock</name><operator>-&gt;</operator><name>pBtree</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;=</operator><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLock</name><operator>-&gt;</operator><name>pBtree</name></name><operator>==</operator><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppIter</name> <operator>=</operator> <name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <name>pLock</name><operator>==</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLock</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>ppIter</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_PENDING</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name><operator>==</operator><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTS_EXCLUSIVE</name><operator>|</operator><name>BTS_PENDING</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nTransaction</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* This function is called when Btree p is concluding its 
    ** transaction. If there currently exists a writer, and p is not
    ** that writer, then the number of locks held by connections other
    ** than the writer must be about to drop to zero. In this case
    ** set the BTS_PENDING flag to 0.
    **
    ** If there is not currently a writer, then BTS_PENDING must
    ** be zero already. So this next line is harmless in that case.
    */</comment>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_PENDING</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function changes all write-locks held by Btree p into read-locks.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>downgradeAllSharedCacheTableLocks</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name><operator>==</operator><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pLock</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTS_EXCLUSIVE</name><operator>|</operator><name>BTS_PENDING</name><operator>)</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pLock</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</init> <condition><expr><name>pLock</name></expr>;</condition> <incr><expr><name>pLock</name><operator>=</operator><name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>READ_LOCK</name> <operator>||</operator> <name><name>pLock</name><operator>-&gt;</operator><name>pBtree</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <name>READ_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>releasePage</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>;</function_decl>         <comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>releasePageOne</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>;</function_decl>      <comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>releasePageNotNull</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* Forward reference */</comment>

<comment type="block">/*
***** This routine is used inside of assert() only ****
**
** Verify that the cursor holds the mutex on its BtShared
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cursorHoldsMutex</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Verify that the cursor and the BtShared agree about what is the current
** database connetion. This is important in shared-cache mode. If the database 
** connection pointers get out-of-sync, it is possible for routines like
** btreeInitPage() to reference an stale connection pointer that references a
** a connection that has already closed.  This routine is used inside assert()
** statements only and for the purpose of double-checking that the btree code
** does keep the database connection pointers up-to-date.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cursorOwnsBtShared</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>db</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Invalidate the overflow cache of the cursor passed as the first argument.
** on the shared btree structure pBt.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>invalidateOverflowCache</name><parameter_list>(<parameter><type><name>pCur</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pCur-&gt;curFlags &amp;= ~BTCF_ValidOvfl)</cpp:value></cpp:define>

<comment type="block">/*
** Invalidate the overflow page-list cache for all cursors opened
** on the shared btree structure pBt.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidateAllOverflowCache</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>invalidateOverflowCache</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<comment type="block">/*
** This function is called before modifying the contents of a table
** to invalidate any incrblob cursors that are open on the
** row or one of the rows being modified.
**
** If argument isClearTable is true, then the entire contents of the
** table is about to be deleted. In this case invalidate all incrblob
** cursors open on any row within the table with root-page pgnoRoot.
**
** Otherwise, if argument isClearTable is false, then the row with
** rowid iRow is being replaced or deleted. In this case invalidate
** only those incrblob cursors open on that specific row.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidateIncrblobCursors</name><parameter_list>(
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl></parameter>,          <comment type="block">/* The database file to check */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgnoRoot</name></decl></parameter>,          <comment type="block">/* The table that might be changing */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iRow</name></decl></parameter>,               <comment type="block">/* The rowid that might be changing */</comment>
  <parameter><decl><type><name>int</name></type> <name>isClearTable</name></decl></parameter>        <comment type="block">/* True if all rows are being deleted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBtree</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBtree</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pBtree</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Incrblob</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBtree</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><name>pgnoRoot</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>isClearTable</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name><operator>==</operator><name>iRow</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Stub function when INCRBLOB is omitted */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>invalidateIncrblobCursors</name><parameter_list>(<parameter><type><name>w</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INCRBLOB */</comment>

<comment type="block">/*
** Set bit pgno of the BtShared.pHasContent bitvec. This is called 
** when a page that previously contained data becomes a free-list leaf 
** page.
**
** The BtShared.pHasContent bitvec exists to work around an obscure
** bug caused by the interaction of two useful IO optimizations surrounding
** free-list leaf pages:
**
**   1) When all data is deleted from a page and the page becomes
**      a free-list leaf page, the page is not written to the database
**      (as free-list leaf pages contain no meaningful data). Sometimes
**      such a page is not even journalled (as it will not be modified,
**      why bother journalling it?).
**
**   2) When a free-list leaf page is reused, its content is not read
**      from the database or written to the journal file (why should it
**      be, if it is not at all meaningful?).
**
** By themselves, these optimizations work fine and provide a handy
** performance boost to bulk delete or insert operations. However, if
** a page is moved to the free-list and then reused within the same
** transaction, a problem comes up. If the page is not journalled when
** it is moved to the free-list and it is also not journalled when it
** is extracted from the free-list and reused, then the original data
** may be lost. In the event of a rollback, it may not be possible
** to restore the database to its original configuration.
**
** The solution is the BtShared.pHasContent bitvec. Whenever a page is 
** moved to become a free-list leaf page, the corresponding bit is
** set in the bitvec. Whenever a leaf page is extracted from the free-list,
** optimization 2 above is omitted if the corresponding bit is already
** set in BtShared.pHasContent. The contents of the bitvec are cleared
** at the end of every transaction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeSetHasContent</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name><operator>&lt;=</operator><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name> <operator>=</operator> <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pgno</name><operator>&lt;=</operator><call><name>sqlite3BitvecSize</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Query the BtShared.pHasContent vector.
**
** This function is called when a free-list leaf page is removed from the
** free-list for reuse. It returns false if it is safe to retrieve the
** page from the pager layer with the 'no-content' flag set. True otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeGetHasContent</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pgno</name><operator>&gt;</operator><call><name>sqlite3BitvecSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sqlite3BitvecTestNotNull</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clear (destroy) the BtShared.pHasContent bitvec. This should be
** invoked at the conclusion of each write-transaction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeClearHasContent</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pHasContent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release all of the apPage[] pages for a cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeReleaseAllCursorPages</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The cursor passed as the only argument must point to a valid entry
** when this function is called (i.e. have eState==CURSOR_VALID). This
** function saves the current cursor key in variables pCur-&gt;nKey and
** pCur-&gt;pKey. SQLITE_OK is returned if successful or an SQLite error 
** code otherwise.
**
** If the cursor is open on an intkey table, then the integer key
** (the rowid) is stored in pCur-&gt;nKey and pCur-&gt;pKey is left set to
** NULL. If the cursor is open on a non-intkey table, then pCur-&gt;pKey is 
** set to point to a malloced buffer pCur-&gt;nKey bytes in size containing 
** the key.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>saveCursorKey</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_VALID</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Only the rowid is required for a table btree */</comment>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <call><name>sqlite3BtreeIntegerKey</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* For an index btree, save the complete key content. It is possible
    ** that the current key is corrupt. In that case, it is possible that
    ** the sqlite3VdbeRecordUnpack() function may overread the buffer by
    ** up to the size of 1 varint plus 1 8-byte value when the cursor 
    ** position is restored. Hence the 17 bytes of padding allocated 
    ** below. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <literal type="number">9</literal> <operator>+</operator> <literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pKey</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pKey</name><operator>)</operator><operator>+</operator><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <name>pKey</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name> <operator>||</operator> <operator>!</operator><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Save the current cursor position in the variables BtCursor.nKey 
** and BtCursor.pKey. The cursor's state is set to CURSOR_REQUIRESEEK.
**
** The caller must ensure that the cursor is valid (has eState==CURSOR_VALID)
** prior to calling this routine.  
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>saveCursorPosition</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_VALID</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>||</operator> <name>CURSOR_SKIPNEXT</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Pinned</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CONSTRAINT_PINNED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_SKIPNEXT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_VALID</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveCursorKey</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>btreeReleaseAllCursorPages</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_REQUIRESEEK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_ValidNKey</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>|</operator><name>BTCF_AtLast</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name> <name>SQLITE_NOINLINE</name></type> <name>saveCursorsOnList</name><parameter_list>(<parameter><decl><type><name>BtCursor</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>BtCursor</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Save the positions of all cursors (except pExcept) that are open on
** the table with root-page iRoot.  "Saving the cursor position" means that
** the location in the btree is remembered in such a way that it can be
** moved back to the same spot after the btree has been modified.  This
** routine is called just before cursor pExcept is used to modify the
** table, for example in BtreeDelete() or BtreeInsert().
**
** If there are two or more cursors on the same btree, then all such 
** cursors should have their BTCF_Multiple flag set.  The btreeCursor()
** routine enforces that rule.  This routine only needs to be called in
** the uncommon case when pExpect has the BTCF_Multiple flag set.
**
** If pExpect!=NULL and if no other cursors are found on the same root-page,
** then the BTCF_Multiple flag on pExpect is cleared, to avoid another
** pointless call to this routine.
**
** Implementation note:  This routine merely checks to see if any cursors
** need to be saved.  It calls out to saveCursorsOnList() in the (unusual)
** event that cursors are in need to being saved.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>saveAllCursors</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iRoot</name></decl></parameter>, <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pExcept</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExcept</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExcept</name><operator>-&gt;</operator><name>pBt</name></name><operator>==</operator><name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><name>pExcept</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><name>iRoot</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><name>iRoot</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>saveCursorsOnList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>, <argument><expr><name>pExcept</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExcept</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pExcept</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTCF_Multiple</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This helper routine to saveAllCursors does the actual work of saving
** the cursors if and when a cursor is found that actually requires saving.
** The common case is that no cursors need to be saved, so this routine is
** broken out from its caller to avoid unnecessary stack pointer movement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_NOINLINE</name></type> <name>saveCursorsOnList</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,         <comment type="block">/* The first cursor that needs saving */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iRoot</name></decl></parameter>,          <comment type="block">/* Only save cursor with this iRoot. Save all if zero */</comment>
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pExcept</name></decl></parameter>    <comment type="block">/* Do not save this cursor */</comment>
)</parameter_list><block>{<block_content>
  <do>do<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><name>pExcept</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><name>iRoot</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><name>iRoot</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_SKIPNEXT</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>saveCursorPosition</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>btreeReleaseAllCursorPages</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>p</name></expr> )</condition>;</do>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clear the current cursor position.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeClearCursor</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** In this version of BtreeMoveto, pKey is a packed index record
** such as is generated by the OP_MakeRecord opcode.  Unpack the
** record and then call sqlite3BtreeIndexMoveto() to do the work.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeMoveto</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,     <comment type="block">/* Cursor open on the btree to be searched */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,   <comment type="block">/* Packed key if the btree is an index */</comment>
  <parameter><decl><type><name>i64</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Integer key for tables.  Size of pKey for indices */</comment>
  <parameter><decl><type><name>int</name></type> <name>bias</name></decl></parameter>,           <comment type="block">/* Bias search to the high end */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>           <comment type="block">/* Write search results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Status code */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pIdxKey</name></decl>;</decl_stmt>   <comment type="block">/* Unpacked index key */</comment>

  <if_stmt><if>if<condition>( <expr><name>pKey</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>int</name><operator>)</operator><name>nKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxKey</name> <operator>=</operator> <call><name>sqlite3VdbeAllocUnpackedRecord</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIdxKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nKey</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>nField</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIdxKey</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIndexMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pIdxKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTableMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>bias</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Restore the cursor to the position it was in (or as close to as possible)
** when saveCursorPosition() was called. Note that this call deletes the 
** saved position info stored by saveCursorPosition(), so there can be
** at most one effective restoreCursorPosition() call after each 
** saveCursorPosition().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeRestoreCursorPosition</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>skipNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_FAULT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">410</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skipNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_INVALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>skipNext</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name> <operator>=</operator> <name>skipNext</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_SKIPNEXT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>restoreCursorPosition</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(p-&gt;eState&gt;=CURSOR_REQUIRESEEK ? \
         btreeRestoreCursorPosition(p) : \
         SQLITE_OK)</cpp:value></cpp:define>

<comment type="block">/*
** Determine whether or not a cursor has moved from the position where
** it was last placed, or has been invalidated for any other reason.
** Cursors can move when the row they are pointing at is deleted out
** from under them, for example.  Cursor might also move if a btree
** is rebalanced.
**
** Calling this routine with a NULL cursor pointer returns false.
**
** Use the separate sqlite3BtreeCursorRestore() routine to restore a cursor
** back to where it ought to be if this routine returns true.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorHasMoved</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <name>pCur</name><operator>==</operator><call><name>sqlite3BtreeFakeValidCursor</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BtCursor</name></expr></argument>, <argument><expr><name>eState</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>CURSOR_VALID</name> <operator>!=</operator> <operator>*</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pCur</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to a fake BtCursor object that will always answer
** false to the sqlite3BtreeCursorHasMoved() routine above.  The fake
** cursor returned must not be used with any other Btree interface.
*/</comment>
<function><type><name>BtCursor</name> <modifier>*</modifier></type><name>sqlite3BtreeFakeValidCursor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>u8</name></type> <name>fakeCursor</name> <init>= <expr><name>CURSOR_VALID</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BtCursor</name></expr></argument>, <argument><expr><name>eState</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>BtCursor</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>fakeCursor</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine restores a cursor back to its original position after it
** has been moved by some outside activity (such as a btree rebalance or
** a row having been deleted out from under the cursor).  
**
** On success, the *pDifferentRow parameter is false if the cursor is left
** pointing at exactly the same row.  *pDifferntRow is the row the cursor
** was pointing to has been deleted, forcing the cursor to point to some
** nearby row.
**
** This routine should only be called for a cursor that just returned
** TRUE from sqlite3BtreeCursorHasMoved().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorRestore</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pDifferentRow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDifferentRow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDifferentRow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDifferentRow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/*
** Provide hints to the cursor.  The particular hint given (and the type
** and number of the varargs parameters) is determined by the eHintType
** parameter.  See the definitions of the BTREE_HINT_* macros for details.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeCursorHint</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eHintType</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Used only by system that substitute their own storage engine */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Provide flag hints to the cursor.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeCursorHintFlags</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>BTREE_SEEK_EQ</name> <operator>||</operator> <name>x</name><operator>==</operator><name>BTREE_BULKLOAD</name> <operator>||</operator> <name>x</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>hints</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Given a page number of a regular database page, return the page
** number for the pointer-map page that contains the entry for the
** input page number.
**
** Return 0 (not a valid page) for pgno==1 since there is
** no pointer map associated with page 1.  The integrity_check logic
** requires that ptrmapPageno(*,1)!=1.
*/</comment>
<function><type><specifier>static</specifier> <name>Pgno</name></type> <name>ptrmapPageno</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPagesPerMapPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrMap</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nPagesPerMapPage</name> <operator>=</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>/</operator><literal type="number">5</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iPtrMap</name> <operator>=</operator> <operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><name>nPagesPerMapPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>iPtrMap</name><operator>*</operator><name>nPagesPerMapPage</name><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
  <if_stmt><if>if<condition>( <expr><name>ret</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ret</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write an entry into the pointer map.
**
** This routine updates the pointer map entry for page number 'key'
** so that it maps to type 'eType' and parent page number 'pgno'.
**
** If *pRC is initially non-zero (non-SQLITE_OK) then this routine is
** a no-op.  If an error occurs, the appropriate error code is written
** into *pRC.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ptrmapPut</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>eType</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl>;</decl_stmt>  <comment type="block">/* The pointer map page */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPtrmap</name></decl>;</decl_stmt>      <comment type="block">/* The pointer map data */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrmap</name></decl>;</decl_stmt>     <comment type="block">/* The pointer map page number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>       <comment type="block">/* Offset in pointer map page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>           <comment type="block">/* Return code from subfunctions */</comment>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The super-journal page number must never be used as a pointer map page */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>key</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iPtrmap</name> <operator>=</operator> <call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDbPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first byte of the extra data is the MemPage.isInit byte.
    ** If that byte is set, it means this page is also being used
    ** as a btree page. */</comment>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>ptrmap_exit</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>PTRMAP_PTROFFSET</name><argument_list>(<argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>ptrmap_exit</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPtrmap</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><name><name>pPtrmap</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>||</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPtrmap</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>parent</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"PTRMAP_UPDATE: %d-&gt;(%d,%d)\n"</literal><operator>,</operator> <name>key</name><operator>,</operator> <name>eType</name><operator>,</operator> <name>parent</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRC</name><operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPtrmap</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPtrmap</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>ptrmap_exit</name>:</label>
  <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read an entry from the pointer map.
**
** This routine retrieves the pointer map entry for page 'key', writing
** the type and parent page number to *pEType and *pPgno respectively.
** An error code is returned if something goes wrong, otherwise SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ptrmapGet</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEType</name></decl></parameter>, <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>pPgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl>;</decl_stmt>   <comment type="block">/* The pointer map page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPtrmap</name></decl>;</decl_stmt>       <comment type="block">/* Pointer map page index */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPtrmap</name></decl>;</decl_stmt>       <comment type="block">/* Pointer map page data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>        <comment type="block">/* Offset of entry in pointer map */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iPtrmap</name> <operator>=</operator> <call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDbPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pPtrmap</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>PTRMAP_PTROFFSET</name><argument_list>(<argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEType</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pEType</name> <operator>=</operator> <name><name>pPtrmap</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPgno</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pPgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPtrmap</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name><name>pEType</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>pEType</name></expr></argument>&gt;</argument_list></name><literal type="number">5</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PGNO</name><argument_list>(<argument><expr><name>iPtrmap</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if defined SQLITE_OMIT_AUTOVACUUM */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ptrmapPut</name><parameter_list>(<parameter><type><name>w</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>,<parameter><type><name>rc</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ptrmapGet</name><parameter_list>(<parameter><type><name>w</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ptrmapPutOvflPtr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>rc</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Given a btree page and a cell index (0 means the first cell on
** the page, 1 means the second cell, and so forth) return a pointer
** to the cell content.
**
** findCellPastPtr() does the same except it skips past the initial
** 4-byte child pointer found on interior pages, if there is one.
**
** This routine works only for pages that do not contain overflow cells.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>findCell</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((P)-&gt;aData + ((P)-&gt;maskPage &amp; get2byteAligned(&amp;(P)-&gt;aCellIdx[2*(I)])))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>findCellPastPtr</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((P)-&gt;aDataOfst + ((P)-&gt;maskPage &amp; get2byteAligned(&amp;(P)-&gt;aCellIdx[2*(I)])))</cpp:value></cpp:define>


<comment type="block">/*
** This is common tail processing for btreeParseCellPtr() and
** btreeParseCellPtrIndex() for the case when the cell does not fit entirely
** on a single B-tree page.  Make necessary adjustments to the CellInfo
** structure.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>btreeParseCellAdjustSizeForOverflow</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,         <comment type="block">/* Page containing the cell */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,              <comment type="block">/* Pointer to the cell text. */</comment>
  <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* If the payload will not fit completely on the local page, we have
  ** to decide how much to store locally and how much to spill onto
  ** overflow pages.  The strategy is to minimize the amount of unused
  ** space on overflow pages while keeping the amount of local storage
  ** in between minLocal and maxLocal.
  **
  ** Warning:  changing the way overflow payload is distributed in any
  ** way will result in an incompatible file format.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>minLocal</name></decl>;</decl_stmt>  <comment type="block">/* Minimum amount of payload held locally */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>maxLocal</name></decl>;</decl_stmt>  <comment type="block">/* Maximum amount of payload held locally */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>surplus</name></decl>;</decl_stmt>   <comment type="block">/* Overflow payload available for local storage */</comment>

  <expr_stmt><expr><name>minLocal</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>maxLocal</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>surplus</name> <operator>=</operator> <name>minLocal</name> <operator>+</operator> <operator>(</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name> <operator>-</operator> <name>minLocal</name><operator>)</operator><operator>%</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>surplus</name><operator>==</operator><name>maxLocal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>surplus</name><operator>==</operator><name>maxLocal</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>surplus</name> <operator>&lt;=</operator> <name>maxLocal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>surplus</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>minLocal</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pPayload</name><index>[<expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name></expr>]</index></name> <operator>-</operator> <name>pCell</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given a record with nPayload bytes of payload stored within btree
** page pPage, return the number of bytes of payload stored locally.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreePayloadToLocal</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nPayload</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>maxLocal</name></decl>;</decl_stmt>  <comment type="block">/* Maximum amount of payload held locally */</comment>
  <expr_stmt><expr><name>maxLocal</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;=</operator><name>maxLocal</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>nPayload</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>minLocal</name></decl>;</decl_stmt>  <comment type="block">/* Minimum amount of payload held locally */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>surplus</name></decl>;</decl_stmt>   <comment type="block">/* Overflow payload available for local storage */</comment>
    <expr_stmt><expr><name>minLocal</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>surplus</name> <operator>=</operator> <name>minLocal</name> <operator>+</operator> <operator>(</operator><name>nPayload</name> <operator>-</operator> <name>minLocal</name><operator>)</operator><operator>%</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator> <name>surplus</name> <operator>&lt;=</operator> <name>maxLocal</name> <operator>)</operator></expr> ?</condition><then> <expr><name>surplus</name></expr> </then><else>: <expr><name>minLocal</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following routines are implementations of the MemPage.xParseCell()
** method.
**
** Parse a cell content block and fill in the CellInfo structure.
**
** btreeParseCellPtr()        =&gt;   table btree leaf nodes
** btreeParseCellNoPayload()  =&gt;   table btree internal nodes
** btreeParseCellPtrIndex()   =&gt;   index btree nodes
**
** There is also a wrapper function btreeParseCell() that works for
** all MemPage types and that references the cell by index rather than
** by pointer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeParseCellPtrNoPayload</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,         <comment type="block">/* Page containing the cell */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,              <comment type="block">/* Pointer to the cell text. */</comment>
  <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifndef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <call><name>getVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pPayload</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeParseCellPtr</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,         <comment type="block">/* Page containing the cell */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,              <comment type="block">/* Pointer to the cell text. */</comment>
  <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>              <comment type="block">/* For scanning through pCell */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPayload</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes of cell payload */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>iKey</name></decl>;</decl_stmt>               <comment type="block">/* Extracted Key value */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>

  <comment type="block">/* The next block of code is equivalent to:
  **
  **     pIter += getVarint32(pIter, nPayload);
  **
  ** The code is inlined to avoid a function call.
  */</comment>
  <expr_stmt><expr><name>nPayload</name> <operator>=</operator> <operator>*</operator><name>pIter</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nPayload</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>nPayload</name> <operator>=</operator> <operator>(</operator><name>nPayload</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><operator>++</operator><name>pIter</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>*</operator><name>pIter</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>pIter</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* The next block of code is equivalent to:
  **
  **     pIter += getVarint(pIter, (u64*)&amp;pInfo-&gt;nKey);
  **
  ** The code is inlined and the loop is unrolled for performance.
  ** This routine is a high-runner.
  */</comment>
  <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>*</operator><name>pIter</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iKey</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>iKey</name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator><operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
                  <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><name>iKey</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><operator>++</operator><name>pIter</name><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name> <operator>=</operator> <name>nPayload</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pPayload</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPayload</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPayload</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is the (easy) common case where the entire payload fits
    ** on the local page.  No overflow is required.
    */</comment>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name>nPayload</name> <operator>+</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nPayload</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>btreeParseCellAdjustSizeForOverflow</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeParseCellPtrIndex</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,         <comment type="block">/* Page containing the cell */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,              <comment type="block">/* Pointer to the cell text. */</comment>
  <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>              <comment type="block">/* For scanning through pCell */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPayload</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes of cell payload */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name>pCell</name> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPayload</name> <operator>=</operator> <operator>*</operator><name>pIter</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nPayload</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>nPayload</name> <operator>=</operator> <operator>(</operator><name>nPayload</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><operator>++</operator><name>pIter</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>*</operator><operator>(</operator><name>pIter</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>pIter</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <name>nPayload</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name> <operator>=</operator> <name>nPayload</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pPayload</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPayload</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPayload</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is the (easy) common case where the entire payload fits
    ** on the local page.  No overflow is required.
    */</comment>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name>nPayload</name> <operator>+</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nPayload</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>btreeParseCellAdjustSizeForOverflow</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeParseCell</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,         <comment type="block">/* Page containing the cell */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,              <comment type="block">/* The cell index.  First cell is 0 */</comment>
  <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following routines are implementations of the MemPage.xCellSize
** method.
**
** Compute the total number of bytes that a Cell needs in the cell
** data area of the btree-page.  The return number includes the cell
** data header and the local payload, but not any overflow page or
** the space used by the cell pointer.
**
** cellSizePtrNoPayload()    =&gt;   table internal nodes
** cellSizePtrTableLeaf()    =&gt;   table leaf nodes
** cellSizePtr()             =&gt;   all index nodes &amp; table leaf nodes
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>cellSizePtr</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><name>pCell</name> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* For looping over bytes of pCell */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>                                <comment type="block">/* End mark for a varint */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nSize</name></decl>;</decl_stmt>                               <comment type="block">/* Size value to return */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The value returned by this function should always be the same as
  ** the (CellInfo.nSize) value found by doing a full parse of the
  ** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of
  ** this function verifies that this invariant is not violated. */</comment>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>debuginfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>debuginfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>nSize</name> <operator>=</operator> <operator>*</operator><name>pIter</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pIter</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSize</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <operator>(</operator><name>nSize</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><operator>++</operator><name>pIter</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>*</operator><operator>(</operator><name>pIter</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>pIter</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nSize</name> <operator>+=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nSize</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>minLocal</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>minLocal</name> <operator>+</operator> <operator>(</operator><name>nSize</name> <operator>-</operator> <name>minLocal</name><operator>)</operator> <operator>%</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&gt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>minLocal</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nSize</name> <operator>+=</operator> <literal type="number">4</literal> <operator>+</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><name><name>debuginfo</name><operator>.</operator><name>nSize</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>u16</name><operator>)</operator><name>nSize</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>cellSizePtrNoPayload</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><name>pCell</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* For looping over bytes of pCell */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>              <comment type="block">/* End mark for a varint */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The value returned by this function should always be the same as
  ** the (CellInfo.nSize) value found by doing a full parse of the
  ** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of
  ** this function verifies that this invariant is not violated. */</comment>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>debuginfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>debuginfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name>pIter</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>pIter</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>debuginfo</name><operator>.</operator><name>nSize</name></name><operator>==</operator><operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>cellSizePtrTableLeaf</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><name>pCell</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* For looping over bytes of pCell */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>            <comment type="block">/* End mark for a varint */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nSize</name></decl>;</decl_stmt>           <comment type="block">/* Size value to return */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The value returned by this function should always be the same as
  ** the (CellInfo.nSize) value found by doing a full parse of the
  ** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of
  ** this function verifies that this invariant is not violated. */</comment>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>debuginfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>debuginfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>nSize</name> <operator>=</operator> <operator>*</operator><name>pIter</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pIter</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSize</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <operator>(</operator><name>nSize</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><operator>++</operator><name>pIter</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>*</operator><operator>(</operator><name>pIter</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>pIter</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>
  <comment type="block">/* pIter now points at the 64-bit integer key value, a variable length 
  ** integer. The following block moves pIter to point at the first byte
  ** past the end of the key value. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pIter</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nSize</name> <operator>+=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nSize</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>minLocal</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>minLocal</name> <operator>+</operator> <operator>(</operator><name>nSize</name> <operator>-</operator> <name>minLocal</name><operator>)</operator> <operator>%</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&gt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>minLocal</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nSize</name> <operator>+=</operator> <literal type="number">4</literal> <operator>+</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSize</name><operator>==</operator><name><name>debuginfo</name><operator>.</operator><name>nSize</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>u16</name><operator>)</operator><name>nSize</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/* This variation on cellSizePtr() is used inside of assert() statements
** only. */</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>cellSize</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** The cell pCell is currently part of page pSrc but will ultimately be part
** of pPage.  (pSrc and pPage are often the same.)  If pCell contains a
** pointer to an overflow page, insert an entry into the pointer-map for
** the overflow page that will be valid after pCell has been moved to pPage.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ptrmapPutOvflPtr</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCell</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>info</name><operator>.</operator><name>nLocal</name></name><operator>&lt;</operator><name><name>info</name><operator>.</operator><name>nPayload</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>ovfl</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>pCell</name><operator>+</operator><name><name>info</name><operator>.</operator><name>nLocal</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>ovfl</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><name><name>info</name><operator>.</operator><name>nSize</name></name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>ovfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW1</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><name>pRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Defragment the page given. This routine reorganizes cells within the
** page so that there are no free-blocks on the free-block list.
**
** Parameter nMaxFrag is the maximum amount of fragmented space that may be
** present in the page after this routine returns.
**
** EVIDENCE-OF: R-44582-60138 SQLite may from time to time reorganize a
** b-tree page so that there are no freeblocks or fragment bytes, all
** unused bytes are contained in the unallocated space region, and all
** cells are packed tightly at the end of the page.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>defragmentPage</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMaxFrag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>                    <comment type="block">/* Address of the i-th cell */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>                   <comment type="block">/* Offset to the page header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>                  <comment type="block">/* Size of a cell */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>            <comment type="block">/* Number of usable bytes on a page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellOffset</name></decl>;</decl_stmt>            <comment type="block">/* Offset to the cell pointer array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cbrk</name></decl>;</decl_stmt>                  <comment type="block">/* Offset to the cell content area */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                 <comment type="block">/* Number of cells on the page */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>       <comment type="block">/* The page data */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>       <comment type="block">/* Temp area for cell content */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>        <comment type="block">/* Source of content */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellFirst</name></decl>;</decl_stmt>            <comment type="block">/* First allowable cell index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellLast</name></decl>;</decl_stmt>             <comment type="block">/* Last possible cell index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellStart</name></decl>;</decl_stmt>            <comment type="block">/* First cell offset in input */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>&lt;=</operator> <name>SQLITE_MAX_PAGE_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cellOffset</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>==</operator><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellFirst</name> <operator>=</operator> <name>cellOffset</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>nCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>usableSize</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>;</expr_stmt>

  <comment type="block">/* This block handles pages with two or fewer free blocks and nMaxFrag
  ** or fewer fragmented bytes. In this case it is faster to move the
  ** two (or one) blocks of cells using memmove() and add the required
  ** offsets to each pointer in the cell-pointer array than it is to 
  ** reconstruct the entire page.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name><operator>&lt;=</operator><name>nMaxFrag</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iFree</name> <init>= <expr><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>&gt;</operator><name>usableSize</name><operator>-</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFree</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iFree2</name> <init>= <expr><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFree</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iFree2</name><operator>&gt;</operator><name>usableSize</name><operator>-</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>iFree2</name> <operator>||</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>iFree2</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>iFree2</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellOffset</name> <operator>+</operator> <name>nCell</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pAddr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFree</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>top</name><operator>&gt;=</operator><name>iFree</name></expr> )</condition><block>{<block_content>
          <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iFree2</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>+</operator><name>sz</name><operator>&gt;</operator><name>iFree2</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>sz2</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFree2</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iFree2</name><operator>+</operator><name>sz2</name> <operator>&gt;</operator> <name>usableSize</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFree</name><operator>+</operator><name>sz</name><operator>+</operator><name>sz2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFree</name><operator>+</operator><name>sz</name></expr>]</index></name></expr></argument>, <argument><expr><name>iFree2</name><operator>-</operator><operator>(</operator><name>iFree</name><operator>+</operator><name>sz</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>sz2</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iFree</name><operator>+</operator><name>sz</name><operator>&gt;</operator><name>usableSize</name></expr> )</condition><block>{<block_content>
          <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>cbrk</name> <operator>=</operator> <name>top</name><operator>+</operator><name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cbrk</name><operator>+</operator><operator>(</operator><name>iFree</name><operator>-</operator><name>top</name><operator>)</operator> <operator>&lt;=</operator> <name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>top</name></expr>]</index></name></expr></argument>, <argument><expr><name>iFree</name><operator>-</operator><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>pAddr</name><operator>=</operator><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellOffset</name></expr>]</index></name></expr>;</init> <condition><expr><name>pAddr</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pAddr</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pc</name><operator>&lt;</operator><name>iFree</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>, <argument><expr><name>pc</name><operator>+</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <if type="elseif">else if<condition>( <expr><name>pc</name><operator>&lt;</operator><name>iFree2</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>, <argument><expr><name>pc</name><operator>+</operator><name>sz2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <goto>goto <name>defragment_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>cbrk</name> <operator>=</operator> <name>usableSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellLast</name> <operator>=</operator> <name>usableSize</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellStart</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nCell</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>sqlite3PagerTempSpace</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>temp</name><index>[<expr><name>iCellStart</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iCellStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>usableSize</name> <operator>-</operator> <name>iCellStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pAddr</name></decl>;</decl_stmt>     <comment type="block">/* The i-th cell pointer */</comment>
      <expr_stmt><expr><name>pAddr</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellOffset</name> <operator>+</operator> <name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>==</operator><name>iCellFirst</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>==</operator><name>iCellLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* These conditions have already been verified in btreeInitPage()
      ** if PRAGMA cell_size_check=ON.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pc</name><argument_list type="generic">&lt;<argument><expr><name>iCellStart</name> <operator>||</operator> <name>pc</name></expr></argument>&gt;</argument_list></name><name>iCellLast</name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pc</name><operator>&gt;=</operator><name>iCellStart</name> <operator>&amp;&amp;</operator> <name>pc</name><operator>&lt;=</operator><name>iCellLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cbrk</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cbrk</name><argument_list type="generic">&lt;<argument><expr><name>iCellStart</name> <operator>||</operator> <name>pc</name><operator>+</operator><name>size</name></expr></argument>&gt;</argument_list></name><name>usableSize</name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cbrk</name><operator>+</operator><name>size</name><operator>&lt;=</operator><name>usableSize</name> <operator>&amp;&amp;</operator> <name>cbrk</name><operator>&gt;=</operator><name>iCellStart</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>cbrk</name><operator>+</operator><name>size</name><operator>==</operator><name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>+</operator><name>size</name><operator>==</operator><name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>, <argument><expr><name>cbrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>defragment_out</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name><operator>+</operator><name>cbrk</name><operator>-</operator><name>iCellFirst</name><operator>!=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cbrk</name><operator>&gt;=</operator><name>iCellFirst</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>cbrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iCellFirst</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cbrk</name><operator>-</operator><name>iCellFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search the free-list on page pPg for space to store a cell nByte bytes in
** size. If one can be found, return a pointer to the space and remove it
** from the free-list.
**
** If no suitable space can be found on the free-list, return NULL.
**
** This function may detect corruption within pPg.  If corruption is
** detected then *pRc is set to SQLITE_CORRUPT and NULL is returned.
**
** Slots on the free list that are between 1 and 3 bytes larger than nByte
** will be ignored if adding the extra space to the fragmentation count
** causes the fragmentation count to exceed 60.
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name> <modifier>*</modifier></type><name>pageFindSlot</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hdr</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Offset to page header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>aData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Page data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name> <init>= <expr><name>hdr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Address of ptr to pc */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iAddr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Temporary ptr into aData[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><call><name>get2byte</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Address of a free slot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>                                     <comment type="block">/* Excess size of the slot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>maxPC</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <name>nByte</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Max address for a usable slot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>                                  <comment type="block">/* Size of the free slot */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pc</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pc</name><operator>&lt;=</operator><name>maxPC</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-22710-53328 The third and fourth bytes of each
    ** freeblock form a big-endian integer which is the size of the freeblock
    ** in bytes, including the 4-byte header. */</comment>
    <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aData</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>x</name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>nByte</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-11498-58022 In a well-formed b-tree page, the total
        ** number of bytes in fragments may not exceed 60. */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">57</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Remove the slot from the free-list. Update the number of
        ** fragmented bytes within the page. */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iAddr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
        <return>return <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>pc</name></expr>]</index></name></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>+</operator><name>pc</name> <operator>&gt;</operator> <name>maxPC</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This slot extends off the end of the usable part of the page */</comment>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* The slot remains on the free-list. Reduce its size to account
        ** for the portion used by the new allocation. */</comment>
        <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>pc</name> <operator>+</operator> <name>x</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iAddr</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aData</name><index>[<expr><name>pc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pc</name><operator>&lt;=</operator><name>iAddr</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pc</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The next slot in the chain comes before the current slot */</comment>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pc</name><operator>&gt;</operator><name>maxPC</name><operator>+</operator><name>nByte</name><operator>-</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The free slot chain extends off the end of the page */</comment>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate nByte bytes of space from within the B-Tree page passed
** as the first argument. Write into *pIdx the index into pPage-&gt;aData[]
** of the first byte of allocated space. Return either SQLITE_OK or
** an error code (usually SQLITE_CORRUPT).
**
** The caller guarantees that there is sufficient space to make the
** allocation.  This routine might need to defragment in order to bring
** all the space together, however.  This routine will avoid using
** the first two bytes past the cell pointer area since presumably this
** allocation is being made in order to insert a new cell, so we will
** also end up needing a new cell pointer.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>allocateSpace</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hdr</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Local cache of pPage-&gt;hdrOffset */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>data</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Local cache of pPage-&gt;aData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>                             <comment type="block">/* First byte of cell content area */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Integer return code */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>                            <comment type="block">/* Temp ptr into data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>gap</name></decl>;</decl_stmt>        <comment type="block">/* First byte of gap between cell pointers and cell content */</comment>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Minimum cell size is 4 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">8</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>==</operator> <name>hdr</name> <operator>+</operator> <literal type="number">12</literal> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>gap</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>gap</name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-29356-02391 If the database uses a 65536-byte page size
  ** and the reserved space is zero (the usual value for reserved space)
  ** then the cell content offset of an empty page wants to be 65536.
  ** However, that integer is too large to be stored in a 2-byte unsigned
  ** integer, so a value of 0 is used in its place. */</comment>
  <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>top</name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* by btreeComputeFreeSpace() */</comment>
  <if_stmt><if>if<condition>( <expr><name>gap</name><operator>&gt;</operator><name>top</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>top</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>==</operator><literal type="number">65536</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there is enough space between gap and top for one more cell pointer,
  ** and if the freelist is not empty, then search the
  ** freelist looking for a slot big enough to satisfy the request.
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>gap</name><operator>+</operator><literal type="number">2</literal><operator>==</operator><name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>gap</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>gap</name><operator>==</operator><name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>||</operator> <name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>gap</name><operator>+</operator><literal type="number">2</literal><operator>&lt;=</operator><name>top</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSpace</name> <init>= <expr><call><name>pageFindSlot</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSpace</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>g2</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSpace</name><operator>+</operator><name>nByte</name><operator>&lt;=</operator><name>data</name><operator>+</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pIdx</name> <operator>=</operator> <name>g2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pSpace</name><operator>-</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>g2</name><operator>&lt;=</operator><name>gap</name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The request could not be fulfilled using a freelist slot.  Check
  ** to see if defragmentation is necessary.
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>gap</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nByte</name><operator>==</operator><name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>gap</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nByte</name><operator>&gt;</operator><name>top</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>defragmentPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>-</operator> <operator>(</operator><literal type="number">2</literal><operator>+</operator><name>nByte</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>get2byteNotZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>gap</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nByte</name><operator>&lt;=</operator><name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* Allocate memory from the gap in between the cell pointer array
  ** and the cell content area.  The btreeComputeFreeSpace() call has already
  ** validated the freelist.  Given that the freelist is valid, there
  ** is no way that the allocation can extend off the end of the page.
  ** The assert() below verifies the previous sentence.
  */</comment>
  <expr_stmt><expr><name>top</name> <operator>-=</operator> <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>top</name><operator>+</operator><name>nByte</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pIdx</name> <operator>=</operator> <name>top</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a section of the pPage-&gt;aData to the freelist.
** The first byte of the new free block is pPage-&gt;aData[iStart]
** and the size of the block is iSize bytes.
**
** Adjacent freeblocks are coalesced.
**
** Even though the freeblock list was checked by btreeComputeFreeSpace(),
** that routine will not detect overlap between cells or freeblocks.  Nor
** does it detect cells or freeblocks that encrouch into the reserved bytes
** at the end of the page.  So do additional corruption checks inside this
** routine and return SQLITE_CORRUPT if any problems are found.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>freeSpace</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>iSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>iPtr</name></decl>;</decl_stmt>                             <comment type="block">/* Address of ptr to next freeblock */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>iFreeBlk</name></decl>;</decl_stmt>                         <comment type="block">/* Address of the next freeblock */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hdr</name></decl>;</decl_stmt>                               <comment type="block">/* Page header size.  0 or 100 */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nFrag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                         <comment type="block">/* Reduction in fragmentation */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>iOrigSize</name> <init>= <expr><name>iSize</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Original value of iSize */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>x</name></decl>;</decl_stmt>                                <comment type="block">/* Offset to cell content area */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iEnd</name> <init>= <expr><name>iStart</name> <operator>+</operator> <name>iSize</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* First byte past the iStart buffer */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Page content */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>                             <comment type="block">/* Temporary ptr into data[] */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name>iStart</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">6</literal><operator>+</operator><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name>iEnd</name> <operator>&lt;=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSize</name><operator>&gt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Minimum cell size is 4 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStart</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The list of freeblocks must be in ascending order.  Find the 
  ** spot on the list where iStart should be inserted.
  */</comment>
  <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name>hdr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>data</name><index>[<expr><name>iPtr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>iPtr</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iFreeBlk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Shortcut for the case when the freelist is empty */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><name>iFreeBlk</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;</operator><name>iStart</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iFreeBlk</name><operator>&lt;=</operator><name>iPtr</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iFreeBlk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* TH3: corrupt082.100 */</comment>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name>iFreeBlk</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>iFreeBlk</name><operator>&gt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content> <comment type="block">/* TH3: corrupt081.100 */</comment>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFreeBlk</name><operator>&gt;</operator><name>iPtr</name> <operator>||</operator> <name>iFreeBlk</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* At this point:
    **    iFreeBlk:   First freeblock after iStart, or zero if none
    **    iPtr:       The address of a pointer to iFreeBlk
    **
    ** Check to see if iFreeBlk should be coalesced onto the end of iStart.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>iFreeBlk</name> <operator>&amp;&amp;</operator> <name>iEnd</name><operator>+</operator><literal type="number">3</literal><operator>&gt;=</operator><name>iFreeBlk</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nFrag</name> <operator>=</operator> <name>iFreeBlk</name> <operator>-</operator> <name>iEnd</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>&gt;</operator><name>iFreeBlk</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>iFreeBlk</name> <operator>+</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFreeBlk</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iEnd</name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iSize</name> <operator>=</operator> <name>iEnd</name> <operator>-</operator> <name>iStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFreeBlk</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iFreeBlk</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If iPtr is another freeblock (that is, if iPtr is not the freelist
    ** pointer in the page header) then check to see if iStart should be
    ** coalesced onto the end of iPtr.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>iPtr</name><operator>&gt;</operator><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPtrEnd</name> <init>= <expr><name>iPtr</name> <operator>+</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iPtr</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPtrEnd</name><operator>+</operator><literal type="number">3</literal><operator>&gt;=</operator><name>iStart</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPtrEnd</name><operator>&gt;</operator><name>iStart</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nFrag</name> <operator>+=</operator> <name>iStart</name> <operator>-</operator> <name>iPtrEnd</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iSize</name> <operator>=</operator> <name>iEnd</name> <operator>-</operator> <name>iPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>iPtr</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFrag</name><operator>&gt;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>-=</operator> <name>nFrag</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iStart</name><operator>&lt;=</operator><name>x</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The new freeblock is at the beginning of the cell content area,
    ** so just extend the cell content area rather than create another
    ** freelist entry */</comment>
    <if_stmt><if>if<condition>( <expr><name>iStart</name><operator>&lt;</operator><name>x</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPtr</name><operator>!=</operator><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iFreeBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Insert the new freeblock into the freelist */</comment>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_FAST_SECURE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Overwrite deleted information with zeros when the secure_delete
    ** option is enabled */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>iFreeBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>iStart</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>+=</operator> <name>iOrigSize</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode the flags byte (the first byte of the header) for a page
** and initialize fields of the MemPage structure accordingly.
**
** Only the following combinations are supported.  Anything different
** indicates a corrupt database files:
**
**         PTF_ZERODATA                             (0x02,  2)
**         PTF_LEAFDATA | PTF_INTKEY                (0x05,  5)
**         PTF_ZERODATA | PTF_LEAF                  (0x0a, 10)
**         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF     (0x0d, 13)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decodeFlags</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flagByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>     <comment type="block">/* A copy of pPage-&gt;pBt */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>==</operator><operator>(</operator><ternary><condition><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>max1bytePayload</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>max1bytePayload</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flagByte</name><operator>&gt;=</operator><operator>(</operator><name>PTF_ZERODATA</name> <operator>|</operator> <name>PTF_LEAF</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flagByte</name><operator>==</operator><operator>(</operator><name>PTF_LEAFDATA</name> <operator>|</operator> <name>PTF_INTKEY</name> <operator>|</operator> <name>PTF_LEAF</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name> <operator>=</operator> <name>cellSizePtrTableLeaf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name> <operator>=</operator> <name>btreeParseCellPtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>maxLeaf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>minLeaf</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flagByte</name><operator>==</operator><operator>(</operator><name>PTF_ZERODATA</name> <operator>|</operator> <name>PTF_LEAF</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name> <operator>=</operator> <name>cellSizePtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name> <operator>=</operator> <name>btreeParseCellPtrIndex</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>minLocal</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name> <operator>=</operator> <name>cellSizePtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name> <operator>=</operator> <name>btreeParseCellPtrIndex</name></expr>;</expr_stmt>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flagByte</name><operator>==</operator><operator>(</operator><name>PTF_ZERODATA</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name> <operator>=</operator> <name>cellSizePtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name> <operator>=</operator> <name>btreeParseCellPtrIndex</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>minLocal</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flagByte</name><operator>==</operator><operator>(</operator><name>PTF_LEAFDATA</name> <operator>|</operator> <name>PTF_INTKEY</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name> <operator>=</operator> <name>cellSizePtrNoPayload</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name> <operator>=</operator> <name>btreeParseCellPtrNoPayload</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>maxLeaf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>minLeaf</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name> <operator>=</operator> <name>cellSizePtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name> <operator>=</operator> <name>btreeParseCellPtrIndex</name></expr>;</expr_stmt>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute the amount of freespace on the page.  In other words, fill
** in the pPage-&gt;nFree field.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeComputeFreeSpace</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>            <comment type="block">/* Address of a freeblock within pPage-&gt;aData[] */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hdr</name></decl>;</decl_stmt>            <comment type="block">/* Offset to beginning of page header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>          <comment type="block">/* Equal to pPage-&gt;aData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>    <comment type="block">/* Amount of usable space on each page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFree</name></decl>;</decl_stmt>         <comment type="block">/* Number of unused bytes on the page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>           <comment type="block">/* First byte of the cell content area */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellFirst</name></decl>;</decl_stmt>    <comment type="block">/* First allowable cell or freeblock offset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellLast</name></decl>;</decl_stmt>     <comment type="block">/* Last possible cell or freeblock offset */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><call><name>sqlite3PagerPagenumber</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name> <operator>==</operator> <call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>==</operator> <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>usableSize</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-58015-48175 The two-byte integer at offset 5 designates
  ** the start of the cell content area. A zero value for this integer is
  ** interpreted as 65536. */</comment>
  <expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>get2byteNotZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellFirst</name> <operator>=</operator> <name>hdr</name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellLast</name> <operator>=</operator> <name>usableSize</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>

  <comment type="block">/* Compute the total free space on the page
  ** EVIDENCE-OF: R-23588-34450 The two-byte integer at offset 1 gives the
  ** start of the first freeblock on the page, or is zero if there are no
  ** freeblocks. */</comment>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFree</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <name>top</name></expr>;</expr_stmt>  <comment type="block">/* Init nFree to non-freeblock free space */</comment>
  <if_stmt><if>if<condition>( <expr><name>pc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>next</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pc</name><operator>&lt;</operator><name>top</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-55530-52930 In a well-formed b-tree page, there will
      ** always be at least one cell before the first freeblock.
      */</comment>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return> 
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pc</name><operator>&gt;</operator><name>iCellLast</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Freeblock off the end of the page */</comment>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nFree</name> <operator>=</operator> <name>nFree</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>next</name><operator>&lt;=</operator><name>pc</name><operator>+</operator><name>size</name><operator>+</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>next</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Freeblock not in ascending order */</comment>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pc</name><operator>+</operator><name>size</name><operator>&gt;</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>usableSize</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Last freeblock extends past page end */</comment>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* At this point, nFree contains the sum of the offset to the start
  ** of the cell-content area plus the number of free bytes within
  ** the cell-content area. If this is greater than the usable-size
  ** of the page, then the page must be corrupted. This check also
  ** serves to verify that the offset to the start of the cell-content
  ** area, according to the page header, lies within the page.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nFree</name><operator>&gt;</operator><name>usableSize</name> <operator>||</operator> <name>nFree</name><operator>&lt;</operator><name>iCellFirst</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>nFree</name> <operator>-</operator> <name>iCellFirst</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do additional sanity check after btreeInitPage() if
** PRAGMA cell_size_check=ON 
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>btreeCellSizeCheck</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellFirst</name></decl>;</decl_stmt>    <comment type="block">/* First allowable cell or freeblock offset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellLast</name></decl>;</decl_stmt>     <comment type="block">/* Last possible cell or freeblock offset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Index into the cell pointer array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>            <comment type="block">/* Size of a cell */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>            <comment type="block">/* Address of a freeblock within pPage-&gt;aData[] */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>          <comment type="block">/* Equal to pPage-&gt;aData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>    <comment type="block">/* Maximum usable space on the page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellOffset</name></decl>;</decl_stmt>    <comment type="block">/* Start of cell content area */</comment>

  <expr_stmt><expr><name>iCellFirst</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>usableSize</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellLast</name> <operator>=</operator> <name>usableSize</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cellOffset</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCellLast</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byteAligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellOffset</name><operator>+</operator><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>==</operator><name>iCellFirst</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>==</operator><name>iCellLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pc</name><argument_list type="generic">&lt;<argument><expr><name>iCellFirst</name> <operator>||</operator> <name>pc</name></expr></argument>&gt;</argument_list></name><name>iCellLast</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>+</operator><name>sz</name><operator>==</operator><name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pc</name><operator>+</operator><name>sz</name><operator>&gt;</operator><name>usableSize</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize the auxiliary information for a disk block.
**
** Return SQLITE_OK on success.  If we see that the page does
** not contain a well-formed database page, then return 
** SQLITE_CORRUPT.  Note that a return of SQLITE_OK does not
** guarantee that the page is well-formed.  It only shows that
** we failed to detect any corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeInitPage</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>          <comment type="block">/* Equal to pPage-&gt;aData */</comment>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>        <comment type="block">/* The main btree structure */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><call><name>sqlite3PagerPagenumber</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name> <operator>==</operator> <call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>==</operator> <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-28594-02890 The one-byte flag at offset 0 indicating
  ** the b-tree page type. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>decodeFlags</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&gt;=</operator><literal type="number">512</literal> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>maskPage</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aCellIdx</name></name> <operator>=</operator> <name>data</name> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>+</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aDataOfst</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
  ** number of cells on the page. */</comment>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><call><name>MX_CELL</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* To many cells for a single page.  The page must be corrupt */</comment>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><call><name>MX_CELL</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-24089-57979 If a page contains no cells (which is only
  ** possible for a root page of a table that contains no rows) then the
  ** offset to the cell content area will equal the page size minus the
  ** bytes of reserved space. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>get2byteNotZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name>
       <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Indicate that this value is yet uncomputed */</comment>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CellSizeCk</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>btreeCellSizeCheck</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set up a raw page so that it looks like a database page holding
** no entries.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zeroPage</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>hdr</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>first</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerPagenumber</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>data</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_FAST_SECURE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>first</name> <operator>=</operator> <name>hdr</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>PTF_LEAF</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">12</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <name>first</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decodeFlags</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>=</operator> <name>first</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aCellIdx</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>first</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aDataOfst</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&gt;=</operator><literal type="number">512</literal> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>maskPage</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Convert a DbPage obtained from the pager into a MemPage used by
** the btree layer.
*/</comment>
<function><type><specifier>static</specifier> <name>MemPage</name> <modifier>*</modifier></type><name>btreePageFromDbPage</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>, <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>MemPage</name><operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>!=</operator><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name> <operator>=</operator> <name>pDbPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name> <operator>=</operator> <ternary><condition><expr><name>pgno</name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>==</operator><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pPage</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** Get a page from the pager.  Initialize the MemPage.pBt and
** MemPage.aData elements if needed.  See also: btreeGetUnusedPage().
**
** If the PAGER_GET_NOCONTENT flag is set, it means that we do not care
** about the content of the page at this time.  So do not go to the disk
** to fetch the content.  Just fill in the content with zeros for now.
** If in the future we call sqlite3PagerWrite() on this page, that
** means we have started to be concerned about content and the disk
** read should occur at that point.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeGetPage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,       <comment type="block">/* The btree */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,           <comment type="block">/* Number of the page to fetch */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* Return the page in this parameter */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>            <comment type="block">/* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>flags</name><operator>==</operator><name>PAGER_GET_NOCONTENT</name> <operator>||</operator> <name>flags</name><operator>==</operator><name>PAGER_GET_READONLY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>(</operator><name>DbPage</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pDbPage</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <call><name>btreePageFromDbPage</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Retrieve a page from the pager cache. If the requested page is not
** already in the pager cache return NULL. Initialize the MemPage.pBt and
** MemPage.aData elements if needed.
*/</comment>
<function><type><specifier>static</specifier> <name>MemPage</name> <modifier>*</modifier></type><name>btreePageLookup</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDbPage</name> <operator>=</operator> <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDbPage</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>btreePageFromDbPage</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the database file in pages. If there is any kind of
** error, return ((unsigned int)-1).
*/</comment>
<function><type><specifier>static</specifier> <name>Pgno</name></type> <name>btreePagecount</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>Pgno</name></type> <name>sqlite3BtreeLastPage</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>btreePagecount</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Get a page from the pager and initialize it.
**
** If pCur!=0 then the page is being fetched as part of a moveToChild()
** call.  Do additional sanity checking on the page in this case.
** And if the fetch fails, this routine must decrement pCur-&gt;iPage.
**
** The page is fetched as read-write unless pCur is not NULL and is
** a read-only cursor.
**
** If an error occurs, then *ppPage is undefined. It
** may remain unchanged, or it may be set to an invalid value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getAndInitPage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,                  <comment type="block">/* The database file */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,                      <comment type="block">/* Number of the page to get */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,               <comment type="block">/* Write the page pointer here */</comment>
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,                 <comment type="block">/* Cursor to receive the page, or NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReadOnly</name></decl></parameter>                   <comment type="block">/* True for a read-only page */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>ppPage</name><operator>==</operator><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bReadOnly</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>curPagerFlags</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>getAndInitPage_error1</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>(</operator><name>DbPage</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pDbPage</name></expr></argument>, <argument><expr><name>bReadOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>getAndInitPage_error1</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <operator>(</operator><name>MemPage</name><operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>btreePageFromDbPage</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeInitPage</name><argument_list>(<argument><expr><operator>*</operator><name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>getAndInitPage_error2</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><name>pgno</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>aData</name></name><operator>==</operator><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If obtaining a child page for a cursor, we must verify that the page is
  ** compatible with the root page. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>nCell</name></name><operator>&lt;</operator><literal type="number">1</literal> <operator>||</operator> <name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>intKey</name></name><operator>!=</operator><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PGNO</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>getAndInitPage_error2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>getAndInitPage_error2</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><operator>*</operator><name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>getAndInitPage_error1</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pCur</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pgno</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a MemPage.  This should be called once for each prior
** call to btreeGetPage.
**
** Page1 is a special case and must be released using releasePageOne().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releasePageNotNull</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releasePage</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releasePageOne</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerUnrefPageOne</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Get an unused page.
**
** This works just like btreeGetPage() with the addition:
**
**   *  If the page is already in use for some other purpose, immediately
**      release it and return an SQLITE_CURRUPT error.
**   *  Make sure the isInit flag is clear
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeGetUnusedPage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,       <comment type="block">/* The btree */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,           <comment type="block">/* Number of the page to fetch */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* Return the page in this parameter */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>            <comment type="block">/* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><operator>*</operator><name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** During a rollback, when the pager reloads information into the cache
** so that the cache is restored to its original state at the start of
** the transaction, for each page restored this routine is called.
**
** This routine needs to reset the extra data section at the end of the
** page to agree with the restored data.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pageReinit</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <operator>(</operator><name>MemPage</name> <operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* pPage might not be a btree page;  it might be an overflow page
      ** or ptrmap page or a free page.  In those cases, the following
      ** call to btreeInitPage() will likely return SQLITE_CORRUPT.
      ** But no harm is done by this.  And it is very important that
      ** btreeInitPage() be called on every btree page so we make
      ** the call for every page that comes in for re-initing. */</comment>
      <expr_stmt><expr><call><name>btreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the busy handler for a btree.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeInvokeBusyHandler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><operator>(</operator><name>BtShared</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3InvokeBusyHandler</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>busyHandler</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a database file.
** 
** zFilename is the name of the database file.  If zFilename is NULL
** then an ephemeral database is created.  The ephemeral database might
** be exclusively in memory, or it might use a disk-based memory cache.
** Either way, the ephemeral database will be automatically deleted 
** when sqlite3BtreeClose() is called.
**
** If zFilename is ":memory:" then an in-memory database is created
** that is automatically destroyed when it is closed.
**
** The "flags" parameter is a bitmask that might contain bits like
** BTREE_OMIT_JOURNAL and/or BTREE_MEMORY.
**
** If the database is already opened in the same database connection
** and we are in shared cache mode, then the open will fail with an
** SQLITE_CONSTRAINT error.  We cannot allow two or more BtShared
** objects in the same database connection since doing so will lead
** to problems with locking.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,      <comment type="block">/* VFS to use for this b-tree */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,  <comment type="block">/* Name of the file containing the BTree database */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Associated database handle */</comment>
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppBtree</name></decl></parameter>,        <comment type="block">/* Pointer to new Btree object written here */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,              <comment type="block">/* Options */</comment>
  <parameter><decl><type><name>int</name></type> <name>vfsFlags</name></decl></parameter>            <comment type="block">/* Flags passed through to sqlite3_vfs.xOpen() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Shared part of btree structure */</comment>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                      <comment type="block">/* Handle to return */</comment>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>mutexOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Prevents a race condition. Ticket #3537 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Result code from this function */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nReserve</name></decl>;</decl_stmt>                   <comment type="block">/* Byte of unused space on each page */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zDbHeader</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Database header content */</comment>

  <comment type="block">/* True if opening an ephemeral, temporary database */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isTempDb</name> <init>= <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Set the variable isMemdb to true for an in-memory database, or 
  ** false for a file-based database.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isMemdb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isMemdb</name> <init>= <expr><operator>(</operator><name>zFilename</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="string">":memory:"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
                       <operator>||</operator> <operator>(</operator><name>isTempDb</name> <operator>&amp;&amp;</operator> <call><name>sqlite3TempInMemory</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call><operator>)</operator>
                       <operator>||</operator> <operator>(</operator><name>vfsFlags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MEMORY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVfs</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>flags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* flags fit in 8 bits */</comment>

  <comment type="block">/* Only a BTREE_SINGLE database can be BTREE_UNORDERED */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_UNORDERED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_SINGLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A BTREE_SINGLE database is always a temporary and/or ephemeral */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_SINGLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isTempDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>isMemdb</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BTREE_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>vfsFlags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_DB</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>isMemdb</name> <operator>||</operator> <name>isTempDb</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>vfsFlags</name> <operator>=</operator> <operator>(</operator><name>vfsFlags</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_OPEN_MAIN_DB</name><operator>)</operator> <operator>|</operator> <name>SQLITE_OPEN_TEMP_DB</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Btree</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name> <operator>=</operator> <name>TRANS_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>pBtree</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>iTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DISKIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*
  ** If this Btree is a candidate for shared cache, try to find an
  ** existing BtShared object that we can share with
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isTempDb</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>isMemdb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>vfsFlags</name><operator>&amp;</operator><name>SQLITE_OPEN_URI</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>vfsFlags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_SHAREDCACHE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nFilename</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nFullPathname</name> <init>= <expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFullPathname</name> <init>= <expr><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>nFullPathname</name></expr></argument>,<argument><expr><name>nFilename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>sqlite3_mutex *mutexShared;</argument> )</argument_list></macro>

      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFullPathname</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>isMemdb</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFullPathname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>,
                                   <argument><expr><name>nFullPathname</name></expr></argument>, <argument><expr><name>zFullPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK_SYMLINK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rc</name></expr>;</return>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
      <expr_stmt><expr><name>mutexOpen</name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutexOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mutexShared</name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <for>for<control>(<init><expr><name>pBt</name><operator>=</operator><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pBt</name></expr>;</condition> <incr><expr><name>pBt</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>, <argument><expr><call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                 <operator>&amp;&amp;</operator> <call><name>sqlite3PagerVfs</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>pVfs</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>iDb</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>iDb</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pExisting</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>pExisting</name> <operator>&amp;&amp;</operator> <name><name>pExisting</name><operator>-&gt;</operator><name>pBt</name></name><operator>==</operator><name>pBt</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <else>else<block>{<block_content>
      <comment type="block">/* In debug mode, we mark all persistent databases as sharable
      ** even when they are not.  This exercises the locking code and
      ** gives more opportunity for asserts(sqlite3_mutex_held())
      ** statements to find locking problems.
      */</comment>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>pBt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/*
    ** The following asserts make sure that structures used by the btree are
    ** the right size.  This is to guard against size changes that result
    ** when compiling on a different architecture.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u64</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pgno</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <expr_stmt><expr><name>pBt</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBt</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>btree_open_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>,
                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemPage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>, <argument><expr><name>pageReinit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PagerSetMmapLimit</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>szMmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerReadFileheader</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDbHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zDbHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>btree_open_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerSetBusyHandler</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>btreeInvokeBusyHandler</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
  
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3PagerIsreadonly</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_READ_ONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SECURE_DELETE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_SECURE_DELETE</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_FAST_SECURE_DELETE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_OVERWRITE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* EVIDENCE-OF: R-51873-39618 The page size for a database file is
    ** determined by the 2-byte integer located at an offset of 16 bytes from
    ** the beginning of the database file. */</comment>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>=</operator> <operator>(</operator><name><name>zDbHeader</name><index>[<expr><literal type="number">16</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>zDbHeader</name><index>[<expr><literal type="number">17</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&lt;</operator><literal type="number">512</literal> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&gt;</operator><name>SQLITE_MAX_PAGE_SIZE</name>
         <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <comment type="block">/* If the magic name ":memory:" will create an in-memory database, then
      ** leave the autoVacuum mode at 0 (do not auto-vacuum), even if
      ** SQLITE_DEFAULT_AUTOVACUUM is true. On the other hand, if
      ** SQLITE_OMIT_MEMORYDB has been defined, then ":memory:" is just a
      ** regular file-name. In this case the auto-vacuum applies as per normal.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>zFilename</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isMemdb</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>SQLITE_DEFAULT_AUTOVACUUM</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>SQLITE_DEFAULT_AUTOVACUUM</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-37497-42412 The size of the reserved region is
      ** determined by the one-byte unsigned integer found at an offset of 20
      ** into the database file header. */</comment>
      <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <name><name>zDbHeader</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_PAGESIZE_FIXED</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDbHeader</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDbHeader</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <literal type="number">7</literal><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>nReserve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>btree_open_out</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <name>nReserve</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 8-byte alignment of pageSize */</comment>
   
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DISKIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Add the new BtShared object to the linked list sharable BtShareds.
    */</comment>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
      <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>sqlite3_mutex *mutexShared;</argument> )</argument_list></macro>
      <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);</argument>)</argument_list></macro>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_THREADSAFE</name> <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
          <goto>goto <name>btree_open_out</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DISKIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* If the new Btree uses a sharable pBtShared, then link the new
  ** Btree into the list of all sharable Btrees for the same connection.
  ** The list is kept in ascending order by pBt address.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pSib</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pSib</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSib</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name><name>pSib</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pSib</name> <operator>=</operator> <name><name>pSib</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>uptr</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name><operator>&lt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name><name>pSib</name><operator>-&gt;</operator><name>pBt</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pSib</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pSib</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <while>while<condition>( <expr><name><name>pSib</name><operator>-&gt;</operator><name>pNext</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>uptr</name><operator>)</operator><name><name>pSib</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pBt</name></name><operator>&lt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pSib</name> <operator>=</operator> <name><name>pSib</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pSib</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pSib</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pSib</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>ppBtree</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<label><name>btree_open_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pBt</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PagerClose</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppBtree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>

    <comment type="block">/* If the B-Tree was successfully opened, set the pager-cache size to the
    ** default value. Except, when opening on an existing shared pager-cache,
    ** do not change the pager-cache size.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeSchema</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeSetCacheSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_CACHE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_PDB</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mutexOpen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>mutexOpen</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>sqlite3BtreeConnectionCount</name><argument_list>(<argument><expr><operator>*</operator><name>ppBtree</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decrement the BtShared.nRef counter.  When it reaches zero,
** remove the BtShared structure from the sharing list.  Return
** true if the BtShared.nRef counter reaches zero and return
** false if it is still positive.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>removeFromSharingList</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>sqlite3_mutex *pMainMtx;</argument> )</argument_list></macro>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_notheld</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMainMtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nRef</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call><operator>==</operator><name>pBt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pList</name><operator>-&gt;</operator><name>pNext</name></name><operator>!=</operator><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pList</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_THREADSAFE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>removed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMainMtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>removed</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Make sure pBt-&gt;pTmpSpace points to an allocation of 
** MX_CELL_SIZE(pBt) bytes with a 4-byte prefix for a left-child
** pointer.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>allocateTempSpace</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* This routine is called only by btreeCursor() when allocating the
  ** first write cursor for the BtShared object */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_WriteFlag</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name> <operator>=</operator> <call><name>sqlite3PageMalloc</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>  <comment type="block">/* Unlink the cursor */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* One of the uses of pBt-&gt;pTmpSpace is to format cells before
  ** inserting them into a leaf page (function fillInCell()). If
  ** a cell is less than 4 bytes in size, it is rounded up to 4 bytes
  ** by the various routines that manipulate binary cells. Which
  ** can mean that fillInCell() only initializes the first 2 or 3
  ** bytes of pTmpSpace, but that the first 4 bytes are copied from
  ** it into a database page. This is not actually a problem, but it
  ** does cause a valgrind error when the 1 or 2 bytes of unitialized 
  ** data is passed to system call write(). So to avoid this error,
  ** zero the first 4 bytes of temp space here.
  **
  ** Also:  Provide four bytes of initialized space before the
  ** beginning of pTmpSpace as an area available to prepend the
  ** left-child pointer to the beginning of a cell.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the pBt-&gt;pTmpSpace allocation
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeTempSpace</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close an open database and invalidate all cursors.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeClose</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Close all cursors opened via this handle.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify that no other cursors have this Btree open */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>pCur</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><name>pCur</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTmp</name><operator>-&gt;</operator><name>pBtree</name></name><operator>!=</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></while>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Rollback any active transaction and free the handle structure.
  ** The call to sqlite3BtreeRollback() drops any table-locks held by
  ** this handle.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeRollback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there are still other outstanding references to the shared-btree
  ** structure, return now. The remainder of this procedure cleans 
  ** up the shared-btree.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wantToLock</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>locked</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name> <operator>||</operator> <call><name>removeFromSharingList</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* The pBt is no longer on the sharing list, so we can access
    ** it without having to hold the mutex.
    **
    ** Clean out and delete the BtShared object.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerClose</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>xFreeSchema</name></name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pBt</name><operator>-&gt;</operator><name>xFreeSchema</name></name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wantToLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>locked</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the "soft" limit on the number of pages in the cache.
** Unused and unmodified pages will be recycled when the number of
** pages in the cache exceeds this soft limit.  But the size of the
** cache is allowed to grow larger than this limit if it contains
** dirty pages or pages still in active use.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetCacheSize</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerSetCachesize</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the "spill" limit on the number of pages in the cache.
** If the number of pages exceeds this limit during a write transaction,
** the pager might attempt to "spill" pages to the journal early in
** order to free up memory.
**
** The value returned is the current spill size.  If zero is passed
** as an argument, no changes are made to the spill size setting, so
** using mxPage of 0 is a way to query the current spill size.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetSpillSize</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3PagerSetSpillsize</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Change the limit on the amount of the database file that may be
** memory mapped.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetMmapLimit</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>szMmap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerSetMmapLimit</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>szMmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_MMAP_SIZE&gt;0 */</comment>

<comment type="block">/*
** Change the way data is synced to disk in order to increase or decrease
** how well the database resists damage due to OS crashes and power
** failures.  Level 1 is the same as asynchronous (no syncs() occur and
** there is a high probability of damage)  Level 2 is the default.  There
** is a very low but non-zero probability of damage.  Level 3 reduces the
** probability of damage to near zero but with a write performance reduction.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3BtreeSetPagerFlags</name><parameter_list>(
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,              <comment type="block">/* The btree to set the safety level on */</comment>
  <parameter><decl><type><name>unsigned</name></type> <name>pgFlags</name></decl></parameter>       <comment type="block">/* Various PAGER_* flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerSetFlags</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>pgFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Change the default pages size and the number of reserved bytes per page.
** Or, if the page size has already been fixed, return SQLITE_READONLY 
** without changing anything.
**
** The page size must be a power of 2 between 512 and 65536.  If the page
** size supplied does not meet this constraint then the page size is not
** changed.
**
** Page sizes are constrained to be a power of two so that the region
** of the database file used for locking (beginning at PENDING_BYTE,
** the first byte past the 1GB boundary, 0x40000000) needs to occur
** at the beginning of a page.
**
** If parameter nReserve is less than zero, then the number of reserved
** bytes per page is left unchanged.
**
** If the iFix!=0 then the BTS_PAGESIZE_FIXED flag is set so that the page size
** and autovacuum mode can no longer be changed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetPageSize</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReserve</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iFix</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReserve</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nReserve</name><operator>&lt;=</operator><literal type="number">255</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nReserveWanted</name></name> <operator>=</operator> <name>nReserve</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReserve</name><operator>&lt;</operator><name>x</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_PAGESIZE_FIXED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReserve</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nReserve</name><operator>&lt;=</operator><literal type="number">255</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pageSize</name><operator>&gt;=</operator><literal type="number">512</literal> <operator>&amp;&amp;</operator> <name>pageSize</name><operator>&lt;=</operator><name>SQLITE_MAX_PAGE_SIZE</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><name>pageSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>pageSize</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pageSize</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nReserve</name><operator>&gt;</operator><literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>pageSize</name><operator>==</operator><literal type="number">512</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pageSize</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>pageSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>nReserve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nReserve</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_PAGESIZE_FIXED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the currently defined page size
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetPageSize</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is similar to sqlite3BtreeGetReserve(), except that it
** may only be called if it is guaranteed that the b-tree mutex is already
** held.
**
** This is useful in one special case in the backup API code where it is
** known that the shared b-tree mutex is held, but the mutex on the 
** database handle that owns *p is not. In this case if sqlite3BtreeEnter()
** were to be called, it might collide with some other operation on the
** database handle that owns *p, causing undefined behavior.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetReserveNoMutex</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes of space at the end of every page that
** are intentually left unused.  This is the "reserved" space that is
** sometimes used by extensions.
**
** The value returned is the larger of the current reserve size and
** the latest reserve size requested by SQLITE_FILECTRL_RESERVE_BYTES.
** The amount of reserve can only grow - never shrink.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetRequestedReserve</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>nReserveWanted</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>sqlite3BtreeGetReserveNoMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>n1</name><operator>&gt;</operator><name>n2</name></expr> ?</condition><then> <expr><name>n1</name></expr> </then><else>: <expr><name>n2</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Set the maximum page count for a database if mxPage is positive.
** No changes are made if mxPage is 0 or negative.
** Regardless of the value of mxPage, return the maximum page count.
*/</comment>
<function><type><name>Pgno</name></type> <name>sqlite3BtreeMaxPageCount</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3PagerMaxPageCount</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the values for the BTS_SECURE_DELETE and BTS_OVERWRITE flags:
**
**    newFlag==0       Both BTS_SECURE_DELETE and BTS_OVERWRITE are cleared
**    newFlag==1       BTS_SECURE_DELETE set and BTS_OVERWRITE is cleared
**    newFlag==2       BTS_SECURE_DELETE cleared and BTS_OVERWRITE is set
**    newFlag==(-1)    No changes
**
** This routine acts as a query if newFlag is less than zero
**
** With BTS_OVERWRITE set, deleted content is overwritten by zeros, but
** freelist leaf pages are not written back to the database.  Thus in-page
** deleted content is cleared, but freelist deleted content is not.
**
** With BTS_SECURE_DELETE, operation is like BTS_OVERWRITE with the addition
** that freelist leaf pages are written back into the database, increasing
** the amount of disk I/O.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSecureDelete</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>BTS_OVERWRITE</name><operator>==</operator><name>BTS_SECURE_DELETE</name><operator>*</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>BTS_FAST_SECURE</name><operator>==</operator><operator>(</operator><name>BTS_OVERWRITE</name><operator>|</operator><name>BTS_SECURE_DELETE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>newFlag</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_FAST_SECURE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_SECURE_DELETE</name><operator>*</operator><name>newFlag</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_FAST_SECURE</name><operator>)</operator><operator>/</operator><name>BTS_SECURE_DELETE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the 'auto-vacuum' property of the database. If the 'autoVacuum'
** parameter is non-zero, then auto-vacuum mode is enabled. If zero, it
** is disabled. The default value for the auto-vacuum property is 
** determined by the SQLITE_DEFAULT_AUTOVACUUM macro.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetAutoVacuum</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>autoVacuum</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>av</name> <init>= <expr><operator>(</operator><name>u8</name><operator>)</operator><name>autoVacuum</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_PAGESIZE_FIXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name>av</name></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>!=</operator><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>=</operator> <ternary><condition><expr><name>av</name></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name> <operator>=</operator> <ternary><condition><expr><name>av</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return the value of the 'auto-vacuum' property. If auto-vacuum is 
** enabled 1 is returned. Otherwise 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetAutoVacuum</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <return>return <expr><name>BTREE_AUTOVACUUM_NONE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator>
    <ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name><operator>)</operator></expr>?</condition><then><expr><name>BTREE_AUTOVACUUM_NONE</name></expr></then><else>:
    <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name><operator>)</operator></expr>?</condition><then><expr><name>BTREE_AUTOVACUUM_FULL</name></expr></then><else>:
    <expr><name>BTREE_AUTOVACUUM_INCR</name></expr></else></ternary></expr></else></ternary>
  <operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** If the user has not set the safety-level for this database connection
** using "PRAGMA synchronous", and if the safety-level is not already
** set to the value passed to this function as the second parameter,
** set it so.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_SYNCHRONOUS</name><operator>!=</operator><name>SQLITE_DEFAULT_WAL_SYNCHRONOUS</name> \
    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setDefaultSyncFlag</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>safety_level</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>db</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>db</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>pDb</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><name>pBt</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pDb</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bSyncSet</name></name><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>safety_level</name></name><operator>!=</operator><name>safety_level</name> 
     <operator>&amp;&amp;</operator> <name>pDb</name><operator>!=</operator><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>safety_level</name></name> <operator>=</operator> <name>safety_level</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerSetFlags</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>,
          <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>safety_level</name></name> <operator>|</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGER_FLAGS_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>setDefaultSyncFlag</name><parameter_list>(<parameter><type><name>pBt</name></type></parameter>,<parameter><type><name>safety_level</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>newDatabase</name><parameter_list>(<parameter><decl><type><name>BtShared</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
** Get a reference to pPage1 of the database file.  This will
** also acquire a readlock on that file.
**
** SQLITE_OK is returned on success.  If the file is not a
** well-formed database file, then SQLITE_CORRUPT is returned.
** SQLITE_BUSY is returned if the database is locked.  SQLITE_NOMEM
** is returned if we run out of memory. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lockBtree</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>              <comment type="block">/* Result code from subfunctions */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name></decl>;</decl_stmt>     <comment type="block">/* Page 1 of the database file */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPage</name></decl>;</decl_stmt>           <comment type="block">/* Number of pages in the database */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPageFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Number of pages in the database file */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSharedLock</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Do some checking to help insure the file we opened really is
  ** a valid database file. 
  */</comment>
  <expr_stmt><expr><name>nPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><literal type="number">28</literal><operator>+</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nPageFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="number">24</literal><operator>+</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><literal type="number">92</literal><operator>+</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <name>nPageFile</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ResetDatabase</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>pageSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>usableSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>page1</name> <init>= <expr><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTADB</name></expr>;</expr_stmt>
    <comment type="block">/* EVIDENCE-OF: R-43737-39999 Every valid SQLite database file begins
    ** with the following 16 bytes (in hex): 53 51 4c 69 74 65 20 66 6f 72 6d
    ** 61 74 20 33 00. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>page1</name></expr></argument>, <argument><expr><name>zMagicHeader</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>page1_init_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>page1</name><index>[<expr><literal type="number">18</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_READ_ONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>page1</name><index>[<expr><literal type="number">19</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>page1_init_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if<condition>( <expr><name><name>page1</name><index>[<expr><literal type="number">18</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_READ_ONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>page1</name><index>[<expr><literal type="number">19</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>page1_init_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the read version is set to 2, this database should be accessed
    ** in WAL mode. If the log is not already open, open it now. Then 
    ** return SQLITE_OK and return without populating BtShared.pPage1.
    ** The caller detects this and calls this function again. This is
    ** required as the version of page 1 currently in the page1 buffer
    ** may not be the latest version - there may be a newer one in the log
    ** file.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>page1</name><index>[<expr><literal type="number">19</literal></expr>]</index></name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_NO_WAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerOpenWal</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>page1_init_failed</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>setDefaultSyncFlag</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_WAL_SYNCHRONOUS</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>releasePageOne</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTADB</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>setDefaultSyncFlag</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_SYNCHRONOUS</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* EVIDENCE-OF: R-15465-20813 The maximum and minimum embedded payload
    ** fractions and the leaf payload fraction values must be 64, 32, and 32.
    **
    ** The original design allowed these amounts to vary, but as of
    ** version 3.6.0, we require them to be fixed.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page1</name><index>[<expr><literal type="number">21</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"\100\040\040"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>page1_init_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* EVIDENCE-OF: R-51873-39618 The page size for a database file is
    ** determined by the 2-byte integer located at an offset of 16 bytes from
    ** the beginning of the database file. */</comment>
    <expr_stmt><expr><name>pageSize</name> <operator>=</operator> <operator>(</operator><name><name>page1</name><index>[<expr><literal type="number">16</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>page1</name><index>[<expr><literal type="number">17</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* EVIDENCE-OF: R-25008-21688 The size of a page is a power of two
    ** between 512 and 65536 inclusive. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>pageSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>pageSize</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>||</operator> <name>pageSize</name><operator>&gt;</operator><name>SQLITE_MAX_PAGE_SIZE</name> 
     <operator>||</operator> <name>pageSize</name><operator>&lt;=</operator><literal type="number">256</literal></expr> 
    )</condition><block>{<block_content>
      <goto>goto <name>page1_init_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_PAGESIZE_FIXED</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pageSize</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* EVIDENCE-OF: R-59310-51205 The "reserved space" size in the 1-byte
    ** integer at offset 20 is the number of bytes of space at the end of
    ** each page to reserve for extensions. 
    **
    ** EVIDENCE-OF: R-37497-42412 The size of the reserved region is
    ** determined by the one-byte unsigned integer found at an offset of 20
    ** into the database file header. */</comment>
    <expr_stmt><expr><name>usableSize</name> <operator>=</operator> <name>pageSize</name> <operator>-</operator> <name><name>page1</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name>pageSize</name><operator>!=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* After reading the first page of the database assuming a page size
      ** of BtShared.pageSize, we have discovered that the page-size is
      ** actually pageSize. Unlock the database, leave pBt-&gt;pPage1 at
      ** zero and return SQLITE_OK. The caller will call this function
      ** again with the correct page-size.
      */</comment>
      <expr_stmt><expr><call><name>releasePageOne</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>=</operator> <name>usableSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>=</operator> <name>pageSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>freeTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>,
                                   <argument><expr><name>pageSize</name><operator>-</operator><name>usableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>&gt;</operator><name>nPageFile</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>page1_init_failed</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nPage</name> <operator>=</operator> <name>nPageFile</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* EVIDENCE-OF: R-28312-64704 However, the usable size is not allowed to
    ** be less than 480. In other words, if the page size is 512, then the
    ** reserved space size cannot exceed 32. */</comment>
    <if_stmt><if>if<condition>( <expr><name>usableSize</name><operator>&lt;</operator><literal type="number">480</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>page1_init_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>=</operator> <name>pageSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>=</operator> <name>usableSize</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page1</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page1</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <literal type="number">7</literal><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* maxLocal is the maximum amount of payload to store locally for
  ** a cell.  Make sure it is small enough so that at least minFanout
  ** cells can will fit on one page.  We assume a 10-byte page header.
  ** Besides the payload, the cell must store:
  **     2-byte pointer to the cell
  **     4-byte child pointer
  **     9-byte nKey value
  **     4-byte nData value
  **     4-byte overflow page pointer
  ** So a cell consists of a 2-byte pointer, a header which is as much as
  ** 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow
  ** page pointer.
  */</comment>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">64</literal><operator>/</operator><literal type="number">255</literal> <operator>-</operator> <literal type="number">23</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>minLocal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">32</literal><operator>/</operator><literal type="number">255</literal> <operator>-</operator> <literal type="number">23</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>maxLeaf</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">35</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>minLeaf</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">32</literal><operator>/</operator><literal type="number">255</literal> <operator>-</operator> <literal type="number">23</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>&gt;</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>max1bytePayload</name></name> <operator>=</operator> <literal type="number">127</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>max1bytePayload</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>maxLeaf</name></name> <operator>+</operator> <literal type="number">23</literal> <operator>&lt;=</operator> <call><name>MX_CELL_SIZE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name> <operator>=</operator> <name>pPage1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <name>nPage</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>page1_init_failed</name>:</label>
  <expr_stmt><expr><call><name>releasePageOne</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Return the number of cursors open on pBt. This is for use
** in assert() expressions, so it is only compiled if NDEBUG is not
** defined.
**
** Only write cursors are counted if wrOnly is true.  If wrOnly is
** false then all cursors are counted.
**
** For the purposes of this routine, a cursor is any cursor that
** is capable of reading or writing to the database.  Cursors that
** have been tripped into the CURSOR_FAULT state are not counted.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>countValidCursors</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrOnly</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCur</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>pCur</name></expr>;</condition> <incr><expr><name>pCur</name><operator>=</operator><name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wrOnly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_WriteFlag</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_FAULT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  </block_content>}</block></for>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If there are no outstanding cursors and we are not in the middle
** of a transaction but there is a read lock on the database, then
** this routine unrefs the first page of the database file which 
** has the effect of releasing the read lock.
**
** If there is a transaction in progress, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unlockBtreeIfUnused</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>countValidCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>&gt;</operator><name>TRANS_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_NONE</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePageOne</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If pBt points to an empty file then convert that empty file
** into a new empty database by initializing the first page of
** the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>newDatabase</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pP1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pP1</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pP1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pP1</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pP1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>zMagicHeader</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zMagicHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zMagicHeader</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">16</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>&lt;=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>+</operator><literal type="number">255</literal><operator>&gt;=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>-</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">21</literal></expr>]</index></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">22</literal></expr>]</index></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">23</literal></expr>]</index></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">100</literal><operator>-</operator><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pP1</name></expr></argument>, <argument><expr><name>PTF_INTKEY</name><operator>|</operator><name>PTF_LEAF</name><operator>|</operator><name>PTF_LEAFDATA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_PAGESIZE_FIXED</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <literal type="number">7</literal><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize the first page of the database file (creating a database
** consisting of a single page and no schema objects). Return SQLITE_OK
** if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeNewDb</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>newDatabase</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to start a new transaction. A write-transaction
** is started if the second argument is nonzero, otherwise a read-
** transaction.  If the second argument is 2 or more and exclusive
** transaction is started, meaning that no other process is allowed
** to access the database.  A preexisting transaction may not be
** upgraded to exclusive by calling this routine a second time - the
** exclusivity flag only works for a new transaction.
**
** A write-transaction must be started before attempting any 
** changes to the database.  None of the following routines 
** will work unless a transaction is started first:
**
**      sqlite3BtreeCreateTable()
**      sqlite3BtreeCreateIndex()
**      sqlite3BtreeClearTable()
**      sqlite3BtreeDropTable()
**      sqlite3BtreeInsert()
**      sqlite3BtreeDelete()
**      sqlite3BtreeUpdateMeta()
**
** If an initial attempt to acquire the lock fails because of lock contention
** and the database was previously unlocked, then invoke the busy handler
** if there is one.  But if there was previously a read-lock, do not
** invoke the busy handler - just return SQLITE_BUSY.  SQLITE_BUSY is 
** returned when there is already a read-lock in order to avoid a deadlock.
**
** Suppose there are two processes A and B.  A has a read lock and B has
** a reserved lock.  B tries to promote to exclusive but is blocked because
** of A's read lock.  A tries to promote to reserved but is blocked by B.
** One or the other of the two processes must give way or there can be
** no progress.  By returning SQLITE_BUSY and not invoking the busy callback
** when A already has a read lock, we encourage A to give up and let B
** proceed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeBeginTrans</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrflag</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pSchemaVersion</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the btree is already in a write-transaction, or it
  ** is already in a read-transaction and a read-transaction
  ** is requested, this is a no-op.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_READ</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>wrflag</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <goto>goto <name>trans_begun</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name> <operator>||</operator> <call><name>IfNotOmitAV</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>bDoTruncate</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ResetDatabase</name><operator>)</operator> 
   <operator>&amp;&amp;</operator> <call><name>sqlite3PagerIsreadonly</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_READ_ONLY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write transactions are not possible on a read-only database */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wrflag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY</name></expr>;</expr_stmt>
    <goto>goto <name>trans_begun</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* If another database handle has already opened a write transaction 
    ** on this shared-btree structure and a second write transaction is
    ** requested, return SQLITE_LOCKED.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wrflag</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_PENDING</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>wrflag</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>BtLock</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>pBtree</name></name><operator>!=</operator><name>p</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBlock</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ConnectionBlocked</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED_SHAREDCACHE</name></expr>;</expr_stmt>
      <goto>goto <name>trans_begun</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Any read-only or read-write transaction implies a read-lock on 
  ** page 1. So if some other shared-cache client already has a write-lock 
  ** on page 1, the transaction cannot be opened. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>querySharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SCHEMA_ROOT</name></expr></argument>, <argument><expr><name>READ_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>trans_begun</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_INITIALLY_EMPTY</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_INITIALLY_EMPTY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PagerWalDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
    <comment type="block">/* If transitioning from no transaction directly to a write transaction,
    ** block for the WRITER lock first if possible. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wrflag</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWalWriteLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Call lockBtree() until either pBt-&gt;pPage1 is populated or
    ** lockBtree() returns something other than SQLITE_OK. lockBtree()
    ** may return SQLITE_OK but leave pBt-&gt;pPage1 set to 0 if after
    ** reading page 1 it discovers that the page-size of the database 
    ** file is not pBt-&gt;pageSize. In this case lockBtree() will update
    ** pBt-&gt;pageSize to the page-size of the file on disk.
    */</comment>
    <while>while<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>lockBtree</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>wrflag</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerBegin</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>wrflag</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3TempInMemory</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>newDatabase</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_SNAPSHOT</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_NONE</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* if there was no transaction opened when this function was
          ** called and SQLITE_BUSY_SNAPSHOT is returned, change the error
          ** code to SQLITE_BUSY. */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3PagerWalWriteLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_NONE</name> <operator>&amp;&amp;</operator>
          <call><name>btreeInvokeBusyHandler</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>sqlite3PagerWalDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_TIMEOUT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_NONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nTransaction</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>pBtree</name></name><operator>==</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>iTable</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name> <operator>=</operator> <name>READ_LOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pLock</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>wrflag</name></expr>?</condition><then><expr><name>TRANS_WRITE</name></expr></then><else>:<expr><name>TRANS_READ</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;</operator><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>wrflag</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pWriter</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_EXCLUSIVE</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>wrflag</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_EXCLUSIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* If the db-size header field is incorrect (as it may be if an old
      ** client has been writing the database file), update it now. Doing
      ** this sooner rather than later means the database size can safely 
      ** re-read the database size from page 1 if a savepoint or transaction
      ** rollback occurs within the transaction.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>!=</operator><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>trans_begun</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pSchemaVersion</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pSchemaVersion</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>wrflag</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This call makes sure that the pager has the correct number of
      ** open savepoints. If the second parameter is greater than 0 and
      ** the sub-journal is not already open, then it will be opened here.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerOpenSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>

<comment type="block">/*
** Set the pointer-map entries for all children of page pPage. Also, if
** pPage contains cells that point to overflow pages, set the pointer
** map entries for the overflow pages as well.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>setChildPtrmaps</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                             <comment type="block">/* Counter variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                         <comment type="block">/* Number of cells in page pPage */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                            <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><call><name>btreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ptrmapPutOvflPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>childPgno</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>childPgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>childPgno</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>childPgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Somewhere on pPage is a pointer to page iFrom.  Modify this pointer so
** that it points to iTo. Parameter eType describes the type of pointer to
** be modified, as  follows:
**
** PTRMAP_BTREE:     pPage is a btree-page. The pointer points at a child 
**                   page of pPage.
**
** PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow
**                   page pointed to by one of the cells on pPage.
**
** PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next
**                   overflow page in the list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>modifyPagePointer</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iFrom</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iTo</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_OVERFLOW2</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The pointer is always the first 4 bytes of the page in this case.  */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>get4byte</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call><operator>!=</operator><name>iFrom</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><call><name>btreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nCell</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_OVERFLOW1</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>info</name><operator>.</operator><name>nLocal</name></name><operator>&lt;</operator><name><name>info</name><operator>.</operator><name>nPayload</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pCell</name><operator>+</operator><name><name>info</name><operator>.</operator><name>nSize</name></name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>+</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr> )</condition><block>{<block_content>
            <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iFrom</name><operator>==</operator><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name><operator>+</operator><name><name>info</name><operator>.</operator><name>nSize</name></name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pCell</name><operator>+</operator><name><name>info</name><operator>.</operator><name>nSize</name></name><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pCell</name><operator>+</operator><literal type="number">4</literal> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>+</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr> )</condition><block>{<block_content>
          <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call><operator>==</operator><name>iFrom</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nCell</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><name>PTRMAP_BTREE</name> <operator>||</operator> 
          <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>iFrom</name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Move the open database page pDbPage to location iFreePage in the 
** database. The pDbPage reference remains valid.
**
** The isCommit flag indicates that there is no need to remember that
** the journal needs to be sync()ed before database page pDbPage-&gt;pgno 
** can be written to. The caller has already promised not to write to that
** page.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>relocatePage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,           <comment type="block">/* Btree */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl></parameter>,        <comment type="block">/* Open page to move */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eType</name></decl></parameter>,                <comment type="block">/* Pointer map 'type' entry for pDbPage */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iPtrPage</name></decl></parameter>,           <comment type="block">/* Pointer map 'page-no' entry for pDbPage */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iFreePage</name></decl></parameter>,          <comment type="block">/* The location to move pDbPage to */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCommit</name></decl></parameter>             <comment type="block">/* isCommit flag passed to sqlite3PagerMovepage */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPtrPage</name></decl>;</decl_stmt>   <comment type="block">/* The page that contains a pointer to pDbPage */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iDbPage</name> <init>= <expr><name><name>pDbPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>PTRMAP_OVERFLOW2</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>PTRMAP_OVERFLOW1</name> <operator>||</operator> 
      <name>eType</name><operator>==</operator><name>PTRMAP_BTREE</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>PTRMAP_ROOTPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDbPage</name><operator>-&gt;</operator><name>pBt</name></name><operator>==</operator><name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDbPage</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Move page iDbPage from its current location to page number iFreePage */</comment>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n"</literal><operator>,</operator> 
      <name>iDbPage</name><operator>,</operator> <name>iFreePage</name><operator>,</operator> <name>iPtrPage</name><operator>,</operator> <name>eType</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerMovepage</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pDbPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pDbPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>=</operator> <name>iFreePage</name></expr>;</expr_stmt>

  <comment type="block">/* If pDbPage was a btree-page, then it may have child pages and/or cells
  ** that point to overflow pages. The pointer map entries for all these
  ** pages need to be changed.
  **
  ** If pDbPage is an overflow page, then the first 4 bytes may store a
  ** pointer to a subsequent overflow page. If this is the case, then
  ** the pointer map needs to be updated for the subsequent overflow page.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_BTREE</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>PTRMAP_ROOTPAGE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>setChildPtrmaps</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nextOvfl</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><name><name>pDbPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nextOvfl</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nextOvfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW2</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Fix the database pointer on page iPtrPage that pointed at iDbPage so
  ** that it points at iFreePage. Also fix the pointer map entry for
  ** iPtrPage.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><name>PTRMAP_ROOTPAGE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPtrPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPtrPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>modifyPagePointer</name><argument_list>(<argument><expr><name>pPtrPage</name></expr></argument>, <argument><expr><name>iDbPage</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward declaration required by incrVacuumStep(). */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>allocateBtreePage</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Pgno</name></type></decl></parameter>, <parameter><decl><type><name>u8</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Perform a single step of an incremental-vacuum. If successful, return
** SQLITE_OK. If there is no work to do (and therefore no point in 
** calling this function again), return SQLITE_DONE. Or, if an error 
** occurs, return some other error code.
**
** More specifically, this function attempts to re-organize the database so 
** that the last page of the file currently in use is no longer in use.
**
** Parameter nFin is the number of pages that this database would contain
** were this function called until it returns SQLITE_DONE.
**
** If the bCommit parameter is non-zero, this function assumes that the 
** caller will keep calling incrVacuumStep() until it returns SQLITE_DONE 
** or an error. bCommit is passed true for an auto-vacuum-on-commit 
** operation, or false for an incremental vacuum.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>incrVacuumStep</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>nFin</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iLastPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCommit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nFreeList</name></decl>;</decl_stmt>           <comment type="block">/* Number of pages still on the free-list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLastPg</name><operator>&gt;</operator><name>nFin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iLastPg</name><operator>!=</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrPage</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nFreeList</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFreeList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_ROOTPAGE</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_FREEPAGE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bCommit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Remove the page from the files free-list. This is not required
        ** if bCommit is non-zero. In that case, the free-list will be
        ** truncated to zero after this function returns, so it doesn't 
        ** matter if it still contains some garbage entries.
        */</comment>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iFreePg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pFreePg</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFreePg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFreePg</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>, <argument><expr><name>BTALLOC_EXACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFreePg</name><operator>==</operator><name>iLastPg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pFreePg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>iFreePg</name></decl>;</decl_stmt>             <comment type="block">/* Index of free page to move pLastPg to */</comment>
      <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pLastPg</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>eMode</name> <init>= <expr><name>BTALLOC_ANY</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Mode parameter for allocateBtreePage() */</comment>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>iNear</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* nearby parameter for allocateBtreePage() */</comment>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLastPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If bCommit is zero, this loop runs exactly once and page pLastPg
      ** is swapped with the first free page pulled off the free list.
      **
      ** On the other hand, if bCommit is greater than zero, then keep
      ** looping until a free-page located within the first nFin pages
      ** of the file is found.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>bCommit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eMode</name> <operator>=</operator> <name>BTALLOC_LE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iNear</name> <operator>=</operator> <name>nFin</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <do>do <block>{<block_content>
        <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pFreePg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>dbSize</name> <init>= <expr><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFreePg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFreePg</name></expr></argument>, <argument><expr><name>iNear</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pLastPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pFreePg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iFreePg</name><operator>&gt;</operator><name>dbSize</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pLastPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>bCommit</name> <operator>&amp;&amp;</operator> <name>iFreePg</name><operator>&gt;</operator><name>nFin</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFreePg</name><operator>&lt;</operator><name>iLastPg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>relocatePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pLastPg</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr><name>iFreePg</name></expr></argument>, <argument><expr><name>bCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pLastPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bCommit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>iLastPg</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>iLastPg</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>bDoTruncate</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <name>iLastPg</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The database opened by the first argument is an auto-vacuum database
** nOrig pages in size containing nFree free pages. Return the expected 
** size of the database in pages following an auto-vacuum operation.
*/</comment>
<function><type><specifier>static</specifier> <name>Pgno</name></type> <name>finalDbSize</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>nOrig</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>nFree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>                     <comment type="block">/* Number of entries on one ptrmap page */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPtrmap</name></decl>;</decl_stmt>                   <comment type="block">/* Number of PtrMap pages to be freed */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nFin</name></decl>;</decl_stmt>                      <comment type="block">/* Return value */</comment>

  <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>/</operator><literal type="number">5</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPtrmap</name> <operator>=</operator> <operator>(</operator><name>nFree</name><operator>-</operator><name>nOrig</name><operator>+</operator><call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>)</argument_list></call><operator>+</operator><name>nEntry</name><operator>)</operator><operator>/</operator><name>nEntry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFin</name> <operator>=</operator> <name>nOrig</name> <operator>-</operator> <name>nFree</name> <operator>-</operator> <name>nPtrmap</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOrig</name><operator>&gt;</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nFin</name><operator>&lt;</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nFin</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>nFin</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nFin</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>nFin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A write-transaction must be opened before calling this function.
** It performs a single unit of work towards an incremental vacuum.
**
** If the incremental vacuum is finished after this function has run,
** SQLITE_DONE is returned. If it is not finished, but no error occurred,
** SQLITE_OK is returned. Otherwise an SQLite error code. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIncrVacuum</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nOrig</name> <init>= <expr><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nFree</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nFin</name> <init>= <expr><call><name>finalDbSize</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>, <argument><expr><name>nFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>nOrig</name><operator>&lt;</operator><name>nFin</name> <operator>||</operator> <name>nFree</name><operator>&gt;=</operator><name>nOrig</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nFree</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>invalidateAllOverflowCache</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>incrVacuumStep</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called prior to sqlite3PagerCommit when a transaction
** is committed for an auto-vacuum database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>autoVacuumCommit</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>int nRef</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>  
  <expr_stmt><expr><name>pPager</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr>;</expr_stmt>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>nRef = sqlite3PagerRefcount(pPager);</argument> )</argument_list></macro>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>invalidateAllOverflowCache</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nFin</name></decl>;</decl_stmt>         <comment type="block">/* Number of pages in database after autovacuuming */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nFree</name></decl>;</decl_stmt>        <comment type="block">/* Number of pages on the freelist initially */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nVac</name></decl>;</decl_stmt>         <comment type="block">/* Number of pages to vacuum */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iFree</name></decl>;</decl_stmt>        <comment type="block">/* The next page to be freed */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nOrig</name></decl>;</decl_stmt>        <comment type="block">/* Database size before freeing */</comment>

    <expr_stmt><expr><name>nOrig</name> <operator>=</operator> <call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>nOrig</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* It is not possible to create a database for which the final page
      ** is either a pointer-map page or the pending-byte page. If one
      ** is encountered, this indicates corruption.
      */</comment>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nFree</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xAutovacPages</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>iDb</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iDb</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>==</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>nVac</name> <operator>=</operator> <call><name><name>db</name><operator>-&gt;</operator><name>xAutovacPages</name></name><argument_list>(
        <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pAutovacPagesArg</name></name></expr></argument>,
        <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>,
        <argument><expr><name>nOrig</name></expr></argument>,
        <argument><expr><name>nFree</name></expr></argument>,
        <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nVac</name><operator>&gt;</operator><name>nFree</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nVac</name> <operator>=</operator> <name>nFree</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nVac</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nVac</name> <operator>=</operator> <name>nFree</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>nFin</name> <operator>=</operator> <call><name>finalDbSize</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>, <argument><expr><name>nVac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFin</name><operator>&gt;</operator><name>nOrig</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFin</name><operator>&lt;</operator><name>nOrig</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>iFree</name><operator>=</operator><name>nOrig</name></expr>;</init> <condition><expr><name>iFree</name><operator>&gt;</operator><name>nFin</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>iFree</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>incrVacuumStep</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>, <argument><expr><name>iFree</name></expr></argument>, <argument><expr><name>nVac</name><operator>==</operator><name>nFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_DONE</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nFree</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nVac</name><operator>==</operator><name>nFree</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>bDoTruncate</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <name>nFin</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PagerRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRef</name><operator>&gt;=</operator><call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ifndef SQLITE_OMIT_AUTOVACUUM */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>setChildPtrmaps</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine does the first phase of a two-phase commit.  This routine
** causes a rollback journal to be created (if it does not already exist)
** and populated with enough information so that if a power loss occurs
** the database can be restored to its original state by playing back
** the journal.  Then the contents of the journal are flushed out to
** the disk.  After the journal is safely on oxide, the changes to the
** database are written into the database file and flushed to oxide.
** At the end of this call, the rollback journal still exists on the
** disk and we are still holding all locks, so the transaction has not
** committed.  See sqlite3BtreeCommitPhaseTwo() for the second phase of the
** commit process.
**
** This call is a no-op if no write-transaction is currently active on pBt.
**
** Otherwise, sync the database file for the btree pBt. zSuperJrnl points to
** the name of a super-journal file that should be written into the
** individual journal file, or is NULL, indicating no super-journal file 
** (single database transaction).
**
** When this is called, the super-journal should already have been
** created, populated with this journal pointer and synced to disk.
**
** Once this is routine has returned, the only thing required to commit
** the write-transaction for this database file is to delete the journal.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommitPhaseOne</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSuperJrnl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>autoVacuumCommit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>bDoTruncate</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PagerTruncateImage</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerCommitPhaseOne</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>zSuperJrnl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called from both BtreeCommitPhaseTwo() and BtreeRollback()
** at the conclusion of a transaction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeEndTransaction</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>bDoTruncate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;</operator><name>TRANS_NONE</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there are other active statements that belong to this database
    ** handle, downgrade to a read-only transaction. The other statements
    ** may still be reading from the database.  */</comment>
    <expr_stmt><expr><call><name>downgradeAllSharedCacheTableLocks</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name> <operator>=</operator> <name>TRANS_READ</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If the handle had any kind of transaction open, decrement the 
    ** transaction count of the shared btree. If the transaction count 
    ** reaches 0, set the shared state to TRANS_NONE. The unlockBtreeIfUnused()
    ** call below will unlock the pager.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>!=</operator><name>TRANS_NONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>clearAllSharedCacheTableLocks</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nTransaction</name></name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>pBt</name><operator>-&gt;</operator><name>nTransaction</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <name>TRANS_NONE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set the current transaction state to TRANS_NONE and unlock the 
    ** pager if this call closed the only read or write transaction.  */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name> <operator>=</operator> <name>TRANS_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Commit the transaction currently in progress.
**
** This routine implements the second phase of a 2-phase commit.  The
** sqlite3BtreeCommitPhaseOne() routine does the first phase and should
** be invoked prior to calling this routine.  The sqlite3BtreeCommitPhaseOne()
** routine did all the work of writing information out to disk and flushing the
** contents so that they are written onto the disk platter.  All this
** routine has to do is delete or truncate or zero the header in the
** the rollback journal (which causes the transaction to commit) and
** drop locks.
**
** Normally, if an error occurs while the pager layer is attempting to 
** finalize the underlying journal file, this function returns an error and
** the upper layer will attempt a rollback. However, if the second argument
** is non-zero then this b-tree transaction is part of a multi-file 
** transaction. In this case, the transaction has already been committed 
** (by deleting a super-journal file) and the caller will ignore this 
** functions return code. So, even if an error occurs in the pager layer,
** reset the b-tree objects internal state to indicate that the write
** transaction has been closed. This is quite safe, as the pager will have
** transitioned to the error state.
**
** This will release the write lock on the database file.  If there
** are no active cursors, it also releases the read lock.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommitPhaseTwo</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCleanup</name></decl></parameter>)</parameter_list><block>{<block_content>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_NONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the handle has a write-transaction open, commit the shared-btrees 
  ** transaction and set the shared state to TRANS_READ.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nTransaction</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerCommitPhaseTwo</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bCleanup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBDataVersion</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Compensate for pPager-&gt;iDataVersion++; */</comment>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <name>TRANS_READ</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>btreeClearHasContent</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>btreeEndTransaction</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do both phases of a commit.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommit</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine sets the state to CURSOR_FAULT and the error
** code to errCode for every cursor on any BtShared that pBtree
** references.  Or if the writeOnly flag is set to 1, then only
** trip write cursors and leave read cursors unchanged.
**
** Every cursor is a candidate to be tripped, including cursors
** that belong to other database connections that happen to be
** sharing the cache with pBtree.
**
** This routine gets called when a rollback occurs. If the writeOnly
** flag is true, then only write-cursors need be tripped - read-only
** cursors save their current positions so that they may continue 
** following the rollback. Or, if writeOnly is false, all cursors are 
** tripped. In general, writeOnly is false if the transaction being
** rolled back modified the database schema. In this case b-tree root
** pages may be moved or deleted from the database altogether, making
** it unsafe for read cursors to continue.
**
** If the writeOnly flag is true and an error is encountered while 
** saving the current position of a read-only cursor, all cursors, 
** including all read-cursors are tripped.
**
** SQLITE_OK is returned if successful, or if an error occurs while
** saving a cursor position, an SQLite error code.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeTripAllCursors</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeOnly</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>writeOnly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>writeOnly</name><operator>==</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>BTCF_WriteFlag</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBtree</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pBtree</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>writeOnly</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_WriteFlag</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_SKIPNEXT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveCursorPosition</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3BtreeTripAllCursors</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_FAULT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>skipNext</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>btreeReleaseAllCursorPages</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the pBt-&gt;nPage field correctly, according to the current
** state of the database.  Assume pBt-&gt;pPage1 is valid.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeSetNPage</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPage</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>!=</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <name>nPage</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Rollback the transaction in progress.
**
** If tripCode is not SQLITE_OK then cursors will be invalidated (tripped).
** Only write cursors are tripped if writeOnly is true but all cursors are
** tripped if writeOnly is false.  Any attempt to use
** a tripped cursor will result in an error.
**
** This will release the write lock on the database file.  If there
** are no active cursors, it also releases the read lock.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeRollback</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tripCode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeOnly</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>writeOnly</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>writeOnly</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>tripCode</name><operator>==</operator><name>SQLITE_ABORT_ROLLBACK</name> <operator>||</operator> <name>tripCode</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>tripCode</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>tripCode</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>writeOnly</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>tripCode</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>sqlite3BtreeTripAllCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tripCode</name></expr></argument>, <argument><expr><name>writeOnly</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name>writeOnly</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc2</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TRANS_WRITE</name><operator>==</operator><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3PagerRollback</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The rollback may have destroyed the pPage1-&gt;aData value.  So
    ** call btreeGetPage() on page 1 again to make
    ** sure pPage1-&gt;aData is set correctly. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>btreeSetNPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePageOne</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>countValidCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <name>TRANS_READ</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>btreeClearHasContent</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>btreeEndTransaction</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Start a statement subtransaction. The subtransaction can be rolled
** back independently of the main transaction. You must start a transaction 
** before starting a subtransaction. The subtransaction is ended automatically 
** if the main transaction commits or rolls back.
**
** Statement subtransactions are used around individual SQL statements
** that are contained within a BEGIN...COMMIT block.  If a constraint
** error occurs within the statement, the effect of that one statement
** can be rolled back without having to rollback the entire transaction.
**
** A statement sub-transaction is implemented as an anonymous savepoint. The
** value passed as the second parameter is the total number of savepoints,
** including the new anonymous savepoint, open on the B-Tree. i.e. if there
** are no active savepoints and no other statement-transactions open,
** iStatement is 1. This anonymous savepoint can be released or rolled back
** using the sqlite3BtreeSavepoint() function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeBeginStmt</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStatement</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStatement</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStatement</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* At the pager level, a statement transaction is a savepoint with
  ** an index greater than all savepoints created explicitly using
  ** SQL statements. It is illegal to open, release or rollback any
  ** such savepoints while the statement transaction savepoint is active.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerOpenSavepoint</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>iStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second argument to this function, op, is always SAVEPOINT_ROLLBACK
** or SAVEPOINT_RELEASE. This function either releases or rolls back the
** savepoint identified by parameter iSavepoint, depending on the value 
** of op.
**
** Normally, iSavepoint is greater than or equal to zero. However, if op is
** SAVEPOINT_ROLLBACK, then iSavepoint may also be -1. In this case the 
** contents of the entire transaction are rolled back. This is different
** from a normal transaction rollback, as no locks are released and the
** transaction remains open.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSavepoint</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>SAVEPOINT_RELEASE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSavepoint</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iSavepoint</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSavepoint</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iSavepoint</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_INITIALLY_EMPTY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>newDatabase</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>btreeSetNPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* pBt-&gt;nPage might be zero if the database was corrupt when 
      ** the transaction was started. Otherwise, it must be at least 1.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new cursor for the BTree whose root is on the page
** iTable. If a read-only cursor is requested, it is assumed that
** the caller already has at least a read-only transaction open
** on the database already. If a write-cursor is requested, then
** the caller is assumed to have an open write transaction.
**
** If the BTREE_WRCSR bit of wrFlag is clear, then the cursor can only
** be used for reading.  If the BTREE_WRCSR bit is set, then the cursor
** can be used for reading or for writing if other conditions for writing
** are also met.  These are the conditions that must be met in order
** for writing to be allowed:
**
** 1:  The cursor must have been opened with wrFlag containing BTREE_WRCSR
**
** 2:  Other database connections that share the same pager cache
**     but which are not in the READ_UNCOMMITTED state may not have
**     cursors open with wrFlag==0 on the same table.  Otherwise
**     the changes made by this write cursor would be visible to
**     the read cursors in the other database connection.
**
** 3:  The database must be writable (not on read-only media)
**
** 4:  There must be an active transaction.
**
** The BTREE_FORDELETE bit of wrFlag may optionally be set if BTREE_WRCSR
** is set.  If FORDELETE is set, that is a hint to the implementation that
** this cursor will only be used to seek to and delete entries of an index
** as part of a larger DELETE statement.  The FORDELETE hint is not used by
** this implementation.  But in a hypothetical alternative storage engine 
** in which index entries are automatically deleted when corresponding table
** rows are deleted, the FORDELETE flag is a hint that all SEEK and DELETE
** operations on this cursor can be no-ops and all READ operations can 
** return a null row (2-bytes: 0x01 0x00).
**
** No checking is done to make sure that page iTable really is the
** root page of a b-tree.  If it is not, then the cursor acquired
** will not work correctly.
**
** It is assumed that the sqlite3BtreeCursorZero() has been called
** on pCur to initialize the memory space prior to invoking this routine.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursor</name><parameter_list>(
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                              <comment type="block">/* The btree */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iTable</name></decl></parameter>,                           <comment type="block">/* Root page of table to open */</comment>
  <parameter><decl><type><name>int</name></type> <name>wrFlag</name></decl></parameter>,                            <comment type="block">/* 1 to write. 0 read-only */</comment>
  <parameter><decl><type><name><name>struct</name> <name>KeyInfo</name></name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,              <comment type="block">/* First arg to comparison function */</comment>
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>                         <comment type="block">/* Space for new cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Shared b-tree handle */</comment>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>                          <comment type="block">/* Looping over other all cursors */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wrFlag</name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <name>wrFlag</name><operator>==</operator><name>BTREE_WRCSR</name> 
       <operator>||</operator> <name>wrFlag</name><operator>==</operator><operator>(</operator><name>BTREE_WRCSR</name><operator>|</operator><name>BTREE_FORDELETE</name><operator>)</operator></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The following assert statements verify that if this is a sharable 
  ** b-tree database, the connection is holding the required table locks, 
  ** and that no other connection has any open cursor that conflicts with 
  ** this lock.  The iTable&lt;1 term disables the check for corrupt schemas. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>hasSharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pKeyInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>wrFlag</name></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call>
          <operator>||</operator> <name>iTable</name><operator>&lt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wrFlag</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>hasReadConflicts</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assert that the caller has opened the required transaction. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;</operator><name>TRANS_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wrFlag</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wrFlag</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wrFlag</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iTable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now that no other errors can occur, finish filling in the BtCursor
  ** variables and link the cursor into the BtShared list.  */</comment>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name> <operator>=</operator> <name>iTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* If there are two or more cursors on the same btree, then all such
  ** cursors *must* have the BTCF_Multiple flag set. */</comment>
  <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><name>iTable</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_Multiple</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>=</operator> <name>BTCF_Multiple</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>wrFlag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_WriteFlag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curPagerFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>allocateTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curPagerFlags</name></name> <operator>=</operator> <name>PAGER_GET_READONLY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorWithLock</name><parameter_list>(
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                              <comment type="block">/* The btree */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iTable</name></decl></parameter>,                           <comment type="block">/* Root page of table to open */</comment>
  <parameter><decl><type><name>int</name></type> <name>wrFlag</name></decl></parameter>,                            <comment type="block">/* 1 to write. 0 read-only */</comment>
  <parameter><decl><type><name><name>struct</name> <name>KeyInfo</name></name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,              <comment type="block">/* First arg to comparison function */</comment>
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>                         <comment type="block">/* Space for new cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeCursor</name><parameter_list>(
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                                   <comment type="block">/* The btree */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iTable</name></decl></parameter>,                                <comment type="block">/* Root page of table to open */</comment>
  <parameter><decl><type><name>int</name></type> <name>wrFlag</name></decl></parameter>,                                 <comment type="block">/* 1 to write. 0 read-only */</comment>
  <parameter><decl><type><name><name>struct</name> <name>KeyInfo</name></name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,                   <comment type="block">/* First arg to xCompare() */</comment>
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>                              <comment type="block">/* Write new cursor here */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>btreeCursorWithLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>btreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of a BtCursor object in bytes.
**
** This interfaces is needed so that users of cursors can preallocate
** sufficient storage to hold a cursor.  The BtCursor object is opaque
** to users so they cannot do the sizeof() themselves - they must call
** this routine.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize memory that will be converted into a BtCursor object.
**
** The simple approach here would be to memset() the entire object
** to zero.  But it turns out that the apPage[] and aiIdx[] arrays
** do not need to be zeroed and they are large, so we can save a lot
** of run-time by skipping the initialization of those elements.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeCursorZero</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BtCursor</name></expr></argument>, <argument><expr><name>BTCURSOR_FIRST_UNINIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a cursor.  The read lock on the database file is released
** when the last cursor is closed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCloseCursor</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBtree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name><operator>==</operator><name>pCur</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pPrev</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr></init></decl>;</decl_stmt>
      <do>do<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name>pCur</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pPrev</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>btreeReleaseAllCursorPages</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>&amp;</operator> <name>BTREE_SINGLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Since the BtShared is not sharable, there is no need to
      ** worry about the missing sqlite3BtreeLeave() call here.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBtree</name><operator>-&gt;</operator><name>sharable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make sure the BtCursor* given in the argument has a valid
** BtCursor.info structure.  If it is not already valid, call
** btreeParseCell() to fill it in.
**
** BtCursor.info is a cache of the information in the current cell.
** Using this cache reduces the number of calls to btreeParseCell().
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <function><type><specifier>static</specifier> <name>int</name></type> <name>cellInfoEqual</name><parameter_list>(<parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>nKey</name></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>nKey</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>pPayload</name></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>pPayload</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>nPayload</name></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>nPayload</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>nLocal</name></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>nLocal</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>nSize</name></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>nSize</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></function>
  <function><type><specifier>static</specifier> <name>void</name></type> <name>assertCellInfo</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
    <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>btreeParseCell</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <call><name>cellInfoEqual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assertCellInfo</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>getCellInfo</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_ValidNKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>btreeParseCell</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>,<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assertCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>  <comment type="block">/* The next routine used only within assert() statements */</comment>
<comment type="block">/*
** Return true if the given BtCursor is valid.  A valid cursor is one
** that is currently pointing to a row in a (non-empty) table.
** This is a verification routine is used only within assert() statements.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorIsValid</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>pCur</name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorIsValidNN</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the value of the integer key or "rowid" for a table btree.
** This routine is only valid for a cursor that is pointing into a
** ordinary table btree.  If the cursor points to an index btree or
** is invalid, the result of this routine is undefined.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3BtreeIntegerKey</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Pin or unpin a cursor.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeCursorPin</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Pinned</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_Pinned</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3BtreeCursorUnpin</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Pinned</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTCF_Pinned</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifdef>
<comment type="block">/*
** Return the offset into the database file for the start of the
** payload to which the cursor is pointing.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3BtreeOffset</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>*</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator>
         <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_OFFSET_SQL_FUNC */</comment>

<comment type="block">/*
** Return the number of bytes of payload for the entry that pCur is
** currently pointing to.  For table btrees, this will be the amount
** of data.  For index btrees, this will be the size of the key.
**
** The caller must guarantee that the cursor is pointing to a non-NULL
** valid entry.  In other words, the calling procedure must guarantee
** that the cursor has Cursor.eState==CURSOR_VALID.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3BtreePayloadSize</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return an upper bound on the size of any record for the table
** that the cursor is pointing into.
**
** This is an optimization.  Everything will still work if this
** routine always returns 2147483647 (which is the largest record
** that SQLite can handle) or more.  But returning a smaller value might
** prevent large memory allocations when trying to interpret a
** corrupt datrabase.
**
** The current implementation merely returns the size of the underlying
** database file.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3BtreeMaxRecordSize</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>*</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the page number of an overflow page in the database (parameter
** ovfl), this function finds the page number of the next page in the 
** linked list of overflow pages. If possible, it uses the auto-vacuum
** pointer-map data instead of reading the content of page ovfl to do so. 
**
** If an error occurs an SQLite error code is returned. Otherwise:
**
** The page number of the next overflow page in the linked list is 
** written to *pPgnoNext. If page ovfl is the last page in its linked 
** list, *pPgnoNext is set to zero. 
**
** If ppPage is not NULL, and a reference to the MemPage object corresponding
** to page number pOvfl was obtained, then *ppPage is set to point to that
** reference. It is the responsibility of the caller to call releasePage()
** on *ppPage to free the reference. In no reference was obtained (because
** the pointer-map was used to obtain the value for *pPgnoNext), then
** *ppPage is set to zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getOverflowPage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,               <comment type="block">/* The database file */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>ovfl</name></decl></parameter>,                   <comment type="block">/* Current overflow page number */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,            <comment type="block">/* OUT: MemPage handle (may be NULL) */</comment>
  <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>pPgnoNext</name></decl></parameter>              <comment type="block">/* OUT: Next overflow page number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>next</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPgnoNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <comment type="block">/* Try to find the next page in the overflow list using the
  ** autovacuum pointer-map pages. Guess that the next page in 
  ** the overflow list is page number (ovfl+1). If that guess turns 
  ** out to be wrong, fall back to loading the data of page 
  ** number ovfl to determine the next page number.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iGuess</name> <init>= <expr><name>ovfl</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>

    <while>while<condition>( <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iGuess</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>iGuess</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iGuess</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>iGuess</name><operator>&lt;=</operator><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iGuess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>PTRMAP_OVERFLOW2</name> <operator>&amp;&amp;</operator> <name>pgno</name><operator>==</operator><name>ovfl</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name>iGuess</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>next</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovfl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>ppPage</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>PAGER_GET_READONLY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pPage</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pPgnoNext</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ppPage</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Copy data from a buffer to a page, or from a page to a buffer.
**
** pPayload is a pointer to data stored on database page pDbPage.
** If argument eOp is false, then nByte bytes of data are copied
** from pPayload to the buffer pointed at by pBuf. If eOp is true,
** then sqlite3PagerWrite() is called on pDbPage and nByte bytes
** of data are copied from the buffer pBuf to pPayload.
**
** SQLITE_OK is returned on success, otherwise an error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>copyPayload</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPayload</name></decl></parameter>,           <comment type="block">/* Pointer to page data */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,               <comment type="block">/* Pointer to buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,                <comment type="block">/* Number of bytes to copy */</comment>
  <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>,                  <comment type="block">/* 0 -&gt; copy from page, 1 -&gt; copy to page */</comment>
  <parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl></parameter>           <comment type="block">/* Page containing pPayload */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>eOp</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Copy data from buffer to page (a write operation) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Copy data from page to buffer (a read operation) */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to read or overwrite payload information
** for the entry that the pCur cursor is pointing to. The eOp
** argument is interpreted as follows:
**
**   0: The operation is a read. Populate the overflow cache.
**   1: The operation is a write. Populate the overflow cache.
**
** A total of "amt" bytes are read or written beginning at "offset".
** Data is read to or from the buffer pBuf.
**
** The content being read or written might appear on the main page
** or be scattered out on multiple overflow pages.
**
** If the current cursor entry uses one or more overflow pages
** this function may allocate space for and lazily populate
** the overflow page-list cache array (BtCursor.aOverflow). 
** Subsequent calls use this cache to make seeking to the supplied offset 
** more efficient.
**
** Once an overflow page-list cache has been allocated, it must be
** invalidated if some other cursor writes to the same table, or if
** the cursor is moved to a different row. Additionally, in auto-vacuum
** mode, the following events may invalidate an overflow page-list cache.
**
**   * An incremental vacuum,
**   * A commit in auto_vacuum="full" mode,
**   * Creating a table (may require moving an overflow page).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>accessPayload</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,      <comment type="block">/* Cursor pointing to entry to read from */</comment>
  <parameter><decl><type><name>u32</name></type> <name>offset</name></decl></parameter>,          <comment type="block">/* Begin reading this far into payload */</comment>
  <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>,             <comment type="block">/* Read this many bytes */</comment>
  <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <comment type="block">/* Write the bytes into this buffer */</comment> 
  <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>              <comment type="block">/* zero to read. non-zero to write. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>               <comment type="block">/* Btree page of current entry */</comment>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Btree this cursor belongs to */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DIRECT_OVERFLOW_READ</name></cpp:ifdef>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pBufStart</name> <init>= <expr><name>pBuf</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Start of original out buffer */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eOp</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPayload</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name><operator>+</operator><name>amt</name> <operator>&lt;=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aPayload</name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>uptr</name><operator>)</operator><operator>(</operator><name>aPayload</name> <operator>-</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* Trying to read or write past the end of the data is an error.  The
    ** conditional above is really:
    **    &amp;aPayload[pCur-&gt;info.nLocal] &gt; &amp;pPage-&gt;aData[pBt-&gt;usableSize]
    ** but is recast into its current form to avoid integer overflow problems
    */</comment>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if data must be read/written to/from the btree page itself. */</comment>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><name>amt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>+</operator><name>offset</name><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>copyPayload</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aPayload</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>a</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>offset</name> <operator>-=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>


  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>u32</name></type> <name>ovflSize</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Bytes content per ovfl page */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nextPage</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aPayload</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
    <comment type="block">/* If the BtCursor.aOverflow[] has not been allocated, allocate it now.
    **
    ** The aOverflow[] array is sized at one entry for each overflow page
    ** in the overflow chain. The page number of the first overflow page is
    ** stored in aOverflow[0], etc. A value of 0 in the aOverflow[] array
    ** means "not yet known" (the cache is lazily populated).
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidOvfl</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name> <init>= <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name><operator>-</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name><operator>+</operator><name>ovflSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>ovflSize</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <name>nOvfl</name><operator>*</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Pgno</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name></name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>aNew</name> <init>= <expr><operator>(</operator><name>Pgno</name><operator>*</operator><operator>)</operator><call><name>sqlite3Realloc</name><argument_list>(
            <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name></name></expr></argument>, <argument><expr><name>nOvfl</name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Pgno</name></expr></argument>)</argument_list></sizeof></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nOvfl</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Pgno</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_ValidOvfl</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* If the overflow page-list cache has been allocated and the
      ** entry for the first required overflow page is valid, skip
      ** directly to it.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>offset</name><operator>/</operator><name>ovflSize</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iIdx</name> <operator>=</operator> <operator>(</operator><name>offset</name><operator>/</operator><name>ovflSize</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>offset</name><operator>%</operator><name>ovflSize</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>nextPage</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If required, populate the overflow page-list cache. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nextPage</name> <operator>&gt;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal>
              <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name><operator>==</operator><name>nextPage</name>
              <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name> <operator>=</operator> <name>nextPage</name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&gt;=</operator><name>ovflSize</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The only reason to read this page is to obtain the page
        ** number for the next page in the overflow chain. The page
        ** data is not required. So first try to lookup the overflow
        ** page-list cache, if any, then fall back to the getOverflowPage()
        ** function.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidOvfl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name><name>pBt</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>iIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nextPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aOverflow</name><index>[<expr><name>iIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getOverflowPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nextPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>-=</operator> <name>ovflSize</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Need to read this page properly. It contains some of the
        ** range of data that is being read (eOp==0) or written (eOp!=0).
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><name>amt</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>a</name> <operator>+</operator> <name>offset</name> <operator>&gt;</operator> <name>ovflSize</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>a</name> <operator>=</operator> <name>ovflSize</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DIRECT_OVERFLOW_READ</name></cpp:ifdef>
        <comment type="block">/* If all the following are true:
        **
        **   1) this is a read operation, and 
        **   2) data is required from the start of this overflow page, and
        **   3) there are no dirty pages in the page-cache
        **   4) the database is file-backed, and
        **   5) the page is not in the WAL file
        **   6) at least 4 bytes have already been read into the output buffer 
        **
        ** then data can be read directly from the database file into the
        ** output buffer, bypassing the page-cache altogether. This speeds
        ** up loading large records that span many overflow pages.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><literal type="number">0</literal>                                             <comment type="block">/* (1) */</comment>
         <operator>&amp;&amp;</operator> <name>offset</name><operator>==</operator><literal type="number">0</literal>                                          <comment type="block">/* (2) */</comment>
         <operator>&amp;&amp;</operator> <call><name>sqlite3PagerDirectReadOk</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>nextPage</name></expr></argument>)</argument_list></call>    <comment type="block">/* (3,4,5) */</comment>
         <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>pBuf</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name><operator>&gt;=</operator><name>pBufStart</name></expr>                               <comment type="block">/* (6) */</comment>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u8</name></type> <name><name>aSave</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aWrite</name> <init>= <expr><operator>&amp;</operator><name><name>pBuf</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aWrite</name><operator>&gt;=</operator><name>pBufStart</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>                         <comment type="block">/* due to (6) */</comment>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aSave</name></expr></argument>, <argument><expr><name>aWrite</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aWrite</name></expr></argument>, <argument><expr><name>a</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>*</operator><operator>(</operator><name>nextPage</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <name>nextPage</name><operator>&gt;</operator><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>aWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aWrite</name></expr></argument>, <argument><expr><name>aSave</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <block>{<block_content>
          <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pDbPage</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>nextPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDbPage</name></expr></argument>,
              <argument><expr><operator>(</operator><ternary><condition><expr><name>eOp</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>PAGER_GET_READONLY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>aPayload</name> <operator>=</operator> <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>aPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>copyPayload</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aPayload</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>, <argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>a</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>amt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pBuf</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iIdx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Overflow chain ends prematurely */</comment>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read part of the payload for the row at which that cursor pCur is currently
** pointing.  "amt" bytes will be transferred into pBuf[].  The transfer
** begins at "offset".
**
** pCur can be pointing to either a table or an index b-tree.
** If pointing to a table btree, then the content section is read.  If
** pCur is pointing to an index b-tree then the key section is read.
**
** For sqlite3BtreePayload(), the caller must ensure that pCur is pointing
** to a valid row in the table.  For sqlite3BtreePayloadChecked(), the
** cursor might be invalid or might need to be restored before being read.
**
** Return SQLITE_OK on success or an error code if anything goes
** wrong.  An error is returned if "offset+amt" is larger than
** the available payload.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreePayload</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>accessPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This variant of sqlite3BtreePayload() works even if the cursor has not
** in the CURSOR_VALID state.  It is only used by the sqlite3_blob_read()
** interface.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>accessPayloadChecked</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,
  <parameter><decl><type><name>u32</name></type> <name>offset</name></decl></parameter>,
  <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_INVALID</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ABORT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeRestoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><call><name>accessPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreePayloadChecked</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>accessPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>accessPayloadChecked</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INCRBLOB */</comment>

<comment type="block">/*
** Return a pointer to payload information from the entry that the 
** pCur cursor is pointing to.  The pointer is to the beginning of
** the key if index btrees (pPage-&gt;intKey==0) and is the data for
** table btrees (pPage-&gt;intKey==1). The number of bytes of available
** key/data is written into *pAmt.  If *pAmt==0, then the value
** returned will not be a valid pointer.
**
** This routine is an optimization.  It is common for the entire key
** and data to fit on the local page and for there to be no overflow
** pages.  When that is so, this routine can be used to access the
** key and data without making a copy.  If the key and/or data spills
** onto overflow pages, then accessPayload() must be used to reassemble
** the key/data and copy it into a preallocated buffer.
**
** The pointer returned by this routine looks directly into the cached
** page of the database.  The data might change or move the next time
** any btree routine is called.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>fetchPayload</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,      <comment type="block">/* Cursor pointing to entry to read from */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pAmt</name></decl></parameter>            <comment type="block">/* Write the number of available bytes here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>amt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name> <operator>||</operator><name>CORRUPT_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>amt</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>amt</name><operator>&gt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* There is too little space on the page for the expected amount
    ** of local content. Database must be corrupt. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>amt</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pAmt</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>amt</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** For the entry that cursor pCur is point to, return as
** many bytes of the key or data as are available on the local
** b-tree page.  Write the number of available bytes into *pAmt.
**
** The pointer returned is ephemeral.  The key/data may move
** or be destroyed on the next call to any Btree routine,
** including calls from other threads against the same cache.
** Hence, a mutex on the BtShared should be held prior to calling
** this routine.
**
** These routines is used to get quick access to key and data
** in the common case where no overflow pages are used.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3BtreePayloadFetch</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pAmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fetchPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pAmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Move the cursor down to a new child page.  The newPgno argument is the
** page number of the child page to move to.
**
** This function returns SQLITE_CORRUPT if the page-header flags field of
** the new child page does not match the flags field of the parent (i.e.
** if an intkey page appears to be the parent of a non-intkey page, or
** vice-versa).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>moveToChild</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>newPgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&lt;</operator><name>BTCURSOR_MAX_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><operator>(</operator><name>BTCURSOR_MAX_DEPTH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_ValidNKey</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><call><name>getAndInitPage</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>newPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>,
                        <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curPagerFlags</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Page pParent is an internal (non-leaf) tree page. This function 
** asserts that page number iChild is the left-child if the iIdx'th
** cell in page pParent. Or, if iIdx is equal to the total number of
** cells in pParent, that page number iChild is the right-child of
** the page.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertParentIndex</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iChild</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>CORRUPT_DB</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* The conditions tested below might not be true
                            ** in a corrupt database */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdx</name><operator>&lt;=</operator><name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iIdx</name><operator>==</operator><name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pParent</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>iChild</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><name>iChild</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>assertParentIndex</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Move the cursor up to the parent page.
**
** pCur-&gt;idx is set to the cell index that contains the pointer
** to the page we are coming from.  If we are coming from the
** right-most child page then pCur-&gt;idx is set to one more than
** the largest cell index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>moveToParent</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pLeaf</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assertParentIndex</name><argument_list>(
    <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, 
    <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, 
    <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_ValidNKey</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeaf</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><operator>--</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Move the cursor to point to the root page of its b-tree structure.
**
** If the table has a virtual root page, then the cursor is moved to point
** to the virtual root page instead of the actual root page. A table has a
** virtual root page when the actual root page contains no cells and a 
** single child page. This can only happen with the table rooted at page 1.
**
** If the b-tree structure is empty, the cursor state is set to 
** CURSOR_INVALID and this routine returns SQLITE_EMPTY. Otherwise,
** the cursor is set to point to the first cell located on the root
** (or virtual root) page and the cursor state is set to CURSOR_VALID.
**
** If this function returns successfully, it may be assumed that the
** page-header flags indicate that the [virtual] root-page is the expected 
** kind of b-tree page (i.e. if when opening the cursor the caller did not
** specify a KeyInfo structure the flags byte is set to 0x05 or 0x0D,
** indicating a table b-tree, or if the caller did specify a KeyInfo 
** structure the flags byte is set to 0x02 or 0x0A, indicating an index
** b-tree).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>moveToRoot</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_INVALID</name> <operator>&lt;</operator> <name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_VALID</name>   <operator>&lt;</operator> <name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_FAULT</name>   <operator>&gt;</operator> <name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>&lt;</operator> <name>CURSOR_REQUIRESEEK</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>--</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <goto>goto <name>skip_init</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_EMPTY</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>CURSOR_REQUIRESEEK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_FAULT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getAndInitPage</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>,
                        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curPagerFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pCur-&gt;pKeyInfo is not NULL, then the caller that opened this cursor
  ** expected to open it on an index b-tree. Otherwise, if pKeyInfo is
  ** NULL, the caller expects a table b-tree. If this is not the case,
  ** return an SQLITE_CORRUPT error. 
  **
  ** Earlier versions of SQLite assumed that this test could not fail
  ** if the root page was already loaded when this function was called (i.e.
  ** if pCur-&gt;iPage&gt;=0). But this is not so if the database is corrupted 
  ** in such a way that page pRoot is linked into a second b-tree table 
  ** (or the freelist).  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>intKey</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>intKey</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>intKey</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

<label><name>skip_init</name>:</label>  
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_AtLast</name><operator>|</operator><name>BTCF_ValidNKey</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_VALID</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name><name>pRoot</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>subpage</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>pgno</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>subpage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRoot</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pRoot</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_VALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>subpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_EMPTY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move the cursor down to the left-most leaf entry beneath the
** entry to which it is currently pointing.
**
** The left-most leaf is the one with the smallest key - the first
** in ascending order.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>moveToLeftmost</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name><operator>)</operator><operator>-&gt;</operator><name>leaf</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move the cursor down to the right-most leaf entry beneath the
** page to which it is currently pointing.  Notice the difference
** between moveToLeftmost() and moveToRightmost().  moveToLeftmost()
** finds the left-most entry beneath the *entry* whereas moveToRightmost()
** finds the right-most entry beneath the *page*.
**
** The right-most entry is the one with the largest key - the last
** key in ascending order.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>moveToRightmost</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><operator>(</operator><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name><operator>)</operator><operator>-&gt;</operator><name>leaf</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidNKey</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Move the cursor to the first entry in the table.  Return SQLITE_OK
** on success.  Set *pRes to 0 if the cursor actually points to something
** or set *pRes to 1 if the table is empty.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeFirst</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_EMPTY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Move the cursor to the last entry in the table.  Return SQLITE_OK
** on success.  Set *pRes to 0 if the cursor actually points to something
** or set *pRes to 1 if the table is empty.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>btreeLast</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRightmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_AtLast</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTCF_AtLast</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_EMPTY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeLast</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the cursor already points to the last entry, this is a no-op. */</comment>
  <if_stmt><if>if<condition>( <expr><name>CURSOR_VALID</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_AtLast</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* This block serves to assert() that the cursor really does point 
    ** to the last entry in the b-tree. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>!=</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ^-- dbsqlfuzz b92b72e4de80b5140c30ab71372ca719b8feb618 */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>btreeLast</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Move the cursor so that it points to an entry in a table (a.k.a INTKEY)
** table near the key intKey.   Return a success code.
**
** If an exact match is not found, then the cursor is always
** left pointing at a leaf page which would hold the entry if it
** were present.  The cursor might point to an entry that comes
** before or after the key.
**
** An integer is written into *pRes which is the result of
** comparing the key with the entry to which the cursor is 
** pointing.  The meaning of the integer written into
** *pRes is as follows:
**
**     *pRes&lt;0      The cursor is left pointing at an entry that
**                  is smaller than intKey or if the table is empty
**                  and the cursor is therefore left point to nothing.
**
**     *pRes==0     The cursor is left pointing at an entry that
**                  exactly matches intKey.
**
**     *pRes&gt;0      The cursor is left pointing at an entry that
**                  is larger than intKey.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeTableMoveto</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,          <comment type="block">/* The cursor to be moved */</comment>
  <parameter><decl><type><name>i64</name></type> <name>intKey</name></decl></parameter>,              <comment type="block">/* The table key */</comment>
  <parameter><decl><type><name>int</name></type> <name>biasRight</name></decl></parameter>,           <comment type="block">/* If true, bias the search to the high end */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>                <comment type="block">/* Write search results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRes</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the cursor is already positioned at the point we are trying
  ** to move to, then just return without doing any work */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidNKey</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name><operator>==</operator><name>intKey</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name><operator>&lt;</operator><name>intKey</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_AtLast</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* If the requested key is one more than the previous key, then
      ** try to get there using sqlite3BtreeNext() rather than a full
      ** binary search.  This is an optimization only.  The correct answer
      ** is still obtained without this case, only a little more slowely */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>intKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name><operator>==</operator><name>intKey</name></expr> )</condition><block>{<block_content>
            <return>return <expr><name>SQLITE_OK</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>nSeek</name></name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* Performance measurement during testing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_EMPTY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>intKey</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lwr</name></decl>, <decl><type ref="prev"/><name>upr</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>chldPg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>                          <comment type="block">/* Pointer to current cell in pPage */</comment>

    <comment type="block">/* pPage-&gt;nCell must be greater than zero. If this is the root-page
    ** the cursor would have been INVALID above and this for(;;) loop
    ** not run. If this is not the root-page, then the moveToChild() routine
    ** would have already detected db corruption. Similarly, pPage must
    ** be the right kind (index or table) of b-tree page. Otherwise
    ** a moveToChild() or moveToRoot() call would have detected corruption.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lwr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>upr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>biasRight</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>biasRight</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>upr</name><operator>&gt;&gt;</operator><operator>(</operator><literal type="number">1</literal><operator>-</operator><name>biasRight</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* idx = biasRight ? upr : (lwr+upr)/2; */</comment>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>findCellPastPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><literal type="number">0x80</literal> <operator>&lt;=</operator> <operator>*</operator><operator>(</operator><name>pCell</name><operator>++</operator><operator>)</operator></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pCell</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr> )</condition><block>{<block_content>
            <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>getVarint</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCellKey</name><operator>&lt;</operator><name>intKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>lwr</name> <operator>=</operator> <name>idx</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lwr</name><operator>&gt;</operator><name>upr</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nCellKey</name><operator>&gt;</operator><name>intKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>upr</name> <operator>=</operator> <name>idx</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lwr</name><operator>&gt;</operator><name>upr</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCellKey</name><operator>==</operator><name>intKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>idx</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>lwr</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
          <goto>goto <name>moveto_table_next_layer</name>;</goto>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_ValidNKey</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name> <operator>=</operator> <name>nCellKey</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lwr</name><operator>+</operator><name>upr</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>lwr</name><operator>+</operator><name>upr</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* idx = (lwr+upr)/2; */</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lwr</name><operator>==</operator><name>upr</name><operator>+</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>idx</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <goto>goto <name>moveto_table_finish</name>;</goto>
    </block_content>}</block></if></if_stmt>
<label><name>moveto_table_next_layer</name>:</label>
    <if_stmt><if>if<condition>( <expr><name>lwr</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>chldPg</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>chldPg</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>lwr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>lwr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>chldPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<label><name>moveto_table_finish</name>:</label>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidOvfl</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the "idx"-th cell on the page the cursor pCur is currently
** pointing to to pIdxKey using xRecordCompare.  Return negative or
** zero if the cell is less than or equal pIdxKey.  Return positive
** if unknown.
**
**    Return value negative:     Cell at pCur[idx] less than pIdxKey
**
**    Return value is zero:      Cell at pCur[idx] equals pIdxKey
**
**    Return value positive:     Nothing is known about the relationship
**                               of the cell at pCur[idx] and pIdxKey.
**
** This routine is part of an optimization.  It is always safe to return
** a positive value as that will cause the optimization to be skipped.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexCellCompare</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pIdxKey</name></decl></parameter>,
  <parameter><decl><type><name>RecordCompare</name></type> <name>xRecordCompare</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>  <comment type="block">/* Size of the pCell cell in bytes */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><call><name>findCellPastPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <name><name>pCell</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nCell</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>max1bytePayload</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This branch runs if the record-size field of the cell is a
    ** single byte varint and the record fits entirely on the main
    ** b-tree page.  */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCell</name><operator>+</operator><name>nCell</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>xRecordCompare</name><argument_list>(<argument><expr><name>nCell</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> 
    <operator>&amp;&amp;</operator> <operator>(</operator><name>nCell</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nCell</name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <name><name>pCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* The record-size field is a 2 byte varint and the record 
    ** fits entirely on the main b-tree page.  */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCell</name><operator>+</operator><name>nCell</name><operator>+</operator><literal type="number">2</literal><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>xRecordCompare</name><argument_list>(<argument><expr><name>nCell</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If the record extends into overflow pages, do not attempt
    ** the optimization. */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">99</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true (non-zero) if pCur is current pointing to the last
** page of a table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cursorOnLastPage</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Move the cursor so that it points to an entry in an index table
** near the key pIdxKey.   Return a success code.
**
** If an exact match is not found, then the cursor is always
** left pointing at a leaf page which would hold the entry if it
** were present.  The cursor might point to an entry that comes
** before or after the key.
**
** An integer is written into *pRes which is the result of
** comparing the key with the entry to which the cursor is 
** pointing.  The meaning of the integer written into
** *pRes is as follows:
**
**     *pRes&lt;0      The cursor is left pointing at an entry that
**                  is smaller than pIdxKey or if the table is empty
**                  and the cursor is therefore left point to nothing.
**
**     *pRes==0     The cursor is left pointing at an entry that
**                  exactly matches pIdxKey.
**
**     *pRes&gt;0      The cursor is left pointing at an entry that
**                  is larger than pIdxKey.
**
** The pIdxKey-&gt;eqSeen field is set to 1 if there
** exists an entry in the table that exactly matches pIdxKey.  
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIndexMoveto</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,          <comment type="block">/* The cursor to be moved */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pIdxKey</name></decl></parameter>, <comment type="block">/* Unpacked index key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>                <comment type="block">/* Write search results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecordCompare</name></type> <name>xRecordCompare</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRes</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>nSeek</name></name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* Performance measurement during testing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>xRecordCompare</name> <operator>=</operator> <call><name>sqlite3VdbeFindCompare</name><argument_list>(<argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>default_rc</name></name><operator>==</operator><literal type="number">1</literal> 
       <operator>||</operator> <name><name>pIdxKey</name><operator>-&gt;</operator><name>default_rc</name></name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <name><name>pIdxKey</name><operator>-&gt;</operator><name>default_rc</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Check to see if we can skip a lot of work.  Two cases:
  **
  **    (1) If the cursor is already pointing to the very last cell
  **        in the table and the pIdxKey search key is greater than or
  **        equal to that last cell, then no movement is required.
  **
  **    (2) If the cursor is on the last page of the table and the first
  **        cell on that last page is less than or equal to the pIdxKey
  **        search key, then we can start the search on the current page
  **        without needing to go back to root.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name>
   <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name>
   <operator>&amp;&amp;</operator> <call><name>cursorOnLastPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name>indexCellCompare</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr><name>xRecordCompare</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>  <comment type="block">/* Cursor already pointing at the correct spot */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <call><name>indexCellCompare</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr><name>xRecordCompare</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTCF_ValidOvfl</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>bypass_moveto_root</name>;</goto>  <comment type="block">/* Start search on the current page */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_EMPTY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<label><name>bypass_moveto_root</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curIntKey</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdxKey</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lwr</name></decl>, <decl><type ref="prev"/><name>upr</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>chldPg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>                          <comment type="block">/* Pointer to current cell in pPage */</comment>

    <comment type="block">/* pPage-&gt;nCell must be greater than zero. If this is the root-page
    ** the cursor would have been INVALID above and this for(;;) loop
    ** not run. If this is not the root-page, then the moveToChild() routine
    ** would have already detected db corruption. Similarly, pPage must
    ** be the right kind (index or table) of b-tree page. Otherwise
    ** a moveToChild() or moveToRoot() call would have detected corruption.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lwr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>upr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>upr</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* idx = (lwr+upr)/2; */</comment>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>  <comment type="block">/* Size of the pCell cell in bytes */</comment>
      <expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>findCellPastPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* The maximum supported page-size is 65536 bytes. This means that
      ** the maximum number of record bytes stored on an index B-Tree
      ** page is less than 16384 bytes and may be stored as a 2-byte
      ** varint. This information is used to attempt to avoid parsing 
      ** the entire cell by checking for the cases where the record is 
      ** stored entirely within the b-tree page by inspecting the first 
      ** 2 bytes of the cell.
      */</comment>
      <expr_stmt><expr><name>nCell</name> <operator>=</operator> <name><name>pCell</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCell</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>max1bytePayload</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This branch runs if the record-size field of the cell is a
        ** single byte varint and the record fits entirely on the main
        ** b-tree page.  */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCell</name><operator>+</operator><name>nCell</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>xRecordCompare</name><argument_list>(<argument><expr><name>nCell</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> 
        <operator>&amp;&amp;</operator> <operator>(</operator><name>nCell</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nCell</name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <name><name>pCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* The record-size field is a 2 byte varint and the record 
        ** fits entirely on the main b-tree page.  */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCell</name><operator>+</operator><name>nCell</name><operator>+</operator><literal type="number">2</literal><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>xRecordCompare</name><argument_list>(<argument><expr><name>nCell</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* The record flows over onto one or more overflow pages. In
        ** this case the whole cell needs to be parsed, a buffer allocated
        ** and accessPayload() used to retrieve the record into the
        ** buffer before VdbeRecordCompare() can be called. 
        **
        ** If the record is corrupt, the xRecordCompare routine may read
        ** up to two varints past the end of the buffer. An extra 18 
        ** bytes of padding is allocated at the end of the buffer in
        ** case this happens.  */</comment>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCellKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pCellBody</name> <init>= <expr><name>pCell</name> <operator>-</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nOverrun</name> <init>= <expr><literal type="number">18</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Size of the overrun padding */</comment>
        <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCellBody</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCell</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nCell</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* True if key size is 2^32 or more */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nCell</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Invalid key size:  0x80 0x80 0x00 */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nCell</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Invalid key size:  0x80 0x80 0x01 */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nCell</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Minimum legal index key size */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>nCell</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal> <operator>||</operator> <name>nCell</name><operator>/</operator><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument>&gt;</argument_list></name><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>moveto_index_finish</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pCellKey</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>nCell</name><operator>+</operator><name>nOverrun</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pCellKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
          <goto>goto <name>moveto_index_finish</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>idx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>accessPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nCell</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pCellKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pCellKey</name><operator>)</operator><operator>+</operator><name>nCell</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>nOverrun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Fix uninit warnings */</comment>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTCF_ValidOvfl</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>moveto_index_finish</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>nCell</name></expr></argument>, <argument><expr><name>pCellKey</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( 
          <argument><expr><operator>(</operator><name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_CORRUPT</name> <operator>||</operator> <name>c</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>lwr</name> <operator>=</operator> <name>idx</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>upr</name> <operator>=</operator> <name>idx</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>idx</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <goto>goto <name>moveto_index_finish</name>;</goto>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>lwr</name><operator>&gt;</operator><name>upr</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lwr</name><operator>+</operator><name>upr</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>lwr</name><operator>+</operator><name>upr</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* idx = (lwr+upr)/2 */</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lwr</name><operator>==</operator><name>upr</name><operator>+</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>idx</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <goto>goto <name>moveto_index_finish</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>lwr</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>chldPg</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>chldPg</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>lwr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>lwr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>chldPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<label><name>moveto_index_finish</name>:</label>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidOvfl</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return TRUE if the cursor is not pointing at an entry of the table.
**
** TRUE will be returned after a call to sqlite3BtreeNext() moves
** past the last entry in the table or sqlite3BtreePrev() moves past
** the first entry.  TRUE is also returned if the table is empty.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeEof</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries
  ** have been deleted? This API will need to change to return an error code
  ** as well as the boolean result value.
  */</comment>
  <return>return <expr><operator>(</operator><name>CURSOR_VALID</name><operator>!=</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return an estimate for the number of rows in the table that pCur is
** pointing to.  Return a negative number if no estimate is currently 
** available.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3BtreeRowCountEst</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Currently this interface is only called by the OP_IfSmaller
  ** opcode, and it that case the cursor will always be valid and
  ** will always point to a leaf node. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>*=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nCell</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the cursor to the next entry in the database. 
** Return value:
**
**    SQLITE_OK        success
**    SQLITE_DONE      cursor is already pointing at the last element
**    otherwise        some kind of error occurred
**
** The main entry point is sqlite3BtreeNext().  That routine is optimized
** for the common case of merely incrementing the cell counter BtCursor.aiIdx
** to the next cell on the current page.  The (slower) btreeNext() helper
** routine is called when it is necessary to move to a different page or
** to restore the cursor.
**
** If bit 0x01 of the F argument in sqlite3BtreeNext(C,F) is 1, then the
** cursor corresponds to an SQL index and this routine could have been
** skipped if the SQL index had been a unique index.  The F argument
** is a hint to the implement.  SQLite btree implementation does not use
** this hint, but COMDB2 does.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>btreeNext</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidOvfl</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>CURSOR_INVALID</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_SKIPNEXT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_VALID</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>++</operator><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">412</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>idx</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <do>do<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>moveToParent</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition>;</do>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeNext</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>( <argument><expr><name>flags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Used in COMDB2 but not native SQLite */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>flags</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_ValidNKey</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>btreeNext</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>++</operator><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>)</operator><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><call><name>btreeNext</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Step the cursor to the back to the previous entry in the database.
** Return values:
**
**     SQLITE_OK     success
**     SQLITE_DONE   the cursor is already on the first element of the table
**     otherwise     some kind of error occurred
**
** The main entry point is sqlite3BtreePrevious().  That routine is optimized
** for the common case of merely decrementing the cell counter BtCursor.aiIdx
** to the previous cell on the current page.  The (slower) btreePrevious()
** helper routine is called when it is necessary to move to a different page
** or to restore the cursor.
**
** If bit 0x01 of the F argument to sqlite3BtreePrevious(C,F) is 1, then
** the cursor corresponds to an SQL index and this routine could have been
** skipped if the SQL index had been a unique index.  The F argument is a
** hint to the implement.  The native SQLite btree implementation does not
** use this hint, but COMDB2 does.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>btreePrevious</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>BTCF_AtLast</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>|</operator><name>BTCF_ValidNKey</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>CURSOR_INVALID</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>CURSOR_SKIPNEXT</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_VALID</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRightmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>moveToParent</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>BTCF_ValidOvfl</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreePrevious</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>flags</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>( <argument><expr><name>flags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Used in COMDB2 but not native SQLite */</comment>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_AtLast</name><operator>|</operator><name>BTCF_ValidOvfl</name><operator>|</operator><name>BTCF_ValidNKey</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name>
   <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><call><name>btreePrevious</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new page from the database file.
**
** The new page is marked as dirty.  (In other words, sqlite3PagerWrite()
** has already been called on the new page.)  The new page has also
** been referenced and the calling routine is responsible for calling
** sqlite3PagerUnref() on the new page when it is done.
**
** SQLITE_OK is returned on success.  Any other return value indicates
** an error.  *ppPage is set to NULL in the event of an error.
**
** If the "nearby" parameter is not 0, then an effort is made to 
** locate a page close to the page number "nearby".  This can be used in an
** attempt to keep related pages close to each other in the database file,
** which in turn can make database access faster.
**
** If the eMode parameter is BTALLOC_EXACT and the nearby page exists
** anywhere on the free-list, then it is guaranteed to be returned.  If
** eMode is BTALLOC_LT then the page returned will be less than or equal
** to nearby if any such page exists.  If eMode is BTALLOC_ANY then there
** are no restrictions on which page is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>allocateBtreePage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,         <comment type="block">/* The btree */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,      <comment type="block">/* Store pointer to the allocated page here */</comment>
  <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>pPgno</name></decl></parameter>,           <comment type="block">/* Store the page number here */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>nearby</name></decl></parameter>,           <comment type="block">/* Search for a page near this one */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eMode</name></decl></parameter>               <comment type="block">/* BTALLOC_EXACT, BTALLOC_LT, or BTALLOC_ANY */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>     <comment type="block">/* Number of pages on the freelist */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>k</name></decl>;</decl_stmt>     <comment type="block">/* Number of leaves on the trunk of the freelist */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pTrunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPrevTrunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>mxPage</name></decl>;</decl_stmt>     <comment type="block">/* Total size of the database file */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>==</operator><name>BTALLOC_ANY</name> <operator>||</operator> <operator>(</operator><name>nearby</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IfNotOmitAV</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage1</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxPage</name> <operator>=</operator> <call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-21003-45125 The 4-byte big-endian integer at offset 36
  ** stores the total number of pages on the freelist. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name>mxPage</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><name>mxPage</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* There are pages on the freelist.  Reuse one of those pages. */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iTrunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>searchList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* If the free-list must be searched for 'nearby' */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>nSearch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Count of the number of search attempts */</comment>
    
    <comment type="block">/* If eMode==BTALLOC_EXACT and a query of the pointer-map
    ** shows that the page 'nearby' is somewhere on the free-list, then
    ** the entire-list will be searched for that page.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><name>BTALLOC_EXACT</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nearby</name><operator>&lt;=</operator><name>mxPage</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nearby</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nearby</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_FREEPAGE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>searchList</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eMode</name><operator>==</operator><name>BTALLOC_LE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>searchList</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Decrement the free-list count by 1. Set iTrunk to the index of the
    ** first free-list trunk page. iPrevTrunk is initially 1.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The code within this loop is run only once if the 'searchList' variable
    ** is not true. Otherwise, it runs once for each trunk-page on the
    ** free-list until the page 'nearby' is located (eMode==BTALLOC_EXACT)
    ** or until a page less than 'nearby' is located (eMode==BTALLOC_LT)
    */</comment>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>pPrevTrunk</name> <operator>=</operator> <name>pTrunk</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPrevTrunk</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-01506-11053 The first integer on a freelist trunk page
        ** is the page number of the next freelist trunk page in the list or
        ** zero if this is the last freelist trunk page. */</comment>
        <expr_stmt><expr><name>iTrunk</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPrevTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-59841-13798 The 4-byte big-endian integer at offset 32
        ** stores the page number of the first page of the freelist, or zero if
        ** the freelist is empty. */</comment>
        <expr_stmt><expr><name>iTrunk</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTrunk</name><operator>==</operator><name>mxPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTrunk</name><operator>&gt;</operator><name>mxPage</name> <operator>||</operator> <name>nSearch</name><operator>++</operator> <operator>&gt;</operator> <name>n</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PGNO</name><argument_list>(<argument><expr><ternary><condition><expr><name>pPrevTrunk</name></expr> ?</condition><then> <expr><name><name>pPrevTrunk</name><operator>-&gt;</operator><name>pgno</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetUnusedPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iTrunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTrunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pTrunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>end_allocate_page</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTrunk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* EVIDENCE-OF: R-13523-04394 The second integer on a freelist trunk page
      ** is the number of leaf page pointers to follow. */</comment>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>k</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>searchList</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The trunk has no leaves and the list is not being searched. 
        ** So extract the trunk page itself and use it as the newly 
        ** allocated page */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrevTrunk</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>end_allocate_page</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>pPgno</name> <operator>=</operator> <name>iTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>pTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTrunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ALLOCATE: %d trunk - %d free pages left\n"</literal><operator>,</operator> <operator>*</operator><name>pPgno</name><operator>,</operator> <name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>k</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>/</operator><literal type="number">4</literal> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* Value of k is out of range.  Database corruption */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PGNO</name><argument_list>(<argument><expr><name>iTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>end_allocate_page</name>;</goto>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>searchList</name> 
            <operator>&amp;&amp;</operator> <operator>(</operator><name>nearby</name><operator>==</operator><name>iTrunk</name> <operator>||</operator> <operator>(</operator><name>iTrunk</name><operator>&lt;</operator><name>nearby</name> <operator>&amp;&amp;</operator> <name>eMode</name><operator>==</operator><name>BTALLOC_LE</name><operator>)</operator><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <comment type="block">/* The list is being searched and this trunk page is the page
        ** to allocate, regardless of whether it has leaves.
        */</comment>
        <expr_stmt><expr><operator>*</operator><name>pPgno</name> <operator>=</operator> <name>iTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>pTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>searchList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>end_allocate_page</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>k</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPrevTrunk</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPrevTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <goto>goto <name>end_allocate_page</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPrevTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* The trunk page is required by the caller but it contains 
          ** pointers to free-list leaves. The first leaf becomes a trunk
          ** page in this case.
          */</comment>
          <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pNewTrunk</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Pgno</name></type> <name>iNewTrunk</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>iNewTrunk</name><operator>&gt;</operator><name>mxPage</name></expr> )</condition><block>{<block_content> 
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PGNO</name><argument_list>(<argument><expr><name>iTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>end_allocate_page</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iNewTrunk</name><operator>==</operator><name>mxPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetUnusedPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iNewTrunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNewTrunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <goto>goto <name>end_allocate_page</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pNewTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>end_allocate_page</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNewTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNewTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNewTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>k</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPrevTrunk</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPrevTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
              <goto>goto <name>end_allocate_page</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPrevTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>pTrunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ALLOCATE: %d trunk - %d free pages left\n"</literal><operator>,</operator> <operator>*</operator><name>pPgno</name><operator>,</operator> <name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>k</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Extract a leaf from the trunk */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>closest</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iPage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nearby</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>closest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><name>BTALLOC_LE</name></expr> )</condition><block>{<block_content>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><name>iPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>i</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>&lt;=</operator><name>nearby</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>closest</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <break>break;</break>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>sqlite3AbsInt32</name><argument_list>(<argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nearby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>d2</name> <init>= <expr><call><name>sqlite3AbsInt32</name><argument_list>(<argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>i</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nearby</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if<condition>( <expr><name>d2</name><operator>&lt;</operator><name>dist</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>closest</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d2</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>closest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>iPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>closest</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iPage</name><operator>==</operator><name>mxPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>&gt;</operator><name>mxPage</name> <operator>||</operator> <name>iPage</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_CORRUPT_PGNO</name><argument_list>(<argument><expr><name>iTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>end_allocate_page</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iPage</name><operator>==</operator><name>mxPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>searchList</name> 
         <operator>||</operator> <operator>(</operator><name>iPage</name><operator>==</operator><name>nearby</name> <operator>||</operator> <operator>(</operator><name>iPage</name><operator>&lt;</operator><name>nearby</name> <operator>&amp;&amp;</operator> <name>eMode</name><operator>==</operator><name>BTALLOC_LE</name><operator>)</operator><operator>)</operator></expr> 
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>noContent</name></decl>;</decl_stmt>
          <expr_stmt><expr><operator>*</operator><name>pPgno</name> <operator>=</operator> <name>iPage</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ALLOCATE: %d was leaf %d of %d on trunk %d"</literal>
                 <literal type="string">": %d more free pages\n"</literal><operator>,</operator>
                 <operator>*</operator><name>pPgno</name><operator>,</operator> <name>closest</name><operator>+</operator><literal type="number">1</literal><operator>,</operator> <name>k</name><operator>,</operator> <name><name>pTrunk</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> <name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_allocate_page</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>closest</name><operator>&lt;</operator><name>k</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>closest</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">4</literal><operator>+</operator><name>k</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>noContent</name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><call><name>btreeGetHasContent</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>*</operator><name>pPgno</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><name>PAGER_GET_NOCONTENT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetUnusedPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>*</operator><name>pPgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr><name>noContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><operator>*</operator><name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>searchList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPrevTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrevTrunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>searchList</name></expr> )</condition>;</do>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* There are no pages on the freelist, so append a new page to the
    ** database image.
    **
    ** Normally, new pages allocated by this block can be requested from the
    ** pager layer with the 'no-content' flag set. This prevents the pager
    ** from trying to read the pages content from disk. However, if the
    ** current transaction has already run one or more incremental-vacuum
    ** steps, then the page we are about to allocate may contain content
    ** that is required in the event of a rollback. In this case, do
    ** not set the no-content flag. This causes the pager to load and journal
    ** the current page content before overwriting it.
    **
    ** Note that the pager will not actually attempt to load or journal 
    ** content for any page that really does lie past the end of the database
    ** file on disk. So the effects of disabling the no-content optimization
    ** here are confined to those pages that lie between the end of the
    ** database image and the end of the database file.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bNoContent</name> <init>= <expr><ternary><condition><expr><operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>IfNotOmitAV</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>bDoTruncate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then> <expr><name>PAGER_GET_NOCONTENT</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>&amp;&amp;</operator> <call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* If *pPgno refers to a pointer-map page, allocate two new pages
      ** at the end of the file instead of one. The first allocated page
      ** becomes a new pointer-map page, the second is used by the caller.
      */</comment>
      <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ALLOCATE: %d from end of file (pointer-map page)\n"</literal><operator>,</operator> <name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>!=</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetUnusedPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>, <argument><expr><name>bNoContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><literal type="number">28</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pPgno</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pPgno</name><operator>!=</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetUnusedPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>*</operator><name>pPgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr><name>bNoContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><operator>*</operator><name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ALLOCATE: %d from end of file\n"</literal><operator>,</operator> <operator>*</operator><name>pPgno</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <operator>*</operator><name>pPgno</name><operator>!=</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>end_allocate_page</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPrevTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator><operator>-&gt;</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to add page iPage to the database file free-list. 
** It is assumed that the page is not already a part of the free-list.
**
** The value passed as the second argument to this function is optional.
** If the caller happens to have a pointer to the MemPage object 
** corresponding to page iPage handy, it may pass it as the second value. 
** Otherwise, it may pass NULL.
**
** If a pointer to a MemPage object is passed as the second argument,
** its reference count is not altered by this function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>freePage2</name><parameter_list>(<parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pMemPage</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pTrunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Free-list trunk page */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iTrunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Page number of free-list trunk page */</comment> 
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage1</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Local reference to page 1 */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>                     <comment type="block">/* Page being freed. May be NULL. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nFree</name></decl>;</decl_stmt>                          <comment type="block">/* Initial number of pages on free-list */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name>iPage</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pMemPage</name> <operator>||</operator> <name><name>pMemPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><name>iPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>iPage</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal> <operator>||</operator> <name>iPage</name></expr></argument>&gt;</argument_list></name><name><name>pBt</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMemPage</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name>pMemPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerRef</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>btreePageLookup</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Increment the free page count on pPage1 */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>freepage_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nFree</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nFree</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_SECURE_DELETE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the secure_delete option is enabled, then
    ** always fully overwrite deleted information with zeros.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>!</operator><name>pPage</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>)</operator>
     <operator>||</operator>            <operator>(</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <goto>goto <name>freepage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the database supports auto-vacuum, write an entry in the pointer-map
  ** to indicate that the page is free.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>PTRMAP_FREEPAGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>freepage_out</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now manipulate the actual database free-list structure. There are two
  ** possibilities. If the free-list is currently empty, or if the first
  ** trunk page in the free-list is full, then this page will become a
  ** new free-list trunk page. Otherwise, it will become a leaf of the
  ** first trunk page in the current free-list. This block tests if it
  ** is possible to add the page as a new free-list leaf.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nFree</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>nLeaf</name></decl>;</decl_stmt>                <comment type="block">/* Initial number of leaf cells on trunk page */</comment>

    <expr_stmt><expr><name>iTrunk</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iTrunk</name><operator>&gt;</operator><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>freepage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iTrunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTrunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>freepage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nLeaf</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>&gt;</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nLeaf</name> <operator>&gt;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>/</operator><literal type="number">4</literal> <operator>-</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>freepage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nLeaf</name> <operator>&lt;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>/</operator><literal type="number">4</literal> <operator>-</operator> <literal type="number">8</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* In this case there is room on the trunk page to insert the page
      ** being freed as a new leaf.
      **
      ** Note that the trunk page is not really full until it contains
      ** usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have
      ** coded.  But due to a coding error in versions of SQLite prior to
      ** 3.6.0, databases with freelist trunk pages holding more than
      ** usableSize/4 - 8 entries will be reported as corrupt.  In order
      ** to maintain backwards compatibility with older versions of SQLite,
      ** we will continue to restrict the number of entries to usableSize/4 - 8
      ** for now.  At some point in the future (once everyone has upgraded
      ** to 3.6.0 or later) we should consider fixing the conditional above
      ** to read "usableSize/4-2" instead of "usableSize/4-8".
      **
      ** EVIDENCE-OF: R-19920-11576 However, newer versions of SQLite still
      ** avoid using the last six entries in the freelist trunk page array in
      ** order that database files created by newer versions of SQLite can be
      ** read by older versions of SQLite.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pTrunk</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nLeaf</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>nLeaf</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_SECURE_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3PagerDontWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeSetHasContent</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FREE-PAGE: %d leaf on trunk page %d\n"</literal><operator>,</operator><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator><name><name>pTrunk</name><operator>-&gt;</operator><name>pgno</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>freepage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If control flows to this point, then it was not possible to add the
  ** the page being freed as a leaf page of the first trunk in the free-list.
  ** Possibly because the free-list is empty, or possibly because the 
  ** first trunk in the free-list is full. Either way, the page being freed
  ** will become the new first trunk page in the free-list.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pPage</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <goto>goto <name>freepage_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>freepage_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>iTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FREE-PAGE: %d new trunk page replacing %d\n"</literal><operator>,</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> <name>iTrunk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>freepage_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freePage</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pRC</name><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <call><name>freePage2</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the overflow pages associated with the given Cell.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>clearCellOverflow</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,          <comment type="block">/* The page that contains the Cell */</comment>
  <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,    <comment type="block">/* First byte of the Cell */</comment>
  <parameter><decl><type><name>CellInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>          <comment type="block">/* Size information about the cell */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>ovflPgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>ovflPageSize</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name><operator>!=</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCell</name> <operator>+</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>==</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCell</name> <operator>+</operator> <operator>(</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>+</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Cell extends past end of page */</comment>
    <return>return <expr><call><name>SQLITE_CORRUPT_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ovflPgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name> <operator>+</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ovflPageSize</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOvfl</name> <operator>=</operator> <operator>(</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name> <operator>-</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nLocal</name></name> <operator>+</operator> <name>ovflPageSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>ovflPageSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOvfl</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> 
    <operator>(</operator><name>CORRUPT_DB</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPayload</name></name> <operator>+</operator> <name>ovflPageSize</name><operator>)</operator><operator>&lt;</operator><name>ovflPageSize</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>nOvfl</name><operator>--</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>ovflPgno</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal> <operator>||</operator> <name>ovflPgno</name></expr></argument>&gt;</argument_list></name><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* 0 is not a legal page number and page 1 cannot be an 
      ** overflow page. Therefore if ovflPgno&lt;2 or past the end of the 
      ** file the database must be corrupt. */</comment>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOvfl</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getOverflowPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovflPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pOvfl</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>pOvfl</name> <operator>=</operator> <call><name>btreePageLookup</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovflPgno</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>)</operator>
     <operator>&amp;&amp;</operator> <call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* There is no reason any cursor should have an outstanding reference 
      ** to an overflow page belonging to a cell that is being deleted/updated.
      ** So if there exists more than one reference to this page, then it 
      ** must not really be an overflow page and the database must be corrupt. 
      ** It is helpful to detect this before calling freePage2(), as 
      ** freePage2() may zero the page contents if secure-delete mode is
      ** enabled. If this 'overflow' page happens to be a page that the
      ** caller is iterating through or using in some other way, this
      ** can be problematic.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>freePage2</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pOvfl</name></expr></argument>, <argument><expr><name>ovflPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pOvfl</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ovflPgno</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call xParseCell to compute the size of a cell.  If the cell contains
** overflow, then invoke cellClearOverflow to clear out that overflow.
** STore the result code (SQLITE_OK or some error code) in rc.
**
** Implemented as macro to force inlining for performance.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTREE_CLEAR_CELL</name><parameter_list>(<parameter><type><name>rc</name></type></parameter>, <parameter><type><name>pPage</name></type></parameter>, <parameter><type><name>pCell</name></type></parameter>, <parameter><type><name>sInfo</name></type></parameter>)</parameter_list></cpp:macro>   \
  <cpp:value>pPage-&gt;xParseCell(pPage, pCell, &amp;sInfo);          \
  if( sInfo.nLocal!=sInfo.nPayload ){               \
    rc = clearCellOverflow(pPage, pCell, &amp;sInfo);   \
  }else{                                            \
    rc = SQLITE_OK;                                 \
  }</cpp:value></cpp:define>


<comment type="block">/*
** Create the byte sequence used to represent a cell on page pPage
** and write that byte sequence into pCell[].  Overflow pages are
** allocated and filled in as necessary.  The calling procedure
** is responsible for making sure sufficient space has been allocated
** for pCell[].
**
** Note that pCell does not necessary need to point to the pPage-&gt;aData
** area.  pCell might point to some temporary storage.  The cell will
** be constructed in this temporary area then copied into pPage-&gt;aData
** later.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fillInCell</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,                <comment type="block">/* The page that contains the cell */</comment>
  <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,          <comment type="block">/* Complete text of the cell */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>BtreePayload</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>,        <comment type="block">/* Payload with which to construct the cell */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnSize</name></decl></parameter>                    <comment type="block">/* Write cell size here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>mn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>spaceLeft</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pToRelease</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoOvfl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHeader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* pPage is not necessarily writeable since pCell might be auxiliary
  ** buffer space that is separate from the pPage buffer area */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCell</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>||</operator> <name>pCell</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>]</index></name>
            <operator>||</operator> <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fill in the header. */</comment>
  <expr_stmt><expr><name>nHeader</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPayload</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name><name>pX</name><operator>-&gt;</operator><name>nZero</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSrc</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* fillInCell() only called for leaves */</comment>
    <expr_stmt><expr><name>nHeader</name> <operator>+=</operator> <call><name>putVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr></argument>, <argument><expr><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHeader</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>u64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name><operator>&lt;=</operator><literal type="number">0x7fffffff</literal> <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSrc</name> <operator>=</operator> <name>nPayload</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHeader</name> <operator>+=</operator> <call><name>putVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr></argument>, <argument><expr><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Fill in the payload */</comment>
  <expr_stmt><expr><name>pPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is the common case where everything fits on the btree page
    ** and no overflow pages are required. */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nHeader</name> <operator>+</operator> <name>nPayload</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnSize</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSrc</name><operator>&lt;=</operator><name>nPayload</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nSrc</name><operator>&lt;</operator><name>nPayload</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>nSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPayload</name><operator>+</operator><name>nSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nPayload</name><operator>-</operator><name>nSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we reach this point, it means that some of the content will need
  ** to spill onto overflow pages.
  */</comment>
  <expr_stmt><expr><name>mn</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>mn</name> <operator>+</operator> <operator>(</operator><name>nPayload</name> <operator>-</operator> <name>mn</name><operator>)</operator> <operator>%</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>mn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>spaceLeft</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnSize</name> <operator>=</operator> <name>n</name> <operator>+</operator> <name>nHeader</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCell</name><index>[<expr><name>nHeader</name><operator>+</operator><name>n</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pToRelease</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pgnoOvfl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>

  <comment type="block">/* At this point variables should be set as follows:
  **
  **   nPayload           Total payload size in bytes
  **   pPayload           Begin writing payload here
  **   spaceLeft          Space available at pPayload.  If nPayload&gt;spaceLeft,
  **                      that means content must spill into overflow pages.
  **   *pnSize            Size of the local cell (not counting overflow pages)
  **   pPrior             Where to write the pgno of the first overflow page
  **
  ** Use a call to btreeParseCellPtr() to verify that the values above
  ** were computed correctly.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nHeader</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>info</name><operator>.</operator><name>pPayload</name></name> <operator>-</operator> <name>pCell</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>info</name><operator>.</operator><name>nKey</name></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pnSize</name> <operator>==</operator> <name><name>info</name><operator>.</operator><name>nSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>spaceLeft</name> <operator>==</operator> <name><name>info</name><operator>.</operator><name>nLocal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Write the payload into the local Cell and any extra into overflow pages */</comment>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nPayload</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name>spaceLeft</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>spaceLeft</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If pToRelease is not zero than pPayload points into the data area
    ** of pToRelease.  Make sure pToRelease is still writeable. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToRelease</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pToRelease</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If pPayload is part of the data area of pPage, then make sure pPage
    ** is still writeable */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPayload</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>||</operator> <name>pPayload</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>]</index></name>
            <operator>||</operator> <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>nSrc</name><operator>&gt;=</operator><name>n</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nSrc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nSrc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>nPayload</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pPayload</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSrc</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spaceLeft</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>spaceLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoPtrmap</name> <init>= <expr><name>pgnoOvfl</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Overflow page pointer-map entry page */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
        <do>do<block>{<block_content>
          <expr_stmt><expr><name>pgnoOvfl</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block> while<condition>( 
          <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pgnoOvfl</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> 
        )</condition>;</do>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <comment type="block">/* If the database supports auto-vacuum, and the second or subsequent
      ** overflow page is being allocated, add an entry to the pointer-map
      ** for that page now. 
      **
      ** If this is the first overflow page, then write a partial entry 
      ** to the pointer-map. If we write nothing to this pointer-map slot,
      ** then the optimistic overflow chain processing in clearCell()
      ** may misinterpret the uninitialized values and delete the
      ** wrong pages from the database.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pgnoPtrmap</name></expr>?</condition><then><expr><name>PTRMAP_OVERFLOW2</name></expr></then><else>:<expr><name>PTRMAP_OVERFLOW1</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>pgnoPtrmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pToRelease</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If pToRelease is not zero than pPrior points into the data area
      ** of pToRelease.  Make sure pToRelease is still writeable. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToRelease</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pToRelease</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If pPrior is part of the data area of pPage, then make sure pPage
      ** is still writeable */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>||</operator> <name>pPrior</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>]</index></name>
            <operator>||</operator> <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pToRelease</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pToRelease</name> <operator>=</operator> <name>pOvfl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <name><name>pOvfl</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>spaceLeft</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pToRelease</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove the i-th cell from pPage.  This routine effects pPage only.
** The cell content is not freed or deallocated.  It is assumed that
** the cell content has been copied someplace else.  This routine just
** removes the reference to the cell from pPage.
**
** "sz" must be the number of bytes in the cell.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dropCell</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>pc</name></decl>;</decl_stmt>         <comment type="block">/* Offset to cell content of cell being deleted */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>       <comment type="block">/* pPage-&gt;aData */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>        <comment type="block">/* Used to move bytes around within data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>         <comment type="block">/* The return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>        <comment type="block">/* Beginning of the header.  0 most pages.  100 page 1 */</comment>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name>sz</name><operator>==</operator><call><name>cellSize</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aCellIdx</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>&gt;</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>ptr</name><operator>-</operator><name>data</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pc</name><operator>+</operator><name>sz</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pc</name><operator>+</operator><name>sz</name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>freeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name>
                       <operator>-</operator> <name><name>pPage</name><operator>-&gt;</operator><name>childPtrSize</name></name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>-</operator> <name>idx</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Insert a new cell on pPage at cell index "i".  pCell points to the
** content of the cell.
**
** If the cell content will fit on the page, then put it there.  If it
** will not fit, then make a copy of the cell content into pTemp if
** pTemp is not null.  Regardless of pTemp, allocate a new entry
** in pPage-&gt;apOvfl[] and make it point to the cell content (either
** in pTemp or the original pCell) and also record its index. 
** Allocating a new entry in pPage-&gt;aCell[] implies that 
** pPage-&gt;nOverflow is incremented.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>insertCell</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,   <comment type="block">/* Page into which we are copying */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,            <comment type="block">/* New cell becomes the i-th cell of the page */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,        <comment type="block">/* Content of the new cell */</comment>
  <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>,           <comment type="block">/* Bytes of content in pCell */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTemp</name></decl></parameter>,        <comment type="block">/* Temp storage space for pCell, if needed */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iChild</name></decl></parameter>       <comment type="block">/* If non-zero, replace first 4 bytes with this value */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Where to write new cell content in data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>            <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>         <comment type="block">/* The content of the whole page */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIns</name></decl>;</decl_stmt>         <comment type="block">/* The point in pPage-&gt;aCellIdx[] where no cell inserted */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>+</operator><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>MX_CELL</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">10921</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&lt;=</operator><call><name>MX_CELL</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>&lt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>apOvfl</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>apOvfl</name></name></expr></argument>)</argument_list></call><operator>==</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aiOvfl</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>==</operator><call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>||</operator> <name>sz</name><operator>+</operator><literal type="number">2</literal><operator>&gt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pTemp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTemp</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCell</name> <operator>=</operator> <name>pTemp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iChild</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* Comparison against ArraySize-1 since we hold back one extra slot
    ** as a contingency.  In other words, never need more than 3 overflow
    ** slots but 4 are allocated, just to be safe. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name> <operator>&lt;</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>apOvfl</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>apOvfl</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>i</name></expr>;</expr_stmt>

    <comment type="block">/* When multiple overflows occur, they are always sequential and in
    ** sorted order.  This invariants arise because multiple overflows can
    ** only occur when inserting divider cells into the parent page during
    ** balancing, and the dividers are adjacent and sorted.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><operator>(</operator><name>u16</name><operator>)</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Overflows in sorted order */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Overflows are sequential */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name></expr>]</index></name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>aCellIdx</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <comment type="block">/* The allocateSpace() routine guarantees the following properties
    ** if it returns successfully */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name> <operator>&gt;=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>+</operator><literal type="number">2</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>+</operator><name>sz</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>-=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>sz</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iChild</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* In a corrupt database where an entry in the cell index section of
      ** a btree page has a value of 3 or less, the pCell value might point
      ** as many as 4 bytes in front of the start of the aData buffer for
      ** the source page.  Make sure this does not cause problems by not
      ** reading the first 4 bytes */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>idx</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>sz</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pIns</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aCellIdx</name></name> <operator>+</operator> <name>i</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pIns</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pIns</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>-</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pIns</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* increment the cell count */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>++</operator><name><name>data</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">4</literal></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>data</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* The cell may contain a pointer to an overflow page. If so, write
      ** the entry for the overflow page into the pointer map.
      */</comment>
      <expr_stmt><expr><call><name>ptrmapPutOvflPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc2</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following parameters determine how many adjacent pages get involved
** in a balancing operation.  NN is the number of neighbors on either side
** of the page that participate in the balancing operation.  NB is the
** total number of pages that participate, including the target page and
** NN neighbors on either side.
**
** The minimum value of NN is 1 (of course).  Increasing NN above 1
** (to 2 or 3) gives a modest improvement in SELECT and DELETE performance
** in exchange for a larger degradation in INSERT and UPDATE performance.
** The value of NN appears to give the best results overall.
**
** (Later:) The description above makes it seem as if these values are
** tunable - as if you could change them and recompile and it would all work.
** But that is unlikely.  NB has been 3 since the inception of SQLite and
** we have never tested any other value.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>             <comment type="block">/* Number of neighbors on either side of pPage */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>             <comment type="block">/* (NN*2+1): Total pages involved in the balance */</comment>

<comment type="block">/*
** A CellArray object contains a cache of pointers and sizes for a
** consecutive sequence of cells that might be held on multiple pages.
**
** The cells in this array are the divider cell or cells from the pParent
** page plus up to three child pages.  There are a total of nCell cells.
**
** pRef is a pointer to one of the pages that contributes cells.  This is
** used to access information such as MemPage.intKey and MemPage.pBt-&gt;pageSize
** which should be common to all pages that contribute cells to this array.
**
** apCell[] and szCell[] hold, respectively, pointers to the start of each
** cell and the size of each cell.  Some of the apCell[] pointers might refer
** to overflow cells.  In other words, some apCel[] pointers might not point
** to content area of the pages.
**
** A szCell[] of zero means the size of that cell has not yet been computed.
**
** The cells come from as many as four different pages:
**
**             -----------
**             | Parent  |
**             -----------
**            /     |     \
**           /      |      \
**  ---------   ---------   ---------
**  |Child-1|   |Child-2|   |Child-3|
**  ---------   ---------   ---------
**
** The order of cells is in the array is for an index btree is:
**
**       1.  All cells from Child-1 in order
**       2.  The first divider cell from Parent
**       3.  All cells from Child-2 in order
**       4.  The second divider cell from Parent
**       5.  All cells from Child-3 in order
**
** For a table-btree (with rowids) the items 2 and 4 are empty because
** content exists only in leaves and there are no divider cells.
**
** For an index btree, the apEnd[] array holds pointer to the end of page
** for Child-1, the Parent, Child-2, the Parent (again), and Child-3,
** respectively. The ixNx[] array holds the number of cells contained in
** each of these 5 stages, and all stages to the left.  Hence:
**
**    ixNx[0] = Number of cells in Child-1.
**    ixNx[1] = Number of cells in Child-1 plus 1 for first divider.
**    ixNx[2] = Number of cells in Child-1 and Child-2 + 1 for 1st divider.
**    ixNx[3] = Number of cells in Child-1 and Child-2 + both divider cells
**    ixNx[4] = Total number of cells.
**
** For a table-btree, the concept is similar, except only apEnd[0]..apEnd[2]
** are used and they point to the leaf pages only, and the ixNx value are:
**
**    ixNx[0] = Number of cells in Child-1.
**    ixNx[1] = Number of cells in Child-1 and Child-2.
**    ixNx[2] = Total number of cells.
**
** Sometimes when deleting, a child page can have zero cells.  In those
** cases, ixNx[] entries with higher indexes, and the corresponding apEnd[]
** entries, shift down.  The end result is that each ixNx[] entry should
** be larger than the previous
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>CellArray</name></name></type> <name>CellArray</name>;</typedef>
<struct>struct <name>CellArray</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>              <comment type="block">/* Number of cells in apCell[] */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pRef</name></decl>;</decl_stmt>          <comment type="block">/* Reference page */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>apCell</name></decl>;</decl_stmt>            <comment type="block">/* All cells begin balanced */</comment>
  <decl_stmt><decl><type><name>u16</name> <modifier>*</modifier></type><name>szCell</name></decl>;</decl_stmt>            <comment type="block">/* Local size of all cells in apCell[] */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name><name>apEnd</name><index>[<expr><name>NB</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* MemPage.aDataEnd values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>ixNx</name><index>[<expr><name>NB</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>         <comment type="block">/* Index of at which we move to the next apEnd[] */</comment>
}</block>;</struct>

<comment type="block">/*
** Make sure the cell sizes at idx, idx+1, ..., idx+N-1 have been
** computed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>populateCellCache</name><parameter_list>(<parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pRef</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRef</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name> <modifier>*</modifier></type><name>szCell</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>szCell</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name><operator>+</operator><name>N</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>idx</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>szCell</name><index>[<expr><name>idx</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>szCell</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name><name>pRef</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pRef</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator>
              <name><name>szCell</name><index>[<expr><name>idx</name></expr>]</index></name><operator>==</operator><call><name><name>pRef</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pRef</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>N</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the Nth element of the cell array
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>u16</name></type> <name>computeCellSize</name><parameter_list>(<parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>N</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>N</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>N</name></expr>]</index></name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>pRef</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRef</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>cachedCellSize</name><parameter_list>(<parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>N</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>N</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>computeCellSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Array apCell[] contains pointers to nCell b-tree page cells. The 
** szCell[] array contains the size in bytes of each cell. This function
** replaces the current contents of page pPg with the contents of the cell
** array.
**
** Some of the cells in apCell[] may currently be stored in pPg. This
** function works around problems caused by this by making a copy of any 
** such cells before overwriting the page data.
**
** The MemPage.nFree field is invalidated by this function. It is the 
** responsibility of the caller to set it correctly.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rebuildPage</name><parameter_list>(
  <parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>pCArray</name></decl></parameter>,             <comment type="block">/* Content to be added to page pPg */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFirst</name></decl></parameter>,                     <comment type="block">/* First cell in pCArray to use */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCell</name></decl></parameter>,                      <comment type="block">/* Final number of cells on page */</comment>
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>                    <comment type="block">/* The page to be reconstructed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hdr</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Offset of header on pPg */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>aData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Pointer to data for pPg */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>usableSize</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>usableSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>iFirst</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Which cell to copy from pCArray*/</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>                          <comment type="block">/* Start of cell content area */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><name>i</name><operator>+</operator><name>nCell</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Loop terminator */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellptr</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><call><name>sqlite3PagerTempSpace</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>                          <comment type="block">/* Current slot in pCArray-&gt;apEnd[] */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSrcEnd</name></decl>;</decl_stmt>                    <comment type="block">/* Current pCArray-&gt;apEnd[k] value */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name>iEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>usableSize</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTmp</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>usableSize</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pCArray</name><operator>-&gt;</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name><operator>&lt;=</operator><name>i</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>k</name><operator>&lt;</operator><name>NB</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><name>pSrcEnd</name> <operator>=</operator> <name><name>pCArray</name><operator>-&gt;</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>pData</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr><comment type="block">/*exit by break*/</comment> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>sz</name> <init>= <expr><name><name>pCArray</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>aData</name><operator>+</operator><name>j</name></expr></argument>,<argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>uptr</name><operator>)</operator><operator>(</operator><name>pCell</name><operator>+</operator><name>sz</name><operator>)</operator><operator>)</operator><operator>&gt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pCell</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTmp</name><index>[<expr><name>pCell</name> <operator>-</operator> <name>aData</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>uptr</name><operator>)</operator><operator>(</operator><name>pCell</name><operator>+</operator><name>sz</name><operator>)</operator><operator>&gt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name>pSrcEnd</name>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>uptr</name><operator>)</operator><operator>(</operator><name>pCell</name><operator>)</operator><operator>&lt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name>pSrcEnd</name></expr>
    )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pData</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pCellptr</name></expr></argument>, <argument><expr><operator>(</operator><name>pData</name> <operator>-</operator> <name>aData</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCellptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pData</name> <operator>&lt;</operator> <name>pCellptr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>==</operator><call><name><name>pPg</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>iEnd</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCArray</name><operator>-&gt;</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name><operator>&lt;=</operator><name>i</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSrcEnd</name> <operator>=</operator> <name><name>pCArray</name><operator>-&gt;</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* The pPg-&gt;nFree field is now set incorrectly. The caller will fix it. */</comment>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <name>nCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pData</name> <operator>-</operator> <name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The pCArray objects contains pointers to b-tree cells and the cell sizes.
** This function attempts to add the cells stored in the array to page pPg.
** If it cannot (because the page needs to be defragmented before the cells
** will fit), non-zero is returned. Otherwise, if the cells are added
** successfully, zero is returned.
**
** Argument pCellptr points to the first entry in the cell-pointer array
** (part of page pPg) to populate. After cell apCell[0] is written to the
** page body, a 16-bit offset is written to pCellptr. And so on, for each
** cell in the array. It is the responsibility of the caller to ensure
** that it is safe to overwrite this part of the cell-pointer array.
**
** When this function is called, *ppData points to the start of the 
** content area on page pPg. If the size of the content area is extended,
** *ppData is updated to point to the new start of the content area
** before returning.
**
** Finally, argument pBegin points to the byte immediately following the
** end of the space required by this page for the cell-pointer area (for
** all cells - not just those inserted by the current call). If the content
** area must be extended to before this point in order to accomodate all
** cells in apCell[], then the cells do not fit and non-zero is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pageInsertArray</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,                   <comment type="block">/* Page to add cells to */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBegin</name></decl></parameter>,                     <comment type="block">/* End of cell-pointer array */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>,                    <comment type="block">/* IN/OUT: Page content-area pointer */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellptr</name></decl></parameter>,                   <comment type="block">/* Pointer to cell-pointer area */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFirst</name></decl></parameter>,                     <comment type="block">/* Index of first cell to add */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCell</name></decl></parameter>,                      <comment type="block">/* Number of cells to add to pPg */</comment>
  <parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>pCArray</name></decl></parameter>              <comment type="block">/* Array of cells */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>iFirst</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Loop counter - cell index to insert */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Complete page */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><operator>*</operator><name>ppData</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Content area.  A subset of aData[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><name>iFirst</name> <operator>+</operator> <name>nCell</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* End of loop. One past last cell to ins */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>                          <comment type="block">/* Current slot in pCArray-&gt;apEnd[] */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>                       <comment type="block">/* Maximum extent of cell data */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Never called on page 1 */</comment>
  <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>&lt;=</operator><name>iFirst</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pCArray</name><operator>-&gt;</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name><operator>&lt;=</operator><name>i</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>k</name><operator>&lt;</operator><name>NB</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name><name>pCArray</name><operator>-&gt;</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> <comment type="block">/*Exit by break*/</comment> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSlot</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCArray</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>pCArray</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>aData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pSlot</name> <operator>=</operator> <call><name>pageFindSlot</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>,<argument><expr><name>sz</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pData</name> <operator>-</operator> <name>pBegin</name><operator>)</operator><operator>&lt;</operator><name>sz</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pData</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSlot</name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* pSlot and pCArray-&gt;apCell[i] will never overlap on a well-formed
    ** database.  But they might for a corrupt database.  Hence use memmove()
    ** since memcpy() sends SIGABORT with overlapping buffers on OpenBSD */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pSlot</name><operator>+</operator><name>sz</name><operator>)</operator><operator>&lt;=</operator><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name>
         <operator>||</operator> <name>pSlot</name><operator>&gt;=</operator><operator>(</operator><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><name>sz</name><operator>)</operator>
         <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>uptr</name><operator>)</operator><operator>(</operator><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><name>sz</name><operator>)</operator><operator>&gt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name>pEnd</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>uptr</name><operator>)</operator><operator>(</operator><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&lt;</operator><operator>(</operator><name>uptr</name><operator>)</operator><name>pEnd</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pSlot</name></expr></argument>, <argument><expr><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pCellptr</name></expr></argument>, <argument><expr><operator>(</operator><name>pSlot</name> <operator>-</operator> <name>aData</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCellptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>iEnd</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCArray</name><operator>-&gt;</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name><operator>&lt;=</operator><name>i</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name><name>pCArray</name><operator>-&gt;</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The pCArray object contains pointers to b-tree cells and their sizes.
**
** This function adds the space associated with each cell in the array
** that is currently stored within the body of pPg to the pPg free-list.
** The cell-pointers and other fields of the page are not updated.
**
** This function returns the total number of cells added to the free-list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pageFreeArray</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,                   <comment type="block">/* Page to edit */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFirst</name></decl></parameter>,                     <comment type="block">/* First cell to delete */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCell</name></decl></parameter>,                      <comment type="block">/* Cells to delete */</comment>
  <parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>pCArray</name></decl></parameter>              <comment type="block">/* Array of cells */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>aData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pStart</name> <init>= <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name><name>pPg</name><operator>-&gt;</operator><name>hdrOffset</name></name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pPg</name><operator>-&gt;</operator><name>childPtrSize</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><name>iFirst</name> <operator>+</operator> <name>nCell</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* \__ Parameters for pending call to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* /   freeSpace()                    */</comment>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
      <comment type="block">/* No need to use cachedCellSize() here.  The sizes of all cells that
      ** are to be freed have already been computing while deciding which
      ** cells need freeing */</comment>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>pCArray</name><operator>-&gt;</operator><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pFree</name><operator>!=</operator><operator>(</operator><name>pCell</name> <operator>+</operator> <name>sz</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pFree</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFree</name><operator>&gt;</operator><name>aData</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pFree</name> <operator>-</operator> <name>aData</name><operator>)</operator><operator>&lt;</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>freeSpace</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pFree</name> <operator>-</operator> <name>aData</name><operator>)</operator></expr></argument>, <argument><expr><name>szFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>szFree</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pFree</name><operator>+</operator><name>sz</name><operator>&gt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* The current cell is adjacent to and before the pFree cell.
        ** Combine the two regions into one to reduce the number of calls
        ** to freeSpace(). */</comment>
        <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>szFree</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nRet</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pFree</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFree</name><operator>&gt;</operator><name>aData</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pFree</name> <operator>-</operator> <name>aData</name><operator>)</operator><operator>&lt;</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeSpace</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>pFree</name> <operator>-</operator> <name>aData</name><operator>)</operator></expr></argument>, <argument><expr><name>szFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pCArray contains pointers to and sizes of all cells in the page being
** balanced.  The current page, pPg, has pPg-&gt;nCell cells starting with
** pCArray-&gt;apCell[iOld].  After balancing, this page should hold nNew cells
** starting at apCell[iNew].
**
** This routine makes the necessary adjustments to pPg so that it contains
** the correct cells after being balanced.
**
** The pPg-&gt;nFree field is invalid when this function returns. It is the
** responsibility of the caller to set it correctly.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>editPage</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,                   <comment type="block">/* Edit this page */</comment>
  <parameter><decl><type><name>int</name></type> <name>iOld</name></decl></parameter>,                       <comment type="block">/* Index of first cell currently on page */</comment>
  <parameter><decl><type><name>int</name></type> <name>iNew</name></decl></parameter>,                       <comment type="block">/* Index of new first cell on page */</comment>
  <parameter><decl><type><name>int</name></type> <name>nNew</name></decl></parameter>,                       <comment type="block">/* Final number of cells on page */</comment>
  <parameter><decl><type><name>CellArray</name> <modifier>*</modifier></type><name>pCArray</name></decl></parameter>              <comment type="block">/* Array of cells and sizes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>aData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hdr</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBegin</name> <init>= <expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name><index>[<expr><name>nNew</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>nCell</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Cells stored on pPg */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOldEnd</name> <init>= <expr><name>iOld</name> <operator>+</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nCell</name></name> <operator>+</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iNewEnd</name> <init>= <expr><name>iNew</name> <operator>+</operator> <name>nNew</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><call><name>sqlite3PagerTempSpace</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Remove cells from the start and end of the page */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iOld</name><operator>&lt;</operator><name>iNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nShift</name> <init>= <expr><call><name>pageFreeArray</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iOld</name></expr></argument>, <argument><expr><name>iNew</name><operator>-</operator><name>iOld</name></expr></argument>, <argument><expr><name>pCArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>nShift</name><operator>&gt;</operator><name>nCell</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name><index>[<expr><name>nShift</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nCell</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCell</name> <operator>-=</operator> <name>nShift</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iNewEnd</name> <operator>&lt;</operator> <name>iOldEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nTail</name> <init>= <expr><call><name>pageFreeArray</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iNewEnd</name></expr></argument>, <argument><expr><name>iOldEnd</name> <operator>-</operator> <name>iNewEnd</name></expr></argument>, <argument><expr><name>pCArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>&gt;=</operator><name>nTail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCell</name> <operator>-=</operator> <name>nTail</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pData</name> <operator>=</operator> <operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>get2byteNotZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pData</name><operator>&lt;</operator><name>pBegin</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>editpage_fail</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pData</name><operator>&gt;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>editpage_fail</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Add cells to the start of the page */</comment>
  <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&lt;</operator><name>iOld</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nAdd</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nNew</name></expr></argument>,<argument><expr><name>iOld</name><operator>-</operator><name>iNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>iOld</name><operator>-</operator><name>iNew</name><operator>)</operator><operator>&lt;</operator><name>nNew</name> <operator>||</operator> <name>nCell</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nAdd</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCellptr</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCellptr</name><index>[<expr><name>nAdd</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pCellptr</name></expr></argument>, <argument><expr><name>nCell</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>pageInsertArray</name><argument_list>(
          <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pData</name></expr></argument>, <argument><expr><name>pCellptr</name></expr></argument>,
          <argument><expr><name>iNew</name></expr></argument>, <argument><expr><name>nAdd</name></expr></argument>, <argument><expr><name>pCArray</name></expr></argument>
    )</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>editpage_fail</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nCell</name> <operator>+=</operator> <name>nAdd</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Add any overflow cells */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPg</name><operator>-&gt;</operator><name>nOverflow</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><operator>(</operator><name>iOld</name> <operator>+</operator> <name><name>pPg</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>-</operator> <name>iNew</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCell</name><operator>&lt;</operator><name>nNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pCellptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name><index>[<expr><name>iCell</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCell</name><operator>&gt;</operator><name>iCell</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCellptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pCellptr</name></expr></argument>, <argument><expr><operator>(</operator><name>nCell</name> <operator>-</operator> <name>iCell</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nCell</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cachedCellSize</name><argument_list>(<argument><expr><name>pCArray</name></expr></argument>, <argument><expr><name>iCell</name><operator>+</operator><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>pageInsertArray</name><argument_list>(
            <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pData</name></expr></argument>, <argument><expr><name>pCellptr</name></expr></argument>,
            <argument><expr><name>iCell</name><operator>+</operator><name>iNew</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pCArray</name></expr></argument>
      )</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>editpage_fail</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Append cells to the end of the page */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCellptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name><index>[<expr><name>nCell</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>pageInsertArray</name><argument_list>(
        <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pData</name></expr></argument>, <argument><expr><name>pCellptr</name></expr></argument>,
        <argument><expr><name>iNew</name><operator>+</operator><name>nCell</name></expr></argument>, <argument><expr><name>nNew</name><operator>-</operator><name>nCell</name></expr></argument>, <argument><expr><name>pCArray</name></expr></argument>
  )</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>editpage_fail</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pData</name> <operator>-</operator> <name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>CORRUPT_DB</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name><operator>+</operator><name>iNew</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><call><name>get2byteAligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aCellIdx</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name><name>pPg</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pCell</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTmp</name><index>[<expr><name>pCell</name> <operator>-</operator> <name>aData</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>,
            <argument><expr><call><name><name>pCArray</name><operator>-&gt;</operator><name>pRef</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name><name>pCArray</name><operator>-&gt;</operator><name>pRef</name></name></expr></argument>, <argument><expr><name><name>pCArray</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>i</name><operator>+</operator><name>iNew</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
 <label><name>editpage_fail</name>:</label>
  <comment type="block">/* Unable to edit this page. Rebuild it from scratch instead. */</comment>
  <expr_stmt><expr><call><name>populateCellCache</name><argument_list>(<argument><expr><name>pCArray</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>rebuildPage</name><argument_list>(<argument><expr><name>pCArray</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_QUICKBALANCE</name></cpp:ifndef>
<comment type="block">/*
** This version of balance() handles the common special case where
** a new entry is being inserted on the extreme right-end of the
** tree, in other words, when the new entry will become the largest
** entry in the tree.
**
** Instead of trying to balance the 3 right-most leaf pages, just add
** a new page to the right-hand side and put the one new entry in
** that page.  This leaves the right side of the tree somewhat
** unbalanced.  But odds are that we will be inserting new entries
** at the end soon afterwards so the nearly empty page will quickly
** fill up.  On average.
**
** pPage is the leaf page which is the right-most page in the tree.
** pParent is its parent.  pPage must have a single overflow entry
** which is also the right-most entry on the page.
**
** The pSpace buffer is used to store a temporary copy of the divider
** cell that will be inserted into pParent. Such a cell consists of a 4
** byte page number followed by a variable length integer. In other
** words, at most 13 bytes. Hence the pSpace buffer must be at
** least 13 bytes in size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>balance_quick</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSpace</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pBt</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* B-Tree Database */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>                       <comment type="block">/* Newly allocated page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoNew</name></decl>;</decl_stmt>                        <comment type="block">/* Page number of pNew */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* dbfuzz001.test */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a new page. This page will become the right-sibling of 
  ** pPage. Make the parent page writable, so that the new divider cell
  ** may be inserted. If both these operations are successful, proceed.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>

    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><operator>&amp;</operator><name><name>pSpace</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>apOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>szCell</name> <init>= <expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pStop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CellArray</name></type> <name>b</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><operator>(</operator><name>PTF_INTKEY</name><operator>|</operator><name>PTF_LEAFDATA</name><operator>|</operator><name>PTF_LEAF</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>PTF_INTKEY</name><operator>|</operator><name>PTF_LEAFDATA</name><operator>|</operator><name>PTF_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>nCell</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>pRef</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apCell</name></name> <operator>=</operator> <operator>&amp;</operator><name>pCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>szCell</name></name> <operator>=</operator> <operator>&amp;</operator><name>szCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>ixNx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rebuildPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <name>szCell</name></expr>;</expr_stmt>

    <comment type="block">/* If this is an auto-vacuum database, update the pointer map
    ** with entries for the new page, and any pointer from the 
    ** cell on the page to an overflow page. If either of these
    ** operations fails, the return code is set, but the contents
    ** of the parent page are still manipulated by thh code below.
    ** That is Ok, at this point the parent page is guaranteed to
    ** be marked as dirty. Returning an error code will cause a
    ** rollback, undoing any changes made to the parent page.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoNew</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>szCell</name><operator>&gt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>minLocal</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ptrmapPutOvflPtr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Create a divider cell to insert into pParent. The divider cell
    ** consists of a 4-byte page number (the page number of pPage) and
    ** a variable length key value (which must be the same value as the
    ** largest key on pPage).
    **
    ** To find the largest key value on pPage, first find the right-most 
    ** cell on pPage. The first two fields of this cell are the 
    ** record-length (a variable length integer at most 32-bits in size)
    ** and the key value (a variable length integer, may have any value).
    ** The first of the while(...) loops below skips over the record-length
    ** field. The second while(...) loop copies the key value from the
    ** cell on pPage into the pSpace buffer.
    */</comment>
    <expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStop</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>pCell</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>pCell</name><operator>&lt;</operator><name>pStop</name></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
    <expr_stmt><expr><name>pStop</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>pCell</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>pCell</name><operator>&lt;</operator><name>pStop</name></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

    <comment type="block">/* Insert the new divider cell into pParent. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>insertCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOut</name><operator>-</operator><name>pSpace</name><operator>)</operator></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set the right-child pointer of pParent to point to the new page. */</comment>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pParent</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgnoNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* Release the reference to the new page. */</comment>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_QUICKBALANCE */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** This function does not contribute anything to the operation of SQLite.
** it is sometimes activated temporarily while debugging code responsible 
** for setting pointer-map entries.
*/</comment>
static int ptrmapCheckPages(MemPage **apPage, int nPage){
  int i, j;
  for(i=0; i&lt;nPage; i++){
    Pgno n;
    u8 e;
    MemPage *pPage = apPage[i];
    BtShared *pBt = pPage-&gt;pBt;
    assert( pPage-&gt;isInit );

    for(j=0; j&lt;pPage-&gt;nCell; j++){
      CellInfo info;
      u8 *z;
     
      z = findCell(pPage, j);
      pPage-&gt;xParseCell(pPage, z, &amp;info);
      if( info.nLocal&lt;info.nPayload ){
        Pgno ovfl = get4byte(&amp;z[info.nSize-4]);
        ptrmapGet(pBt, ovfl, &amp;e, &amp;n);
        assert( n==pPage-&gt;pgno &amp;&amp; e==PTRMAP_OVERFLOW1 );
      }
      if( !pPage-&gt;leaf ){
        Pgno child = get4byte(z);
        ptrmapGet(pBt, child, &amp;e, &amp;n);
        assert( n==pPage-&gt;pgno &amp;&amp; e==PTRMAP_BTREE );
      }
    }
    if( !pPage-&gt;leaf ){
      Pgno child = get4byte(&amp;pPage-&gt;aData[pPage-&gt;hdrOffset+8]);
      ptrmapGet(pBt, child, &amp;e, &amp;n);
      assert( n==pPage-&gt;pgno &amp;&amp; e==PTRMAP_BTREE );
    }
  }
  return 1;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is used to copy the contents of the b-tree node stored 
** on page pFrom to page pTo. If page pFrom was not a leaf page, then
** the pointer-map entries for each child page are updated so that the
** parent page stored in the pointer map is page pTo. If pFrom contained
** any cells with overflow page pointers, then the corresponding pointer
** map entries are also updated so that the parent page is page pTo.
**
** If pFrom is currently carrying any overflow cells (entries in the
** MemPage.apOvfl[] array), they are not copied to pTo. 
**
** Before returning, page pTo is reinitialized using btreeInitPage().
**
** The performance of this function is not critical. It is only used by 
** the balance_shallower() and balance_deeper() procedures, neither of
** which are called often under normal circumstances.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>copyNodeContent</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pRC</name><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pBt</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>aFrom</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>aTo</name> <init>= <expr><name><name>pTo</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>iFromHdr</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>iToHdr</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iData</name></decl>;</decl_stmt>
  
  
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><name>iToHdr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrom</name><index>[<expr><name>iFromHdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* Copy the b-tree node content from page pFrom to page pTo. */</comment>
    <expr_stmt><expr><name>iData</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrom</name><index>[<expr><name>iFromHdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aTo</name><index>[<expr><name>iData</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aFrom</name><index>[<expr><name>iData</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>-</operator><name>iData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aTo</name><index>[<expr><name>iToHdr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aFrom</name><index>[<expr><name>iFromHdr</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>pFrom</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* Reinitialize page pTo so that the contents of the MemPage structure
    ** match the new data. The initialization of pTo can actually fail under
    ** fairly obscure circumstances, even though it is a copy of initialized 
    ** page pFrom.
    */</comment>
    <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeInitPage</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If this is an auto-vacuum database, update the pointer-map entries
    ** for any b-tree or overflow pages that pTo now contains the pointers to.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <call><name>setChildPtrmaps</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine redistributes cells on the iParentIdx'th child of pParent
** (hereafter "the page") and up to 2 siblings so that all pages have about the
** same amount of free space. Usually a single sibling on either side of the
** page are used in the balancing, though both siblings might come from one
** side if the page is the first or last child of its parent. If the page 
** has fewer than 2 siblings (something which can only happen if the page
** is a root page or a child of a root page) then all available siblings
** participate in the balancing.
**
** The number of siblings of the page might be increased or decreased by 
** one or two in an effort to keep pages nearly full but not over full. 
**
** Note that when this routine is called, some of the cells on the page
** might not actually be stored in MemPage.aData[]. This can happen
** if the page is overfull. This routine ensures that all cells allocated
** to the page and its siblings fit into MemPage.aData[] before returning.
**
** In the course of balancing the page and its siblings, cells may be
** inserted into or removed from the parent page (pParent). Doing so
** may cause the parent page to become overfull or underfull. If this
** happens, it is the responsibility of the caller to invoke the correct
** balancing routine to fix this problem (see the balance() routine). 
**
** If this routine fails for any reason, it might leave the database
** in a corrupted state. So if this routine fails, the database should
** be rolled back.
**
** The third argument to this function, aOvflSpace, is a pointer to a
** buffer big enough to hold one page. If while inserting cells into the parent
** page (pParent) the parent page becomes overfull, this buffer is
** used to store the parent's overflow cells. Because this function inserts
** a maximum of four divider cells into the parent page, and the maximum
** size of a cell stored within an internal node is always less than 1/4
** of the page-size, the aOvflSpace[] buffer is guaranteed to be large
** enough for all overflow cells.
**
** If aOvflSpace is set to a null pointer, this function returns 
** SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>balance_nonroot</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>,               <comment type="block">/* Parent page of siblings being balanced */</comment>
  <parameter><decl><type><name>int</name></type> <name>iParentIdx</name></decl></parameter>,                 <comment type="block">/* Index of "the page" in pParent */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOvflSpace</name></decl></parameter>,                 <comment type="block">/* page-size bytes of space for parent ovfl */</comment>
  <parameter><decl><type><name>int</name></type> <name>isRoot</name></decl></parameter>,                     <comment type="block">/* True if pParent is a root-page */</comment>
  <parameter><decl><type><name>int</name></type> <name>bBulk</name></decl></parameter>                       <comment type="block">/* True if this call is part of a bulk load */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>               <comment type="block">/* The whole database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxCells</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Allocated size of apCell, szCell, aFrom. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of pages in apNew[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>;</decl_stmt>                    <comment type="block">/* Number of pages in apOld[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nxDiv</name></decl>;</decl_stmt>                   <comment type="block">/* Next divider slot in pParent-&gt;aCell[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* The return code */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>leafCorrection</name></decl>;</decl_stmt>          <comment type="block">/* 4 if pPage is a leaf.  0 if not */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>leafData</name></decl>;</decl_stmt>                <comment type="block">/* True if pPage is a leaf of a LEAFDATA tree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSpace</name></decl>;</decl_stmt>             <comment type="block">/* Bytes in pPage beyond the header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pageFlags</name></decl>;</decl_stmt>               <comment type="block">/* Value of pPage-&gt;aData[0] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSpace1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* First unused byte of aSpace1[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOvflSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* First unused byte of aOvflSpace[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szScratch</name></decl>;</decl_stmt>               <comment type="block">/* Size of scratch memory requested */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name><name>apOld</name><index>[<expr><name>NB</name></expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* pPage and up to two siblings */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name><name>apNew</name><index>[<expr><name>NB</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* pPage and up to NB siblings after balancing */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>                  <comment type="block">/* Location in parent of right-sibling pointer */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name><name>apDiv</name><index>[<expr><name>NB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Divider cells in pParent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>cntNew</name><index>[<expr><name>NB</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>            <comment type="block">/* Index in b.paCell[] of cell after i-th page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>cntOld</name><index>[<expr><name>NB</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>            <comment type="block">/* Old index in b.apCell[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>szNew</name><index>[<expr><name>NB</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Combined size of cells placed on i-th page */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aSpace1</name></decl>;</decl_stmt>                 <comment type="block">/* Space for copies of dividers cells */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>                   <comment type="block">/* Temp var to store a page number in */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>abDone</name><index>[<expr><name>NB</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* True after i'th new page is populated */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name><name>aPgno</name><index>[<expr><name>NB</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>            <comment type="block">/* Page numbers of new pages before shuffling */</comment>
  <decl_stmt><decl><type><name>CellArray</name></type> <name>b</name></decl>;</decl_stmt>                 <comment type="block">/* Parsed information on cells being balanced */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>abDone</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>abDone</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* At this point pParent may have at most one overflow cell. And if
  ** this overflow cell is present, it must be the cell with 
  ** index iParentIdx. This scenario comes about when this function
  ** is called (indirectly) from sqlite3BtreeDelete().
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>iParentIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aOvflSpace</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find the sibling pages to balance. Also locate the cells in pParent 
  ** that divide the siblings. An attempt is made to find NN siblings on 
  ** either side of pPage. More siblings are taken from one side, however, 
  ** if there are fewer than NN siblings on the other side. If pParent
  ** has NB or fewer children then all children of pParent are taken.  
  **
  ** This loop also drops the divider cells from the parent page. This
  ** way, the remainder of the function does not have to deal with any
  ** overflow cells in the parent page, since if any existed they will
  ** have already been removed.
  */</comment>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>+</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nxDiv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bBulk</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bBulk</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iParentIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>                 
      <expr_stmt><expr><name>nxDiv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iParentIdx</name><operator>==</operator><name>i</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nxDiv</name> <operator>=</operator> <name>i</name><operator>-</operator><literal type="number">2</literal><operator>+</operator><name>bBulk</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nxDiv</name> <operator>=</operator> <name>iParentIdx</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal><operator>-</operator><name>bBulk</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nOld</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>+</operator><name>nxDiv</name><operator>-</operator><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>)</operator><operator>==</operator><name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParent</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pParent</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>nxDiv</name><operator>-</operator><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MemPage</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>balance_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nFree</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>i</name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MemPage</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>balance_cleanup</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nMaxCells</name> <operator>+=</operator> <name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nCell</name> <operator>+</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>apOvfl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>--</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><name>nxDiv</name><operator>==</operator><name><name>pParent</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>apOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>pParent</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>nxDiv</name><operator>-</operator><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>pParent</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Drop the cell from the parent page. apDiv[i] still points to
      ** the cell within the parent, even though it has been dropped.
      ** This is safe because dropping a cell only overwrites the first
      ** four bytes of it, and this function does not need the first
      ** four bytes of the divider cell. So the pointer is safe to use
      ** later on.  
      **
      ** But not if we are in secure-delete mode. In secure-delete mode,
      ** the dropCell() routine will overwrite the entire cell with zeroes.
      ** In this case, temporarily copy the cell into the aOvflSpace[]
      ** buffer. It will be copied out again as soon as the aSpace[] buffer
      ** is allocated.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_FAST_SECURE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>

        <comment type="block">/* If the following if() condition is not true, the db is corrupted.
        ** The call to dropCell() below will detect this.  */</comment>
        <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOff</name><operator>+</operator><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aOvflSpace</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>aOvflSpace</name><index>[<expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-</operator><name><name>pParent</name><operator>-&gt;</operator><name>aData</name></name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>nxDiv</name><operator>-</operator><name><name>pParent</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></argument>, <argument><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Make nMaxCells a multiple of 4 in order to preserve 8-byte
  ** alignment */</comment>
  <expr_stmt><expr><name>nMaxCells</name> <operator>=</operator> <operator>(</operator><name>nMaxCells</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">3</literal></expr>;</expr_stmt>

  <comment type="block">/*
  ** Allocate space for memory structures
  */</comment>
  <expr_stmt><expr><name>szScratch</name> <operator>=</operator>
       <name>nMaxCells</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u8</name><operator>*</operator></expr></argument>)</argument_list></sizeof>                       <comment type="block">/* b.apCell */</comment>
     <operator>+</operator> <name>nMaxCells</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></sizeof>                       <comment type="block">/* b.szCell */</comment>
     <operator>+</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</expr_stmt>                              <comment type="block">/* aSpace1 */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szScratch</name><operator>&lt;=</operator><literal type="number">7</literal><operator>*</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apCell</name></name> <operator>=</operator> <call><name>sqlite3StackAllocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>szScratch</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>b</name><operator>.</operator><name>apCell</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>balance_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>b</name><operator>.</operator><name>szCell</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name>nMaxCells</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aSpace1</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name>nMaxCells</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>aSpace1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Load pointers to all cells on sibling pages and the divider cells
  ** into the local b.apCell[] array.  Make copies of the divider cells
  ** into space obtained from aSpace1[]. The divider cells have already
  ** been removed from pParent.
  **
  ** If the siblings are on leaf pages, then the child pointers of the
  ** divider cells are stripped from the cells before they are copied
  ** into aSpace1[].  In this way, all cells in b.apCell[] are without
  ** child pointers.  If siblings are not leaves, then all cell in
  ** b.apCell[] include child pointers.  Either way, all cells in b.apCell[]
  ** are alike.
  **
  ** leafCorrection:  4 if pPage is a leaf.  0 if pPage is not a leaf.
  **       leafData:  1 if pPage holds key+data and pParent holds only keys.
  */</comment>
  <expr_stmt><expr><name><name>b</name><operator>.</operator><name>pRef</name></name> <operator>=</operator> <name><name>apOld</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>leafCorrection</name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>pRef</name><operator>-&gt;</operator><name>leaf</name></name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>leafData</name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>pRef</name><operator>-&gt;</operator><name>intKeyLeaf</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOld</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pOld</name> <init>= <expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><name><name>pOld</name><operator>-&gt;</operator><name>nCell</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><name><name>pOld</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>maskPage</name> <init>= <expr><name><name>pOld</name><operator>-&gt;</operator><name>maskPage</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>piCell</name> <init>= <expr><name>aData</name> <operator>+</operator> <name><name>pOld</name><operator>-&gt;</operator><name>cellOffset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>piEnd</name></decl>;</decl_stmt>
    <macro><name>VVA_ONLY</name><argument_list>( <argument>int nCellAtStart = b.nCell;</argument> )</argument_list></macro>

    <comment type="block">/* Verify that all sibling pages are of the same "type" (table-leaf,
    ** table-interior, index-leaf, or index-interior).
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name><name>apOld</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>balance_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Load b.apCell[] with pointers to all cells in pOld.  If pOld
    ** contains overflow cells, include them in the b.apCell[] array
    ** in the correct spot.
    **
    ** Note that when there are multiple overflow cells, it is always the
    ** case that they are sequential and adjacent.  This invariant arises
    ** because multiple overflows can only occurs when inserting divider
    ** cells into a parent on a prior balance, and divider cells are always
    ** adjacent and are inserted in order.  There is an assert() tagged
    ** with "NOTE 1" in the overflow cell insertion loop to prove this
    ** invariant.
    **
    ** This must be done in advance.  Once the balance starts, the cell
    ** offset section of the btree page will be overwritten and we will no
    ** long be able to find the cells if a pointer to each cell is not saved
    ** first.
    */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>limit</name><operator>+</operator><name><name>pOld</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>limit</name><operator>&lt;</operator><name><name>pOld</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>balance_cleanup</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>limit</name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>limit</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>=</operator> <name>aData</name> <operator>+</operator> <operator>(</operator><name>maskPage</name> <operator>&amp;</operator> <call><name>get2byteAligned</name><argument_list>(<argument><expr><name>piCell</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>piCell</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pOld</name><operator>-&gt;</operator><name>nOverflow</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>k</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOld</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name><name>pOld</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt><comment type="block">/* NOTE 1 */</comment>
        <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>apOvfl</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>piEnd</name> <operator>=</operator> <name>aData</name> <operator>+</operator> <name><name>pOld</name><operator>-&gt;</operator><name>cellOffset</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>pOld</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>piCell</name><operator>&lt;</operator><name>piEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>&lt;</operator><name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>=</operator> <name>aData</name> <operator>+</operator> <operator>(</operator><name>maskPage</name> <operator>&amp;</operator> <call><name>get2byteAligned</name><argument_list>(<argument><expr><name>piCell</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>piCell</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>-</operator><name>nCellAtStart</name><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pOld</name><operator>-&gt;</operator><name>nCell</name></name><operator>+</operator><name><name>pOld</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cntOld</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>nCell</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nOld</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>leafData</name></expr>)</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u16</name></type> <name>sz</name> <init>= <expr><operator>(</operator><name>u16</name><operator>)</operator><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTemp</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>&lt;</operator><name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTemp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aSpace1</name><index>[<expr><name>iSpace1</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iSpace1</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>&lt;=</operator><name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">23</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSpace1</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTemp</name></expr></argument>, <argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>=</operator> <name>pTemp</name><operator>+</operator><name>leafCorrection</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCorrection</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>leafCorrection</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name> <operator>-</operator> <name>leafCorrection</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pOld</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCorrection</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The right pointer of the child page pOld becomes the left
        ** pointer of the divider cell */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOld</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCorrection</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Do not allow any cells smaller than 4 bytes. If a smaller cell
          ** does exist, pad it with 0x00 bytes. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name><operator>==</operator><operator>&amp;</operator><name><name>aSpace1</name><index>[<expr><name>iSpace1</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aSpace1</name><index>[<expr><name>iSpace1</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>nCell</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/*
  ** Figure out the number of pages needed to hold all b.nCell cells.
  ** Store this number in "k".  Also compute szNew[] which is the total
  ** size of all cells on the i-th page and cntNew[] which is the index
  ** in b.apCell[] of the cell that divides page i from page i+1.  
  ** cntNew[k] should equal b.nCell.
  **
  ** Values computed by this block:
  **
  **           k: The total number of sibling pages
  **    szNew[i]: Spaced used on the i-th sibling page.
  **   cntNew[i]: Index in b.apCell[] and b.szCell[] for the first cell to
  **              the right of the i-th sibling page.
  ** usableSpace: Number of bytes of space available on each sibling.
  ** 
  */</comment>
  <expr_stmt><expr><name>usableSpace</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">12</literal> <operator>+</operator> <name>leafCorrection</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOld</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>.</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>cntOld</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>k</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>.</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name><operator>==</operator><name><name>b</name><operator>.</operator><name>ixNx</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Omit b.ixNx[] entry for child pages with no cells */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>leafData</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>.</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>cntOld</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>usableSpace</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nFree</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOverflow</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apOvfl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cntOld</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>k</name> <operator>=</operator> <name>nOld</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><name>usableSpace</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name>k</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>k</name><operator>&gt;</operator><name>NB</name><operator>+</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt> <goto>goto <name>balance_cleanup</name>;</goto> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>nCell</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>leafData</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>b</name><operator>.</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while<condition>( <expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>b</name><operator>.</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><name>sz</name><operator>&gt;</operator><name>usableSpace</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>leafData</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>b</name><operator>.</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><name><name>b</name><operator>.</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <operator>(</operator><ternary><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>cntNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>balance_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/*
  ** The packing computed by the previous block is biased toward the siblings
  ** on the left side (siblings with smaller keys). The left siblings are
  ** always nearly full, while the right-most sibling might be nearly empty.
  ** The next block of code attempts to adjust the packing of siblings to
  ** get a better balance.
  **
  ** This adjustment is more than an optimization.  The packing above might
  ** be so out of balance as to be illegal.  For example, the right-most
  ** sibling might be completely empty.  This adjustment is not optional.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>k</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>szRight</name> <init>= <expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Size of sibling on the right */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>szLeft</name> <init>= <expr><name><name>szNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Size of sibling on the left */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>              <comment type="block">/* Index of right-most cell in left sibling */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>              <comment type="block">/* Index of first cell to the left of right sibling */</comment>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>cntNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <name>r</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>leafData</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>szR</name></decl>, <decl><type ref="prev"/><name>szD</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>d</name><operator>&lt;</operator><name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name><operator>&lt;</operator><name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>szR</name> <operator>=</operator> <call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>szD</name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name>d</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>szRight</name><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>bBulk</name> <operator>||</operator> <name>szRight</name><operator>+</operator><name>szD</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>szLeft</name><operator>-</operator><operator>(</operator><name>szR</name><operator>+</operator><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><name>k</name><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>szRight</name> <operator>+=</operator> <name>szD</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>szLeft</name> <operator>-=</operator> <name>szR</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>d</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>r</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>szRight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>szLeft</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>cntNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <operator>(</operator><ternary><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>cntNew</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>balance_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Sanity check:  For a non-corrupt database file one of the follwing
  ** must be true:
  **    (1) We found one or more cells (cntNew[0])&gt;0), or
  **    (2) pPage is a virtual root page.  A virtual root page is when
  **        the real root page is page 1 and we are the only child of
  **        that page.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>cntNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pParent</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"BALANCE: old: %d(nc=%d) %d(nc=%d) %d(nc=%d)\n"</literal><operator>,</operator>
    <name><name>apOld</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name><operator>,</operator> <name><name>apOld</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nCell</name><operator>,</operator>
    <ternary><condition><expr><name>nOld</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>apOld</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><name>nOld</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>apOld</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>nCell</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nOld</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>apOld</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><name>nOld</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>apOld</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>nCell</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary>
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Allocate k new pages.  Reuse old pages where possible.
  */</comment>
  <expr_stmt><expr><name>pageFlags</name> <operator>=</operator> <name><name>apOld</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nOld</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nNew</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal><operator>+</operator><operator>(</operator><name>i</name><operator>==</operator><operator>(</operator><name>iParentIdx</name><operator>-</operator><name>nxDiv</name><operator>)</operator><operator>)</operator>
       <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>balance_cleanup</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bBulk</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>pgno</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>balance_cleanup</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pageFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nNew</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cntOld</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>nCell</name></name></expr>;</expr_stmt>

      <comment type="block">/* Set the pointer-map entry for the new sibling page. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>balance_cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/*
  ** Reassign page numbers so that the new pages are in ascending order. 
  ** This helps to keep entries in the disk file in order so that a scan
  ** of the table is closer to a linear scan through the file. That in turn 
  ** helps the operating system to deliver pages from the disk more rapidly.
  **
  ** An O(N*N) sort algorithm is used, but since N is never more than NB+2
  ** (5), that is not a performance concern.
  **
  ** When NB==3, this one optimization makes the database about 25% faster 
  ** for large insertions and deletions.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aPgno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pDbPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_WRITEABLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pDbPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iB</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nNew</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name> <operator>&lt;</operator> <name><name>apNew</name><index>[<expr><name>iB</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iB</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If apNew[i] has a page number that is bigger than any of the
    ** subsequence apNew[i] entries, then swap apNew[i] with the subsequent
    ** entry that has the smallest page number (which we know to be
    ** entry apNew[iB]).
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>iB</name><operator>!=</operator><name>i</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoA</name> <init>= <expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoB</name> <init>= <expr><name><name>apNew</name><index>[<expr><name>iB</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoTemp</name> <init>= <expr><operator>(</operator><name>PENDING_BYTE</name><operator>/</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u16</name></type> <name>fgA</name> <init>= <expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pDbPage</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u16</name></type> <name>fgB</name> <init>= <expr><name><name>apNew</name><index>[<expr><name>iB</name></expr>]</index></name><operator>-&gt;</operator><name><name>pDbPage</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerRekey</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pDbPage</name></expr></argument>, <argument><expr><name>pgnoTemp</name></expr></argument>, <argument><expr><name>fgB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerRekey</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><name>iB</name></expr>]</index></name><operator>-&gt;</operator><name>pDbPage</name></expr></argument>, <argument><expr><name>pgnoA</name></expr></argument>, <argument><expr><name>fgA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerRekey</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pDbPage</name></expr></argument>, <argument><expr><name>pgnoB</name></expr></argument>, <argument><expr><name>fgB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name> <operator>=</operator> <name>pgnoB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iB</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name> <operator>=</operator> <name>pgnoA</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"BALANCE: new: %d(%d nc=%d) %d(%d nc=%d) %d(%d nc=%d) "</literal>
         <literal type="string">"%d(%d nc=%d) %d(%d nc=%d)\n"</literal><operator>,</operator>
    <name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name><operator>,</operator> <name><name>szNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>cntNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>apNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>szNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>cntNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>cntNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>!</operator><name>leafData</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>apNew</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>szNew</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>cntNew</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>cntNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>!</operator><name>leafData</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">4</literal></expr> ?</condition><then> <expr><name><name>apNew</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">4</literal></expr> ?</condition><then> <expr><name><name>szNew</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">4</literal></expr> ?</condition><then> <expr><name><name>cntNew</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>cntNew</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <operator>!</operator><name>leafData</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">5</literal></expr> ?</condition><then> <expr><name><name>apNew</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">5</literal></expr> ?</condition><then> <expr><name><name>szNew</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
    <ternary><condition><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">5</literal></expr> ?</condition><then> <expr><name><name>cntNew</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>-</operator> <name><name>cntNew</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <operator>!</operator><name>leafData</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary>
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nNew</name><operator>&lt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>apNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apNew</name><index>[<expr><name>nNew</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>apNew</name><index>[<expr><name>nNew</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the sibling pages are not leaves, ensure that the right-child pointer
  ** of the right-most new sibling page is set to the value that was 
  ** originally in the same field of the right-most old sibling page. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pageFlags</name> <operator>&amp;</operator> <name>PTF_LEAF</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nOld</name><operator>!=</operator><name>nNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pOld</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>nNew</name><operator>&gt;</operator><name>nOld</name></expr> ?</condition><then> <expr><name>apNew</name></expr> </then><else>: <expr><name>apOld</name></expr></else></ternary><operator>)</operator><index>[<expr><name>nOld</name><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apNew</name><index>[<expr><name>nNew</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOld</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make any required updates to pointer map entries associated with 
  ** cells stored on sibling pages following the balance operation. Pointer
  ** map entries associated with divider cells are set by the insertCell()
  ** routine. The associated pointer map entries are:
  **
  **   a) if the cell contains a reference to an overflow chain, the
  **      entry associated with the first page in the overflow chain, and
  **
  **   b) if the sibling pages are not leaves, the child page associated
  **      with the cell.
  **
  ** If the sibling pages are not leaves, then the pointer map entry 
  ** associated with the right-child of each sibling may also need to be 
  ** updated. This happens below, after the sibling pages have been 
  ** populated, not here.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><name>pOld</name> <operator>=</operator> <name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cntOldNext</name> <init>= <expr><name><name>pNew</name><operator>-&gt;</operator><name>nCell</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>b</name><operator>.</operator><name>nCell</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><name>i</name><operator>==</operator><name>cntOldNext</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iOld</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOld</name><operator>&lt;</operator><name>nNew</name> <operator>||</operator> <name>iOld</name><operator>&lt;</operator><name>nOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOld</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iOld</name><operator>&lt;</operator><name>NB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOld</name> <operator>=</operator> <ternary><condition><expr><name>iOld</name><operator>&lt;</operator><name>nNew</name></expr> ?</condition><then> <expr><name><name>apNew</name><index>[<expr><name>iOld</name></expr>]</index></name></expr> </then><else>: <expr><name><name>apOld</name><index>[<expr><name>iOld</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>cntOldNext</name> <operator>+=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>nCell</name></name> <operator>+</operator> <name><name>pOld</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>+</operator> <operator>!</operator><name>leafData</name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>cntNew</name><index>[<expr><name>iNew</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>apNew</name><index>[<expr><operator>++</operator><name>iNew</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>leafData</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Cell pCell is destined for new sibling page pNew. Originally, it
      ** was either part of sibling page iOld (possibly an overflow cell), 
      ** or else the divider cell to the left of sibling page iOld. So,
      ** if sibling page iOld had the same page number as pNew, and if
      ** pCell really was a part of sibling page iOld (not a divider or
      ** overflow cell), we can skip updating the pointer map entries.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>iOld</name><operator>&gt;=</operator><name>nNew</name>
       <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>pgno</name></name><operator>!=</operator><name><name>aPgno</name><index>[<expr><name>iOld</name></expr>]</index></name>
       <operator>||</operator> <operator>!</operator><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>,<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>leafCorrection</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cachedCellSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>minLocal</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ptrmapPutOvflPtr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>balance_cleanup</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Insert new divider cells into pParent. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTemp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSrcEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;</operator><name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>leafCorrection</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTemp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOvflSpace</name><index>[<expr><name>iOvflSpace</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pNew</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>leafData</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the tree is a leaf-data tree, and the siblings are leaves, 
      ** then there is no divider cell in b.apCell[]. Instead, the divider 
      ** cell consists of the integer key for the right-most cell of 
      ** the sibling-page assembled above only.
      */</comment>
      <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>pNew</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>apCell</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCell</name> <operator>=</operator> <name>pTemp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <call><name>putVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTemp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pCell</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <comment type="block">/* Obscure case for non-leaf-data trees: If the cell at pCell was
      ** previously stored on a leaf node, and its reported size was 4
      ** bytes, then it may actually be smaller than this 
      ** (see btreeParseCellPtr(), 4 bytes is the minimum size of
      ** any cell). But it is important to pass the correct size to 
      ** insertCell(), so reparse the cell now.
      **
      ** This can only happen for b-trees used to evaluate "IN (SELECT ...)"
      ** and WITHOUT ROWID tables with exactly one column which is the
      ** primary key.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>b</name><operator>.</operator><name>szCell</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>leafCorrection</name><operator>==</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name><name>pParent</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>iOvflSpace</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>&lt;=</operator><name><name>pBt</name><operator>-&gt;</operator><name>maxLocal</name></name><operator>+</operator><literal type="number">23</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOvflSpace</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>b</name><operator>.</operator><name>ixNx</name><index>[<expr><name>k</name></expr>]</index></name><operator>&lt;=</operator><name>j</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>k</name><operator>&lt;</operator><name>NB</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><name>pSrcEnd</name> <operator>=</operator> <name><name>b</name><operator>.</operator><name>apEnd</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>pSrcEnd</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>pCell</name><operator>+</operator><name>sz</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>balance_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>insertCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>nxDiv</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pTemp</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>balance_cleanup</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Now update the actual sibling pages. The order in which they are updated
  ** is important, as this code needs to avoid disrupting any page from which
  ** cells may still to be read. In practice, this means:
  **
  **  (1) If cells are moving left (from apNew[iPg] to apNew[iPg-1])
  **      then it is not safe to update page apNew[iPg] until after
  **      the left-hand sibling apNew[iPg-1] has been updated.
  **
  **  (2) If cells are moving right (from apNew[iPg] to apNew[iPg+1])
  **      then it is not safe to update page apNew[iPg] until after
  **      the right-hand sibling apNew[iPg+1] has been updated.
  **
  ** If neither of the above apply, the page is safe to update.
  **
  ** The iPg value in the following loop starts at nNew-1 goes down
  ** to 0, then back up to nNew-1 again, thus making two passes over
  ** the pages.  On the initial downward pass, only condition (1) above
  ** needs to be tested because (2) will always be true from the previous
  ** step.  On the upward pass, both conditions are always true, so the
  ** upwards pass simply processes pages that were missed on the downward
  ** pass.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal><operator>-</operator><name>nNew</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPg</name> <init>= <expr><ternary><condition><expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>i</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iPg</name><operator>&lt;</operator><name>nNew</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>abDone</name><index>[<expr><name>iPg</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>         <comment type="block">/* Skip pages already processed */</comment>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal>                            <comment type="block">/* On the upwards pass, or... */</comment>
     <operator>||</operator> <name><name>cntOld</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><name><name>cntNew</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>    <comment type="block">/* Condition (1) is true */</comment>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iOld</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nNewCell</name></decl>;</decl_stmt>

      <comment type="block">/* Verify condition (1):  If cells are moving left, update iPg
      ** only after iPg-1 has already been updated. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>cntOld</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><name><name>cntNew</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>abDone</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Verify condition (2):  If cells are moving right, update iPg
      ** only after iPg+1 has already been updated. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>cntNew</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>&gt;=</operator><name><name>cntOld</name><index>[<expr><name>iPg</name></expr>]</index></name> <operator>||</operator> <name><name>abDone</name><index>[<expr><name>iPg</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iNew</name> <operator>=</operator> <name>iOld</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNewCell</name> <operator>=</operator> <name><name>cntNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iOld</name> <operator>=</operator> <ternary><condition><expr><name>iPg</name><operator>&lt;</operator><name>nOld</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>cntOld</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>!</operator><name>leafData</name><operator>)</operator></expr> </then><else>: <expr><name><name>b</name><operator>.</operator><name>nCell</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>iNew</name> <operator>=</operator> <name><name>cntNew</name><index>[<expr><name>iPg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>!</operator><name>leafData</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNewCell</name> <operator>=</operator> <name><name>cntNew</name><index>[<expr><name>iPg</name></expr>]</index></name> <operator>-</operator> <name>iNew</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>editPage</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><name>iPg</name></expr>]</index></name></expr></argument>, <argument><expr><name>iOld</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><name>nNewCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>balance_cleanup</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>abDone</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>-&gt;</operator><name>nFree</name> <operator>=</operator> <name>usableSpace</name><operator>-</operator><name><name>szNew</name><index>[<expr><name>iPg</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apNew</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>-&gt;</operator><name>nOverflow</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apNew</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>-&gt;</operator><name>nCell</name><operator>==</operator><name>nNewCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* All pages have been processed exactly once */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>abDone</name></expr></argument>, <argument><expr><literal type="string">"\01\01\01\01\01"</literal></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOld</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>isRoot</name> <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>&lt;=</operator><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nFree</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The root page of the b-tree now contains no cells. The only sibling
    ** page is the right-child of the parent. Copy the contents of the
    ** child page into the parent, decreasing the overall height of the
    ** b-tree structure by one. This is described as the "balance-shallower"
    ** sub-algorithm in some documentation.
    **
    ** If this is an auto-vacuum database, the call to copyNodeContent() 
    ** sets all pointer-map entries corresponding to database image pages 
    ** for which the pointer is stored within the content being copied.
    **
    ** It is critical that the child page be defragmented before being
    ** copied into the parent, because if the parent is page 1 then it will
    ** by smaller than the child due to the database header, and so all the
    ** free space needs to be up front.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>defragmentPage</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nFree</name> <operator>==</operator> 
        <operator>(</operator><call><name>get2byteNotZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>aData</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>cellOffset</name>
          <operator>-</operator> <name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nCell</name><operator>*</operator><literal type="number">2</literal><operator>)</operator>
      <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyNodeContent</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>leafCorrection</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Fix the pointer map entries associated with the right-child of each
    ** sibling page. All other pointer map entries have already been taken
    ** care of.  */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>key</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>aData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>isInit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"BALANCE: finished: old=%d new=%d cells=%d\n"</literal><operator>,</operator>
          <name>nOld</name><operator>,</operator> <name>nNew</name><operator>,</operator> <name><name>b</name><operator>.</operator><name>nCell</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free any old pages that were not reused as new pages.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nNew</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOld</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  if( ISAUTOVACUUM(pBt) &amp;&amp; rc==SQLITE_OK &amp;&amp; apNew[0]-&gt;isInit ){
    <comment type="block">/* The ptrmapCheckPages() contains assert() statements that verify that
    ** all pointer map pages are set correctly. This is helpful while 
    ** debugging. This is usually disabled because a corrupt database may
    ** cause an assert() statement to fail.  */</comment>
    ptrmapCheckPages(apNew, nNew);
    ptrmapCheckPages(&amp;pParent, 1);
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/*
  ** Cleanup before returning.
  */</comment>
<label><name>balance_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3StackFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>apCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOld</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNew</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called when the root page of a b-tree structure is
** overfull (has one or more overflow pages).
**
** A new child page is allocated and the contents of the current root
** page, including overflow cells, are copied into the child. The root
** page is then overwritten to make it an empty page with the right-child 
** pointer pointing to the new page.
**
** Before returning, all pointer-map entries corresponding to pages 
** that the new child-page now contains pointers to are updated. The
** entry corresponding to the new right-child pointer of the root
** page is also updated.
**
** If successful, *ppChild is set to contain a reference to the child 
** page and SQLITE_OK is returned. In this case the caller is required
** to call releasePage() on *ppChild exactly once. If an error occurs,
** an error code is returned and *ppChild is set to 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>balance_deeper</name><parameter_list>(<parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pRoot</name></decl></parameter>, <parameter><decl><type><name>MemPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppChild</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                        <comment type="block">/* Return value from subprocedures */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pChild</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Pointer to a new child page */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoChild</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Page number of the new child page */</comment>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pRoot</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* The BTree */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make pRoot, the root page of the b-tree, writable. Allocate a new 
  ** page that will become the new right-child of pPage. Copy the contents
  ** of the node stored on pRoot into the new child page.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pChild</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pgnoChild</name></expr></argument>,<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyNodeContent</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoChild</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppChild</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><name><name>pRoot</name><operator>-&gt;</operator><name>nCell</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"BALANCE: copy root %d into %d\n"</literal><operator>,</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pgno</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy the overflow cells from pRoot to pChild */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>aiOvfl</name></name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>aiOvfl</name></name></expr></argument>,
         <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>apOvfl</name></name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>apOvfl</name></name></expr></argument>,
         <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>apOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pChild</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>nOverflow</name></name></expr>;</expr_stmt>

  <comment type="block">/* Zero the contents of pRoot. Then install pChild as the right-child. */</comment>
  <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name>PTF_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRoot</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pRoot</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgnoChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppChild</name> <operator>=</operator> <name>pChild</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return SQLITE_CORRUPT if any cursor other than pCur is currently valid
** on the same B-tree as pCur.
**
** This can occur if a database is corrupt with two or more SQL tables
** pointing to the same b-tree.  If an insert occurs on one SQL table
** and causes a BEFORE TRIGGER to do a secondary insert on the other SQL
** table linked to the same b-tree.  If the secondary insert causes a
** rebalance, that can change content out from under the cursor on the
** first SQL table, violating invariants on the first insert.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>anotherValidCursor</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pOther</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pOther</name><operator>=</operator><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</init> <condition><expr><name>pOther</name></expr>;</condition> <incr><expr><name>pOther</name><operator>=</operator><name><name>pOther</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pOther</name><operator>!=</operator><name>pCur</name>
     <operator>&amp;&amp;</operator> <name><name>pOther</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name>
     <operator>&amp;&amp;</operator> <name><name>pOther</name><operator>-&gt;</operator><name>pPage</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>
    )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The page that pCur currently points to has just been modified in
** some way. This function figures out if this modification means the
** tree needs to be balanced, and if so calls the appropriate balancing 
** routine. Balancing routines are:
**
**   balance_quick()
**   balance_deeper()
**   balance_nonroot()
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>balance</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aBalanceQuickSpace</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <macro><name>VVA_ONLY</name><argument_list>( <argument>int balance_quick_called = <literal type="number">0</literal></argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>int balance_deeper_called = <literal type="number">0</literal></argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>*</operator><literal type="number">3</literal><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>*</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* No rebalance required as long as:
      **   (1) There are no overflow cells
      **   (2) The amount of free space on the page is less than 2/3rds of
      **       the total usable space on the page. */</comment>
      <break>break;</break>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>iPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>anotherValidCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The root page of the b-tree is overfull. In this case call the
        ** balance_deeper() function to create a new child for the root-page
        ** and copy the current contents of the root-page to it. The
        ** next iteration of the do-loop will balance the child page.
        */</comment> 
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>balance_deeper_called</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>balance_deeper_called</name><operator>++</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>balance_deeper</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The page being written is not a root page, and there is currently
      ** more than one reference to it. This only happens if the page is one 
      ** of its own ancestor pages. Corruption. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pParent</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name>iPage</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>iIdx</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>aiIdx</name><index>[<expr><name>iPage</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nFree</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_QUICKBALANCE</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKeyLeaf</name></name>
         <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">1</literal>
         <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aiOvfl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name>
         <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pgno</name></name><operator>!=</operator><literal type="number">1</literal>
         <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><name>iIdx</name></expr>
        )</condition><block>{<block_content>
          <comment type="block">/* Call balance_quick() to create a new sibling of pPage on which
          ** to store the overflow cell. balance_quick() inserts a new cell
          ** into pParent, which may cause pParent overflow. If this
          ** happens, the next iteration of the do-loop will balance pParent 
          ** use either balance_nonroot() or balance_deeper(). Until this
          ** happens, the overflow cell is stored in the aBalanceQuickSpace[]
          ** buffer. 
          **
          ** The purpose of the following assert() is to check that only a
          ** single call to balance_quick() is made for each call to this
          ** function. If this were not verified, a subtle bug involving reuse
          ** of the aBalanceQuickSpace[] might sneak in.
          */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>balance_quick_called</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
          <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>balance_quick_called</name><operator>++</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>balance_quick</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>aBalanceQuickSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <comment type="block">/* In this case, call balance_nonroot() to redistribute cells
          ** between pPage and up to 2 of its sibling pages. This involves
          ** modifying the contents of pParent, which may cause pParent to
          ** become overfull or underfull. The next iteration of the do-loop
          ** will balance the parent page to correct this.
          ** 
          ** If the parent page becomes overfull, the overflow cell or cells
          ** are stored in the pSpace buffer allocated immediately below. 
          ** A subsequent iteration of the do-loop will deal with this by
          ** calling balance_nonroot() (balance_deeper() may be called first,
          ** but it doesn't deal with overflow cells - just moves them to a
          ** different page). Once this subsequent call to balance_nonroot() 
          ** has completed, it is safe to release the pSpace buffer used by
          ** the previous call, as the overflow cell data will have been 
          ** copied either into the body of a database page or into the new
          ** pSpace buffer passed to the latter call to balance_nonroot().
          */</comment>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSpace</name> <init>= <expr><call><name>sqlite3PageMalloc</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>balance_nonroot</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>, <argument><expr><name>iPage</name><operator>==</operator><literal type="number">1</literal></expr></argument>,
                               <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>hints</name></name><operator>&amp;</operator><name>BTREE_BULKLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pFree</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If pFree is not NULL, it points to the pSpace buffer used 
            ** by a previous call to balance_nonroot(). Its contents are
            ** now stored either on real database pages or within the 
            ** new pSpace buffer, so it may be safely freed here. */</comment>
            <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* The pSpace buffer will be freed after the next call to
          ** balance_nonroot(), or just before this function returns, whichever
          ** comes first. */</comment>
          <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name>pSpace</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* The next iteration of the do-loop balances the parent page. */</comment>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition>;</do>

  <if_stmt><if>if<condition>( <expr><name>pFree</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Overwrite content from pX into pDest.  Only do the write if the
** content is different from what is already there.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeOverwriteContent</name><parameter_list>(
  <parameter><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,           <comment type="block">/* MemPage on which writing will occur */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,                <comment type="block">/* Pointer to the place to start writing */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>BtreePayload</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>,   <comment type="block">/* Source of data to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>iOffset</name></decl></parameter>,              <comment type="block">/* Offset of first byte to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>                  <comment type="block">/* Number of bytes to be written */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><name><name>pX</name><operator>-&gt;</operator><name>nData</name></name> <operator>-</operator> <name>iOffset</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Overwritting with zeros */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iAmt</name> <operator>&amp;&amp;</operator> <name><name>pDest</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDest</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iAmt</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&lt;</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Mixed read data and zeros at the end.  Make a recursive call
      ** to write the zeros then fall through to write the real data */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>btreeOverwriteContent</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pDest</name><operator>+</operator><name>nData</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>iOffset</name><operator>+</operator><name>nData</name></expr></argument>,
                                 <argument><expr><name>iAmt</name><operator>-</operator><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iAmt</name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pX</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator> <operator>+</operator> <name>iOffset</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <comment type="block">/* In a corrupt database, it is possible for the source and destination
      ** buffers to overlap.  This is harmless since the database is already
      ** corrupt but it does cause valgrind and ASAN warnings.  So use
      ** memmove(). */</comment>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pX</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator> <operator>+</operator> <name>iOffset</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Overwrite the cell that cursor pCur is pointing to with fresh content
** contained in pX.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeOverwriteCell</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BtreePayload</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>                        <comment type="block">/* Next byte of pX-&gt;pData to write */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTotal</name> <init>= <expr><name><name>pX</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name><name>pX</name><operator>-&gt;</operator><name>nZero</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Total bytes of to write */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Page being written */</comment>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>                      <comment type="block">/* Btree */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>ovflPgno</name></decl>;</decl_stmt>                      <comment type="block">/* Next overflow page to write */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>ovflPageSize</name></decl>;</decl_stmt>                   <comment type="block">/* Size to write on overflow page */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name> <operator>+</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name>
   <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name> <operator>&lt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>cellOffset</name></name></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Overwrite the local portion first */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeOverwriteContent</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>,
                             <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name><operator>==</operator><name>nTotal</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Now overwrite the overflow pages */</comment>
  <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTotal</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOffset</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ovflPgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name> <operator>+</operator> <name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ovflPageSize</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovflPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iOffset</name><operator>+</operator><name>ovflPageSize</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nTotal</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ovflPgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>ovflPageSize</name> <operator>=</operator> <name>nTotal</name> <operator>-</operator> <name>iOffset</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeOverwriteContent</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>pX</name></expr></argument>,
                                 <argument><expr><name>iOffset</name></expr></argument>, <argument><expr><name>ovflPageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iOffset</name> <operator>+=</operator> <name>ovflPageSize</name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>iOffset</name><operator>&lt;</operator><name>nTotal</name></expr> )</condition>;</do>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>    
</block_content>}</block></function>


<comment type="block">/*
** Insert a new record into the BTree.  The content of the new record
** is described by the pX object.  The pCur cursor is used only to
** define what table the record should be inserted into, and is left
** pointing at a random location.
**
** For a table btree (used for rowid tables), only the pX.nKey value of
** the key is used. The pX.pKey value must be NULL.  The pX.nKey is the
** rowid or INTEGER PRIMARY KEY of the row.  The pX.nData,pData,nZero fields
** hold the content of the row.
**
** For an index btree (used for indexes and WITHOUT ROWID tables), the
** key is an arbitrary byte sequence stored in pX.pKey,nKey.  The 
** pX.pData,nData,nZero fields must be zero.
**
** If the seekResult parameter is non-zero, then a successful call to
** sqlite3BtreeIndexMoveto() to seek cursor pCur to (pKey,nKey) has already
** been performed.  In other words, if seekResult!=0 then the cursor
** is currently pointing to a cell that will be adjacent to the cell
** to be inserted.  If seekResult&lt;0 then pCur points to a cell that is
** smaller then (pKey,nKey).  If seekResult&gt;0 then pCur points to a cell
** that is larger than (pKey,nKey).
**
** If seekResult==0, that means pCur is pointing at some unknown location.
** In that case, this routine must seek the cursor to the correct insertion
** point for (pKey,nKey) before doing the insertion.  For index btrees,
** if pX-&gt;nMem is non-zero, then pX-&gt;aMem contains pointers to the unpacked
** key values and pX-&gt;aMem can be used instead of pX-&gt;pKey to avoid having
** to decode the key.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeInsert</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,                <comment type="block">/* Insert data into the table of this cursor */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>BtreePayload</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>,        <comment type="block">/* Content of the row to be inserted */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                     <comment type="block">/* True if this is likely an append */</comment>
  <parameter><decl><type><name>int</name></type> <name>seekResult</name></decl></parameter>                 <comment type="block">/* Result of prior IndexMoveto() call */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>loc</name> <init>= <expr><name>seekResult</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* -1: before desired location  +1: after */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>oldCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>newCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BTREE_SAVEPOSITION</name><operator>|</operator><name>BTREE_APPEND</name><operator>|</operator><name>BTREE_PREFORMAT</name><operator>)</operator><operator>)</operator><operator>==</operator><name>flags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_PREFORMAT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>seekResult</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save the positions of any other cursors open on this table.
  **
  ** In some cases, the call to btreeMoveto() below is a no-op. For
  ** example, when inserting data into a table with auto-generated integer
  ** keys, the VDBE layer invokes sqlite3BtreeLast() to figure out the 
  ** integer key to use. It then calls this function to actually insert the 
  ** data into the intkey B-Tree. In this case btreeMoveto() recognizes
  ** that the cursor is already where it needs to be and returns without
  ** doing any work. To avoid thwarting these optimizations, it is important
  ** not to clear the cursor here.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Multiple</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>loc</name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This can only happen if the schema is corrupt such that there is more
      ** than one table or index with the same root page as used by the cursor.
      ** Which can only happen if the SQLITE_NoSchemaError flag was set when
      ** the schema was loaded. This cannot be asserted though, as a user might
      ** set the flag, load the schema, and then unset the flag.  */</comment>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Ensure that the cursor is not in the CURSOR_FAULT state and that it
  ** points to a valid cell.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>CURSOR_REQUIRESEEK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_FAULT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_EMPTY</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_WriteFlag</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
              <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name>
              <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>hasSharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assert that the caller has been consistent. If this cursor was opened
  ** expecting an index b-tree, then the caller should be inserting blob
  ** keys with no associated data. If the cursor was opened expecting an
  ** intkey table, the caller should be inserting integer keys with a
  ** blob of associated data.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_PREFORMAT</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If this is an insert into a table b-tree, invalidate any incrblob 
    ** cursors open on the row being replaced */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>invalidateIncrblobCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If BTREE_SAVEPOSITION is set, the cursor must already be pointing 
    ** to a row with the same key as the new entry being inserted.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>BTREE_SAVEPOSITION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidNKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>loc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* On the other hand, BTREE_SAVEPOSITION==0 does not imply
    ** that the cursor is not pointing to a row to be overwritten.
    ** So do a complete check.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name><operator>&amp;</operator><name>BTCF_ValidNKey</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The cursor is pointing to the entry that is to be
      ** overwritten */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nData</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>nZero</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pX</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name><name>pX</name><operator>-&gt;</operator><name>nZero</name></name></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* New entry is the same size as the old.  Do an overwrite */</comment>
        <return>return <expr><call><name>btreeOverwriteCell</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>loc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>loc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The cursor is *not* pointing to the cell to be overwritten, nor
      ** to an adjacent cell.  Move the cursor so that it is pointing either
      ** to the cell to be overwritten or an adjacent cell.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTableMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, 
               <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_APPEND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This is an index or a WITHOUT ROWID table */</comment>

    <comment type="block">/* If BTREE_SAVEPOSITION is set, the cursor must already be pointing 
    ** to a row with the same key as the new entry being inserted.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_SAVEPOSITION</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>loc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the cursor is not already pointing either to the cell to be
    ** overwritten, or if a new cell is being inserted, if the cursor is
    ** not pointing to an immediately adjacent cell, then move the cursor
    ** so that it does.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>loc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_SAVEPOSITION</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>nMem</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIndexMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, 
                    <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_APPEND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the cursor is currently pointing to an entry to be overwritten
    ** and the new content is the same as as the old, then use the
    ** overwrite optimization.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>loc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>BtreePayload</name></type> <name>x2</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>x2</name><operator>.</operator><name>pData</name></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x2</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x2</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><call><name>btreeOverwriteCell</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x2</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name> 
       <operator>||</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_INVALID</name> <operator>&amp;&amp;</operator> <name>loc</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_PREFORMAT</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name> <operator>||</operator> <operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;</operator><name>CURSOR_INVALID</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
     <comment type="block">/* ^^^^^--- due to the moveToRoot() call above */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n"</literal><operator>,</operator>
          <name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>,</operator> <name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name><operator>,</operator> <name><name>pX</name><operator>-&gt;</operator><name>nData</name></name><operator>,</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator>
          <ternary><condition><expr><name>loc</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"overwrite"</literal></expr> </then><else>: <expr><literal type="string">"new entry"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>newCell</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>newCell</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>BTREE_PREFORMAT</name><operator>==</operator><name>OPFLAG_PREFORMAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>BTREE_PREFORMAT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>szNew</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>nPreformatSize</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>szNew</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szNew</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>szNew</name><operator>&gt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>info</name><operator>.</operator><name>nPayload</name></name><operator>!=</operator><name><name>info</name><operator>.</operator><name>nLocal</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>ovfl</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newCell</name><index>[<expr><name>szNew</name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>ovfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW1</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_insert</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fillInCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_insert</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szNew</name><operator>==</operator><call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szNew</name> <operator>&lt;=</operator> <call><name>MX_CELL_SIZE</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>loc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>idx</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>end_insert</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>oldCell</name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>oldCell</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BTREE_CLEAR_CELL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>oldCell</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_ValidOvfl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>invalidateOverflowCache</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>info</name><operator>.</operator><name>nSize</name></name><operator>==</operator><name>szNew</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>nLocal</name></name><operator>==</operator><name><name>info</name><operator>.</operator><name>nPayload</name></name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>szNew</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>minLocal</name></name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* Overwrite the old cell with the new if they are the same size.
      ** We could also try to do this if the old cell is smaller, then add
      ** the leftover space to the free list.  But experiments show that
      ** doing that is no faster then skipping this optimization and just
      ** calling dropCell() and insertCell(). 
      **
      ** This optimization cannot be used on an autovacuum database if the
      ** new entry uses overflow pages, as the insertCell() call below is
      ** necessary to add the PTRMAP_OVERFLOW1 pointer-map entry.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* clearCell never fails when nLocal==nPayload */</comment>
      <if_stmt><if>if<condition>( <expr><name>oldCell</name> <operator>&lt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name><operator>+</operator><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>oldCell</name><operator>+</operator><name>szNew</name> <operator>&gt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>oldCell</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>nSize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_insert</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>loc</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>++</operator><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTCF_ValidNKey</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>insertCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If no error has occurred and pPage has an overflow cell, call balance() 
  ** to redistribute the cells within the tree. Since balance() may move
  ** the cursor, zero the BtCursor.info.nSize and BTCF_ValidNKey
  ** variables.
  **
  ** Previous versions of SQLite called moveToRoot() to move the cursor
  ** back to the root page as balance() used to invalidate the contents
  ** of BtCursor.apPage[] and BtCursor.aiIdx[]. Instead of doing that,
  ** set the cursor state to "invalid". This makes common insert operations
  ** slightly faster.
  **
  ** There is a subtle but important optimization here too. When inserting
  ** multiple records into an intkey b-tree using a single cursor (as can
  ** happen while processing an "INSERT INTO ... SELECT" statement), it
  ** is advantageous to leave the cursor pointing to the last entry in
  ** the b-tree if possible. If the cursor is left pointing to the last
  ** entry in the table, and the next row inserted has an integer key
  ** larger than the largest existing key, it is possible to insert the
  ** row without seeking the cursor. This can be a big performance boost.
  */</comment>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTCF_ValidNKey</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Must make sure nOverflow is reset to zero even if the balance()
    ** fails. Internal data structure corruption will result otherwise. 
    ** Also, set the cursor state to invalid. This stops saveCursorPosition()
    ** from trying to save the current position of the cursor.  */</comment>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_INVALID</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_SAVEPOSITION</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>btreeReleaseAllCursorPages</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_REQUIRESEEK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>end_insert</name>:</label>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used as part of copying the current row from cursor
** pSrc into cursor pDest. If the cursors are open on intkey tables, then
** parameter iKey is used as the rowid value when the record is copied
** into pDest. Otherwise, the record is copied verbatim.
**
** This function does not actually write the new value to cursor pDest.
** Instead, it creates and populates any required overflow pages and
** writes the data for the new cell into the BtShared.pTmpSpace buffer
** for the destination database. The size of the cell, in bytes, is left
** in BtShared.nPreformatSize. The caller completes the insertion by
** calling sqlite3BtreeInsert() with the BTREE_PREFORMAT flag specified.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeTransferRow</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Pointer to next output buffer */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name></decl>;</decl_stmt>                <comment type="block">/* Pointer to next input buffer */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nIn</name></decl>;</decl_stmt>                      <comment type="block">/* Size of input buffer aIn[] */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nRem</name></decl>;</decl_stmt>                     <comment type="block">/* Bytes of data still to copy */</comment>

  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>aOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <call><name>sqlite3PutVarint</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nLocal</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aIn</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aIn</name><operator>+</operator><name>nIn</name><operator>&gt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nRem</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>==</operator><name>nRem</name> <operator>&amp;&amp;</operator> <name>nIn</name><operator>&lt;</operator><name><name>pDest</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>maxLocal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPreformatSize</name></name> <operator>=</operator> <name>nIn</name> <operator>+</operator> <operator>(</operator><name>aOut</name> <operator>-</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pSrcPager</name> <init>= <expr><name><name>pSrc</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPgnoOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>ovflIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPageIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPageOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>nOut</name></decl>;</decl_stmt>                     <comment type="block">/* Size of output buffer aOut[] */</comment>

    <expr_stmt><expr><name>nOut</name> <operator>=</operator> <call><name>btreePayloadToLocal</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPreformatSize</name></name> <operator>=</operator> <name>nOut</name> <operator>+</operator> <operator>(</operator><name>aOut</name> <operator>-</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nPayload</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pPgnoOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOut</name><index>[<expr><name>nOut</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>nPreformatSize</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>&gt;</operator><name>nIn</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>aIn</name><operator>+</operator><name>nIn</name><operator>+</operator><literal type="number">4</literal><operator>&gt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>aDataEnd</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ovflIn</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pPayload</name><index>[<expr><name>nIn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nOut</name></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOut</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>aIn</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nOut</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nIn</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aIn</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPageIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPageIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pSrcPager</name></expr></argument>, <argument><expr><name>ovflIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPageIn</name></expr></argument>, <argument><expr><name>PAGER_GET_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>aIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pPageIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ovflIn</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>aIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>aIn</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>nIn</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nOut</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
  
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>pPgnoOut</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPgnoOut</name></expr></argument>, <argument><expr><name>pgnoNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ISAUTOVACUUM</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pPageOut</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoNew</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW2</name></expr></argument>, <argument><expr><name><name>pPageOut</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPageOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPageOut</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pPageOut</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pPgnoOut</name> <operator>=</operator> <name><name>pPageOut</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPgnoOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPgnoOut</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nOut</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>nRem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition>;</do>
  
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPageOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPageIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete the entry that the cursor is pointing to. 
**
** If the BTREE_SAVEPOSITION bit of the flags parameter is zero, then
** the cursor is left pointing at an arbitrary location after the delete.
** But if that bit is set, then the cursor is left in a state such that
** the next call to BtreeNext() or BtreePrev() moves it to the same row
** as it would have been on if the call to BtreeDelete() had been omitted.
**
** The BTREE_AUXDELETE bit of flags indicates that is one of several deletes
** associated with a single table entry and its indexes.  Only one of those
** deletes is considered the "primary" delete.  The primary delete occurs
** on a cursor that is not a BTREE_FORDELETE cursor.  All but one delete
** operation on non-FORDELETE cursors is tagged with the AUXDELETE flag.
** The BTREE_AUXDELETE bit is a hint that is not used by this implementation,
** but which might be used by alternative storage engines.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeDelete</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>              
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>            <comment type="block">/* Page to delete cell from */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>      <comment type="block">/* Pointer to cell to delete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellIdx</name></decl>;</decl_stmt>              <comment type="block">/* Index of cell to delete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellDepth</name></decl>;</decl_stmt>            <comment type="block">/* Depth of node containing pCell */</comment> 
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>             <comment type="block">/* Size of the cell being deleted */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bPreserve</name></decl>;</decl_stmt>              <comment type="block">/* Keep cursor valid.  2 for CURSOR_SKIPNEXT */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_WriteFlag</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>hasSharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>hasReadConflicts</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>BTREE_SAVEPOSITION</name> <operator>|</operator> <name>BTREE_AUXDELETE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>CURSOR_REQUIRESEEK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeRestoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>CORRUPT_DB</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iCellDepth</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCellIdx</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&lt;=</operator><name>iCellIdx</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCellIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the BTREE_SAVEPOSITION bit is on, then the cursor position must
  ** be preserved following this delete operation. If the current delete
  ** will cause a b-tree rebalance, then this is done by saving the cursor
  ** key and leaving the cursor in CURSOR_REQUIRESEEK state before 
  ** returning. 
  **
  ** If the current delete will not cause a rebalance, then the cursor
  ** will be left in CURSOR_SKIPNEXT state pointing to the entry immediately
  ** before or after the deleted entry.
  **
  ** The bPreserve value records which path is required:
  **
  **    bPreserve==0         Not necessary to save the cursor position
  **    bPreserve==1         Use CURSOR_REQUIRESEEK to save the cursor position
  **    bPreserve==2         Cursor won't move.  Set CURSOR_SKIPNEXT.
  */</comment>
  <expr_stmt><expr><name>bPreserve</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BTREE_SAVEPOSITION</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bPreserve</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name> 
     <operator>||</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>+</operator><call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pCell</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal><operator>)</operator> <operator>&gt;</operator>
                                                   <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>*</operator><literal type="number">2</literal><operator>/</operator><literal type="number">3</literal><operator>)</operator>
     <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">1</literal></expr>  <comment type="block">/* See dbfuzz001.test for a test case */</comment>
    )</condition><block>{<block_content>
      <comment type="block">/* A b-tree rebalance will be required after deleting this entry.
      ** Save the cursor key.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveCursorKey</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>bPreserve</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the page containing the entry to delete is not a leaf page, move
  ** the cursor to the largest entry in the tree that is smaller than
  ** the entry being deleted. This cell will replace the cell being deleted
  ** from the internal node. The 'previous' entry is used for this instead
  ** of the 'next' entry, as the previous entry is always a part of the
  ** sub-tree headed by the child page of the cell being deleted. This makes
  ** balancing the tree following the delete operation easier.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Save the positions of any other cursors open on this table before
  ** making any modifications.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Multiple</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is a delete operation to remove a row from a table b-tree,
  ** invalidate any incrblob cursors open on the row being deleted.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>invalidateIncrblobCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>nKey</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make the page containing the entry to be deleted writable. Then free any
  ** overflow pages associated with the entry and finally remove the cell
  ** itself from within the page.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>BTREE_CLEAR_CELL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCellIdx</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>nSize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* If the cell deleted was not located on a leaf page, then the cursor
  ** is currently pointing to the largest entry in the sub-tree headed
  ** by the child-page of the cell that was just deleted from an internal
  ** node. The cell from the leaf node needs to be moved to the internal
  ** node to replace the deleted cell.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pLeaf</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pLeaf</name><operator>-&gt;</operator><name>nFree</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCellDepth</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name>iCellDepth</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>pgno</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCell</name><operator>&lt;</operator><operator>&amp;</operator><name><name>pLeaf</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name><name>pLeaf</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>MX_CELL_SIZE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTmp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>insertCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCellIdx</name></expr></argument>, <argument><expr><name>pCell</name><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>nCell</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Balance the tree. If the entry deleted was located on a leaf page,
  ** then the cursor still points to that page. In this case the first
  ** call to balance() repairs the tree, and the if(...) condition is
  ** never true.
  **
  ** Otherwise, if the entry deleted was on an internal node page, then
  ** pCur is pointing to the leaf page from which a cell was removed to
  ** replace the cell deleted from the internal node. This is slightly
  ** tricky as the leaf node may be underfull, and the internal node may
  ** be either under or overfull. In this case run the balancing algorithm
  ** on the leaf node first. If the balance proceeds far enough up the
  ** tree that we can be sure that any problem in the internal node has
  ** been corrected, so be it. Otherwise, after balancing the leaf node,
  ** walk the cursor up the tree to the internal node and balance it as 
  ** well.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nOverflow</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name><operator>*</operator><literal type="number">3</literal><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>*</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Optimization: If the free space is less than 2/3rds of the page,
    ** then balance() will always be a no-op.  No need to invoke it. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;</operator><name>iCellDepth</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>releasePageNotNull</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>--</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>&gt;</operator><name>iCellDepth</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>--</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apPage</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bPreserve</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>==</operator><name>iCellDepth</name> <operator>||</operator> <name>CORRUPT_DB</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>iCellIdx</name><operator>&lt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_SKIPNEXT</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCellIdx</name><operator>&gt;=</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>skipNext</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bPreserve</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>btreeReleaseAllCursorPages</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>CURSOR_REQUIRESEEK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_EMPTY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new BTree table.  Write into *piTable the page
** number for the root page of the new table.
**
** The type of type is determined by the flags parameter.  Only the
** following values of flags are currently in use.  Other values for
** flags might not work:
**
**     BTREE_INTKEY|BTREE_LEAFDATA     Used for SQL tables with rowid keys
**     BTREE_ZERODATA                  Used for SQL indices
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCreateTable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>piTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>createTabFlags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ptfFlags</name></decl>;</decl_stmt>          <comment type="block">/* Page-type flage for the root page of new table */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoRoot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoMove</name></decl>;</decl_stmt>      <comment type="block">/* Move a page here to make room for the root-page */</comment>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPageMove</name></decl>;</decl_stmt> <comment type="block">/* The page to move to. */</comment>

    <comment type="block">/* Creating a new table may probably require moving an existing database
    ** to make room for the new tables root page. In case this page turns
    ** out to be an overflow page, delete all overflow page-map caches
    ** held by open cursors.
    */</comment>
    <expr_stmt><expr><call><name>invalidateAllOverflowCache</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read the value of meta[3] from the database to determine where the
    ** root page of the new table should go. meta[3] is the largest root-page
    ** created so far, so the new root-page is (meta[3]+1).
    */</comment>
    <expr_stmt><expr><call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BTREE_LARGEST_ROOT_PAGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pgnoRoot</name><operator>&gt;</operator><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pgnoRoot</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* The new root-page may not be allocated on a pointer-map page, or the
    ** PENDING_BYTE page.
    */</comment>
    <while>while<condition>( <expr><name>pgnoRoot</name><operator>==</operator><call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name>pgnoRoot</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pgnoRoot</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgnoRoot</name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate a page. The page that currently resides at pgnoRoot will
    ** be moved to the allocated page (unless the allocated page happens
    ** to reside at pgnoRoot).
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPageMove</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoMove</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr><name>BTALLOC_EXACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pgnoMove</name><operator>!=</operator><name>pgnoRoot</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pgnoRoot is the page that will be used for the root-page of
      ** the new table (assuming an error did not occur). But we were
      ** allocated pgnoMove. If required (i.e. if it was not allocated
      ** by extending the file), the current page at position pgnoMove
      ** is already journaled.
      */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Save the positions of any open cursors. This is required in
      ** case they are holding a reference to an xFetch reference
      ** corresponding to page pgnoRoot.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPageMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Move the page currently at pgnoRoot to pgnoMove. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>PTRMAP_ROOTPAGE</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>PTRMAP_FREEPAGE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>!=</operator><name>PTRMAP_ROOTPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>!=</operator><name>PTRMAP_FREEPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>relocatePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr><name>pgnoMove</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Obtain the page at pgnoRoot */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name>pPageMove</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt> 

    <comment type="block">/* Update the pointer-map and meta-data with the new root-page number. */</comment>
    <expr_stmt><expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr><name>PTRMAP_ROOTPAGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* When the new root page was allocated, page 1 was made writable in
    ** order either to increase the database filesize, or to decrement the
    ** freelist count.  Hence, the sqlite3BtreeUpdateMeta() call cannot fail.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgnoRoot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>createTabFlags</name> <operator>&amp;</operator> <name>BTREE_INTKEY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ptfFlags</name> <operator>=</operator> <name>PTF_INTKEY</name> <operator>|</operator> <name>PTF_LEAFDATA</name> <operator>|</operator> <name>PTF_LEAF</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>ptfFlags</name> <operator>=</operator> <name>PTF_ZERODATA</name> <operator>|</operator> <name>PTF_LEAF</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>ptfFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>&amp;</operator> <name>BTREE_SINGLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pgnoRoot</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piTable</name> <operator>=</operator> <name>pgnoRoot</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeCreateTable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>piTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCreateTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>piTable</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Erase the given database page and all its children.  Return
** the page to the freelist.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clearDatabasePage</name><parameter_list>(
  <parameter><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>,           <comment type="block">/* The BTree that contains the table */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,               <comment type="block">/* Page number to clear */</comment>
  <parameter><decl><type><name>int</name></type> <name>freePageFlag</name></decl></parameter>,        <comment type="block">/* Deallocate page if true */</comment>
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pnChange</name></decl></parameter>            <comment type="block">/* Add number of Cells freed to this counter */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBt</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>&amp;</operator> <name>BTREE_SINGLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>pgno</name><operator>==</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>cleardatabasepage_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>clearDatabasePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pnChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>cleardatabasepage_out</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BTREE_CLEAR_CELL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>cleardatabasepage_out</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>clearDatabasePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pnChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>cleardatabasepage_out</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pnChange</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnChange</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnChange</name> <operator>+=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>freePageFlag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>hdr</name></expr>]</index></name> <operator>|</operator> <name>PTF_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>cleardatabasepage_out</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete all information from a single table in the database.  iTable is
** the page number of the root of the table.  After this routine returns,
** the root page is empty, but still exists.
**
** This routine will fail with SQLITE_LOCKED if there are any open
** read cursors on the table.  Open write cursors are moved to the
** root of the table.
**
** If pnChange is not NULL, then the integer value pointed to by pnChange
** is incremented by the number of entries in the table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeClearTable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pnChange</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>(</operator><name>Pgno</name><operator>)</operator><name>iTable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Invalidate all incrblob cursors open on table iTable (assuming iTable
    ** is the root of a table b-tree - if it is not, the following call is
    ** a no-op).  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>invalidateIncrblobCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>Pgno</name><operator>)</operator><name>iTable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>clearDatabasePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>(</operator><name>Pgno</name><operator>)</operator><name>iTable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pnChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete all information from the single table that pCur is open on.
**
** This routine only work for pCur on an ephemeral table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeClearTableOfCursor</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3BtreeClearTable</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Erase all information in a table and add the root of the table to
** the freelist.  Except, the root of the principle table (the one on
** page 1) is never added to the freelist.
**
** This routine will fail with SQLITE_LOCKED if there are any open
** cursors on the table.
**
** If AUTOVACUUM is enabled and the page at iTable is not the last
** root page in the database file, then the last root page 
** in the database file is moved into the slot formerly occupied by
** iTable and that last slot formerly occupied by the last root page
** is added to the freelist instead of iTable.  In this say, all
** root pages are kept at the beginning of the database file, which
** is necessary for AUTOVACUUM to work right.  *piMoved is set to the 
** page number that used to be the last root page in the file before
** the move.  If no page gets moved, *piMoved is set to 0.
** The last root page is recorded in meta[3] and the value of
** meta[3] is updated by this procedure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeDropTable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piMoved</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTable</name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>&gt;</operator><call><name>btreePagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeClearTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>(</operator><name>Pgno</name><operator>)</operator><name>iTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piMoved</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>maxRootPgno</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BTREE_LARGEST_ROOT_PAGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxRootPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>==</operator><name>maxRootPgno</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the table being dropped is the table with the largest root-page
      ** number in the database, put the root page on the free list. 
      */</comment>
      <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The table being dropped does not have the largest root-page
      ** number in the database. So move the page that does into the 
      ** gap left by the deleted root-page.
      */</comment>
      <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pMove</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMove</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>relocatePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pMove</name></expr></argument>, <argument><expr><name>PTRMAP_ROOTPAGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pMove</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMove</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name>pMove</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piMoved</name> <operator>=</operator> <name>maxRootPgno</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set the new 'max-root-page' value in the database header. This
    ** is the old value less one, less one more if that happens to
    ** be a root-page number, less one again if that is the
    ** PENDING_BYTE_PAGE.
    */</comment>
    <expr_stmt><expr><name>maxRootPgno</name><operator>--</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>maxRootPgno</name><operator>==</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call>
           <operator>||</operator> <call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>maxRootPgno</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>maxRootPgno</name><operator>!=</operator><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>  
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeDropTable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piMoved</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeDropTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>piMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function may only be called if the b-tree connection already
** has a read or write transaction open on the database.
**
** Read the meta-information out of a database file.  Meta[0]
** is the number of free pages currently in the database.  Meta[1]
** through meta[15] are available for use by higher layers.  Meta[0]
** is read-only, the others are read/write.
** 
** The schema layer numbers meta values differently.  At the schema
** layer (and the SetCookie and ReadCookie opcodes) the number of
** free pages is not visible.  So Cookie[0] is the same as Meta[1].
**
** This routine treats Meta[BTREE_DATA_VERSION] as a special case.  Instead
** of reading the value out of the header, it instead loads the "DataVersion"
** from the pager.  The BTREE_DATA_VERSION value is not actually stored in the
** database file.  It is a number computed by the pager.  But its access
** pattern is the same as header meta values, and so it is convenient to
** read it from this routine.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeGetMeta</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pMeta</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;</operator><name>TRANS_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OK</name><operator>==</operator><call><name>querySharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SCHEMA_ROOT</name></expr></argument>, <argument><expr><name>READ_LOCK</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name><operator>&lt;=</operator><literal type="number">15</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>idx</name><operator>==</operator><name>BTREE_DATA_VERSION</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pMeta</name> <operator>=</operator> <call><name>sqlite3PagerDataVersion</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iBDataVersion</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pMeta</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <name>idx</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If auto-vacuum is disabled in this build and this is an auto-vacuum
  ** database, mark the database as read-only.  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>idx</name><operator>==</operator><name>BTREE_LARGEST_ROOT_PAGE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pMeta</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_READ_ONLY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write meta-information back into the database.  Meta[0] is
** read-only and may not be written.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeUpdateMeta</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iMeta</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pP1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>idx</name><operator>&lt;=</operator><literal type="number">15</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pP1</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pP1</name><index>[<expr><literal type="number">36</literal> <operator>+</operator> <name>idx</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>idx</name><operator>==</operator><name>BTREE_INCR_VACUUM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>||</operator> <name>iMeta</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iMeta</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iMeta</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>incrVacuum</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iMeta</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The first argument, pCur, is a cursor opened on some b-tree. Count the
** number of entries in the b-tree and write the result to *pnEntry.
**
** SQLITE_OK is returned if the operation is successfully executed. 
** Otherwise, if an error is encountered (i.e. an IO error or database
** corruption) an SQLite error code is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCount</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pnEntry</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Value to return in *pnEntry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_EMPTY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnEntry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Unless an error occurs, the following loop runs one iteration for each
  ** page in the B-Tree structure (not including overflow pages). 
  */</comment>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>                          <comment type="block">/* Index of child node in parent */</comment>
    <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>                    <comment type="block">/* Current page of the b-tree */</comment>

    <comment type="block">/* If this is a leaf page or the tree is not an int-key tree, then 
    ** this page contains countable entries. Increment the entry counter
    ** accordingly.
    */</comment>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name> <operator>||</operator> <operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nEntry</name> <operator>+=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pPage is a leaf node. This loop navigates the cursor so that it 
    ** points to the first interior cell that it points to the parent of
    ** the next page in the tree that has not yet been visited. The
    ** pCur-&gt;aiIdx[pCur-&gt;iPage] value is set to the index of the parent cell
    ** of the page, or to the number of cells in the page if the next page
    ** to visit is the right-child of its parent.
    **
    ** If all pages in the tree have been visited, return SQLITE_OK to the
    ** caller.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <do>do <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* All pages of the b-tree have been visited. Return successfully. */</comment>
          <expr_stmt><expr><operator>*</operator><name>pnEntry</name> <operator>=</operator> <name>nEntry</name></expr>;</expr_stmt>
          <return>return <expr><call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>moveToParent</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>while <condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition>;</do>

      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Descend to the child node of the cell that the cursor currently 
    ** points at. This is the right-child if (iIdx==pPage-&gt;nCell).
    */</comment>
    <expr_stmt><expr><name>iIdx</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>ix</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iIdx</name><operator>==</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* An error has occurred. Return an error code. */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the pager associated with a BTree.  This routine is used for
** testing and debugging only.
*/</comment>
<function><type><name>Pager</name> <modifier>*</modifier></type><name>sqlite3BtreePager</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** Append a message to the error message string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkAppendMsg</name><parameter_list>(
  <parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCheck</name><operator>-&gt;</operator><name>mxErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>mxErr</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>errMsg</name><operator>.</operator><name>nChar</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>v1</name></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>v2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>errMsg</name><operator>.</operator><name>accError</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>bOomFault</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>

<comment type="block">/*
** Return non-zero if the bit in the IntegrityCk.aPgRef[] array that
** corresponds to page iPg is already set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getPageReferenced</name><parameter_list>(<parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>&lt;=</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nPage</name></name> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>aPgRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name><name>pCheck</name><operator>-&gt;</operator><name>aPgRef</name><index>[<expr><name>iPg</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iPg</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the bit in the IntegrityCk.aPgRef[] array that corresponds to page iPg.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setPageReferenced</name><parameter_list>(<parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>&lt;=</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nPage</name></name> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>aPgRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>aPgRef</name><index>[<expr><name>iPg</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iPg</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Add 1 to the reference count for page iPage.  If this is the second
** reference to the page, add an error message to pCheck-&gt;zErrMsg.
** Return 1 if there are 2 or more references to the page and 0 if
** if this is the first reference to the page.
**
** Also check that the page number is in bounds.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkRef</name><parameter_list>(<parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>&gt;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nPage</name></name> <operator>||</operator> <name>iPage</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"invalid page number %d"</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>getPageReferenced</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"2nd reference to page %d"</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>setPageReferenced</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Check that the entry in the pointer-map for page iChild maps to 
** page iParent, pointer type ptrType. If not, append an error message
** to pCheck.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkPtrmap</name><parameter_list>(
  <parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,   <comment type="block">/* Integrity check context */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iChild</name></decl></parameter>,           <comment type="block">/* Child page number */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eType</name></decl></parameter>,              <comment type="block">/* Expected pointer map type */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iParent</name></decl></parameter>           <comment type="block">/* Expected pointer map parent page number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>ePtrmapType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrmapParent</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrmapGet</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ePtrmapType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPtrmapParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>bOomFault</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Failed to read ptrmap key=%d"</literal></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>ePtrmapType</name><operator>!=</operator><name>eType</name> <operator>||</operator> <name>iPtrmapParent</name><operator>!=</operator><name>iParent</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
      <argument><expr><literal type="string">"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"</literal></expr></argument>, 
      <argument><expr><name>iChild</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>ePtrmapType</name></expr></argument>, <argument><expr><name>iPtrmapParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Check the integrity of the freelist or of an overflow page list.
** Verify that the number of pages on the list is N.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkList</name><parameter_list>(
  <parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,  <comment type="block">/* Integrity checking context */</comment>
  <parameter><decl><type><name>int</name></type> <name>isFreeList</name></decl></parameter>,       <comment type="block">/* True for a freelist.  False for overflow page list */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iPage</name></decl></parameter>,           <comment type="block">/* Page number for first page in the list */</comment>
  <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>                 <comment type="block">/* Expected number of pages in the list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>expected</name> <init>= <expr><name>N</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nErrAtStart</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>nErr</name></name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>iPage</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>mxErr</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pOvflPage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pOvflData</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>checkRef</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>N</name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Pgno</name><operator>)</operator><name>iPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOvflPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"failed to get page %d"</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pOvflData</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pOvflPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isFreeList</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOvflData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>PTRMAP_FREEPAGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name><operator>/</operator><literal type="number">4</literal><operator>-</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
           <argument><expr><literal type="string">"freelist leaf count too big on page %d"</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>N</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>Pgno</name></type> <name>iFreePage</name> <init>= <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOvflData</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>i</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>PTRMAP_FREEPAGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><call><name>checkRef</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>N</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <else>else<block>{<block_content>
      <comment type="block">/* If this database supports auto-vacuum and iPage is not the last
      ** page in this overflow list, check that the pointer-map entry for
      ** the following page matches iPage.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>&amp;&amp;</operator> <name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>pOvflData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW2</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>iPage</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>pOvflData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pOvflPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>N</name> <operator>&amp;&amp;</operator> <name>nErrAtStart</name><operator>==</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
      <argument><expr><literal type="string">"%s is %d but should be %d"</literal></expr></argument>,
      <argument><expr><ternary><condition><expr><name>isFreeList</name></expr> ?</condition><then> <expr><literal type="string">"size"</literal></expr> </then><else>: <expr><literal type="string">"overflow list length"</literal></expr></else></ternary></expr></argument>,
      <argument><expr><name>expected</name><operator>-</operator><name>N</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<comment type="block">/*
** An implementation of a min-heap.
**
** aHeap[0] is the number of elements on the heap.  aHeap[1] is the
** root element.  The daughter nodes of aHeap[N] are aHeap[N*2]
** and aHeap[N*2+1].
**
** The heap property is this:  Every node is less than or equal to both
** of its daughter nodes.  A consequence of the heap property is that the
** root node aHeap[1] is always the minimum value currently in the heap.
**
** The btreeHeapInsert() routine inserts an unsigned 32-bit number onto
** the heap, preserving the heap property.  The btreeHeapPull() routine
** removes the root element from the heap (the minimum value in the heap)
** and then moves other nodes around as necessary to preserve the heap
** property.
**
** This heap is used for cell overlap and coverage testing.  Each u32
** entry represents the span of a cell or freeblock on a btree page.  
** The upper 16 bits are the index of the first byte of a range and the
** lower 16 bits are the index of the last byte of that range.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeHeapInsert</name><parameter_list>(<parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aHeap</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><operator>++</operator><name><name>aHeap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>j</name> <operator>=</operator> <name>i</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name><operator>&gt;</operator><name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeHeapPull</name><parameter_list>(<parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aHeap</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>x</name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pOut</name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aHeap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aHeap</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aHeap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>j</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>&lt;=</operator><name><name>aHeap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name><operator>&gt;</operator><name><name>aHeap</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** Do various sanity checks on a single page of a tree.  Return
** the tree depth.  Root pages return 0.  Parents of root pages
** return 1, and so forth.
** 
** These checks are done:
**
**      1.  Make sure that cells and freeblocks do not overlap
**          but combine to completely cover the page.
**      2.  Make sure integer cell keys are in order.
**      3.  Check the integrity of overflow pages.
**      4.  Recursively call checkTreePage on all children.
**      5.  Verify that the depth of all children is the same.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkTreePage</name><parameter_list>(
  <parameter><decl><type><name>IntegrityCk</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,  <comment type="block">/* Context for the sanity check */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iPage</name></decl></parameter>,           <comment type="block">/* Page number of the page to check */</comment>
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piMinKey</name></decl></parameter>,        <comment type="block">/* Write minimum integer primary key here */</comment>
  <parameter><decl><type><name>i64</name></type> <name>maxKey</name></decl></parameter>            <comment type="block">/* Error if integer primary key greater than this */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemPage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* The page being analyzed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                  <comment type="block">/* Result code from subroutine call */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>d2</name></decl>;</decl_stmt>      <comment type="block">/* Depth of a subtree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pgno</name></decl>;</decl_stmt>                <comment type="block">/* Page number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrag</name></decl>;</decl_stmt>               <comment type="block">/* Number of fragmented bytes on the page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>                 <comment type="block">/* Offset to the page header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellStart</name></decl>;</decl_stmt>           <comment type="block">/* Offset to the start of the cell pointer array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>               <comment type="block">/* Number of cells */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>doCoverageCheck</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True if cell coverage checking should be done */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>keyCanBeEqual</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* True if IPK can be equal to maxKey
                           ** False if IPK must be strictly less than maxKey */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>                <comment type="block">/* Page content */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>               <comment type="block">/* Cell content */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellIdx</name></decl>;</decl_stmt>            <comment type="block">/* Next element of the cell pointer array */</comment>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>           <comment type="block">/* The BtShared object that owns pPage */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>pc</name></decl>;</decl_stmt>                  <comment type="block">/* Address of a cell */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>usableSize</name></decl>;</decl_stmt>          <comment type="block">/* Usable size of the page */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>contentOffset</name></decl>;</decl_stmt>       <comment type="block">/* Offset to the start of the cell content area */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>heap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Min-heap used for checking cell coverage */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Next and previous entry on the min-heap */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>saved_zPfx</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>saved_v1</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>v1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>saved_v2</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>v2</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>savedIsInit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check that the page exists
  */</comment>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>usableSize</name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>usableSize</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>checkRef</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name> <operator>=</operator> <literal type="string">"Page %u: "</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>v1</name></name> <operator>=</operator> <name>iPage</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>btreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
       <argument><expr><literal type="string">"unable to get the page. error code=%d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_of_check</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear MemPage.isInit to make sure the corruption detection code in
  ** btreeInitPage() is executed.  */</comment>
  <expr_stmt><expr><name>savedIsInit</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>btreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_CORRUPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The only possible error from InitPage */</comment>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
                   <argument><expr><literal type="string">"btreeInitPage() returns error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_of_check</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>btreeComputeFreeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_CORRUPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"free space corruption"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_of_check</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>hdrOffset</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set up for cell analysis */</comment>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name> <operator>=</operator> <literal type="string">"On tree page %u cell %d: "</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>contentOffset</name> <operator>=</operator> <call><name>get2byteNotZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>contentOffset</name><operator>&lt;=</operator><name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Enforced by btreeInitPage() */</comment>

  <comment type="block">/* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
  ** number of cells on the page. */</comment>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* EVIDENCE-OF: R-23882-45353 The cell pointer array of a b-tree page
  ** immediately follows the b-tree page header. */</comment>
  <expr_stmt><expr><name>cellStart</name> <operator>=</operator> <name>hdr</name> <operator>+</operator> <literal type="number">12</literal> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>aCellIdx</name></name><operator>==</operator><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellStart</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCellIdx</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellStart</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>nCell</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Analyze the right-child page of internal pages */</comment>
    <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name> <operator>=</operator> <literal type="string">"On page %u at right child: "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>depth</name> <operator>=</operator> <call><name>checkTreePage</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxKey</name></expr></argument>, <argument><expr><name>maxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>keyCanBeEqual</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* For leaf pages, the coverage check will occur in the same loop
    ** as the other cell checks, so initialize the heap.  */</comment>
    <expr_stmt><expr><name>heap</name> <operator>=</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>heap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* EVIDENCE-OF: R-02776-14802 The cell pointer array consists of K 2-byte
  ** integer offsets to the cell contents. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nCell</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>mxErr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>

    <comment type="block">/* Check cell size */</comment>
    <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>v2</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCellIdx</name><operator>==</operator><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellStart</name> <operator>+</operator> <name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byteAligned</name><argument_list>(<argument><expr><name>pCellIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCellIdx</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pc</name><argument_list type="generic">&lt;<argument><expr><name>contentOffset</name> <operator>||</operator> <name>pc</name></expr></argument>&gt;</argument_list></name><name>usableSize</name><operator>-</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Offset %d out of range %d..%d"</literal></expr></argument>,
                             <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>contentOffset</name></expr></argument>, <argument><expr><name>usableSize</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>doCoverageCheck</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pCell</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>xParseCell</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pc</name><operator>+</operator><name><name>info</name><operator>.</operator><name>nSize</name></name><operator>&gt;</operator><name>usableSize</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Extends off end of page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>doCoverageCheck</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for integer primary key out of range */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><ternary><condition><expr><name>keyCanBeEqual</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>info</name><operator>.</operator><name>nKey</name></name> <operator>&gt;</operator> <name>maxKey</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name><name>info</name><operator>.</operator><name>nKey</name></name> <operator>&gt;=</operator> <name>maxKey</name><operator>)</operator></expr></else></ternary></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Rowid %lld out of order"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>maxKey</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>nKey</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>keyCanBeEqual</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>     <comment type="block">/* Only the first key on the page may ==maxKey */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check the content overflow list */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>info</name><operator>.</operator><name>nPayload</name></name><operator>&gt;</operator><name><name>info</name><operator>.</operator><name>nLocal</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>nPage</name></decl>;</decl_stmt>       <comment type="block">/* Number of pages on the overflow chain */</comment>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoOvfl</name></decl>;</decl_stmt>   <comment type="block">/* First page of the overflow chain */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pc</name> <operator>+</operator> <name><name>info</name><operator>.</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPage</name> <operator>=</operator> <operator>(</operator><name><name>info</name><operator>.</operator><name>nPayload</name></name> <operator>-</operator> <name><name>info</name><operator>.</operator><name>nLocal</name></name> <operator>+</operator> <name>usableSize</name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator><operator>/</operator><operator>(</operator><name>usableSize</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pgnoOvfl</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><name><name>info</name><operator>.</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW1</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>checkList</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Check sanity of left child page for internal pages */</comment>
      <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>d2</name> <operator>=</operator> <call><name>checkTreePage</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxKey</name></expr></argument>, <argument><expr><name>maxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>keyCanBeEqual</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>d2</name><operator>!=</operator><name>depth</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Child page depth differs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>depth</name> <operator>=</operator> <name>d2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Populate the coverage-checking heap for leaf pages */</comment>
      <expr_stmt><expr><call><name>btreeHeapInsert</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>(</operator><name>pc</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>|</operator><operator>(</operator><name>pc</name><operator>+</operator><name><name>info</name><operator>.</operator><name>nSize</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>piMinKey</name> <operator>=</operator> <name>maxKey</name></expr>;</expr_stmt>

  <comment type="block">/* Check for complete coverage of the page
  */</comment>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>doCoverageCheck</name> <operator>&amp;&amp;</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>mxErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* For leaf pages, the min-heap has already been initialized and the
    ** cells have already been inserted.  But for internal pages, that has
    ** not yet been done, so do it now */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>leaf</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>heap</name> <operator>=</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>heap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nCell</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>size</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>get2byteAligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cellStart</name><operator>+</operator><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>pPage</name><operator>-&gt;</operator><name>xCellSize</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>btreeHeapInsert</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>(</operator><name>pc</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>|</operator><operator>(</operator><name>pc</name><operator>+</operator><name>size</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Add the freeblocks to the min-heap
    **
    ** EVIDENCE-OF: R-20690-50594 The second field of the b-tree page header
    ** is the offset of the first freeblock, or zero if there are no
    ** freeblocks on the page. 
    */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>i</name><operator>&lt;=</operator><name>usableSize</name><operator>-</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Enforced by btreeComputeFreeSpace() */</comment>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>i</name><operator>+</operator><name>size</name><operator>)</operator><operator>&lt;=</operator><name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* due to btreeComputeFreeSpace() */</comment>
      <expr_stmt><expr><call><name>btreeHeapInsert</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name>i</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>|</operator><operator>(</operator><name>i</name><operator>+</operator><name>size</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* EVIDENCE-OF: R-58208-19414 The first 2 bytes of a freeblock are a
      ** big-endian integer which is the offset in the b-tree page of the next
      ** freeblock in the chain, or zero if the freeblock is the last on the
      ** chain. */</comment>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>get2byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* EVIDENCE-OF: R-06866-39125 Freeblocks are always connected in order of
      ** increasing offset. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>j</name><operator>&gt;</operator><name>i</name><operator>+</operator><name>size</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* Enforced by btreeComputeFreeSpace() */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>j</name><operator>&lt;=</operator><name>usableSize</name><operator>-</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Enforced by btreeComputeFreeSpace() */</comment>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* Analyze the min-heap looking for overlap between cells and/or 
    ** freeblocks, and counting the number of untracked bytes in nFrag.
    ** 
    ** Each min-heap entry is of the form:    (start_address&lt;&lt;16)|end_address.
    ** There is an implied first entry the covers the page header, the cell
    ** pointer index, and the gap between the cell pointer index and the start
    ** of cell content.  
    **
    ** The loop below pulls entries from the min-heap in order and compares
    ** the start_address against the previous end_address.  If there is an
    ** overlap, that means bytes are used multiple times.  If there is a gap,
    ** that gap is added to the fragmentation count.
    */</comment>
    <expr_stmt><expr><name>nFrag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>contentOffset</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Implied first min-heap entry */</comment>
    <while>while<condition>( <expr><call><name>btreeHeapPull</name><argument_list>(<argument><expr><name>heap</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>prev</name><operator>&amp;</operator><literal type="number">0xffff</literal><operator>)</operator><operator>&gt;=</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
          <argument><expr><literal type="string">"Multiple uses for byte %u of page %u"</literal></expr></argument>, <argument><expr><name>x</name><operator>&gt;&gt;</operator><literal type="number">16</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nFrag</name> <operator>+=</operator> <operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>prev</name><operator>&amp;</operator><literal type="number">0xffff</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>nFrag</name> <operator>+=</operator> <name>usableSize</name> <operator>-</operator> <operator>(</operator><name>prev</name><operator>&amp;</operator><literal type="number">0xffff</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* EVIDENCE-OF: R-43263-13491 The total number of bytes in all fragments
    ** is stored in the fifth field of the b-tree page header.
    ** EVIDENCE-OF: R-07161-27322 The one-byte integer at offset 7 gives the
    ** number of fragmented free bytes within the cell content area.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>heap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nFrag</name><operator>!=</operator><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
          <argument><expr><literal type="string">"Fragmentation of %d bytes reported as %d on page %u"</literal></expr></argument>,
          <argument><expr><name>nFrag</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>hdr</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>end_of_check</name>:</label>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>doCoverageCheck</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <name>savedIsInit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zPfx</name></name> <operator>=</operator> <name>saved_zPfx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>v1</name></name> <operator>=</operator> <name>saved_v1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>v2</name></name> <operator>=</operator> <name>saved_v2</name></expr>;</expr_stmt>
  <return>return <expr><name>depth</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** This routine does a complete check of the given BTree file.  aRoot[] is
** an array of pages numbers were each page number is the root page of
** a table.  nRoot is the number of entries in aRoot.
**
** A read-only or read-write transaction must be opened before calling
** this function.
**
** Write the number of error seen in *pnErr.  Except for some memory
** allocation errors,  an error message held in memory obtained from
** malloc is returned if *pnErr is non-zero.  If *pnErr==0 then NULL is
** returned.  If a memory allocation error occurs, NULL is returned.
**
** If the first entry in aRoot[] is 0, that indicates that the list of
** root pages is incomplete.  This is a "partial integrity-check".  This
** happens when performing an integrity check on a single table.  The
** zero is skipped, of course.  But in addition, the freelist checks
** and the checks to make sure every page is referenced are also skipped,
** since obviously it is not possible to know which pages are covered by
** the unverified btrees.  Except, if aRoot[1] is 1, then the freelist
** checks are still performed.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3BtreeIntegrityCheck</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,  <comment type="block">/* Database connection that is running the check */</comment>
  <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,     <comment type="block">/* The btree to be checked */</comment>
  <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>aRoot</name></decl></parameter>,  <comment type="block">/* An array of root pages numbers for individual trees */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRoot</name></decl></parameter>,    <comment type="block">/* Number of entries in aRoot[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>mxErr</name></decl></parameter>,    <comment type="block">/* Stop reporting errors after this many */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnErr</name></decl></parameter>    <comment type="block">/* Write number of errors seen to this variable */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IntegrityCk</name></type> <name>sCheck</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>savedDbFlags</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zErr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bPartial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* True if not checking all btrees */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bCkFreelist</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* True to scan the freelist */</comment>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>int nRef</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRoot</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* aRoot[0]==0 means this is a partial check */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>aRoot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRoot</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bPartial</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aRoot</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bCkFreelist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>&gt;</operator><name>TRANS_NONE</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>&gt;</operator><name>TRANS_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>nRef</name> <operator>=</operator> <call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRef</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>pBt</name></name> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>pPager</name></name> <operator>=</operator> <name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>nPage</name></name> <operator>=</operator> <call><name>btreePagecount</name><argument_list>(<argument><expr><name><name>sCheck</name><operator>.</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>mxErr</name></name> <operator>=</operator> <name>mxErr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>nErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>bOomFault</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>zPfx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>v1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>v2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>aPgRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sCheck</name><operator>.</operator><name>errMsg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>errMsg</name><operator>.</operator><name>printfFlags</name></name> <operator>=</operator> <name>SQLITE_PRINTF_INTERNAL</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sCheck</name><operator>.</operator><name>nPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>integrity_ck_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>aPgRef</name></name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><operator>(</operator><name><name>sCheck</name><operator>.</operator><name>nPage</name></name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator><operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>sCheck</name><operator>.</operator><name>aPgRef</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>bOomFault</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>integrity_ck_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><call><name>sqlite3PageMalloc</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sCheck</name><operator>.</operator><name>heap</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>bOomFault</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>integrity_ck_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;=</operator><name><name>sCheck</name><operator>.</operator><name>nPage</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setPageReferenced</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Check the integrity of the freelist
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>bCkFreelist</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>zPfx</name></name> <operator>=</operator> <literal type="string">"Main freelist: "</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>zPfx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check all the tables.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bPartial</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>mxInHdr</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name><operator>&lt;</operator><name>nRoot</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name>mx</name><operator>&lt;</operator><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mx</name> <operator>=</operator> <name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
      <expr_stmt><expr><name>mxInHdr</name> <operator>=</operator> <call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">52</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>mx</name><operator>!=</operator><name>mxInHdr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>,
          <argument><expr><literal type="string">"max rootpage (%d) disagrees with header (%d)"</literal></expr></argument>,
          <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>mxInHdr</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>,
        <argument><expr><literal type="string">"incremental_vacuum enabled with a max rootpage of zero"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CellSizeCk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>u64</name><operator>)</operator><name>SQLITE_CellSizeCk</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name><operator>&lt;</operator><name>nRoot</name> <operator>&amp;&amp;</operator> <name><name>sCheck</name><operator>.</operator><name>mxErr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>notUsed</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name> <operator>&amp;&amp;</operator> <name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>bPartial</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>PTRMAP_ROOTPAGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>checkTreePage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>notUsed</name></expr></argument>, <argument><expr><name>LARGEST_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>savedDbFlags</name></expr>;</expr_stmt>

  <comment type="block">/* Make sure every page in the file is referenced
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bPartial</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>sCheck</name><operator>.</operator><name>nPage</name></name> <operator>&amp;&amp;</operator> <name><name>sCheck</name><operator>.</operator><name>mxErr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><call><name>getPageReferenced</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><literal type="string">"Page %d is never used"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* If the database supports auto-vacuum, make sure no tables contain
      ** references to pointer-map pages.
      */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>getPageReferenced</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> 
         <operator>(</operator><call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><name>i</name> <operator>||</operator> <operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><literal type="string">"Page %d is never used"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>getPageReferenced</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> 
         <operator>(</operator><call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><name>i</name> <operator>&amp;&amp;</operator> <name><name>pBt</name><operator>-&gt;</operator><name>autoVacuum</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCheck</name></expr></argument>, <argument><expr><literal type="string">"Pointer map page %d is referenced"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clean  up and report errors.
  */</comment>
<label><name>integrity_ck_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name><name>sCheck</name><operator>.</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sCheck</name><operator>.</operator><name>aPgRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sCheck</name><operator>.</operator><name>bOomFault</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sCheck</name><operator>.</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCheck</name><operator>.</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnErr</name> <operator>=</operator> <name><name>sCheck</name><operator>.</operator><name>nErr</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sCheck</name><operator>.</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sCheck</name><operator>.</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* Make sure this analysis did not leave any unref() pages. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRef</name><operator>==</operator><call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sCheck</name><operator>.</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<comment type="block">/*
** Return the full pathname of the underlying database file.  Return
** an empty string if the database is in-memory or a TEMP database.
**
** The pager filename is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3BtreeGetFilename</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the pathname of the journal file for this database. The return
** value of this routine is the same regardless of whether the journal file
** has been created or not.
**
** The pager journal filename is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3BtreeGetJournalname</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PagerJournalname</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return one of SQLITE_TXN_NONE, SQLITE_TXN_READ, or SQLITE_TXN_WRITE
** to describe the current transaction state of Btree p.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeTxnState</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** Run a checkpoint on the Btree passed as the first argument.
**
** Return SQLITE_LOCKED if this or any other connection has an open 
** transaction on the shared-cache the argument Btree is connected to.
**
** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCheckpoint</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>!=</operator><name>TRANS_NONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerCheckpoint</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>, <argument><expr><name>pnLog</name></expr></argument>, <argument><expr><name>pnCkpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return true if there is currently a backup running on Btree p.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIsInBackup</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nBackup</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function returns a pointer to a blob of memory associated with
** a single shared-btree. The memory is used by client code for its own
** purposes (for example, to store a high-level schema associated with 
** the shared-btree). The btree layer manages reference counting issues.
**
** The first time this is called on a shared-btree, nBytes bytes of memory
** are allocated, zeroed, and returned to the caller. For each subsequent 
** call the nBytes parameter is ignored and a pointer to the same blob
** of memory returned. 
**
** If the nBytes parameter is 0 and the blob of memory has not yet been
** allocated, a null pointer is returned. If the blob has already been
** allocated, it is returned as normal.
**
** Just before the shared-btree is closed, the function passed as the 
** xFree argument when the memory allocation was made is invoked on the 
** blob of allocated memory. The xFree function should not call sqlite3_free()
** on the memory, the btree layer does that.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3BtreeSchema</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBytes</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xFree</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>&amp;&amp;</operator> <name>nBytes</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>xFreeSchema</name></name> <operator>=</operator> <name>xFree</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pBt</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return SQLITE_LOCKED_SHAREDCACHE if another user of the same shared 
** btree as the argument handle holds an exclusive lock on the 
** sqlite_schema table. Otherwise SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSchemaLocked</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>querySharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SCHEMA_ROOT</name></expr></argument>, <argument><expr><name>READ_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_LOCKED_SHAREDCACHE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Obtain a lock on the table whose root page is iTab.  The
** lock is a write lock if isWritelock is true or a read lock
** if it is false.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeLockTable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>isWriteLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTrans</name></name><operator>!=</operator><name>TRANS_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>lockType</name> <init>= <expr><name>READ_LOCK</name> <operator>+</operator> <name>isWriteLock</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>READ_LOCK</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isWriteLock</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isWriteLock</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>querySharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>lockType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>setSharedCacheTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>lockType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<comment type="block">/*
** Argument pCsr must be a cursor opened for writing on an 
** INTKEY table currently pointing at a valid table entry. 
** This function modifies the data stored as part of that entry.
**
** Only the data content may only be modified, it is not possible to 
** change the length of the data stored. If this function is called with
** parameters that attempt to write past the end of the existing data,
** no modifications are made and SQLITE_CORRUPT is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreePutData</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorOwnsBtShared</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_Incrblob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>CURSOR_VALID</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ABORT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Save the positions of all other cursors open on this table. This is
  ** required in case any of them are holding references to an xFetch
  ** version of the b-tree page modified by the accessPayload call below.
  **
  ** Note that pCsr must be open on a INTKEY table and saveCursorPosition()
  ** and hence saveAllCursors() cannot fail on a BTREE_INTKEY table, hence
  ** saveAllCursors can only return SQLITE_OK.
  */</comment>
  <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>saveAllCursors</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check some assumptions: 
  **   (a) the cursor is open for writing,
  **   (b) there is a read/write transaction open,
  **   (c) the connection holds a write-lock on the table (if required),
  **   (d) there are no conflicting read-locks, and
  **   (e) the cursor points at a valid row of an intKey table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>&amp;</operator> <name>BTCF_WriteFlag</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
              <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>hasSharedCacheTableLock</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtree</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>hasReadConflicts</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtree</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>intKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>accessPayload</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Mark this cursor as an incremental blob cursor.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeIncrblobCursor</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>curFlags</name></name> <operator>|=</operator> <name>BTCF_Incrblob</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pBtree</name><operator>-&gt;</operator><name>hasIncrblobCur</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Set both the "read version" (single byte at byte offset 18) and 
** "write version" (single byte at byte offset 19) fields in the database
** header to iVersion.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetVersion</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVersion</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>pBtree</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iVersion</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iVersion</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If setting the version fields to 1, do not automatically open the
  ** WAL connection, even if the version fields are currently set to 2.
  */</comment>
  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_NO_WAL</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iVersion</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>|=</operator> <name>BTS_NO_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aData</name><index>[<expr><literal type="number">18</literal></expr>]</index></name><operator>!=</operator><operator>(</operator><name>u8</name><operator>)</operator><name>iVersion</name> <operator>||</operator> <name><name>aData</name><index>[<expr><literal type="number">19</literal></expr>]</index></name><operator>!=</operator><operator>(</operator><name>u8</name><operator>)</operator><name>iVersion</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPage1</name><operator>-&gt;</operator><name>pDbPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iVersion</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aData</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iVersion</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_NO_WAL</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the cursor has a hint specified.  This routine is
** only used from within assert() statements
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorHasHint</name><parameter_list>(<parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>hints</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the given Btree is read-only.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIsReadonly</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;</operator> <name>BTS_READ_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the header added to each page by this module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3HeaderSizeBtree</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemPage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** If no transaction is active and the database is not a temp-db, clear
** the in-memory pager cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeClearCache</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>BtShared</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBt</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>==</operator><name>TRANS_NONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PagerClearCache</name><argument_list>(<argument><expr><name><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Return true if the Btree passed as the only argument is sharable.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSharable</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of connections to the BtShared object accessed by
** the Btree handle passed as the only argument. For private caches 
** this is always 1. For shared caches it may be 1 or greater.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeConnectionCount</name><parameter_list>(<parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sharable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>nRef</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
