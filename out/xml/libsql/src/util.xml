<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/util.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Utility functions used throughout sqlite.
**
** This file contains functions for allocating memory, comparing
** strings, and stuff like that.
**
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Calls to sqlite3FaultSim() are used to simulate a failure during testing,
** or to bypass normal error detection during testing in order to let 
** execute proceed futher downstream.
**
** In deployment, sqlite3FaultSim() *always* return SQLITE_OK (0).  The
** sqlite3FaultSim() function only returns non-zero during testing.
**
** During testing, if the test harness has set a fault-sim callback using
** a call to sqlite3_test_control(SQLITE_TESTCTRL_FAULT_INSTALL), then
** each call to sqlite3FaultSim() is relayed to that application-supplied
** callback and the integer return value form the application-supplied
** callback is returned by sqlite3FaultSim().
**
** The integer argument to sqlite3FaultSim() is a code to identify which
** sqlite3FaultSim() instance is being invoked. Each call to sqlite3FaultSim()
** should have a unique code.  To prevent legacy testing applications from
** breaking, the codes should not be changed or reused.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3FaultSim</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iTest</name></decl></parameter>)</parameter_list><block>{<block_content>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xTestCallback</name></name></expr></init>;</function_decl>
  <return>return <expr><ternary><condition><expr><name>xCallback</name></expr> ?</condition><then> <expr><call><name>xCallback</name><argument_list>(<argument><expr><name>iTest</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** Return true if the floating point value is Not a Number (NaN).
**
** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.
** Otherwise, we have our own implementation that works on most systems.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsNaN</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>   <comment type="block">/* The value return */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_HAVE_ISNAN</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_ISNAN</name></expr></cpp:if>
  <decl_stmt><decl><type><name>u64</name></type> <name>y</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>IsNaN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_ISNAN */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_FLOATING_POINT */</comment>

<comment type="block">/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
**
** The value returned will never be negative.  Nor will it ever be greater
** than the actual length of the string.  For very long strings (greater
** than 1GiB) the value returned might be less than the true string length.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Strlen30</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0x3fffffff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the declared type of a column.  Or return zDflt if the column 
** has no declared type.
**
** The column type is an extra string stored after the zero-terminator on
** the column name if and only if the COLFLAG_HASTYPE flag is set.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3ColumnType</name><parameter_list>(<parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zDflt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_HASTYPE</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name><operator>&lt;=</operator><name>SQLITE_N_STDTYPE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>sqlite3StdType</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>zDflt</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Helper function for sqlite3Error() - called rarely.  Broken out into
** a separate routine to avoid unnecessary register saves on entry to
** sqlite3Error().
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type>  <name>sqlite3ErrorFinish</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err_code</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ValueSetNull</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3SystemError</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the current error code to err_code and clear any prior error message.
** Also set iSysErrno (by calling sqlite3System) if the err_code indicates
** that would be appropriate.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Error</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err_code</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>err_code</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>err_code</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorFinish</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The equivalent of sqlite3Error(db, SQLITE_OK).  Clear the error state
** and error message.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ErrorClear</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ValueSetNull</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Load the sqlite3.iSysErrno field if that is an appropriate thing
** to do based on the SQLite error code in rc.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SystemError</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_IOERR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>iSysErrno</name></name> <operator>=</operator> <call><name>sqlite3OsGetLastError</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the most recent error code and error string for the sqlite
** handle "db". The error code is set to "err_code".
**
** If it is not NULL, string zFormat specifies the format of the
** error string.  zFormat and any string tokens that follow it are
** assumed to be encoded in UTF-8.
**
** To clear the most recent error for sqlite handle "db", sqlite3Error
** should be called with err_code set to SQLITE_OK and zFormat set
** to NULL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ErrorWithMsg</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>err_code</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SystemError</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFormat</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add an error message to pParse-&gt;zErrMsg and increment pParse-&gt;nErr.
**
** This function should be used to report any error that occurs while
** compiling an SQL statement (i.e. within sqlite3_prepare()). The
** last thing the sqlite3_prepare() function does is copy the error
** stored by this function into the database handle using sqlite3Error().
** Functions sqlite3Error() or sqlite3ErrorWithMsg() should be used
** during statement execution (sqlite3_step() etc.).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ErrorMsg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>pToplevel</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name><operator>&lt;</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <name>zMsg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If database connection db is currently parsing SQL, then transfer
** error code errCode to that parser if the parser has not already
** encountered some other kind of error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ErrorToParser</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pParse</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>errCode</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>errCode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** The input string must be zero-terminated.  A new zero-terminator
** is added to the dequoted string.
**
** The return value is -1 if no dequoting occurs or the length of the
** dequoted string, exclusive of the zero terminator, if dequoting does
** occur.
**
** 2002-02-14: This routine is extended to remove MS-Access style
** brackets from around identifiers.  For example:  "[a-b-c]" becomes
** "a-b-c".
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Dequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>quote</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3Isquote</name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>quote</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>quote</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3DequoteExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Isquote</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> ?</condition><then> <expr><name>EP_Quoted</name><operator>|</operator><name>EP_DblQuoted</name></expr> </then><else>: <expr><name>EP_Quoted</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the input token p is quoted, try to adjust the token to remove
** the quotes.  This is not always possible:
**
**     "abc"     -&gt;   abc
**     "ab""cd"  -&gt;   (not possible because of the interior "")
**
** Remove the quotes if possible.  This is a optimization.  The overall
** system should still return the correct answer even if this routine
** is always a no-op.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DequoteToken</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3Isquote</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3Isquote</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate a Token object from a string
*/</comment>
<function><type><name>void</name></type> <name>sqlite3TokenInit</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Convenient short-hand */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UpperToLower</name></cpp:macro> <cpp:value>sqlite3UpperToLower</cpp:value></cpp:define>

<comment type="block">/*
** Some systems have stricmp().  Others have strcasecmp().  Because
** there is no consistency, we will define our own.
**
** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
** sqlite3_strnicmp() APIs allow applications and extensions to compare
** the contents of two buffers containing UTF-8 strings in a
** case-independent fashion, using the same definition of "case
** independence" that SQLite uses internally when comparing identifiers.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_stricmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>zRight</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zLeft</name></expr></argument>, <argument><expr><name>zRight</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3StrICmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr>;</expr_stmt>
  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>x</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>UpperToLower</name><index>[<expr><name>c</name></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>UpperToLower</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_strnicmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>zRight</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>N</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>a</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>a</name></expr>]</index></name><operator>==</operator><name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>b</name></expr>]</index></name></expr>)</condition><block>{<block_content> <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name>N</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>a</name></expr>]</index></name> <operator>-</operator> <name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>b</name></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute an 8-bit hash on a string that is insensitive to case differences
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3StrIHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>UpperToLower</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute 10 to the E-th power.  Examples:  E==1 results in 10.
** E==2 results in 100.  E==50 results in 1.0e50.
**
** This routine only works for values of E between 1 and 341.
*/</comment>
<function><type><specifier>static</specifier> <name>LONGDOUBLE_TYPE</name></type> <name>sqlite3Pow10</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>E</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LONGDOUBLE_TYPE</name></type> <name><name>x</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">1.0e+001L</literal></expr>,
    <expr><literal type="number">1.0e+002L</literal></expr>,
    <expr><literal type="number">1.0e+004L</literal></expr>,
    <expr><literal type="number">1.0e+008L</literal></expr>,
    <expr><literal type="number">1.0e+016L</literal></expr>,
    <expr><literal type="number">1.0e+032L</literal></expr>,
    <expr><literal type="number">1.0e+064L</literal></expr>,
    <expr><literal type="number">1.0e+128L</literal></expr>,
    <expr><literal type="number">1.0e+256L</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>r</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>E</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>E</name><operator>&lt;=</operator><literal type="number">307</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>E</name><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>E</name> <operator>&gt;&gt;=</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>E</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>*=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>x</name> <init>= <expr><literal type="number">10.0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>r</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>E</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>E</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>E</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>r</name></expr>;</return> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** The string z[] is an text representation of a real number.
** Convert this string to a double and write it into *pResult.
**
** The string z[] is length bytes in length (bytes, not characters) and
** uses the encoding enc.  The string is not necessarily zero-terminated.
**
** Return TRUE if the result is a valid real number (or integer) and FALSE
** if the string is empty or contains extraneous text.  More specifically
** return
**      1          =&gt;  The input string is a pure integer
**      2 or more  =&gt;  The input has a decimal point or eNNN clause
**      0 or less  =&gt;  The input string is not a valid number
**     -1          =&gt;  Not a valid number, but has a valid prefix which 
**                     includes a decimal point and/or an eNNN clause
**
** Valid numbers are in one of these formats:
**
**    [+-]digits[E[+-]digits]
**    [+-]digits.[digits][E[+-]digits]
**    [+-].digits[E[+-]digits]
**
** Leading and trailing whitespace is ignored for the purpose of determining
** validity.
**
** If some prefix of the input string is a valid number, this routine
** returns FALSE but it still converts the prefix and writes the result
** into *pResult.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4756</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3AtoF</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>incr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
  <comment type="block">/* sign * significand * (10 ^ (esign * exponent)) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* sign of significand */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* significand */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* adjust exponent for shifting decimal point */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>esign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* sign of exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eValid</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True exponent is either not used or is well-formed */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDigit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of digits processed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* 1: pure integer,  2+: fractional  -1 or less: bad UTF16 */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>   <comment type="block">/* Default return value, in case of an error */</comment>
  <if_stmt><if>if<condition>( <expr><name>length</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <name>z</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_UTF16LE</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>SQLITE_UTF16BE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF16LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal><operator>-</operator><name>enc</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>length</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>length</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>-</operator><literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>^</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <operator>(</operator><name>enc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* skip leading spaces */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* get sign of significand */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* copy max significant digits to significand */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt> <expr_stmt><expr><name>nDigit</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>&gt;=</operator><operator>(</operator><operator>(</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* skip non-significant significand digits
      ** (increase exponent by d to shift decimal left) */</comment>
      <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt> <expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>do_atof_calc</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* if decimal point is present */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* copy digits from after decimal to significand
    ** (decrease exponent by d to shift decimal right) */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>s</name><operator>&lt;</operator><operator>(</operator><operator>(</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nDigit</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>do_atof_calc</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* if exponent is present */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>eValid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* This branch is needed to avoid a (harmless) buffer overread.  The 
    ** special comment alerts the mutation tester that the correct answer
    ** is obtained even if the branch is omitted */</comment>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>do_atof_calc</name>;</goto></block_content></block></if></if_stmt>              <comment type="block">/*PREVENTS-HARMLESS-OVERREAD*/</comment>

    <comment type="block">/* get sign of exponent */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>esign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* copy digits to exponent */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <ternary><condition><expr><name>e</name><operator>&lt;</operator><literal type="number">10000</literal></expr> ?</condition><then> <expr><operator>(</operator><name>e</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator><operator>)</operator></expr> </then><else>: <expr><literal type="number">10000</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>eValid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* skip trailing spaces */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt></block_content></block></while>

<label><name>do_atof_calc</name>:</label>
  <comment type="block">/* adjust exponent by d, and update sign */</comment>
  <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>e</name><operator>*</operator><name>esign</name><operator>)</operator> <operator>+</operator> <name>d</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><name>esign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>esign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>s</name><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <comment type="block">/* In the IEEE 754 standard, zero is signed. */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>sign</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Attempt to reduce exponent.
    **
    ** Branches that are not required for the correct answer but which only
    ** help to obtain the correct answer faster are marked with special
    ** comments, as a hint to the mutation tester.
    */</comment>
    <while>while<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>                                       <comment type="block">/*OPTIMIZATION-IF-TRUE*/</comment>
      <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>s</name><operator>&gt;=</operator><operator>(</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>             <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
        <expr_stmt><expr><name>s</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>s</name><operator>%</operator><literal type="number">10</literal><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>                           <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
        <expr_stmt><expr><name>s</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>e</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* adjust the sign of significand */</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <ternary><condition><expr><name>sign</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>s</name></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>                                         <comment type="block">/*OPTIMIZATION-IF-TRUE*/</comment>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>s</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* attempt to handle extremely small/large numbers better */</comment>
      <if_stmt><if>if<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">307</literal></expr> )</condition><block>{<block_content>                                      <comment type="block">/*OPTIMIZATION-IF-TRUE*/</comment>
        <if_stmt><if>if<condition>( <expr><name>e</name><operator>&lt;</operator><literal type="number">342</literal></expr> )</condition><block>{<block_content>                                    <comment type="block">/*OPTIMIZATION-IF-TRUE*/</comment>
          <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>scale</name> <init>= <expr><call><name>sqlite3Pow10</name><argument_list>(<argument><expr><name>e</name><operator>-</operator><literal type="number">308</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>/=</operator> <literal type="number">1.0e+308</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>*=</operator> <literal type="number">1.0e+308</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>e</name><operator>&gt;=</operator><literal type="number">342</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal><operator>*</operator><name>s</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFINITY</name></cpp:ifdef>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>INFINITY</name><operator>*</operator><name>s</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1e308</literal><operator>*</operator><literal type="number">1e308</literal><operator>*</operator><name>s</name></expr>;</expr_stmt>  <comment type="block">/* Infinity */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>scale</name> <init>= <expr><call><name>sqlite3Pow10</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* store the result */</comment>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

  <comment type="block">/* return true if number and no extra non-whitespace chracters after */</comment>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name>nDigit</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eValid</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>eType</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eType</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>eValid</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nDigit</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>!</operator><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_FLOATING_POINT */</comment>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>default</name> <name>:</name> <name>4756</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Render an signed 64-bit integer as text.  Store the result in zOut[].
**
** The caller must ensure that zOut[] is at least 21 bytes in size.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Int64ToText</name><parameter_list>(<parameter><decl><type><name>i64</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTemp</name><index>[<expr><literal type="number">22</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>v</name><operator>==</operator><name>SMALLEST_INT64</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">63</literal></expr> </then><else>: <expr><operator>(</operator><name>u64</name><operator>)</operator><operator>-</operator><name>v</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zTemp</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>x</name><operator>%</operator><literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>x</name></expr> )</condition>;</do>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zTemp</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare the 19-character string zNum against the text representation
** value 2^63:  9223372036854775808.  Return negative, zero, or positive
** if zNum is less than, equal to, or greater than the string.
** Note that zNum must contain exactly 19 characters.
**
** Unlike memcmp() this routine is guaranteed to return the difference
** in the values of the last digit if the only difference is in the
** last digit.  So, for example,
**
**      compare2pow63("9223372036854775800", 1)
**
** will return -8.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>compare2pow63</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>incr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                    <comment type="block">/* 012345678901234567 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pow63</name> <init>= <expr><literal type="string">"922337203685477580"</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">18</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name><name>zNum</name><index>[<expr><name>i</name><operator>*</operator><name>incr</name></expr>]</index></name><operator>-</operator><name><name>pow63</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>*</operator><literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zNum</name><index>[<expr><literal type="number">18</literal><operator>*</operator><name>incr</name></expr>]</index></name> <operator>-</operator> <literal type="char">'8'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><operator>(</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert zNum to a 64-bit signed integer.  zNum must be decimal. This
** routine does *not* accept hexadecimal notation.
**
** Returns:
**
**    -1    Not even a prefix of the input text looks like an integer
**     0    Successful transformation.  Fits in a 64-bit signed integer.
**     1    Excess non-space text after the integer value
**     2    Integer too large for a 64-bit signed integer or is malformed
**     3    Special case of 9223372036854775808
**
** length is the number of bytes in the string (bytes, not characters).
** The string is not necessarily zero-terminated.  The encoding is
** given by enc.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Atoi64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>incr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* assume positive */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nonNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True if input contains UTF16 with high byte non-zero */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>          <comment type="block">/* Baseline return code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><name>zNum</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_UTF16LE</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>SQLITE_UTF16BE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal><operator>-</operator><name>enc</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>length</name> <operator>&amp;&amp;</operator> <name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><name>nonNum</name> <operator>=</operator> <name>i</name><operator>&lt;</operator><name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name><operator>^</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNum</name> <operator>+=</operator> <operator>(</operator><name>enc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <while>while<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zNum</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zNum</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>zNum</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>zNum</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* Skip leading zeros. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>incr</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">18</literal><operator>*</operator><name>incr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">19</literal><operator>*</operator><name>incr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">20</literal><operator>*</operator><name>incr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>u</name><operator>&gt;</operator><name>LARGEST_INT64</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This test and assignment is needed only to suppress UB warnings
    ** from clang and -fsanitize=undefined.  This test and assignment make
    ** the code a little larger and slower, and no harm comes from omitting
    ** them, but we must appaise the undefined-behavior pharisees. */</comment>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><name>SMALLEST_INT64</name></expr> </then><else>: <expr><name>LARGEST_INT64</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>neg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>i64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zStart</name><operator>==</operator><name>zNum</name></expr> )</condition><block>{<block_content>    <comment type="block">/* No digits */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nonNum</name></expr> )</condition><block>{<block_content>            <comment type="block">/* UTF16 with high-order bytes non-zero */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>     <comment type="block">/* Extra bytes at the end */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
    <do>do<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>jj</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>          <comment type="block">/* Extra non-space text after the integer */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>jj</name> <operator>+=</operator> <name>incr</name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>jj</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">19</literal><operator>*</operator><name>incr</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Less than 19 digits, so we know that it fits in 64 bits */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <ternary><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">19</literal><operator>*</operator><name>incr</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>compare2pow63</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* zNum is less than 9223372036854775808 so it fits */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><name>SMALLEST_INT64</name></expr> </then><else>: <expr><name>LARGEST_INT64</name></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* zNum is greater than 9223372036854775808 so it overflows */</comment>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* zNum is exactly 9223372036854775808.  Fits if negative.  The
        ** special case 2 overflow if positive */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal><operator>==</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Transform a UTF-8 integer literal, in either decimal or hexadecimal,
** into a 64-bit signed integer.  This routine accepts hexadecimal literals,
** whereas sqlite3Atoi64() does not.
**
** Returns:
**
**     0    Successful transformation.  Fits in a 64-bit signed integer.
**     1    Excess text after the integer value
**     2    Integer too large for a 64-bit signed integer or is malformed
**     3    Special case of 9223372036854775808
*/</comment>
<function><type><name>int</name></type> <name>sqlite3DecOrHexToI64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_HEX_INTEGER</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name><operator>-</operator><name>i</name><operator>&lt;=</operator><literal type="number">16</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_HEX_INTEGER */</comment>
  <block>{<block_content>
    <return>return <expr><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If zNum represents an integer that will fit in 32-bits, then set
** *pValue to that integer and return true.  Otherwise return false.
**
** This routine accepts both decimal and hexadecimal notation for integers.
**
** Any non-numeric characters that following zNum are ignored.
** This is different from sqlite3Atoi64() which requires the
** input number to be zero-terminated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetInt32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_HEX_INTEGER</name></cpp:ifndef>
  <if type="elseif">else if<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zNum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>zNum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal><operator>)</operator>
        <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zNum</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u</name><operator>&amp;</operator><literal type="number">0x80000000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">11</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* The longest decimal representation of a 32 bit integer is 10 digits:
  **
  **             1234567890
  **     2^31 -&gt; 2147483648
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>v</name><operator>-</operator><name>neg</name><operator>==</operator><literal type="number">2147483647</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>-</operator><name>neg</name><operator>&gt;</operator><literal type="number">2147483647</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>neg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 32-bit integer value extracted from a string.  If the
** string is not an integer, just return 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Atoi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to convert z into an unsigned 32-bit integer.  Return true on
** success and false if there is an error.
**
** Only decimal notation is accepted.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetUInt32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pI</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;</operator><literal type="number">4294967296LL</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pI</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The variable-length integer encoding is as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**         C = xxxxxxxx    8 bits of data
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** 28 bits - BBBA
** 35 bits - BBBBA
** 42 bits - BBBBBA
** 49 bits - BBBBBBA
** 56 bits - BBBBBBBA
** 64 bits - BBBBBBBBC
*/</comment>

<comment type="block">/*
** Write a 64-bit variable-length integer to memory starting at p[0].
** The length of data write will be between 1 and 9 bytes.  The number
** of bytes written is returned.
**
** A variable-length integer consists of the lower 7 bits of each byte
** for all bytes that have the 8th bit set and one byte with the 8th
** bit clear.  Except, if we get to the 9th byte, it stores the full
** 8 bits and is the last byte.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_NOINLINE</name></type> <name>putVarint64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>buf</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">0xff000000</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">7</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">9</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>    
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3PutVarint</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x7f</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x3fff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator><operator>|</operator><literal type="number">0x80</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>putVarint64</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Bitmasks used by sqlite3GetVarint().  These precomputed constants
** are defined here rather than simply putting the constant expressions
** inline in order to work around bugs in the RVT compiler.
**
** SLOT_2_0     A mask for  (0x7f&lt;&lt;14) | 0x7f
**
** SLOT_4_2_0   A mask for  (0x7f&lt;&lt;28) | SLOT_2_0
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT_2_0</name></cpp:macro>     <cpp:value>0x001fc07f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT_4_2_0</name></cpp:macro>   <cpp:value>0xf01fc07f</cpp:value></cpp:define>


<comment type="block">/*
** Read a 64-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read.  The value is stored in *v.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3GetVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>,<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>signed</name> <name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>signed</name> <name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Verify that constants are precomputed correctly */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SLOT_2_0</name> <operator>==</operator> <operator>(</operator><operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SLOT_4_2_0</name> <operator>==</operator> <operator>(</operator><operator>(</operator><literal type="number">0xfU</literal><operator>&lt;&lt;</operator><literal type="number">28</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;14 | p2 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* CSE1 from below */</comment>
  <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1&lt;&lt;14 | p3 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <comment type="block">/* moved CSE1 up */</comment>
    <comment type="block">/* a &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* a: p0&lt;&lt;14 | p2 (masked) */</comment>
  <comment type="block">/* b: p1&lt;&lt;14 | p3 (unmasked) */</comment>
  <comment type="block">/* 1:save off p0&lt;&lt;21 | p1&lt;&lt;14 | p2&lt;&lt;7 | p3 (masked) */</comment>
  <comment type="block">/* moved CSE1 up */</comment>
  <comment type="block">/* a &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
  <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
  <comment type="block">/* s: p0&lt;&lt;14 | p2 (masked) */</comment>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;28 | p2&lt;&lt;14 | p4 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* we can skip these cause they were (effectively) done above
    ** while calculating s */</comment>
    <comment type="block">/* a &amp;= (0x7f&lt;&lt;28)|(0x7f&lt;&lt;14)|(0x7f); */</comment>
    <comment type="block">/* b &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">18</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 2:save off p0&lt;&lt;21 | p1&lt;&lt;14 | p2&lt;&lt;7 | p3 (masked) */</comment>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
  <comment type="block">/* s: p0&lt;&lt;21 | p1&lt;&lt;14 | p2&lt;&lt;7 | p3 (masked) */</comment>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1&lt;&lt;28 | p3&lt;&lt;14 | p5 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* we can skip this cause it was (effectively) done above in calc'ing s */</comment>
    <comment type="block">/* b &amp;= (0x7f&lt;&lt;28)|(0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">18</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p2&lt;&lt;28 | p4&lt;&lt;14 | p6 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">11</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">7</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* CSE2 from below */</comment>
  <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p3&lt;&lt;28 | p5&lt;&lt;14 | p7 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <comment type="block">/* moved CSE2 up */</comment>
    <comment type="block">/* a &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">8</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">15</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p4&lt;&lt;29 | p6&lt;&lt;15 | p8 (unmasked) */</comment>

  <comment type="block">/* moved CSE2 up */</comment>
  <comment type="block">/* a &amp;= (0x7f&lt;&lt;29)|(0x7f&lt;&lt;15)|(0xff); */</comment>
  <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&lt;&lt;</operator><literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&gt;&gt;</operator><literal type="number">3</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>

  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read a 32-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read.  The value is stored in *v.
**
** If the varint stored in p[0] is larger than can fit in a 32-bit unsigned
** integer, then set *v to 0xffffffff.
**
** A MACRO version, getVarint32, is provided which inlines the 
** single-byte case.  All code should use the MACRO version as 
** this function assumes the single-byte case has already been handled.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3GetVarint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

  <comment type="block">/* The 1-byte case.  Overwhelmingly the most common.  Handled inline
  ** by the getVarin32() macro */</comment>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0 (unmasked) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>getVarint32</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 0 and 127 */</comment>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* The 2-byte case */</comment>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 128 and 16383 */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The 3-byte case */</comment>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;14 | p2 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 16384 and 2097151 */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator><operator>|</operator><operator>(</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* A 32-bit varint is used to store size information in btrees.
  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.
  ** A 3-byte varint is sufficient, for example, to record the size
  ** of a 1048569-byte BLOB or string.
  **
  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very
  ** rare larger cases can be handled by the slower 64-bit varint
  ** routine.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>v64</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>v64</name> <operator>&amp;</operator> <name>SQLITE_MAX_U32</name><operator>)</operator><operator>!=</operator><name>v64</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>v64</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>n</name></expr>;</return>
  </block_content>}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* For following code (kept for historical record only) shows an
  ** unrolling for the 3- and 4-byte varint cases.  This code is
  ** slightly faster, but it is also larger and much harder to test.
  */</comment>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1&lt;&lt;14 | p3 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 2097152 and 268435455 */</comment>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator><operator>|</operator><operator>(</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator><operator>|</operator><operator>(</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;28 | p2&lt;&lt;14 | p4 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values  between 268435456 and 34359738367 */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We can only reach this point when reading a corrupt database
  ** file.  In that case we are not in any hurry.  Use the (relatively
  ** slow) general-purpose sqlite3GetVarint() routine to extract the
  ** value. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>v64</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>v64</name></expr>;</expr_stmt>
    <return>return <expr><name>n</name></expr>;</return>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes that will be needed to store the given
** 64-bit integer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VarintLen</name><parameter_list>(<parameter><decl><type><name>u64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></for>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Read or write a four-byte big-endian integer value.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3Get4byte</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>x</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>_byteswap_ulong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3Put4byte</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name> <init>= <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name> <init>= <expr><call><name>_byteswap_ulong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<comment type="block">/*
** Translate a single byte of Hex into an integer.
** This routine only works if h really is a valid hexadecimal
** character:  0..9a..fA..F
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3HexToInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>  <operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'f'</literal><operator>)</operator> <operator>||</operator>  <operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'F'</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ASCII</name></cpp:ifdef>
  <expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">9</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EBCDIC</name></cpp:ifdef>
  <expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">9</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><operator>~</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>h</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_BLOB_LITERAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Convert a BLOB literal of the form "x'hhhhhh'" into its binary
** value.  Return a pointer to its binary value.  Space to hold the
** binary value has been obtained from malloc and must be freed by
** the calling routine.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3HexToBlob</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zBlob</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBlob</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>zBlob</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>|</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zBlob</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zBlob</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_BLOB_LITERAL */</comment>

<comment type="block">/*
** Log an error that is an API call on a connection pointer that should
** not have been used.  The "type" of connection pointer is given as the
** argument.  The zType is a word like "NULL" or "closed" or "invalid".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>logBadConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, 
     <argument><expr><literal type="string">"API call with %s database connection pointer"</literal></expr></argument>,
     <argument><expr><name>zType</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to make sure we have a valid db pointer.  This test is not
** foolproof but it does provide some measure of protection against
** misuse of the interface such as passing in db pointers that are
** NULL or which have been previously closed.  If this routine returns
** 1 it means that the db pointer is valid and 0 if it should not be
** dereferenced for any reason.  The calling function should invoke
** SQLITE_MISUSE immediately.
**
** sqlite3SafetyCheckOk() requires that the db pointer be valid for
** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to
** open properly and is not fit for general use but which can be
** used as an argument to sqlite3_errmsg() or sqlite3_close().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SafetyCheckOk</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>eOpenState</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>logBadConnection</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>eOpenState</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eOpenState</name><operator>!=</operator><name>SQLITE_STATE_OPEN</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>logBadConnection</name><argument_list>(<argument><expr><literal type="string">"unopened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3SafetyCheckSickOrOk</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>eOpenState</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>eOpenState</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eOpenState</name><operator>!=</operator><name>SQLITE_STATE_SICK</name> <operator>&amp;&amp;</operator>
      <name>eOpenState</name><operator>!=</operator><name>SQLITE_STATE_OPEN</name> <operator>&amp;&amp;</operator>
      <name>eOpenState</name><operator>!=</operator><name>SQLITE_STATE_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>logBadConnection</name><argument_list>(<argument><expr><literal type="string">"invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to add, substract, or multiply the 64-bit signed value iB against
** the other 64-bit signed integer at *pA and store the result in *pA.
** Return 0 on success.  Or if the operation would have resulted in an
** overflow, leave *pA unchanged and return 1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3AddInt64</name><parameter_list>(<parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iB</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">5004000</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><call><name>__builtin_add_overflow</name><argument_list>(<argument><expr><operator>*</operator><name>pA</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name> <init>= <expr><operator>*</operator><name>pA</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iB</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iB</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LARGEST_INT64</name> <operator>-</operator> <name>iA</name> <operator>==</operator> <name>iB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LARGEST_INT64</name> <operator>-</operator> <name>iA</name> <operator>==</operator> <name>iB</name> <operator>-</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LARGEST_INT64</name> <operator>-</operator> <name>iA</name> <operator>&lt;</operator> <name>iB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>-</operator><operator>(</operator><name>iA</name> <operator>+</operator> <name>LARGEST_INT64</name><operator>)</operator> <operator>==</operator> <name>iB</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>-</operator><operator>(</operator><name>iA</name> <operator>+</operator> <name>LARGEST_INT64</name><operator>)</operator> <operator>==</operator> <name>iB</name> <operator>+</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>iA</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>-</operator><operator>(</operator><name>iA</name> <operator>+</operator> <name>LARGEST_INT64</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name>iB</name> <operator>+</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>+=</operator> <name>iB</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3SubInt64</name><parameter_list>(<parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iB</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">5004000</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><call><name>__builtin_sub_overflow</name><argument_list>(<argument><expr><operator>*</operator><name>pA</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iB</name><operator>==</operator><name>SMALLEST_INT64</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iB</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>pA</name><operator>)</operator><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>pA</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pA</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>-=</operator> <name>iB</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><operator>-</operator><name>iB</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3MulInt64</name><parameter_list>(<parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iB</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">5004000</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><call><name>__builtin_mul_overflow</name><argument_list>(<argument><expr><operator>*</operator><name>pA</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name> <init>= <expr><operator>*</operator><name>pA</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&gt;</operator><name>LARGEST_INT64</name><operator>/</operator><name>iB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&lt;</operator><name>SMALLEST_INT64</name><operator>/</operator><name>iB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iB</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&lt;</operator><name>SMALLEST_INT64</name><operator>/</operator><name>iA</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iB</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>-</operator><name>iA</name><operator>&gt;</operator><name>LARGEST_INT64</name><operator>/</operator><operator>-</operator><name>iB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>=</operator> <name>iA</name><operator>*</operator><name>iB</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Compute the absolute value of a 32-bit signed integer, of possible.  Or 
** if the integer has a value of -2147483648, return +2147483647
*/</comment>
<function><type><name>int</name></type> <name>sqlite3AbsInt32</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0x80000000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x7fffffff</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>-</operator><name>x</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifdef>
<comment type="block">/*
** If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the database
** filename in zBaseFilename is a URI with the "8_3_names=1" parameter and
** if filename in z[] has a suffix (a.k.a. "extension") that is longer than
** three characters, then shorten the suffix on z[] to be the last three
** characters of the original suffix.
**
** If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then always
** do the suffix shortening regardless of URI parameter.
**
** Examples:
**
**     test.db-journal    =&gt;   test.nal
**     test.db-wal        =&gt;   test.wal
**     test.db-shm        =&gt;   test.shm
**     test.db-mj7f3319fa =&gt;   test.9fa
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FileSuffix3</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBaseFilename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_8_3_NAMES</name><operator>&lt;</operator><literal type="number">2</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name>zBaseFilename</name></expr></argument>, <argument><expr><literal type="string">"8_3_names"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>sz</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>sz</name><operator>&gt;</operator><name>i</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>sz</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* 
** Find (an approximate) sum of two LogEst values.  This computation is
** not a simple "+" operator because LogEst is stored as a logarithmic
** value.
** 
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3LogEstAdd</name><parameter_list>(<parameter><decl><type><name>LogEst</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>LogEst</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[]</index></name> <init>= <expr><block>{
     <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>,                         <comment type="block">/* 0,1 */</comment>
      <expr><literal type="number">9</literal></expr>, <expr><literal type="number">9</literal></expr>,                          <comment type="block">/* 2,3 */</comment>
      <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>,                          <comment type="block">/* 4,5 */</comment>
      <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>,                       <comment type="block">/* 6,7,8 */</comment>
      <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,                       <comment type="block">/* 9,10,11 */</comment>
      <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>,                       <comment type="block">/* 12-14 */</comment>
      <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>,                    <comment type="block">/* 15-18 */</comment>
      <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>,              <comment type="block">/* 19-24 */</comment>
      <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>,           <comment type="block">/* 25-31 */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;=</operator><name>b</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;</operator><name>b</name><operator>+</operator><literal type="number">49</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;</operator><name>b</name><operator>+</operator><literal type="number">31</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>a</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>a</name><operator>+</operator><name><name>x</name><index>[<expr><name>a</name><operator>-</operator><name>b</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>b</name><operator>&gt;</operator><name>a</name><operator>+</operator><literal type="number">49</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>b</name><operator>&gt;</operator><name>a</name><operator>+</operator><literal type="number">31</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>b</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>b</name><operator>+</operator><name><name>x</name><index>[<expr><name>b</name><operator>-</operator><name>a</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert an integer into a LogEst.  In other words, compute an
** approximation for 10*log2(x).
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3LogEst</name><parameter_list>(<parameter><decl><type><name>u64</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>LogEst</name></type> <name><name>a</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>y</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>  <expr_stmt><expr><name>y</name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">5004000</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">60</literal> <operator>-</operator> <call><name>__builtin_clzll</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>y</name> <operator>+=</operator> <name>i</name><operator>*</operator><literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <name>i</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <while>while<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">255</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>y</name> <operator>+=</operator> <literal type="number">40</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></while>  <comment type="block">/*OPTIMIZATION-IF-TRUE*/</comment>
    <while>while<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">15</literal></expr> )</condition><block>{<block_content>  <expr_stmt><expr><name>y</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>a</name><index>[<expr><name>x</name><operator>&amp;</operator><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <name>y</name> <operator>-</operator> <literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert a double into a LogEst
** In other words, compute an approximation for 10*log2(x).
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3LogEstFromDouble</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">2000000000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>a</name><operator>&gt;&gt;</operator><literal type="number">52</literal><operator>)</operator> <operator>-</operator> <literal type="number">1022</literal></expr>;</expr_stmt>
  <return>return <expr><name>e</name><operator>*</operator><literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert a LogEst into an integer.
*/</comment>
<function><type><name>u64</name></type> <name>sqlite3LogEstToInt</name><parameter_list>(<parameter><decl><type><name>LogEst</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>x</name><operator>%</operator><literal type="number">10</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">5</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">60</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>u64</name><operator>)</operator><name>LARGEST_INT64</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><name>x</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><operator>(</operator><name>n</name><operator>+</operator><literal type="number">8</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><name>x</name><operator>-</operator><literal type="number">3</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>n</name><operator>+</operator><literal type="number">8</literal><operator>)</operator><operator>&gt;&gt;</operator><operator>(</operator><literal type="number">3</literal><operator>-</operator><name>x</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a new name/number pair to a VList.  This might require that the
** VList object be reallocated, so return the new VList.  If an OOM
** error occurs, the original VList returned and the
** db-&gt;mallocFailed flag is set.
**
** A VList is really just an array of integers.  To destroy a VList,
** simply pass it to sqlite3DbFree().
**
** The first integer is the number of integers allocated for the whole
** VList.  The second integer is the number of integers actually used.
** Each name/number pair is encoded by subsequent groups of 3 or more
** integers.
**
** Each name/number pair starts with two integers which are the numeric
** value for the pair and the size of the name/number pair, respectively.
** The text name overlays one or more following integers.  The text name
** is always zero-terminated.
**
** Conceptually:
**
**    struct VList {
**      int nAlloc;   // Number of allocated slots 
**      int nUsed;    // Number of used slots 
**      struct VListEntry {
**        int iValue;    // Value for this entry
**        int nSlot;     // Slots used by this entry
**        // ... variable name goes here
**      } a[0];
**    }
**
** During code generation, pointers to the variable names within the
** VList are taken.  When that happens, nAlloc is set to zero as an 
** indication that the VList may never again be enlarged, since the
** accompanying realloc() would invalidate the pointers.
*/</comment>
<function><type><name>VList</name> <modifier>*</modifier></type><name>sqlite3VListAdd</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* The database connection used for malloc() */</comment>
  <parameter><decl><type><name>VList</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,            <comment type="block">/* The input VList.  Might be NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,     <comment type="block">/* Name of symbol to add */</comment>
  <parameter><decl><type><name>int</name></type> <name>nName</name></decl></parameter>,             <comment type="block">/* Bytes of text in zName */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>               <comment type="block">/* Value to associate with zName */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nInt</name></decl>;</decl_stmt>              <comment type="block">/* number of sizeof(int) objects needed for zName */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>               <comment type="block">/* Pointer to where zName will be stored */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Index in pIn[] where zName is stored */</comment>

  <expr_stmt><expr><name>nInt</name> <operator>=</operator> <name>nName</name><operator>/</operator><literal type="number">4</literal> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Verify ok to add new elements */</comment>
  <if_stmt><if>if<condition>( <expr><name>pIn</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><name>nInt</name> <operator>&gt;</operator> <name><name>pIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Enlarge the allocation */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pIn</name></expr> ?</condition><then> <expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>nInt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VList</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pIn</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIn</name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nAlloc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name><operator>+</operator><name>nInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;=</operator><name><name>pIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>nName</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>pIn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the name of a variable in the given VList that
** has the value iVal.  Or return a NULL if there is no such variable in
** the list
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3VListNumToName</name><parameter_list>(<parameter><decl><type><name>VList</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mx</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>mx</name> <operator>=</operator> <name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>iVal</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>pIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>mx</name></expr> )</condition>;</do>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of the variable named zName, if it is in VList.
** or return 0 if there is no such variable.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VListNameToNum</name><parameter_list>(<parameter><decl><type><name>VList</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mx</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>mx</name> <operator>=</operator> <name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><name>nName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>nName</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>pIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>mx</name></expr> )</condition>;</do>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** High-resolution hardware timer used for debugging and testing only.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_PERFORMANCE_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"hwtime.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
