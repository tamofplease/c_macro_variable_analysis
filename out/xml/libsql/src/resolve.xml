<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/resolve.c"><comment type="block">/*
** 2008 August 18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains routines used for walking the parser tree and
** resolve all identifiers by associating them with a particular
** table and column.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Magic table number to mean the EXCLUDED table in an UPSERT statement.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXCLUDED_TABLE_NUMBER</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
** Walk the expression tree pExpr and increase the aggregate function
** depth (the Expr.op2 field) by N on every TK_AGG_FUNCTION node.
** This needs to occur when copying a TK_AGG_FUNCTION node from an
** outer query into an inner subquery.
**
** incrAggFunctionDepth(pExpr,n) is the main routine.  incrAggDepth(..)
** is a helper function - a callback for the tree walker.
**
** See also the sqlite3WindowExtraAggFuncDepth() routine in window.c
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>incrAggDepth</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>+=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>incrAggFunctionDepth</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>incrAggDepth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Turn the pExpr expression into an alias for the iCol-th column of the
** result set in pEList.
**
** If the reference is followed by a COLLATE operator, then make sure
** the COLLATE operator is preserved.  For example:
**
**     SELECT a+b, c+d FROM t1 ORDER BY 1 COLLATE nocase;
**
** Should be transformed into:
**
**     SELECT a+b, c+d FROM t1 ORDER BY (a+b) COLLATE nocase;
**
** The nSubquery parameter specifies how many levels of subquery the
** alias is removed from the original expression.  The usual value is
** zero but it might be more if the alias is contained within a subquery
** of the original expression.  The Expr.op2 field of TK_AGG_FUNCTION
** structures must be increased by the nSubquery amount.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveAlias</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,      <comment type="block">/* A result set */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,              <comment type="block">/* A column in the result set.  0..pEList-&gt;nExpr-1 */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,           <comment type="block">/* Transform this into an alias to the result set */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSubquery</name></decl></parameter>          <comment type="block">/* Number of subqueries that the label is moving */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOrig</name></decl>;</decl_stmt>           <comment type="block">/* The iCol-th column of the result set */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>            <comment type="block">/* Copy of pOrig */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database connection */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrig</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrig</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name></type> <name>temp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>incrAggFunctionDepth</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>, <argument><expr><name>nSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDeferredDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Subqueries stores the original database, table and column names for their
** result sets in ExprList.a[].zSpan, in the form "DATABASE.TABLE.COLUMN".
** Check to see if the zSpan given to this routine matches the zDb, zTab,
** and zCol.  If any of zDb, zTab, and zCol are NULL then those fields will
** match anything.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MatchEName</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpan</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name><operator>!=</operator><name>ENAME_TAB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSpan</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSpan</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zDb</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSpan</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zTab</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSpan</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zTab</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSpan</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCol</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zSpan</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the double-quoted string  mis-feature should be supported.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>areDoubleQuotedStringsEnabled</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pTopNC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Always support for legacy schemas */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTopNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsDDL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Currently parsing a DDL statement */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DqsDML</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DqsDDL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Currently parsing a DML statement */</comment>
    <return>return <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DqsDML</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The argument is guaranteed to be a non-NULL Expr node of type TK_COLUMN.
** return the appropriate colUsed mask.
*/</comment>
<function><type><name>Bitmask</name></type> <name>sqlite3ExprColUsed</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pExTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExTab</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pExTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>pExTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><name>ALLBITS</name></expr> </then><else>: <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name><name>pExTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><name>BMS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>BMS</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>n</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a new expression term for the column specified by pMatch and
** iColumn.  Append this new expression term to the FULL JOIN Match set
** in *ppList.  Create a new *ppList if this is the first term in the
** set.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>extendFJMatch</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppList</name></decl></parameter>,      <comment type="block">/* ExprList to extend */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pMatch</name></decl></parameter>,        <comment type="block">/* Source table containing the column */</comment>
  <parameter><decl><type><name>i16</name></type> <name>iColumn</name></decl></parameter>             <comment type="block">/* The column number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pMatch</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>pMatch</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMatch</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>*</operator><name>ppList</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up
** that name in the set of source tables in pSrcList and make the pExpr 
** expression node refer back to that source column.  The following changes
** are made to pExpr:
**
**    pExpr-&gt;iDb           Set the index in db-&gt;aDb[] of the database X
**                         (even if X is implied).
**    pExpr-&gt;iTable        Set to the cursor number for the table obtained
**                         from pSrcList.
**    pExpr-&gt;y.pTab        Points to the Table structure of X.Y (even if
**                         X and/or Y are implied.)
**    pExpr-&gt;iColumn       Set to the column number within the table.
**    pExpr-&gt;op            Set to TK_COLUMN.
**    pExpr-&gt;pLeft         Any expression this points to is deleted
**    pExpr-&gt;pRight        Any expression this points to is deleted.
**
** The zDb variable is the name of the database (the "X").  This value may be
** NULL meaning that name is of the form Y.Z or Z.  Any available database
** can be used.  The zTable variable is the name of the table (the "Y").  This
** value can be NULL if zDb is also NULL.  If zTable is NULL it
** means that the form of the name is Z and that columns from any table
** can be used.
**
** If the name cannot be resolved unambiguously, leave an error message
** in pParse and return WRC_Abort.  Return WRC_Prune on success.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lookupName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,     <comment type="block">/* Name of the database containing table, or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,    <comment type="block">/* Name of table containing column, or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>,    <comment type="block">/* Name of the column. */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,    <comment type="block">/* The name context used to resolve the name */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>          <comment type="block">/* Make this EXPR node point to the selected column */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                         <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Number of matching column names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cntTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of matching table names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSubquery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* How many levels of subquery */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>                   <comment type="block">/* Use for looping over pSrcList items */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* The matching pSrcList item */</comment>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pTopNC</name> <init>= <expr><name>pNC</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* First namecontext in the list */</comment>
  <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Schema of the expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eNewExprOp</name> <init>= <expr><name>TK_COLUMN</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* New value for pExpr-&gt;op on success */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Table holding the row */</comment>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>                     <comment type="block">/* A column of pTab */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pFJMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Matches for FULL JOIN .. USING */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* the name context cannot be NULL. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* The Z in X.Y.Z cannot be NULL */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the node to no-match */</comment>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Translate the schema name in zDb into a pointer to the corresponding
  ** schema.  If not found, pSchema will remain NULL and nothing will match
  ** resulting in an appropriate error message toward the end of this routine
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zDb</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_PartIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_IsCheck</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Silently ignore database qualifiers inside CHECK constraints and
      ** partial indices.  Do not raise errors because that might break
      ** legacy and because it does not hurt anything to just ignore the
      ** database name. */</comment>
      <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>,<argument><expr><name>zDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This branch is taken when the main database has been renamed
        ** using SQLITE_DBCONFIG_MAINDBNAME. */</comment>
        <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Start at the inner-most context and move outward until a match is found */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name> <operator>&amp;&amp;</operator> <name>cnt</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>pSrcList</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pSrcList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>hCol</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name> <operator>==</operator> <call><name>IsNestedFrom</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* In this case, pItem is a subquery that has been formed from a
          ** parenthesized subset of the FROM clause terms.  Example:
          **   .... FROM t1 LEFT JOIN (t2 RIGHT JOIN t3 USING(x)) USING(y) ...
          **                          \_________________________/
          **             This pItem -------------^
          */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3MatchEName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal>
               <operator>||</operator> <call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>
              )</condition><block>{<block_content>
                <comment type="block">/* Two or more tables have the same column name which is
                ** not joined by USING.  This is an error.  Signal as much
                ** by clearing pFJMatch and letting cnt go above 1. */</comment>
                <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFJMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pFJMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else
              if<condition>( <expr><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <comment type="block">/* An INNER or LEFT JOIN.  Use the left-most table */</comment>
                <continue>continue;</continue>
              </block_content>}</block></if><if type="elseif">else
              if<condition>( <expr><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <comment type="block">/* A RIGHT JOIN.  Use the right-most table */</comment>
                <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFJMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pFJMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <comment type="block">/* For a FULL JOIN, we must construct a coalesce() func */</comment>
                <expr_stmt><expr><call><name>extendFJMatch</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFJMatch</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>cntTab</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pItem</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bUsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bUsingTerm</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>hit</name> <operator>||</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTabName</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>zDb</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>!=</operator><name>pSchema</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>pSchema</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>,<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zTabName</name> <operator>=</operator> <ternary><condition><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> ?</condition><then> <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTabName</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>hCol</name> <operator>=</operator> <call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name><operator>==</operator><name>hCol</name>
           <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal>
               <operator>||</operator> <call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>
              )</condition><block>{<block_content>
                <comment type="block">/* Two or more tables have the same column name which is
                ** not joined by USING.  This is an error.  Signal as much
                ** by clearing pFJMatch and letting cnt go above 1. */</comment>
                <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFJMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pFJMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else
              if<condition>( <expr><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <comment type="block">/* An INNER or LEFT JOIN.  Use the left-most table */</comment>
                <continue>continue;</continue>
              </block_content>}</block></if><if type="elseif">else
              if<condition>( <expr><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <comment type="block">/* A RIGHT JOIN.  Use the right-most table */</comment>
                <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFJMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pFJMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <comment type="block">/* For a FULL JOIN, we must construct a coalesce() func */</comment>
                <expr_stmt><expr><call><name>extendFJMatch</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFJMatch</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pItem</name></expr>;</expr_stmt>
            <comment type="block">/* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */</comment>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <ternary><condition><expr><name>j</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>i16</name><operator>)</operator><name>j</name></expr></else></ternary></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3SrcItemColumnUsed</name><argument_list>(<argument><expr><name>pItem</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>cnt</name> <operator>&amp;&amp;</operator> <call><name>VisibleRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>cntTab</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pItem</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pMatch</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pMatch</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>pMatch</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMatch</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> <comment type="block">/* if( pSrcList ) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_UPSERT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* If we have not already resolved the name, then maybe 
    ** it is a new.* or old.* trigger argument reference.  Or
    ** maybe it is an excluded.* from an upsert.  Or maybe it is
    ** a reference in the RETURNING clause to a table being modified.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>eTriggerOp</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_DELETE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UPDATE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_INSERT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_UBaseReg</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>,<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>op</name><operator>!=</operator><name>TK_DELETE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_DELETE</name> <operator>&amp;&amp;</operator> <name>zTab</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_INSERT</name> <operator>&amp;&amp;</operator> <name>zTab</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRIGGER */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UPSERT</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_UUpsert</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zTab</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>uNC</name><operator>.</operator><name>pUpsert</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pUpsert</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><literal type="string">"excluded"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>EXCLUDED_TABLE_NUMBER</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UPSERT */</comment>

      <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content> 
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name></type> <name>hCol</name> <init>= <expr><call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cntTab</name><operator>++</operator></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name><operator>==</operator><name>hCol</name>
           <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>iCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>VisibleRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* IMP: R-51414-32910 */</comment>
          <expr_stmt><expr><name>iCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UPSERT</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>EXCLUDED_TABLE_NUMBER</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>eNewExprOp</name> <operator>=</operator> <name>TK_COLUMN</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>uNC</name><operator>.</operator><name>pUpsert</name><operator>-&gt;</operator><name>regData</name></name> <operator>+</operator>
                 <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>eNewExprOp</name> <operator>=</operator> <name>TK_REGISTER</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UPSERT */</comment>
          <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>eNewExprOp</name> <operator>=</operator> <name>TK_REGISTER</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>TK_COLUMN</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>uNC</name><operator>.</operator><name>iBaseReg</name></name> <operator>+</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>+</operator>
                 <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>eNewExprOp</name> <operator>=</operator> <name>TK_TRIGGER</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
              <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>oldmask</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">32</literal></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>iCol</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>newmask</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">32</literal></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>iCol</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRIGGER */</comment>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */</comment>

    <comment type="block">/*
    ** Perhaps the name is a reference to the ROWID
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>cntTab</name><operator>==</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <name>pMatch</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_IdxExpr</name><operator>|</operator><name>NC_GenCol</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>VisibleRowid</name><argument_list>(<argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z
    ** might refer to an result-set alias.  This happens, for example, when
    ** we are resolving names in the WHERE clause of the following command:
    **
    **     SELECT a+b AS x FROM table WHERE x&lt;10;
    **
    ** In cases like this, replace pExpr with a copy of the expression that
    ** forms the result set entry ("a+b" in the example) and return immediately.
    ** Note that the expression in the result set should have already been
    ** resolved by the time the WHERE clause is resolved.
    **
    ** The ability to use an output result-set column in the WHERE, GROUP BY,
    ** or HAVING clauses, or as part of a larger expression in the ORDER BY
    ** clause is not standard SQL.  This is a (goofy) SQLite extension, that
    ** is supported for backwards compatibility only. Hence, we issue a warning
    ** on sqlite3_log() whenever the capability is used.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_UEList</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>uNC</name><operator>.</operator><name>pEList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAs</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name>
         <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zAs</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOrig</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOrig</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name><operator>&amp;</operator><name>NC_AllowAgg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>EP_Agg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of aliased aggregate %s"</literal></expr></argument>, <argument><expr><name>zAs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WRC_Abort</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>EP_Win</name></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name><operator>&amp;</operator><name>NC_AllowWin</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pNC</name><operator>!=</operator><name>pTopNC</name> <operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of aliased window function %s"</literal></expr></argument>,<argument><expr><name>zAs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WRC_Abort</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"row value misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WRC_Abort</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>resolveAlias</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>nSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zDb</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <goto>goto <name>lookupname_end</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for> 
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Advance to the next name context.  The loop will exit when either
    ** we have a match (cnt&gt;0) or when we run out of name contexts.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pNC</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSubquery</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>pNC</name></expr> )</condition>;</do>


  <comment type="block">/*
  ** If X and Y are NULL (in other words if only the column name Z is
  ** supplied) and the value of Z is enclosed in double-quotes, then
  ** Z is a string literal if it doesn't match any column names.  In that
  ** case, we need to return right away and not make any changes to
  ** pExpr.
  **
  ** Because no reference was made to outer contexts, the pNC-&gt;nRef
  ** fields are not changed in any context.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_DblQuoted</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>areDoubleQuotedStringsEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTopNC</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* If a double-quoted identifier does not match any known column name,
      ** then treat it as a string.
      **
      ** This hack was added in the early days of SQLite in a misguided attempt
      ** to be compatible with MySQL 3.x, which used double-quotes for strings.
      ** I now sorely regret putting in this hack. The effect of this hack is
      ** that misspelled identifier names are silently converted into strings
      ** rather than causing an error, to the frustration of countless
      ** programmers. To all those frustrated programmers, my apologies.
      **
      ** Someday, I hope to get rid of this hack. Unfortunately there is
      ** a huge amount of legacy SQL that uses it. So for now, we just
      ** issue a warning.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>,
        <argument><expr><literal type="string">"double-quoted string literal: \"%w\""</literal></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3VdbeAddDblquoteStr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_STRING</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIdToTrueFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** cnt==0 means there was not match.
  ** cnt&gt;1 means there were two or more matches.
  **
  ** cnt==0 is always an error.  cnt&gt;1 is often an error, but might
  ** be multiple matches for a NATURAL LEFT JOIN or a LEFT JOIN USING.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFJMatch</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name><operator>|</operator><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pFJMatch</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFJMatch</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>cnt</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>extendFJMatch</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFJMatch</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_FUNCTION</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <literal type="string">"coalesce"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pFJMatch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>lookupname_end</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFJMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pFJMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <ternary><condition><expr><name>cnt</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"no such column"</literal></expr> </then><else>: <expr><literal type="string">"ambiguous column name"</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDb</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s.%s.%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s.%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTopNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFJMatch</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove all substructure from pExpr */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><operator>(</operator><name>EP_TokenOnly</name><operator>|</operator><name>EP_Leaf</name><operator>)</operator></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a column from a table in pSrcList is referenced, then record
  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes
  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  Bit 63 is
  ** set if the 63rd or any subsequent column is used.
  **
  ** The colUsed mask is an optimization used to help determine if an
  ** index is a covering index.  The correct answer is still obtained
  ** if the mask contains extra set bits.  However, it is important to
  ** avoid setting bits beyond the maximum column number of the table.
  ** (See ticket [b92e5e8ec2cdbaa1]).
  **
  ** If a generated column is referenced, set bits for every column
  ** of the table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pMatch</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>|=</operator> <call><name>sqlite3ExprColUsed</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>eNewExprOp</name></expr>;</expr_stmt>
<label><name>lookupname_end</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>xAuth</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRIGGER</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3AuthRead</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>, <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Increment the nRef value on all name contexts from TopNC up to
    ** the point where the name matched. */</comment>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTopNC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTopNC</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTopNC</name><operator>==</operator><name>pNC</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pTopNC</name> <operator>=</operator> <name><name>pTopNC</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a pointer to an expression to load the column iCol
** from datasource iSrc in SrcList pSrc.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3CreateColumnExpr</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iSrc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>==</operator><name>iCol</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">63</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">64</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;=</operator><literal type="number">64</literal></expr> ?</condition><then> <expr><name>ALLBITS</name></expr> </then><else>: <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>iCol</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Report an error that an expression is not valid for some set of
** pNC-&gt;ncFlags values determined by validMask.
**
** static void notValid(
**   Parse *pParse,       // Leave error message here
**   NameContext *pNC,    // The name context 
**   const char *zMsg,    // Type of error
**   int validMask,       // Set of contexts for which prohibited
**   Expr *pExpr          // Invalidate this expression on error
** ){...}
**
** As an optimization, since the conditional is almost always false
** (because errors are rare), the conditional is moved outside of the
** function call using a macro.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>notValidImpl</name><parameter_list>(
   <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Leave error message here */</comment>
   <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,    <comment type="block">/* The name context */</comment>
   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl></parameter>,    <comment type="block">/* Type of error */</comment>
   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,         <comment type="block">/* Invalidate this expression on error */</comment>
   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pError</name></decl></parameter>         <comment type="block">/* Associate error with this expression */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><literal type="string">"partial index WHERE clauses"</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IdxExpr</name></expr> )</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>zIn</name> <operator>=</operator> <literal type="string">"index expressions"</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <if type="elseif">else if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zIn</name> <operator>=</operator> <literal type="string">"CHECK constraints"</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
  <if type="elseif">else if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_GenCol</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zIn</name> <operator>=</operator> <literal type="string">"generated columns"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s prohibited in %s"</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3ResolveNotValid</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>M</name></type></parameter>,<parameter><type><name>X</name></type></parameter>,<parameter><type><name>E</name></type></parameter>,<parameter><type><name>R</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>assert( ((X)&amp;~(NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol))==0 ); \
  if( ((N)-&gt;ncFlags &amp; (X))!=0 ) notValidImpl(P,N,M,E,R);</cpp:value></cpp:define>

<comment type="block">/*
** Expression p should encode a floating point value between 1.0 and 0.0.
** Return 1024 times this value.  Or return -1 if p is not a floating point
** value between 1.0 and 0.0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprProbability</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><operator>-</operator><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_FLOAT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name><operator>&gt;=</operator><literal type="number">0.0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;</operator><literal type="number">1.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>r</name><operator>*</operator><literal type="number">134217728.0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is callback for sqlite3WalkExpr().
**
** Resolve symbolic names into TK_COLUMN operators for the current
** node in the expression tree.  Return 0 to continue the search down
** the tree or 2 to abort the tree walk.
**
** This routine also does error checking and name resolution for
** function names.  The operator for aggregate functions is changed
** to TK_AGG_FUNCTION.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveExprStep</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNC</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>==</operator><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name> <operator>&amp;&amp;</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrcList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSrcList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>

    <comment type="block">/* The special operator TK_ROW means use the rowid for the first
    ** column in the FROM clause.  This is used by the LIMIT and ORDER BY
    ** clause processing on UPDATE and DELETE statements, and by 
    ** UPDATE ... FROM statement processing.
    */</comment>
    <case>case <expr><name>TK_ROW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrcList</name> <operator>&amp;&amp;</operator> <name><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pSrcList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_COLUMN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* An optimization:  Attempt to convert
    **
    **      "expr IS NOT NULL"  --&gt;  "TRUE"
    **      "expr IS NULL"      --&gt;  "FALSE"
    **
    ** if we can prove that "expr" is never NULL.  Call this the
    ** "NOT NULL strength reduction optimization".
    **
    ** If this optimization occurs, also restore the NameContext ref-counts
    ** to the state they where in before the "column" LHS expression was
    ** resolved.  This prevents "column" from being counted as having been
    ** referenced, which might prevent a SELECT from being erroneously
    ** marked as correlated.
    */</comment>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name><name>anRef</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name>pNC</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>anRef</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
        <expr_stmt><expr><name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nRef</name></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <literal type="string">"true"</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IsTrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <literal type="string">"false"</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IsFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_TRUEFALSE</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name>pNC</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>anRef</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block>

    <comment type="block">/* A column name:                    ID
    ** Or table name and column name:    ID.ID
    ** Or a database, table and column:  ID.ID.ID
    **
    ** The TK_ID and TK_OUT cases are combined so that there will only
    ** be one call to lookupName().  Then the compiler will in-line 
    ** lookupName() for a size reduction and performance increase.
    */</comment>
    <case>case <expr><name>TK_ID</name></expr>:</case>
    <case>case <expr><name>TK_DOT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColumn</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zTable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zColumn</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IdxExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_GenCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ResolveNotValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"the \".\" operator"</literal></expr></argument>,
                               <argument><expr><name>NC_IdxExpr</name><operator>|</operator><name>NC_GenCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_DOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseUToken</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ExprUseUToken</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zTable</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zColumn</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><call><name>lookupName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zColumn</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>

    <comment type="block">/* Resolve function names
    */</comment>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* The argument list */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><name>pList</name></expr> ?</condition><then> <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>no_such_func</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* True if no such function exists */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>wrong_num_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* True if wrong number of arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>is_agg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if is an aggregate function */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl>;</decl_stmt>            <comment type="block">/* The function name. */</comment>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>              <comment type="block">/* Information about the function */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* The database encoding */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>savedAllowFlags</name> <init>= <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_AllowAgg</name> <operator>|</operator> <name>NC_AllowWin</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>IsWindowFunc</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name><operator>|</operator><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zId</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>no_such_func</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>wrong_num_args</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>is_agg</name> <operator>=</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xFinalize</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_UNLIKELY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Unlikely</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <call><name>exprProbability</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                <argument><expr><literal type="string">"second argument to %#T() must be a "</literal>
                <literal type="string">"constant between 0.0 and 1.0"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is
            ** equivalent to likelihood(X, 0.0625).
            ** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is
            ** short-hand for likelihood(X,0.0625).
            ** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand
            ** for likelihood(X,0.9375).
            ** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent
            ** to likelihood(X,0.9375). */</comment>
            <comment type="block">/* TUNING: unlikely() probability is 0.0625.  likely() is 0.9375 */</comment>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'u'</literal></expr> ?</condition><then> <expr><literal type="number">8388608</literal></expr> </then><else>: <expr><literal type="number">125829120</literal></expr></else></ternary></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>             
        </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
        <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>auth</name> <init>= <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_FUNCTION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>auth</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>auth</name><operator>==</operator><name>SQLITE_DENY</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"not authorized to use function: %#T"</literal></expr></argument>,
                                      <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>WRC_Prune</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_CONSTANT</name><operator>|</operator><name>SQLITE_FUNC_SLOCHNG</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <comment type="block">/* For the purposes of the EP_ConstFunc flag, date and time
          ** functions and other functions that change slowly are considered
          ** constant because they are constant for the duration of one query.
          ** This allows them to be factored out of inner loops. */</comment>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_ConstFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_CONSTANT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Clearly non-deterministic functions like random(), but also
          ** date/time functions that use 'now', and other functions like
          ** sqlite_version() that might change over time cannot be used
          ** in an index or generated column.  Curiously, they can be used
          ** in a CHECK constraint.  SQLServer, MySQL, and PostgreSQL all
          ** all this. */</comment>
          <expr_stmt><expr><call><name>sqlite3ResolveNotValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"non-deterministic functions"</literal></expr></argument>,
                                 <argument><expr><name>NC_IdxExpr</name><operator>|</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_GenCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>NC_SelfRef</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>NC_SelfRef</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Must fit in 8 bits */</comment>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_SelfRef</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_FromDDL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromDDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_INTERNAL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_InternalFunc</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <comment type="block">/* Internal-use-only functions are disallowed unless the
          ** SQL is being compiled using sqlite3NestedParse() or
          ** the SQLITE_TESTCTRL_INTERNAL_FUNCTIONS test-control has be
          ** used to activate internal functions for testing purposes */</comment>
          <expr_stmt><expr><name>no_such_func</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pDef</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_DIRECT</name><operator>|</operator><name>SQLITE_FUNC_UNSAFE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><name>IN_RENAME_OBJECT</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprFunctionUsable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>is_agg</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator>
          <operator>||</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>xValue</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xInverse</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
          <operator>||</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>xValue</name></name> <operator>&amp;&amp;</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xInverse</name></name> <operator>&amp;&amp;</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xSFunc</name></name> <operator>&amp;&amp;</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xFinalize</name></name><operator>)</operator></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pDef</name> <operator>&amp;&amp;</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xValue</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pWin</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
              <argument><expr><literal type="string">"%#T() may not be used as a window function"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( 
              <expr><operator>(</operator><name>is_agg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_AllowAgg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator>
           <operator>||</operator> <operator>(</operator><name>is_agg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name><operator>&amp;</operator><name>SQLITE_FUNC_WINDOW</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>pWin</name><operator>)</operator>
           <operator>||</operator> <operator>(</operator><name>is_agg</name> <operator>&amp;&amp;</operator> <name>pWin</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_AllowWin</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_WINDOW</name><operator>)</operator> <operator>||</operator> <name>pWin</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"window"</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"aggregate"</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of %s function %#T()"</literal></expr></argument>,<argument><expr><name>zType</name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>is_agg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>is_agg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_AllowAgg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="string">"misuse of aggregate function %#T()"</literal></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>is_agg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if type="elseif">else if<condition>( <expr><name>no_such_func</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION</name></cpp:ifdef>
                  <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such function: %#T"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>wrong_num_args</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="string">"wrong number of arguments to function %#T()"</literal></expr></argument>,
               <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
        <if type="elseif">else if<condition>( <expr><name>is_agg</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
              <argument><expr><literal type="string">"FILTER may not be used with non-aggregate %#T()"</literal></expr></argument>,
              <argument><expr><name>pExpr</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name>is_agg</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Window functions may not be arguments of aggregate functions.
          ** Or arguments of other window functions. But aggregate functions
          ** may be arguments for window functions.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>NC_AllowWin</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>!</operator><name>pWin</name></expr> ?</condition><then> <expr><name>NC_AllowAgg</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_AllowAgg</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <if type="elseif">else if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>is_agg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>is_agg</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name>pWin</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pWinSelect</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWin</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><call><name>ExprUseYWin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pWin</name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3WindowUpdate</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pSel</name></expr> ?</condition><then> <expr><name><name>pSel</name><operator>-&gt;</operator><name>pWinDefn</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>pWin</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3WindowLink</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_HasWin</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>
        <block>{<block_content>
          <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC2</name></decl>;</decl_stmt>          <comment type="block">/* For looping up thru outer contexts */</comment>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_AGG_FUNCTION</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>pNC2</name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>pNC2</name> 
              <operator>&amp;&amp;</operator> <call><name>sqlite3ReferencesSrcList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pNC2</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pNC2</name> <operator>=</operator> <name><name>pNC2</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDef</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>IN_RENAME_OBJECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pNC2</name> <operator>&amp;&amp;</operator> <name>pDef</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_MINMAX</name><operator>==</operator><name>NC_MinMaxAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_ANYORDER</name><operator>==</operator><name>NC_OrderAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_ANYORDER</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pNC2</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_HasAgg</name> 
              <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name><operator>^</operator><name>SQLITE_FUNC_ANYORDER</name><operator>)</operator>
                  <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_MINMAX</name><operator>|</operator><name>SQLITE_FUNC_ANYORDER</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>savedAllowFlags</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* FIX ME:  Compute pExpr-&gt;affinity based on the expected return
      ** type of the function 
      */</comment>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_SELECT</name></expr>:</case>
    <case>case <expr><name>TK_EXISTS</name></expr>:</case>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nRef</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_PartIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IdxExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_GenCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_SelfRef</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>notValidImpl</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"subqueries"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;=</operator><name>nRef</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nRef</name><operator>!=</operator><name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_VarSelect</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_VARIABLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_PartIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IdxExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_GenCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ResolveNotValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"parameters"</literal></expr></argument>,
               <argument><expr><name>NC_IsCheck</name><operator>|</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_IdxExpr</name><operator>|</operator><name>NC_GenCol</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Handle special cases of "x IS TRUE", "x IS FALSE", "x IS NOT TRUE",
      ** and "x IS NOT FALSE". */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRUEFALSE</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>resolveExprStep</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>WRC_Abort</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRUEFALSE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_TRUTH</name></expr>;</expr_stmt>
          <return>return <expr><name>WRC_Continue</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name></decl>, <decl><type ref="prev"/><name>nRight</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nLeft</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_BETWEEN</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRight</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>==</operator><name>nLeft</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nRight</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRight</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>!=</operator><name>nRight</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_BETWEEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"row value misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break> 
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> ?</condition><then> <expr><name>WRC_Abort</name></expr> </then><else>: <expr><name>WRC_Continue</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pEList is a list of expressions which are really the result set of the
** a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.
** This routine checks to see if pE is a simple identifier which corresponds
** to the AS-name of one of the terms of the expression list.  If it is,
** this routine return an integer between 1 and N where N is the number of
** elements in pEList, corresponding to the matching entry.  If there is
** no match, or if pE is not a simple identifier, then this routine
** return 0.
**
** pEList has been resolved.  pE has not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveAsName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context for error messages */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,  <comment type="block">/* List of expressions to scan */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl></parameter>           <comment type="block">/* Expression we are trying to match */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCol</name> <operator>=</operator> <name><name>pE</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pE is a pointer to an expression which is a single term in the
** ORDER BY of a compound SELECT.  The expression has not been
** name resolved.
**
** At the point this routine is called, we already know that the
** ORDER BY term is not an integer index into the result set.  That
** case is handled by the calling routine.
**
** Attempt to match pE against result set columns in the left-most
** SELECT statement.  Return the index i of the matching column,
** as an indication to the caller that it should sort by the i-th column.
** The left-most column is 1.  In other words, the value returned is the
** same integer value that would be used in the SQL statement to indicate
** the column.
**
** If there is no match, return 0.  Return -1 if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveOrderByTermToExprList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context for error messages */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,   <comment type="block">/* The SELECT statement with the ORDER BY clause */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl></parameter>           <comment type="block">/* The specific ORDER BY term */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>  <comment type="block">/* The columns of the result set */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>nc</name></decl>;</decl_stmt>    <comment type="block">/* Name context for resolving pE */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>       <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>            <comment type="block">/* Return code from subprocedures */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>savedSuppErr</name></decl>;</decl_stmt>   <comment type="block">/* Saved value of db-&gt;suppressErr */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>

  <comment type="block">/* Resolve all names in the ORDER BY term expression
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>uNC</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name>pEList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>NC_AllowAgg</name><operator>|</operator><name>NC_UEList</name><operator>|</operator><name>NC_NoSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>nNcErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedSuppErr</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nc</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name> <operator>=</operator> <name>savedSuppErr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Try to match the ORDER BY expression against an expression
  ** in the result set.  Return an 1-based index of the matching
  ** result-set entry.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If no match, return 0. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate an ORDER BY or GROUP BY term out-of-range error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveOutOfRangeError</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The error context into which to write the error */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>,     <comment type="block">/* "ORDER" or "GROUP" */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,                 <comment type="block">/* The index (1-based) of the term out of range */</comment>
  <parameter><decl><type><name>int</name></type> <name>mx</name></decl></parameter>,                <comment type="block">/* Largest permissible value of i */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pError</name></decl></parameter>           <comment type="block">/* Associate the error with the expression */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
    <argument><expr><literal type="string">"%r %s BY term out of range - should be "</literal>
    <literal type="string">"between 1 and %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Analyze the ORDER BY clause in a compound SELECT statement.   Modify
** each term of the ORDER BY clause is a constant integer between 1
** and N where N is the number of columns in the compound SELECT.
**
** ORDER BY terms that are already an integer between 1 and N are
** unmodified.  ORDER BY terms that are integers outside the range of
** 1 through N generate an error.  ORDER BY terms that are expressions
** are matched against result set expressions of compound SELECT
** beginning with the left-most SELECT and working toward the right.
** At the first match, the ORDER BY expression is transformed into
** the integer column number.
**
** Return the number of errors seen.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveCompoundOrderBy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context.  Leave error messages here */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>       <comment type="block">/* The SELECT statement containing the ORDER BY */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>moreToDo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many terms in ORDER BY clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>pSelect</name> <operator>&amp;&amp;</operator> <name>moreToDo</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>moreToDo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>done</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pE</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pE</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>&gt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>resolveOutOfRangeError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ORDER"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>resolveAsName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Now test if expression pE matches one of the values returned
          ** by pSelect. In the usual case this is done by duplicating the 
          ** expression, resolving any symbols in it, and then comparing
          ** it against each expression returned by the SELECT statement.
          ** Once the comparisons are finished, the duplicate expression
          ** is deleted.
          **
          ** If this is running as part of an ALTER TABLE operation and
          ** the symbols resolve successfully, also resolve the symbols in the
          ** actual expression. This allows the code in alter.c to modify
          ** column references within the ORDER BY expression as required.  */</comment>
          <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>resolveOrderByTermToExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>resolveOrderByTermToExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Convert the ORDER BY term into an integer column number iCol,
        ** taking care to preserve the COLLATE clause if it exists. */</comment>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_IntValue</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name><operator>==</operator><name>pE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>( <expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><name>pE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>moreToDo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>done</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%r ORDER BY term does not match any "</literal>
            <literal type="string">"column in the result set"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check every term in the ORDER BY or GROUP BY clause pOrderBy of
** the SELECT statement pSelect.  If any term is reference to a
** result set expression (as determined by the ExprList.a.u.x.iOrderByCol
** field) then convert that term into a copy of the corresponding result set
** column.
**
** If any errors are detected, add an error message to pParse and
** return non-zero.  Return zero if no errors are seen.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveOrderGroupBy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context.  Leave error messages here */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* The SELECT statement containing the clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* The ORDER BY or GROUP BY clause to be processed */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>     <comment type="block">/* "ORDER" or "GROUP" */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name>IN_RENAME_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many terms in %s BY clause"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3SelectNew() guarantees this */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>&gt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>resolveOutOfRangeError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>resolveAlias</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
<comment type="block">/*
** Walker callback for windowRemoveExprFromSelect().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveRemoveWindowsCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3WindowUnlinkFromSelect</name><argument_list>(<argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove any Window objects owned by the expression pExpr from the
** Select.pWin list of Select object pSelect.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowRemoveExprFromSelect</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>resolveRemoveWindowsCb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>windowRemoveExprFromSelect</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>

<comment type="block">/*
** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.
** The Name context of the SELECT statement is pNC.  zType is either
** "ORDER" or "GROUP" depending on which type of clause pOrderBy is.
**
** This routine resolves each term of the clause into an expression.
** If the order-by term is an integer I between 1 and N (where N is the
** number of columns in the result set of the SELECT) then the expression
** in the resolution is a copy of the I-th result-set expression.  If
** the order-by term is an identifier that corresponds to the AS-name of
** a result-set expression, then the term resolves to a copy of the
** result-set expression.  Otherwise, the expression is resolved in
** the usual way - using sqlite3ResolveExprNames().
**
** This routine returns the number of errors.  If errors occur, then
** an appropriate error message might be left in pParse.  (OOM errors
** excepted.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveOrderGroupBy</name><parameter_list>(
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,     <comment type="block">/* The name context of the SELECT statement */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* The SELECT statement holding pOrderBy */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* An ORDER BY or GROUP BY clause to resolve */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>     <comment type="block">/* Either "ORDER" or "GROUP", as appropriate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                      <comment type="block">/* Column number */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>   <comment type="block">/* A term of the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>                 <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nResult</name></decl>;</decl_stmt>                   <comment type="block">/* Number of terms in the result set */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nResult</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pE2</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'G'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>resolveAsName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If an AS-name match is found, mark this ORDER BY column as being
        ** a copy of the iCol-th result-set column.  The subsequent call to
        ** sqlite3ResolveOrderGroupBy() will convert the expression to a
        ** copy of the iCol-th result-set expression. */</comment>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* The ORDER BY term is an integer constant.  Again, set the column
      ** number so that sqlite3ResolveOrderGroupBy() will convert the
      ** order-by term to a copy of the result-set expression */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>iCol</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>iCol</name></expr></argument>&gt;</argument_list></name><literal type="number">0xffff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>resolveOutOfRangeError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nResult</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise, treat the ORDER BY term as an ordinary expression */</comment>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Since this expresion is being changed into a reference
        ** to an identical expression in the result set, remove all Window
        ** objects belonging to the expression from the Select.pWin list. */</comment>
        <expr_stmt><expr><call><name>windowRemoveExprFromSelect</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <return>return <expr><call><name>sqlite3ResolveOrderGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve names in the SELECT statement p and all of its descendants.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveSelectStep</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pOuterNC</name></decl>;</decl_stmt>  <comment type="block">/* Context that contains this SELECT */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>        <comment type="block">/* Name context of this SELECT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isCompound</name></decl>;</decl_stmt>         <comment type="block">/* True if p is a compound select */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCompound</name></decl>;</decl_stmt>          <comment type="block">/* Number of compound terms processed so far */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>          <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                  <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name></decl>;</decl_stmt>     <comment type="block">/* The GROUP BY clause */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pLeftmost</name></decl>;</decl_stmt>      <comment type="block">/* Left-most of SELECT of a compound */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>            <comment type="block">/* Database connection */</comment>
  

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOuterNC</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>

  <comment type="block">/* Normally sqlite3SelectExpand() will be called first and will have
  ** already expanded this SELECT.  However, if this is a subquery within
  ** an expression, sqlite3ResolveExprNames() will be called without a
  ** prior call to sqlite3SelectExpand().  When that happens, let
  ** sqlite3SelectPrep() do all of the processing for this SELECT.
  ** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and
  ** this routine in the correct order.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Expanded</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOuterNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> ?</condition><then> <expr><name>WRC_Abort</name></expr> </then><else>: <expr><name>WRC_Prune</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>isCompound</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCompound</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeftmost</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Expanded</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* SF_Resolved not set if errors suppressed */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Resolved</name></expr>;</expr_stmt>


    <comment type="block">/* Resolve the expressions in the LIMIT and OFFSET clauses. These
    ** are not allowed to refer to any names, so pass an empty NameContext.
    */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pWinSelect</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the SF_Converted flags is set, then this Select object was
    ** was created by the convertCompoundSelectToSubquery() function.
    ** In this case the ORDER BY clause (p-&gt;pOrderBy) should be resolved
    ** as if it were part of the sub-query, not the parent. This block
    ** moves the pOrderBy down to the sub-query. It will be moved back
    ** after the names have been resolved.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Converted</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Recursively resolve names in all subqueries in the FROM clause
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nRef</name> <init>= <expr><ternary><condition><expr><name>pOuterNC</name></expr> ?</condition><then> <expr><name><name>pOuterNC</name><operator>-&gt;</operator><name>nRef</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSavedContext</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ResolveSelectNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><name>pOuterNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name>zSavedContext</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the number of references to the outer context changed when
        ** expressions in the sub-select were resolved, the sub-select
        ** is correlated. It is not required to check the refcount on any
        ** but the innermost outer context object, as lookupName() increments
        ** the refcount on all contexts between the current one and the
        ** context containing the column when it resolves a name. */</comment>
        <if_stmt><if>if<condition>( <expr><name>pOuterNC</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOuterNC</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;=</operator><name>nRef</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name> <operator>=</operator> <operator>(</operator><name><name>pOuterNC</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><name>nRef</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  
    <comment type="block">/* Set up the local name-context to pass to sqlite3ResolveExprNames() to
    ** resolve the result-set expression list.
    */</comment>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>NC_AllowAgg</name><operator>|</operator><name>NC_AllowWin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name>pOuterNC</name></expr>;</expr_stmt>
  
    <comment type="block">/* Resolve names in the result set. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_AllowWin</name></expr>;</expr_stmt>
  
    <comment type="block">/* If there are no aggregate functions in the result-set, and no GROUP BY 
    ** expression, do not allow aggregates in any of the other expressions.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroupBy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pGroupBy</name> <operator>||</operator> <operator>(</operator><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasAgg</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>NC_MinMaxAgg</name><operator>==</operator><name>SF_MinMaxAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>NC_OrderAgg</name><operator>==</operator><name>SF_OrderByReqd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Aggregate</name> <operator>|</operator> <operator>(</operator><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name><operator>&amp;</operator><operator>(</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_AllowAgg</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Add the output column list to the name-context before parsing the
    ** other expressions in the SELECT statement. This is so that
    ** expressions in the WHERE clause (etc.) can refer to expressions by
    ** aliases in the result set.
    **
    ** Minor point: If this is the case, then the expression will be
    ** re-evaluated for each reference to it.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_UAggInfo</name><operator>|</operator><name>NC_UUpsert</name><operator>|</operator><name>NC_UBaseReg</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>uNC</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_UEList</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"HAVING clause on a non-aggregate query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Resolve names in table-valued-function arguments */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pWinDefn</name></name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call>
         <operator>||</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <return>return <expr><name>WRC_Abort</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The ORDER BY and GROUP BY clauses may not refer to terms in
    ** outer queries 
    */</comment>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_AllowAgg</name><operator>|</operator><name>NC_AllowWin</name></expr>;</expr_stmt>

    <comment type="block">/* If this is a converted compound query, move the ORDER BY clause from 
    ** the sub-query back to the parent query. At this point each term
    ** within the ORDER BY clause has been transformed to an integer value.
    ** These integers will be replaced by copies of the corresponding result
    ** set expressions by the call to resolveOrderGroupBy() below.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Converted</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process the ORDER BY clause for singleton SELECT statements.
    ** The ORDER BY clause for compounds SELECT statements is handled
    ** below, after all of the result-sets for all of the elements of
    ** the compound have been resolved.
    **
    ** If there is an ORDER BY clause on a term of a compound-select other
    ** than the right-most term, then that is a syntax error.  But the error
    ** is not detected until much later, and so we need to go ahead and
    ** resolve those symbols on the incorrect ORDER BY for consistency.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>isCompound</name><operator>&lt;=</operator><name>nCompound</name>  <comment type="block">/* Defer right-most ORDER BY of a compound */</comment>
     <operator>&amp;&amp;</operator> <call><name>resolveOrderGroupBy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="string">"ORDER"</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_AllowWin</name></expr>;</expr_stmt>
  
    <comment type="block">/* Resolve the GROUP BY clause.  At the same time, make sure 
    ** the GROUP BY clause does not contain aggregate functions.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    
      <if_stmt><if>if<condition>( <expr><call><name>resolveOrderGroupBy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><literal type="string">"GROUP"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_Agg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"aggregate functions are not allowed in "</literal>
              <literal type="string">"the GROUP BY clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>WRC_Abort</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is part of a compound SELECT, check that it has the right
    ** number of expressions in the select list. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SelectWrongNumTermsError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Advance to the next term of the compound
    */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCompound</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Resolve the ORDER BY on a compound SELECT after all terms of
  ** the compound have been resolved.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCompound</name> <operator>&amp;&amp;</operator> <call><name>resolveCompoundOrderBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeftmost</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>WRC_Prune</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine walks an expression tree and resolves references to
** table columns and result-set columns.  At the same time, do error
** checking on function usage and set a flag if any aggregate functions
** are seen.
**
** To resolve table columns references we look for nodes (or subtrees) of the 
** form X.Y.Z or Y.Z or just Z where
**
**      X:   The name of a database.  Ex:  "main" or "temp" or
**           the symbolic name assigned to an ATTACH-ed database.
**
**      Y:   The name of a table in a FROM clause.  Or in a trigger
**           one of the special names "old" or "new".
**
**      Z:   The name of a column in table Y.
**
** The node at the root of the subtree is modified as follows:
**
**    Expr.op        Changed to TK_COLUMN
**    Expr.pTab      Points to the Table object for X.Y
**    Expr.iColumn   The column index in X.Y.  -1 for the rowid.
**    Expr.iTable    The VDBE cursor number for X.Y
**
**
** To resolve result-set references, look for expression nodes of the
** form Z (with no X and Y prefix) where the Z matches the right-hand
** size of an AS clause in the result-set of a SELECT.  The Z expression
** is replaced by a copy of the left-hand side of the result-set expression.
** Table-name and function resolution occurs on the substituted expression
** tree.  For example, in:
**
**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY x;
**
** The "x" term of the order by is replaced by "a+b" to render:
**
**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY a+b;
**
** Function calls are checked to make sure that the function is 
** defined and that the correct number of arguments are specified.
** If the function is an aggregate function, then the NC_HasAgg flag is
** set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.
** If an expression contains aggregate functions then the EP_Agg
** property on the expression is set.
**
** An error message is left in pParse if anything is amiss.  The number
** if errors is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveExprNames</name><parameter_list>( 
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,       <comment type="block">/* Namespace to resolve expressions in. */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>             <comment type="block">/* The expression to be analyzed. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>savedHasAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>savedHasAgg</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>resolveExprStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_NoSelect</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>resolveSelectStep</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>+=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name><name>w</name><operator>.</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>-=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>EP_Agg</name><operator>==</operator><name>NC_HasAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>EP_Win</name><operator>==</operator><name>NC_HasWin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasWin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_HasWin</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>savedHasAgg</name></expr>;</expr_stmt>
  <return>return <expr><name><name>pNC</name><operator>-&gt;</operator><name>nNcErr</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve all names for all expression in an expression list.  This is
** just like sqlite3ResolveExprNames() except that it works for an expression
** list rather than a single expression.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveExprListNames</name><parameter_list>( 
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,       <comment type="block">/* Namespace to resolve expressions in. */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>         <comment type="block">/* The expression list to be analyzed. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>savedHasAgg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>resolveExprStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>resolveSelectStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedHasAgg</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>+=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name><name>w</name><operator>.</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>-=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>EP_Agg</name><operator>==</operator><name>NC_HasAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>EP_Win</name><operator>==</operator><name>NC_HasWin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasWin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_HasWin</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>savedHasAgg</name> <operator>|=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator>
                          <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>|</operator><name>NC_HasWin</name><operator>|</operator><name>NC_OrderAgg</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>savedHasAgg</name></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve all names in all expressions of a SELECT and in all
** decendents of the SELECT, including compounds off of p-&gt;pPrior,
** subqueries in expressions, and subqueries used as FROM clause
** terms.
**
** See sqlite3ResolveExprNames() for a description of the kinds of
** transformations that occur.
**
** All SELECT statements should have been expanded using
** sqlite3SelectExpand() prior to invoking this routine.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResolveSelectNames</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* The SELECT statement being coded. */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pOuterNC</name></decl></parameter>  <comment type="block">/* Name context for parent SELECT statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>resolveExprStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>resolveSelectStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pOuterNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Resolve names in expressions that can only reference a single table
** or which cannot reference any tables at all.  Examples:
**
**                                                    "type" flag
**                                                    ------------
**    (1)   CHECK constraints                         NC_IsCheck
**    (2)   WHERE clauses on partial indices          NC_PartIdx
**    (3)   Expressions in indexes on expressions     NC_IdxExpr
**    (4)   Expression arguments to VACUUM INTO.      0
**    (5)   GENERATED ALWAYS as expressions           NC_GenCol
**
** In all cases except (4), the Expr.iTable value for Expr.op==TK_COLUMN
** nodes of the expression is set to -1 and the Expr.iColumn value is
** set to the column number.  In case (4), TK_COLUMN nodes cause an error.
**
** Any errors cause an error message to be set in pParse.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveSelfReference</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,     <comment type="block">/* The table being referenced, or NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,        <comment type="block">/* NC_IsCheck, NC_PartIdx, NC_IdxExpr, NC_GenCol, or 0 */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,     <comment type="block">/* Expression to resolve.  May be NULL. */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>  <comment type="block">/* Expression list to resolve.  May be NULL. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name></type> <name>sSrc</name></decl>;</decl_stmt>                   <comment type="block">/* Fake SrcList for pParse-&gt;pNewTable */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>                <comment type="block">/* Name context for pParse-&gt;pNewTable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>type</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>type</name><operator>==</operator><name>NC_IsCheck</name> <operator>||</operator> <name>type</name><operator>==</operator><name>NC_PartIdx</name> <operator>||</operator> <name>type</name><operator>==</operator><name>NC_IdxExpr</name>
          <operator>||</operator> <name>type</name><operator>==</operator><name>NC_GenCol</name> <operator>||</operator> <name>pTab</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sSrc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>nSrc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>!=</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Cause EP_FromDDL to be set on TK_FUNCTION nodes of non-TEMP
      ** schema elements */</comment>
      <expr_stmt><expr><name>type</name> <operator>|=</operator> <name>NC_FromDDL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <operator>&amp;</operator><name>sSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>type</name> <operator>|</operator> <name>NC_IsDDL</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
