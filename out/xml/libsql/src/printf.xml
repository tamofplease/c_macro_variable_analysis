<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/printf.c"><comment type="block">/*
** The "printf" code that follows dates from the 1980's.  It is in
** the public domain. 
**
**************************************************************************
**
** This file contains code for a set of "printf"-like routines.  These
** routines format strings much like the printf() from the standard C
** library, though the implementation here has enhancements to support
** SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Conversion types fall into various categories as defined by the
** following enumeration.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etRADIX</name></cpp:macro>       <cpp:value>0</cpp:value></cpp:define> <comment type="block">/* non-decimal integer types.  %x %o */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etFLOAT</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Floating point.  %f */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etEXP</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define> <comment type="block">/* Exponentional notation. %e and %E */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etGENERIC</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define> <comment type="block">/* Floating or exponential, depending on exponent. %g */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSIZE</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define> <comment type="block">/* Return number of characters processed so far. %n */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSTRING</name></cpp:macro>      <cpp:value>5</cpp:value></cpp:define> <comment type="block">/* Strings. %s */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etDYNSTRING</name></cpp:macro>   <cpp:value>6</cpp:value></cpp:define> <comment type="block">/* Dynamically allocated strings. %z */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etPERCENT</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define> <comment type="block">/* Percent symbol. %% */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etCHARX</name></cpp:macro>       <cpp:value>8</cpp:value></cpp:define> <comment type="block">/* Characters. %c */</comment>
<comment type="block">/* The rest are extensions, not normally found in printf() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSQLESCAPE</name></cpp:macro>   <cpp:value>9</cpp:value></cpp:define> <comment type="block">/* Strings with '\'' doubled.  %q */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSQLESCAPE2</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> <comment type="block">/* Strings with '\'' doubled and enclosed in '',
                          NULL pointers replaced by SQL NULL.  %Q */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etTOKEN</name></cpp:macro>      <cpp:value>11</cpp:value></cpp:define> <comment type="block">/* a pointer to a Token structure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSRCITEM</name></cpp:macro>    <cpp:value>12</cpp:value></cpp:define> <comment type="block">/* a pointer to a SrcItem */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etPOINTER</name></cpp:macro>    <cpp:value>13</cpp:value></cpp:define> <comment type="block">/* The %p conversion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSQLESCAPE3</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> <comment type="block">/* %w -&gt; Strings with '\"' doubled */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etORDINAL</name></cpp:macro>    <cpp:value>15</cpp:value></cpp:define> <comment type="block">/* %r -&gt; 1st, 2nd, 3rd, 4th, etc.  English only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etDECIMAL</name></cpp:macro>    <cpp:value>16</cpp:value></cpp:define> <comment type="block">/* %d or %u, but not %x, %o */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etINVALID</name></cpp:macro>    <cpp:value>17</cpp:value></cpp:define> <comment type="block">/* Any unrecognized conversion type */</comment>


<comment type="block">/*
** An "etByte" is an 8-bit unsigned value.
*/</comment>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>etByte</name>;</typedef>

<comment type="block">/*
** Each builtin conversion character (ex: the 'd' in "%d") is described
** by an instance of the following structure
*/</comment>
<typedef>typedef <type><struct>struct <name>et_info</name> <block>{   <comment type="block">/* Information about each format field */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>fmttype</name></decl>;</decl_stmt>            <comment type="block">/* The format field code letter */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>base</name></decl>;</decl_stmt>             <comment type="block">/* The base for radix conversion */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flags</name></decl>;</decl_stmt>            <comment type="block">/* One or more of FLAG_ constants below */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>type</name></decl>;</decl_stmt>             <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>charset</name></decl>;</decl_stmt>          <comment type="block">/* Offset into aDigits[] of the digits string */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>prefix</name></decl>;</decl_stmt>           <comment type="block">/* Offset into aPrefix[] of the prefix string */</comment>
}</block></struct></type> <name>et_info</name>;</typedef>

<comment type="block">/*
** Allowed values for et_info.flags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_SIGNED</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>     <comment type="block">/* True if the value to convert is signed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_STRING</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>     <comment type="block">/* Allow infinite precision */</comment>


<comment type="block">/*
** The following table is searched linearly, so it is good to put the
** most frequently used conversion types first.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>aDigits</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789ABCDEF0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>aPrefix</name><index>[]</index></name> <init>= <expr><literal type="string">"-x0\000X0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>et_info</name></type> <name><name>fmtinfo</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{  <expr><literal type="char">'d'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etDECIMAL</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'s'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>etSTRING</name></expr>,     <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'g'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etGENERIC</name></expr>,    <expr><literal type="number">30</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'z'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>etDYNSTRING</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'q'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>etSQLESCAPE</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'Q'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>etSQLESCAPE2</name></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'w'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>etSQLESCAPE3</name></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'c'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etCHARX</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'o'</literal></expr>,  <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etRADIX</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'u'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etDECIMAL</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'x'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etRADIX</name></expr>,      <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'X'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etRADIX</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr> }</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <expr><block>{  <expr><literal type="char">'f'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etFLOAT</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'e'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etEXP</name></expr>,        <expr><literal type="number">30</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'E'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etEXP</name></expr>,        <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'G'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etGENERIC</name></expr>,    <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{  <expr><literal type="char">'i'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etDECIMAL</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'n'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etSIZE</name></expr>,       <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'%'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etPERCENT</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'p'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etPOINTER</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr> }</block></expr>,

  <comment type="block">/* All the rest are undocumented and are for internal use only */</comment>
  <expr><block>{  <expr><literal type="char">'T'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etTOKEN</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'S'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>etSRCITEM</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{  <expr><literal type="char">'r'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>etORDINAL</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Notes:
**
**    %S    Takes a pointer to SrcItem.  Shows name or database.name
**    %!S   Like %S but prefer the zName over the zAlias
*/</comment>

<comment type="block">/* Floating point constants used for rounding */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name><name>arRound</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">5.0e-01</literal></expr>, <expr><literal type="number">5.0e-02</literal></expr>, <expr><literal type="number">5.0e-03</literal></expr>, <expr><literal type="number">5.0e-04</literal></expr>, <expr><literal type="number">5.0e-05</literal></expr>,
  <expr><literal type="number">5.0e-06</literal></expr>, <expr><literal type="number">5.0e-07</literal></expr>, <expr><literal type="number">5.0e-08</literal></expr>, <expr><literal type="number">5.0e-09</literal></expr>, <expr><literal type="number">5.0e-10</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point
** conversions will work.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** "*val" is a double such that 0.1 &lt;= *val &lt; 10.0
** Return the ascii code for the leading digit of *val, then
** multiply "*val" by 10.0 to renormalize.
**
** Example:
**     input:     *val = 3.14159
**     output:    *val = 1.4159    function return = '3'
**
** The counter *cnt is incremented each time.  After counter exceeds
** 16 (the number of significant digits in a 64-bit float) '0' is
** always returned.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>et_getdigit</name><parameter_list>(<parameter><decl><type><name>LONGDOUBLE_TYPE</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>digit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>d</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>cnt</name><operator>)</operator><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'0'</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>cnt</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>digit</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>val</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>=</operator> <name>digit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>digit</name> <operator>+=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>val</name> <operator>-</operator> <name>d</name><operator>)</operator><operator>*</operator><literal type="number">10.0</literal></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>char</name><operator>)</operator><name>digit</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_FLOATING_POINT */</comment>

<comment type="block">/*
** Set the StrAccum object to an error mode.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StrAccumSetError</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>eError</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eError</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name>eError</name><operator>==</operator><name>SQLITE_TOOBIG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name> <operator>=</operator> <name>eError</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>eError</name><operator>==</operator><name>SQLITE_TOOBIG</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ErrorToParser</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>eError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Extra argument values from a PrintfArguments object
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>getIntArg</name><parameter_list>(<parameter><decl><type><name>PrintfArguments</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>double</name></type> <name>getDoubleArg</name><parameter_list>(<parameter><decl><type><name>PrintfArguments</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getTextArg</name><parameter_list>(<parameter><decl><type><name>PrintfArguments</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate memory for a temporary buffer needed for printf rendering.
**
** If the requested size of the temp buffer is larger than the size
** of the output buffer in pAccum, then cause an SQLITE_TOOBIG error.
** Do the size check before the memory allocation to prevent rogue
** SQL from requesting large allocations using the precision or width
** field of the printf() function.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>printfTempBuf</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pAccum</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAccum</name><operator>-&gt;</operator><name>accError</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>pAccum</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><name><name>pAccum</name><operator>-&gt;</operator><name>mxAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3StrAccumSetError</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3StrAccumSetError</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** On machines with a small stack size, you can redefine the
** SQLITE_PRINT_BUF_SIZE to be something smaller, if desired.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_PRINT_BUF_SIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_PRINT_BUF_SIZE</name></cpp:macro> <cpp:value>70</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etBUFSIZE</name></cpp:macro> <cpp:value>SQLITE_PRINT_BUF_SIZE</cpp:value></cpp:define>  <comment type="block">/* Size of the output buffer */</comment>

<comment type="block">/*
** Hard limit on the precision of floating-point conversions.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_FP_PRECISION_LIMIT</name></cpp:macro> <cpp:value>100000000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Render a string given by "fmt" into the StrAccum object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_str_vappendf</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pAccum</name></decl></parameter>,       <comment type="block">/* Accumulate results here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,           <comment type="block">/* Format string */</comment>
  <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>                 <comment type="block">/* arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>                     <comment type="block">/* Next character in the format string */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bufpt</name></decl>;</decl_stmt>               <comment type="block">/* Pointer to the conversion buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>precision</name></decl>;</decl_stmt>             <comment type="block">/* Precision of the current field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>                <comment type="block">/* Length of the field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                   <comment type="block">/* A general purpose loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>                 <comment type="block">/* Width of the current field */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_leftjustify</name></decl>;</decl_stmt>   <comment type="block">/* True if "-" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_prefix</name></decl>;</decl_stmt>        <comment type="block">/* '+' or ' ' or 0 for prefix */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_alternateform</name></decl>;</decl_stmt> <comment type="block">/* True if "#" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_altform2</name></decl>;</decl_stmt>      <comment type="block">/* True if "!" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_zeropad</name></decl>;</decl_stmt>       <comment type="block">/* True if field width constant starts with zero */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_long</name></decl>;</decl_stmt>          <comment type="block">/* 1 for the "l" flag, 2 for "ll", 0 by default */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>done</name></decl>;</decl_stmt>               <comment type="block">/* Loop termination flag */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>cThousand</name></decl>;</decl_stmt>          <comment type="block">/* Thousands separator for %d and %u */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>xtype</name> <init>= <expr><name>etINVALID</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bArgList</name></decl>;</decl_stmt>               <comment type="block">/* True for SQLITE_PRINTF_SQLFUNC */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>prefix</name></decl>;</decl_stmt>               <comment type="block">/* Prefix character.  "+" or "-" or " " or '\0'. */</comment>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>longvalue</name></decl>;</decl_stmt>   <comment type="block">/* Value for integer types */</comment>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>realvalue</name></decl>;</decl_stmt> <comment type="block">/* Value for real types */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>et_info</name> <modifier>*</modifier></type><name>infop</name></decl>;</decl_stmt>      <comment type="block">/* Pointer to the appropriate info structure */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>                <comment type="block">/* Rendering buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name></decl>;</decl_stmt>                  <comment type="block">/* Size of the rendering buffer */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Malloced memory used by some conversion */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type>  <name>exp</name></decl>, <decl><type ref="prev"/><name>e2</name></decl>;</decl_stmt>              <comment type="block">/* exponent of real numbers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nsd</name></decl>;</decl_stmt>                   <comment type="block">/* Number of significant digits returned */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rounder</name></decl>;</decl_stmt>            <comment type="block">/* Used for rounding floating point values */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_dp</name></decl>;</decl_stmt>            <comment type="block">/* True if decimal point should be shown */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_rtz</name></decl>;</decl_stmt>           <comment type="block">/* True if trailing zeros should be removed */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>PrintfArguments</name> <modifier>*</modifier></type><name>pArgList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Arguments for SQLITE_PRINTF_SQLFUNC */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>etBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Conversion buffer */</comment>

  <comment type="block">/* pAccum never starts out with an empty buffer that was obtained from 
  ** malloc().  This precondition is required by the mprintf("%z...")
  ** optimization. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>nChar</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pAccum</name><operator>-&gt;</operator><name>printfFlags</name></name><operator>&amp;</operator><name>SQLITE_PRINTF_MALLOCED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pAccum</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PRINTF_SQLFUNC</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pArgList</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>PrintfArguments</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bArgList</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>bArgList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><name>fmt</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>fmt</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fmt</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_STRCHRNUL</name></expr></cpp:if>
      <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <do>do<block>{<block_content> <expr_stmt><expr><name>fmt</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><operator>*</operator><name>fmt</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>fmt</name> <operator>!=</operator> <literal type="char">'%'</literal></expr> )</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>bufpt</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>fmt</name> <operator>-</operator> <name>bufpt</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>fmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>++</operator><name>fmt</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Find out what flags are present */</comment>
    <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <name>flag_prefix</name> <operator>=</operator> <name>cThousand</name> <operator>=</operator>
     <name>flag_alternateform</name> <operator>=</operator> <name>flag_altform2</name> <operator>=</operator> <name>flag_zeropad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>flag_long</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="char">'-'</literal></expr>:</case>   <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <break>break;</break>
        <case>case <expr><literal type="char">'+'</literal></expr>:</case>   <expr_stmt><expr><name>flag_prefix</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>        <break>break;</break>
        <case>case <expr><literal type="char">' '</literal></expr>:</case>   <expr_stmt><expr><name>flag_prefix</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>        <break>break;</break>
        <case>case <expr><literal type="char">'#'</literal></expr>:</case>   <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <break>break;</break>
        <case>case <expr><literal type="char">'!'</literal></expr>:</case>   <expr_stmt><expr><name>flag_altform2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <break>break;</break>
        <case>case <expr><literal type="char">'0'</literal></expr>:</case>   <expr_stmt><expr><name>flag_zeropad</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>         <break>break;</break>
        <case>case <expr><literal type="char">','</literal></expr>:</case>   <expr_stmt><expr><name>cThousand</name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>          <break>break;</break>
        <default>default:</default>    <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>                 <break>break;</break>
        <case>case <expr><literal type="char">'l'</literal></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>flag_long</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>flag_long</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case>
        <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>unsigned</name></type> <name>wx</name> <init>= <expr><name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>wx</name> <operator>=</operator> <name>wx</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wx</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>width</name> <operator>=</operator> <name>wx</name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></cpp:ifdef>
          <if_stmt><if>if<condition>( <expr><name>width</name><operator>&gt;</operator><name>SQLITE_PRINTF_PRECISION_LIMIT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'l'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>fmt</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>getIntArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>width</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <ternary><condition><expr><name>width</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">2147483647</literal></expr> ?</condition><then> <expr><operator>-</operator><name>width</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></cpp:ifdef>
          <if_stmt><if>if<condition>( <expr><name>width</name><operator>&gt;</operator><name>SQLITE_PRINTF_PRECISION_LIMIT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>fmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'l'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>getIntArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>precision</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>precision</name> <operator>=</operator> <ternary><condition><expr><name>precision</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">2147483647</literal></expr> ?</condition><then> <expr><operator>-</operator><name>precision</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name></type> <name>px</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>px</name> <operator>=</operator> <name>px</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>fmt</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>px</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>px</name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></cpp:ifdef>
          <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>SQLITE_PRINTF_PRECISION_LIMIT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>SQLITE_PRINTF_PRECISION_LIMIT</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>--</operator><name>fmt</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block>while<condition>( <expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>++</operator><name>fmt</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>

    <comment type="block">/* Fetch the info entry for the field */</comment>
    <expr_stmt><expr><name>infop</name> <operator>=</operator> <operator>&amp;</operator><name><name>fmtinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>etINVALID</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>fmtinfo</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name><name>fmtinfo</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>fmttype</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>infop</name> <operator>=</operator> <operator>&amp;</operator><name><name>fmtinfo</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name><name>infop</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
    ** At this point, variables are initialized as follows:
    **
    **   flag_alternateform          TRUE if a '#' is present.
    **   flag_altform2               TRUE if a '!' is present.
    **   flag_prefix                 '+' or ' ' or zero
    **   flag_leftjustify            TRUE if a '-' is present or if the
    **                               field width was negative.
    **   flag_zeropad                TRUE if the width began with 0.
    **   flag_long                   1 for "l", 2 for "ll"
    **   width                       The specified field width.  This is
    **                               always non-negative.  Zero is the default.
    **   precision                   The specified precision.  The default
    **                               is -1.
    **   xtype                       The class of the conversion.
    **   infop                       Pointer to the appropriate info struct.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>width</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>precision</name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>xtype</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>etPOINTER</name></expr>:</case>
        <expr_stmt><expr><name>flag_long</name> <operator>=</operator> <ternary><condition><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:
                     <expr><ternary><condition><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator>sizeof<operator>(</operator><name>long</name> <name>int</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
        <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
      <case>case <expr><name>etORDINAL</name></expr>:</case>
      <case>case <expr><name>etRADIX</name></expr>:</case>      
        <expr_stmt><expr><name>cThousand</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
      <case>case <expr><name>etDECIMAL</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name><name>infop</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FLAG_SIGNED</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>getIntArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flag_long</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>flag_long</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>i64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>v</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>,<argument>long int</argument>)</argument_list></macro></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>v</name><operator>==</operator><name>SMALLEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>v</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <operator>~</operator><name>v</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>longvalue</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>flag_prefix</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <operator>(</operator><name>u64</name><operator>)</operator><call><name>getIntArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flag_long</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>flag_long</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>,<argument>unsigned long int</argument>)</argument_list></macro></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>,<argument>unsigned int</argument>)</argument_list></macro></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>longvalue</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>flag_zeropad</name> <operator>&amp;&amp;</operator> <name>precision</name><operator>&lt;</operator><name>width</name><operator>-</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>width</name><operator>-</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&lt;</operator><name>etBUFSIZE</name><operator>-</operator><literal type="number">10</literal><operator>-</operator><name>etBUFSIZE</name><operator>/</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>etBUFSIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zOut</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>u64</name></type> <name>n</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u64</name><operator>)</operator><name>precision</name> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>cThousand</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>precision</name><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>zOut</name> <operator>=</operator> <name>zExtra</name> <operator>=</operator> <call><name>printfTempBuf</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nOut</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>etORDINAL</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zOrd</name><index>[]</index></name> <init>= <expr><literal type="string">"thstndrd"</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>longvalue</name> <operator>%</operator> <literal type="number">10</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">4</literal> <operator>||</operator> <operator>(</operator><name>longvalue</name><operator>/</operator><literal type="number">10</literal><operator>)</operator><operator>%</operator><literal type="number">10</literal><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name><name>zOrd</name><index>[<expr><name>x</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name><name>zOrd</name><index>[<expr><name>x</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cset</name> <init>= <expr><operator>&amp;</operator><name><name>aDigits</name><index>[<expr><name><name>infop</name><operator>-&gt;</operator><name>charset</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u8</name></type> <name>base</name> <init>= <expr><name><name>infop</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
          <do>do<block>{<block_content>                                           <comment type="block">/* Convert to ascii */</comment>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name><name>cset</name><index>[<expr><name>longvalue</name><operator>%</operator><name>base</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <name>longvalue</name><operator>/</operator><name>base</name></expr>;</expr_stmt>
          </block_content>}</block>while<condition>( <expr><name>longvalue</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
        </block_content>}</block>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>bufpt</name><operator>)</operator></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>precision</name><operator>&gt;</operator><name>length</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>                             <comment type="block">/* Zero pad */</comment>
          <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>cThousand</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nn</name> <init>= <expr><operator>(</operator><name>length</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of "," to insert */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>ix</name> <init>= <expr><operator>(</operator><name>length</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>%</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>bufpt</name> <operator>-=</operator> <name>nn</name></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>nn</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>bufpt</name><index>[<expr><name>idx</name><operator>+</operator><name>nn</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ix</name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>ix</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>bufpt</name><index>[<expr><operator>++</operator><name>idx</name></expr>]</index></name> <operator>=</operator> <name>cThousand</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>nn</name><operator>--</operator></expr>;</expr_stmt>
              <expr_stmt><expr><name>ix</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>               <comment type="block">/* Add sign */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_alternateform</name> <operator>&amp;&amp;</operator> <name><name>infop</name><operator>-&gt;</operator><name>prefix</name></name></expr> )</condition><block>{<block_content>      <comment type="block">/* Add "0" or "0x" */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pre</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name></type> <name>x</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>pre</name> <operator>=</operator> <operator>&amp;</operator><name><name>aPrefix</name><index>[<expr><name><name>infop</name><operator>-&gt;</operator><name>prefix</name></name></expr>]</index></name></expr>;</expr_stmt>
          <for>for<control>(<init>;</init> <condition><expr><operator>(</operator><name>x</name><operator>=</operator><operator>(</operator><operator>*</operator><name>pre</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pre</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>bufpt</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>etFLOAT</name></expr>:</case>
      <case>case <expr><name>etEXP</name></expr>:</case>
      <case>case <expr><name>etGENERIC</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>=</operator> <call><name>getDoubleArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>         <comment type="block">/* Set default precision */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_FP_PRECISION_LIMIT</name></cpp:ifdef>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>SQLITE_FP_PRECISION_LIMIT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>SQLITE_FP_PRECISION_LIMIT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>=</operator> <operator>-</operator><name>realvalue</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>flag_prefix</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>etGENERIC</name> <operator>&amp;&amp;</operator> <name>precision</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>precision</name><operator>&gt;</operator><literal type="number">0xfff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>precision</name> <operator>&amp;</operator> <literal type="number">0xfff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rounder</name> <operator>=</operator> <name><name>arRound</name><index>[<expr><name>idx</name><operator>%</operator><literal type="number">10</literal></expr>]</index></name></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>idx</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rounder</name> <operator>*=</operator> <literal type="number">1.0e-10</literal></expr>;</expr_stmt> <expr_stmt><expr><name>idx</name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>etFLOAT</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>rx</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>realvalue</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ex</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1023</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u</name><operator>&gt;&gt;</operator><literal type="number">52</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x7ff</literal><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>precision</name><operator>+</operator><operator>(</operator><name>ex</name><operator>/</operator><literal type="number">3</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">15</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rounder</name> <operator>+=</operator> <name>realvalue</name><operator>*</operator><literal type="number">3e-16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>realvalue</name> <operator>+=</operator> <name>rounder</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Normalize realvalue to within 10.0 &gt; realvalue &gt;= 1.0 */</comment>
        <expr_stmt><expr><name>exp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>realvalue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="string">"NaN"</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&gt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>scale</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">1e100</literal><operator>*</operator><name>scale</name> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1e100</literal></expr>;</expr_stmt><expr_stmt><expr><name>exp</name><operator>+=</operator><literal type="number">100</literal></expr>;</expr_stmt></block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">1e10</literal><operator>*</operator><name>scale</name> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1e10</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>+=</operator><literal type="number">10</literal></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">10.0</literal><operator>*</operator><name>scale</name> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <expr_stmt><expr><name>realvalue</name> <operator>/=</operator> <name>scale</name></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">1e-8</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">1e8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>-=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">1.0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&gt;</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"Inf"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">3</literal><operator>+</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <comment type="block">/*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>!=</operator><name>etFLOAT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>+=</operator> <name>rounder</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">10.0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>etGENERIC</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>flag_rtz</name> <operator>=</operator> <operator>!</operator><name>flag_alternateform</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>exp</name><argument_list type="generic">&lt;<argument><expr><operator>-</operator><literal type="number">4</literal> <operator>||</operator> <name>exp</name></expr></argument>&gt;</argument_list></name><name>precision</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>etEXP</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>exp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>etFLOAT</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>flag_rtz</name> <operator>=</operator> <name>flag_altform2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>etEXP</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>e2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>e2</name> <operator>=</operator> <name>exp</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>szBufNeeded</name></decl>;</decl_stmt>           <comment type="block">/* Size of a temporary buffer needed */</comment>
          <expr_stmt><expr><name>szBufNeeded</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>e2</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>+</operator><operator>(</operator><name>i64</name><operator>)</operator><name>precision</name><operator>+</operator><operator>(</operator><name>i64</name><operator>)</operator><name>width</name><operator>+</operator><literal type="number">15</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>szBufNeeded</name> <operator>&gt;</operator> <name>etBUFSIZE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>zExtra</name> <operator>=</operator> <call><name>printfTempBuf</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>szBufNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>bufpt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>zOut</name> <operator>=</operator> <name>bufpt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nsd</name> <operator>=</operator> <literal type="number">16</literal> <operator>+</operator> <name>flag_altform2</name><operator>*</operator><literal type="number">10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>flag_dp</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>precision</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <name>flag_alternateform</name> <operator>|</operator> <name>flag_altform2</name></expr>;</expr_stmt>
        <comment type="block">/* The sign in front of the number */</comment>
        <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Digits prior to the decimal point */</comment>
        <if_stmt><if>if<condition>( <expr><name>e2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <for>for<control>(<init>;</init> <condition><expr><name>e2</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>e2</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <call><name>et_getdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* The decimal point */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_dp</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* "0" digits after the decimal point but before the first
        ** significant digit of the number */</comment>
        <for>for<control>(<init><expr><name>e2</name><operator>++</operator></expr>;</init> <condition><expr><name>e2</name><operator>&lt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>precision</name><operator>--</operator></expr><operator>,</operator> <expr><name>e2</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>precision</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* Significant digits after the decimal point */</comment>
        <while>while<condition>( <expr><operator>(</operator><name>precision</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <call><name>et_getdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Remove trailing zeros and the "." if no digits follow the "." */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_rtz</name> <operator>&amp;&amp;</operator> <name>flag_dp</name></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><name><name>bufpt</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bufpt</name><operator>&gt;</operator><name>zOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>bufpt</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>flag_altform2</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Add the "eNNN" suffix */</comment>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>etEXP</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>aDigits</name><index>[<expr><name><name>infop</name><operator>-&gt;</operator><name>charset</name></name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name> <operator>=</operator> <operator>-</operator><name>exp</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&gt;=</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>exp</name><operator>/</operator><literal type="number">100</literal><operator>)</operator><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>        <comment type="block">/* 100's digit */</comment>
            <expr_stmt><expr><name>exp</name> <operator>%=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>exp</name><operator>/</operator><literal type="number">10</literal><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>             <comment type="block">/* 10's digit */</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>exp</name><operator>%</operator><literal type="number">10</literal><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>             <comment type="block">/* 1's digit */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>bufpt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* The converted number is in buf[] and zero terminated. Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions. */</comment>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>bufpt</name><operator>-</operator><name>zOut</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>zOut</name></expr>;</expr_stmt>

        <comment type="block">/* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_zeropad</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>flag_leftjustify</name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&lt;</operator> <name>width</name></expr>)</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nPad</name> <init>= <expr><name>width</name> <operator>-</operator> <name>length</name></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>width</name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name>nPad</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>bufpt</name><index>[<expr><name>i</name><operator>-</operator><name>nPad</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <name>prefix</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>nPad</name><operator>--</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_FLOATING_POINT) */</comment>
        <break>break;</break>
      <case>case <expr><name>etSIZE</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bArgList</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name><name>pAccum</name><operator>-&gt;</operator><name>nChar</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>etPERCENT</name></expr>:</case>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>etCHARX</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <call><name>getTextArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bufpt</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
              <while>while<condition>( <expr><name>length</name><operator>&lt;</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>bufpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>buf</name><index>[<expr><name>length</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ch</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>ap</argument>,<argument>unsigned int</argument>)</argument_list></macro></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>ch</name><operator>&lt;</operator><literal type="number">0x00080</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ch</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ch</name><operator>&lt;</operator><literal type="number">0x00800</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xc0</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x1f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ch</name><operator>&lt;</operator><literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xe0</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xf0</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name><operator>&gt;&gt;</operator><literal type="number">18</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>width</name> <operator>-=</operator> <name>precision</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>width</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>flag_leftjustify</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>width</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <while>while<condition>( <expr><name>precision</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>flag_altform2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>adjust_width_for_utf8</name>;</goto>
      <case>case <expr><name>etSTRING</name></expr>:</case>
      <case>case <expr><name>etDYNSTRING</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <call><name>getTextArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>etSTRING</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>bufpt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>xtype</name><operator>==</operator><name>etDYNSTRING</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pAccum</name><operator>-&gt;</operator><name>nChar</name></name><operator>==</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name><name>pAccum</name><operator>-&gt;</operator><name>mxAlloc</name></name>
           <operator>&amp;&amp;</operator> <name>width</name><operator>==</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name>precision</name><operator>&lt;</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name><name>pAccum</name><operator>-&gt;</operator><name>accError</name></name><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <comment type="block">/* Special optimization for sqlite3_mprintf("%z..."):
            ** Extend an existing memory allocation rather than creating
            ** a new one. */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pAccum</name><operator>-&gt;</operator><name>printfFlags</name></name><operator>&amp;</operator><name>SQLITE_PRINTF_MALLOCED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pAccum</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name>bufpt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pAccum</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>bufpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pAccum</name><operator>-&gt;</operator><name>nChar</name></name> <operator>=</operator> <literal type="number">0x7fffffff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>bufpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pAccum</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>|=</operator> <name>SQLITE_PRINTF_MALLOCED</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zExtra</name> <operator>=</operator> <name>bufpt</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>flag_altform2</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Set length to the number of bytes needed in order to display
            ** precision characters */</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>bufpt</name></expr></init></decl>;</decl_stmt>
            <while>while<condition>( <expr><name>precision</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>bufpt</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <for>for<control>(<init><expr><name>length</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>length</name><operator>&lt;</operator><name>precision</name> <operator>&amp;&amp;</operator> <name><name>bufpt</name><index>[<expr><name>length</name></expr>]</index></name></expr>;</condition> <incr><expr><name>length</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0x7fffffff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>bufpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <label><name>adjust_width_for_utf8</name>:</label>
        <if_stmt><if>if<condition>( <expr><name>flag_altform2</name> <operator>&amp;&amp;</operator> <name>width</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Adjust width to account for extra bytes in UTF-8 characters */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><name>ii</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>bufpt</name><index>[<expr><name>ii</name><operator>--</operator></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>width</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      <case>case <expr><name>etSQLESCAPE</name></expr>:</case>           <comment type="block">/* %q: Escape ' characters */</comment>
      <case>case <expr><name>etSQLESCAPE2</name></expr>:</case>          <comment type="block">/* %Q: Escape ' and enclose in '...' */</comment>
      <case>case <expr><name>etSQLESCAPE3</name></expr>:</case> <block>{<block_content>        <comment type="block">/* %w: Escape " characters */</comment>
        <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>needQuote</name></decl>, <decl><type ref="prev"/><name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>xtype</name><operator>==</operator><name>etSQLESCAPE3</name><operator>)</operator></expr>?</condition><then><expr><literal type="char">'"'</literal></expr></then><else>:<expr><literal type="char">'\''</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* Quote character */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escarg</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>bArgList</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>escarg</name> <operator>=</operator> <call><name>getTextArg</name><argument_list>(<argument><expr><name>pArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>escarg</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>escarg</name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isnull</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>escarg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>xtype</name><operator>==</operator><name>etSQLESCAPE2</name></expr> ?</condition><then> <expr><literal type="string">"NULL"</literal></expr> </then><else>: <expr><literal type="string">"(NULL)"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* For %q, %Q, and %w, the precision is the number of bytes (or
        ** characters if the ! flags is present) to use from the input.
        ** Because of the extra quoting characters inserted, the number
        ** of output characters may be larger than the precision.
        */</comment>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ch</name><operator>=</operator><name><name>escarg</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>k</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>ch</name><operator>==</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>flag_altform2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ch</name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
            <while>while<condition>( <expr><operator>(</operator><name><name>escarg</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>needQuote</name> <operator>=</operator> <operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>xtype</name><operator>==</operator><name>etSQLESCAPE2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name>etBUFSIZE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>zExtra</name> <operator>=</operator> <call><name>printfTempBuf</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bufpt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>needQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name> <operator>=</operator> <name><name>escarg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>ch</name><operator>==</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>needQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        <goto>goto <name>adjust_width_for_utf8</name>;</goto>
      </block_content>}</block>
      <case>case <expr><name>etTOKEN</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pAccum</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PRINTF_INTERNAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>flag_alternateform</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* %#T means an Expr pointer that uses Expr.u.zToken */</comment>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>Expr</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* %T means a Token pointer */</comment>
          <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>Token</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bArgList</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pToken</name> <operator>&amp;&amp;</operator> <name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3RecordErrorByteOffset</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>etSRCITEM</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pAccum</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PRINTF_INTERNAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pItem</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>SrcItem</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bArgList</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>flag_altform2</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSel</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_NestedFrom</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><literal type="string">"(join-%u)"</literal></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>selId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><literal type="string">"(subquery-%u)"</literal></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>selId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xtype</name><operator>==</operator><name>etINVALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block>
    </block_content>}</block></switch><comment type="block">/* End switch over the format type */</comment>
    <comment type="block">/*
    ** The text of the conversion is pointed to by "bufpt" and is
    ** "length" characters long.  The field width is "width".  Do
    ** the output.  Both length and width are in bytes, not characters,
    ** at this point.  If the "!" flag was present on string conversions
    ** indicating that width and precision should be expressed in characters,
    ** then the values have been translated prior to reaching this point.
    */</comment>
    <expr_stmt><expr><name>width</name> <operator>-=</operator> <name>length</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>width</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>flag_leftjustify</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>bufpt</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>flag_leftjustify</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>bufpt</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>zExtra</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zExtra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for><comment type="block">/* End for loop over the format string */</comment>
</block_content>}</block></function> <comment type="block">/* End of function */</comment>


<comment type="block">/*
** The z string points to the first character of a token that is
** associated with an error.  If db does not already have an error
** byte offset recorded, try to compute the error byte offset for
** z and set the error byte offset in db.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RecordErrorByteOffset</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>db</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pParse</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zText</name> <operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>zTail</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>zText</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zText</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>zText</name></expr></argument>,<argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name><operator>-</operator><name>zText</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If pExpr has a byte offset for the start of a token, record that as
** as the error offset.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RecordErrorOffsetOfExpr</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>pExpr</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iOfst</name></name><operator>&lt;=</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iOfst</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Enlarge the memory allocation on a StrAccum object so that it is
** able to accept at least N more bytes of text.
**
** Return the number of bytes of text that StrAccum is able to accept
** after the attempted enlargement.  The value returned might be zero.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3StrAccumEnlarge</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>+</operator><operator>(</operator><name>i64</name><operator>)</operator><name>N</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Only called if really needed */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name><operator>==</operator><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3StrAccumSetError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nChar</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOld</name> <init>= <expr><ternary><condition><expr><call><name>isMalloced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>szNew</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>szNew</name> <operator>+=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>N</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>szNew</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Force exponential buffer size growth as long as it does not overflow,
      ** to avoid having to call this routine too often */</comment>
      <expr_stmt><expr><name>szNew</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>szNew</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StrAccumSetError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>szNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3Realloc</name><argument_list>(<argument><expr><name>zOld</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isMalloced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>|=</operator> <name>SQLITE_PRINTF_MALLOCED</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StrAccumSetError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>N</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append N copies of character c to the given string buffer.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_str_appendchar</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name> <operator>+</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>N</name> <operator>&gt;</operator> <literal type="number">0x7fffffff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>+</operator><operator>(</operator><name>i64</name><operator>)</operator><name>N</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>N</name> <operator>=</operator> <call><name>sqlite3StrAccumEnlarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>N</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
** The StrAccum "p" is not large enough to accept N new bytes of z[].
** So enlarge if first, then do the append.
**
** This is a helper routine to sqlite3_str_append() that does special-case
** work (enlarging the buffer) using tail recursion, so that the
** sqlite3_str_append() routine can use fast calling semantics.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>SQLITE_NOINLINE</name></type> <name>enlargeAndAppend</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>N</name> <operator>=</operator> <call><name>sqlite3StrAccumEnlarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zText</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Append N bytes of text from z to the StrAccum object.  Increase the
** size of the memory allocation for StrAccum if necessary.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_str_append</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>N</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>accError</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>N</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>+</operator><name>N</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>enlargeAndAppend</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>N</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zText</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>-</operator><name>N</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Append the complete text of zero-terminated string z[] to the p string.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_str_appendall</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Finish off a string by making sure it is zero-terminated.
** Return a pointer to the resulting string.  Return a NULL
** pointer if any kind of error was encountered.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>char</name> <modifier>*</modifier></type><name>strAccumFinishRealloc</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zText</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isMalloced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zText</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>|=</operator> <name>SQLITE_PRINTF_MALLOCED</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3StrAccumSetError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name>zText</name></expr>;</expr_stmt>
  <return>return <expr><name>zText</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3StrAccumFinish</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isMalloced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>strAccumFinishRealloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Use the content of the StrAccum passed as the second argument
** as the result of an SQL function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResultStrAccum</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>isMalloced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This singleton is an sqlite3_str object that is returned if
** sqlite3_malloc() fails to provide space for a real one.  This
** sqlite3_str object accepts no new text and always returns
** an SQLITE_NOMEM error.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_str</name></type> <name>sqlite3OomStr</name> <init>= <expr><block>{
   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SQLITE_NOMEM</name></expr>, <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Finalize a string created using sqlite3_str_new().
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_str_finish</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p</name><operator>!=</operator><operator>&amp;</operator><name>sqlite3OomStr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return any error code associated with p */</comment>
<function><type><name>int</name></type> <name>sqlite3_str_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current length of p in bytes */</comment>
<function><type><name>int</name></type> <name>sqlite3_str_length</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current value for p */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_str_value</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nChar</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset an StrAccum string.  Reclaim all malloced memory.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_str_reset</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>isMalloced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_PRINTF_MALLOCED</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a string accumulator.
**
** p:     The accumulator to be initialized.
** db:    Pointer to a database connection.  May be NULL.  Lookaside
**        memory is used if not NULL. db-&gt;mallocFailed is set appropriately
**        when not NULL.
** zBase: An initial buffer.  May be NULL in which case the initial buffer
**        is malloced.
** n:     Size of zBase in bytes.  If total space requirements never exceed
**        n then no memory allocations ever occur.
** mx:    Maximum number of bytes to accumulate.  If mx==0 then no memory
**        allocations will ever occur.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StrAccumInit</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name>zBase</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxAlloc</name></name> <operator>=</operator> <name>mx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>accError</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>printfFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocate and initialize a new dynamic string object */</comment>
<function><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>sqlite3_str_new</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>db</name></expr> ?</condition><then> <expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> </then><else>: <expr><name>SQLITE_MAX_LENGTH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name>sqlite3OomStr</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print into memory obtained from sqliteMalloc().  Use the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3VMPrintf</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBase</name><index>[<expr><name>SQLITE_PRINT_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zBase</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBase</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>acc</name><operator>.</operator><name>printfFlags</name></name> <operator>=</operator> <name>SQLITE_PRINTF_INTERNAL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>acc</name><operator>.</operator><name>accError</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print into memory obtained from sqliteMalloc().  Use the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3MPrintf</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print into memory obtained from sqlite3_malloc().  Omit the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_vmprintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBase</name><index>[<expr><name>SQLITE_PRINT_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>  
  <if_stmt><if>if<condition>( <expr><name>zFormat</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBase</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBase</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print into memory obtained from sqlite3_malloc()().  Omit the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_mprintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** sqlite3_snprintf() works like snprintf() except that it ignores the
** current locale settings.  This is important for SQLite because we
** are not able to use a "," as the decimal point in place of "." as
** specified by some locales.
**
** Oops:  The first two arguments of sqlite3_snprintf() are backwards
** from the snprintf() standard.  Unfortunately, it is too late to change
** this without breaking compatibility, so we just have to live with the
** mistake.
**
** sqlite3_vsnprintf() is the varargs version.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_vsnprintf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zBuf</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zFormat</name><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>zBuf</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name><name>acc</name><operator>.</operator><name>nChar</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>zBuf</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_snprintf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vsnprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the routine that actually formats the sqlite3_log() message.
** We house it in a separate routine from sqlite3_log() to avoid using
** stack space on small-stack systems when logging is disabled.
**
** sqlite3_log() must render into a static buffer.  It cannot dynamically
** allocate memory because it might be called while the memory allocator
** mutex is held.
**
** sqlite3_str_vappendf() might ask for *temporary* memory allocations for
** certain format characters (%q) or for very large precisions or widths.
** Care must be taken that any sqlite3_log() calls that occur while the
** memory mutex is held do not use these mechanisms.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renderLogMsg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iErrCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>                          <comment type="block">/* String accumulator */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zMsg</name><index>[<expr><name>SQLITE_PRINT_BUF_SIZE</name><operator>*</operator><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Complete log message */</comment>

  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pLogArg</name></name></expr></argument>, <argument><expr><name>iErrCode</name></expr></argument>,
                           <argument><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Format and write a message to the log if logging is enabled.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_log</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iErrCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>                             <comment type="block">/* Vararg list */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>renderLogMsg</name><argument_list>(<argument><expr><name>iErrCode</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_OS_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** A version of printf() that understands %lld.  Used for debugging.
** The printf() built into some versions of windows does not understand %lld
** and segfaults if you give it a long long int.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DebugPrintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><name>SQLITE_PRINT_BUF_SIZE</name><operator>*</operator><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OS_TRACE_PROC</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name></type> <name>SQLITE_OS_TRACE_PROC</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>zBuf</name></expr></argument>, <argument><expr><name>int</name> <name>nBuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SQLITE_OS_TRACE_PROC</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** variable-argument wrapper around sqlite3_str_vappendf(). The bFlags argument
** can contain the bit SQLITE_PRINTF_INTERNAL enable internal formats.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_str_appendf</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
