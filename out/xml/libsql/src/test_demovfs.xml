<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/test_demovfs.c"><comment type="block">/*
** 2010 April 7
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements an example of a simple VFS implementation that 
** omits complex features often not required or not possible on embedded
** platforms.  Code is included to buffer writes to the journal file, 
** which can be a significant performance improvement on some embedded
** platforms.
**
** OVERVIEW
**
**   The code in this file implements a minimal SQLite VFS that can be 
**   used on Linux and other posix-like operating systems. The following 
**   system calls are used:
**
**    File-system: access(), unlink(), getcwd()
**    File IO:     open(), read(), write(), fsync(), close(), fstat()
**    Other:       sleep(), usleep(), time()
**
**   The following VFS features are omitted:
**
**     1. File locking. The user must ensure that there is at most one
**        connection to each database when using this VFS. Multiple
**        connections to a single shared-cache count as a single connection
**        for the purposes of the previous statement.
**
**     2. The loading of dynamic extensions (shared libraries).
**
**     3. Temporary files. The user must configure SQLite to use in-memory
**        temp files when using this VFS. The easiest way to do this is to
**        compile with:
**
**          -DSQLITE_TEMP_STORE=3
**
**     4. File truncation. As of version 3.6.24, SQLite may run without
**        a working xTruncate() call, providing the user does not configure
**        SQLite to use "journal_mode=truncate", or use both
**        "journal_mode=persist" and ATTACHed databases.
**
**   It is assumed that the system uses UNIX-like path-names. Specifically,
**   that '/' characters are used to separate path components and that
**   a path-name is a relative path unless it begins with a '/'. And that
**   no UTF-8 encoded paths are greater than 512 bytes in length.
**
** JOURNAL WRITE-BUFFERING
**
**   To commit a transaction to the database, SQLite first writes rollback
**   information into the journal file. This usually consists of 4 steps:
**
**     1. The rollback information is sequentially written into the journal
**        file, starting at the start of the file.
**     2. The journal file is synced to disk.
**     3. A modification is made to the first few bytes of the journal file.
**     4. The journal file is synced to disk again.
**
**   Most of the data is written in step 1 using a series of calls to the
**   VFS xWrite() method. The buffers passed to the xWrite() calls are of
**   various sizes. For example, as of version 3.6.24, when committing a 
**   transaction that modifies 3 pages of a database file that uses 4096 
**   byte pages residing on a media with 512 byte sectors, SQLite makes 
**   eleven calls to the xWrite() method to create the rollback journal, 
**   as follows:
**
**             Write offset | Bytes written
**             ----------------------------
**                        0            512
**                      512              4
**                      516           4096
**                     4612              4
**                     4616              4
**                     4620           4096
**                     8716              4
**                     8720              4
**                     8724           4096
**                    12820              4
**             ++++++++++++SYNC+++++++++++
**                        0             12
**             ++++++++++++SYNC+++++++++++
**
**   On many operating systems, this is an efficient way to write to a file.
**   However, on some embedded systems that do not cache writes in OS 
**   buffers it is much more efficient to write data in blocks that are
**   an integer multiple of the sector-size in size and aligned at the
**   start of a sector.
**
**   To work around this, the code in this file allocates a fixed size
**   buffer of SQLITE_DEMOVFS_BUFFERSZ using sqlite3_malloc() whenever a 
**   journal file is opened. It uses the buffer to coalesce sequential
**   writes into aligned SQLITE_DEMOVFS_BUFFERSZ blocks. When SQLite
**   invokes the xSync() method to sync the contents of the file to disk,
**   all accumulated data is written out, even if it does not constitute
**   a complete block. This means the actual IO to create the rollback 
**   journal for the example transaction above is this:
**
**             Write offset | Bytes written
**             ----------------------------
**                        0           8192
**                     8192           4632
**             ++++++++++++SYNC+++++++++++
**                        0             12
**             ++++++++++++SYNC+++++++++++
**
**   Much more efficient if the underlying OS is not caching write 
**   operations.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_OS_UNIX</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Size of the write buffer used by journal files in bytes.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEMOVFS_BUFFERSZ</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEMOVFS_BUFFERSZ</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The maximum pathname length supported by this VFS.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHNAME</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/*
** When using this VFS, the sqlite3_file* handles that SQLite uses are
** actually pointers to instances of type DemoFile.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>DemoFile</name></name></type> <name>DemoFile</name>;</typedef>
<struct>struct <name>DemoFile</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_file</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class. Must be first. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                         <comment type="block">/* File descriptor */</comment>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>                  <comment type="block">/* Pointer to malloc'd buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name></decl>;</decl_stmt>                    <comment type="block">/* Valid bytes of data in zBuffer */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBufferOfst</name></decl>;</decl_stmt>      <comment type="block">/* Offset in file of zBuffer[0] */</comment>
}</block>;</struct>

<comment type="block">/*
** Write directly to the file passed as the first argument. Even if the
** file has a write-buffer (DemoFile.aBuffer), ignore it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoDirectWrite</name><parameter_list>(
  <parameter><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                    <comment type="block">/* File handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,               <comment type="block">/* Buffer containing data to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,                       <comment type="block">/* Size of data to write in bytes */</comment>
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>              <comment type="block">/* File offset to write to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>off_t</name></type> <name>ofst</name></decl>;</decl_stmt>                     <comment type="block">/* Return value from lseek() */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nWrite</name></decl>;</decl_stmt>                  <comment type="block">/* Return value from write() */</comment>

  <expr_stmt><expr><name>ofst</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>!=</operator><name>iOfst</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_WRITE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>!=</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_WRITE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush the contents of the DemoFile.aBuffer buffer to disk. This is a
** no-op if this particular file does not have a buffer (i.e. it is not
** a journal file) or if the buffer is currently empty.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFlushBuffer</name><parameter_list>(<parameter><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoDirectWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read data from a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>off_t</name></type> <name>ofst</name></decl>;</decl_stmt>                     <comment type="block">/* Return value from lseek() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                      <comment type="block">/* Return value from read() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code from demoFlushBuffer() */</comment>

  <comment type="block">/* Flush any data in the write buffer to disk in case this operation
  ** is trying to read data the file-region currently cached in the buffer.
  ** It would be possible to detect this case and possibly save an 
  ** unnecessary write here, but in practice SQLite will rarely read from
  ** a journal file when there is data cached in the write-buffer.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>ofst</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>!=</operator><name>iOfst</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_READ</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nRead</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>==</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nRead</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>&lt;</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zBuf</name><operator>)</operator><index>[<expr><name>nRead</name></expr>]</index></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iAmt</name><operator>-</operator><name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_IOERR_READ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write data to a crash-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Pointer to remaining data to write */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>iAmt</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of bytes at z */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name> <init>= <expr><name>iOfst</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* File offset to write to */</comment>

    <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes to copy into buffer */</comment>

      <comment type="block">/* If the buffer is full, or if this data is not being written directly
      ** following the data already buffered, flush the buffer. Flushing
      ** the buffer is a no-op if it is empty.  
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><name>SQLITE_DEMOVFS_BUFFERSZ</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>!=</operator><name>i</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name> <operator>=</operator> <name>i</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>

      <comment type="block">/* Copy as much data as possible into the buffer. */</comment>
      <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>SQLITE_DEMOVFS_BUFFERSZ</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><name>n</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>n</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>demoDirectWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate a file. This is a no-op for this VFS (see header comments at
** the top of the file).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  if( ftruncate(((DemoFile *)pFile)-&gt;fd, size) ) return SQLITE_IOERR_TRUNCATE;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync the contents of the file to the persistent media.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_IOERR_FSYNC</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write the size of the file in bytes to *pSize.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code from fstat() call */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>              <comment type="block">/* Output of fstat() call */</comment>

  <comment type="block">/* Flush the contents of the buffer to disk. As with the flush in the
  ** demoRead() method, it would be possible to avoid this and save a write
  ** here and there. But in practice this comes up so infrequently it is
  ** not worth the trouble.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name><name>sStat</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Locking functions. The xLock() and xUnlock() methods are both no-ops.
** The xCheckReservedLock() always indicates that no other process holds
** a reserved lock on the database file. This ensures that if a hot-journal
** file is found in the file-system it is rolled back.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** No xFileControl() verbs are implemented by this VFS.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xSectorSize() and xDeviceCharacteristics() methods. These two
** may return special values allowing SQLite to optimize file-system 
** access to some extent. But it is also safe to simply return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a file handle.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,              <comment type="block">/* VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* File to open, or 0 for a temp file */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,            <comment type="block">/* Pointer to DemoFile struct to populate */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                      <comment type="block">/* Input SQLITE_OPEN_XXX flags */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>                  <comment type="block">/* Output SQLITE_OPEN_XXX flags (or NULL) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name></type> <name>demoio</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><name>demoClose</name></expr>,                    <comment type="block">/* xClose */</comment>
    <expr><name>demoRead</name></expr>,                     <comment type="block">/* xRead */</comment>
    <expr><name>demoWrite</name></expr>,                    <comment type="block">/* xWrite */</comment>
    <expr><name>demoTruncate</name></expr>,                 <comment type="block">/* xTruncate */</comment>
    <expr><name>demoSync</name></expr>,                     <comment type="block">/* xSync */</comment>
    <expr><name>demoFileSize</name></expr>,                 <comment type="block">/* xFileSize */</comment>
    <expr><name>demoLock</name></expr>,                     <comment type="block">/* xLock */</comment>
    <expr><name>demoUnlock</name></expr>,                   <comment type="block">/* xUnlock */</comment>
    <expr><name>demoCheckReservedLock</name></expr>,        <comment type="block">/* xCheckReservedLock */</comment>
    <expr><name>demoFileControl</name></expr>,              <comment type="block">/* xFileControl */</comment>
    <expr><name>demoSectorSize</name></expr>,               <comment type="block">/* xSectorSize */</comment>
    <expr><name>demoDeviceCharacteristics</name></expr>     <comment type="block">/* xDeviceCharacteristics */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Populate this structure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* flags to pass to open() call */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>SQLITE_DEMOVFS_BUFFERSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aBuf</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_EXCLUSIVE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oflags</name> <operator>|=</operator> <name>O_EXCL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_CREATE</name></expr> )</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>oflags</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_READONLY</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>oflags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_READWRITE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oflags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DemoFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>oflags</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <name>aBuf</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutFlags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>demoio</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete the file identified by argument zPath. If the dirSync parameter
** is non-zero, then ensure the file-system modification to delete the
** file has been synced to disk before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dirSync</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>ENOENT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dirSync</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>dfd</name></decl>;</decl_stmt>                      <comment type="block">/* File descriptor open on directory */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Iterator variable */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSlash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Name of directory containing file zPath */</comment>

    <comment type="block">/* Figure out the directory name from the path of the file deleted. */</comment>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>MAXPATHNAME</name></expr></argument>, <argument><expr><name>zDir</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSlash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>,<argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSlash</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Open a file-descriptor on the directory. Sync. Close. */</comment>
      <expr_stmt><expr><name><name>zSlash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>dfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>dfd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_IOERR_DELETE</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>F_OK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>F_OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>R_OK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>R_OK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>W_OK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>W_OK</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Query the file-system to see if the named file exists, is readable or
** is both readable and writable.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoAccess</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* access() return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eAccess</name> <init>= <expr><name>F_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Second argument to access() */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_EXISTS</name>       <comment type="block">/* access(zPath, F_OK) */</comment>
       <operator>||</operator> <name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READ</name>         <comment type="block">/* access(zPath, R_OK) */</comment>
       <operator>||</operator> <name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READWRITE</name></expr></argument>    <comment type="block">/* access(zPath, R_OK|W_OK) */</comment>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READWRITE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eAccess</name> <operator>=</operator> <name>R_OK</name><operator>|</operator><name>W_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READ</name></expr> )</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>eAccess</name> <operator>=</operator> <name>R_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>access</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>eAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <operator>(</operator><name>rc</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument zPath points to a nul-terminated string containing a file path.
** If zPath is an absolute path, then it is copied as is into the output 
** buffer. Otherwise, if it is a relative path, then the equivalent full
** path is written to the output buffer.
**
** This function assumes that paths are UNIX style. Specifically, that:
**
**   1. Path components are separated by a '/'. and 
**   2. Full paths begin with a '/' character.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFullPathname</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,              <comment type="block">/* VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,              <comment type="block">/* Input path (possibly a relative path) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPathOut</name></decl></parameter>,                   <comment type="block">/* Size of output buffer in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPathOut</name></decl></parameter>                  <comment type="block">/* Pointer to output buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>zDir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>getcwd</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nPathOut</name></expr></argument>, <argument><expr><name>zPathOut</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>zDir</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zPathOut</name><index>[<expr><name>nPathOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following four VFS methods:
**
**   xDlOpen
**   xDlError
**   xDlSym
**   xDlClose
**
** are supposed to implement the functionality needed by SQLite to load
** extensions compiled as shared objects. This simple VFS does not support
** this functionality, so the following functions are no-ops.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>demoDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>demoDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><literal type="string">"Loadable extensions are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zErrMsg</name><index>[<expr><name>nByte</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*demoDlSym(sqlite3_vfs *pVfs, void *pH, const char *z)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator><block>{
  <return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>demoDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pHandle</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameter zByte points to a buffer nByte bytes in size. Populate this
** buffer with pseudo-random data.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sleep for at least nMicro microseconds. Return the (approximate) number 
** of microseconds slept for.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMicro</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>nMicro</name> <operator>/</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>nMicro</name> <operator>%</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nMicro</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set *pTime to the current UTC time expressed as a Julian day. Return
** SQLITE_OK if successful, or an error code otherwise.
**
**   http://en.wikipedia.org/wiki/Julian_day
**
** This implementation is not very good. The current time is rounded to
** an integer number of seconds. Also, assuming time_t is a signed 32-bit 
** value, it will stop working some time in the year 2038 AD (the so-called
** "year 2038" problem that afflicts systems that store time this way). 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pTime</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pTime</name> <operator>=</operator> <name>t</name><operator>/</operator><literal type="number">86400.0</literal> <operator>+</operator> <literal type="number">2440587.5</literal></expr>;</expr_stmt> 
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function returns a pointer to the VFS implemented in this file.
** To make the VFS available to SQLite:
**
**   sqlite3_vfs_register(sqlite3_demovfs(), 0);
*/</comment>
<function><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>sqlite3_demovfs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name></type> <name>demovfs</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DemoFile</name></expr></argument>)</argument_list></sizeof></expr>,             <comment type="block">/* szOsFile */</comment>
    <expr><name>MAXPATHNAME</name></expr>,                  <comment type="block">/* mxPathname */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* pNext */</comment>
    <expr><literal type="string">"demo"</literal></expr>,                       <comment type="block">/* zName */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* pAppData */</comment>
    <expr><name>demoOpen</name></expr>,                     <comment type="block">/* xOpen */</comment>
    <expr><name>demoDelete</name></expr>,                   <comment type="block">/* xDelete */</comment>
    <expr><name>demoAccess</name></expr>,                   <comment type="block">/* xAccess */</comment>
    <expr><name>demoFullPathname</name></expr>,             <comment type="block">/* xFullPathname */</comment>
    <expr><name>demoDlOpen</name></expr>,                   <comment type="block">/* xDlOpen */</comment>
    <expr><name>demoDlError</name></expr>,                  <comment type="block">/* xDlError */</comment>
    <expr><name>demoDlSym</name></expr>,                    <comment type="block">/* xDlSym */</comment>
    <expr><name>demoDlClose</name></expr>,                  <comment type="block">/* xDlClose */</comment>
    <expr><name>demoRandomness</name></expr>,               <comment type="block">/* xRandomness */</comment>
    <expr><name>demoSleep</name></expr>,                    <comment type="block">/* xSleep */</comment>
    <expr><name>demoCurrentTime</name></expr>,              <comment type="block">/* xCurrentTime */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>&amp;</operator><name>demovfs</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_TEST) || SQLITE_OS_UNIX */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_SQLITE_TCL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"sqlite_tcl.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>SQLITE_TCLAPI</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_TCLAPI</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>register_demovfs</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>, <comment type="block">/* Pointer to sqlite3_enable_XXX function */</comment>
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,    <comment type="block">/* The TCL interpreter that invoked this command */</comment>
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,              <comment type="block">/* Number of arguments */</comment>
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>  <comment type="block">/* Command arguments */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><call><name>sqlite3_demovfs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>unregister_demovfs</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>, <comment type="block">/* Pointer to sqlite3_enable_XXX function */</comment>
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,    <comment type="block">/* The TCL interpreter that invoked this command */</comment>
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,              <comment type="block">/* Number of arguments */</comment>
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>  <comment type="block">/* Command arguments */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_vfs_unregister</name><argument_list>(<argument><expr><call><name>sqlite3_demovfs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register commands with the TCL interpreter.
*/</comment>
<function><type><name>int</name></type> <name>Sqlitetest_demovfs_Init</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"register_demovfs"</literal></expr></argument>, <argument><expr><name>register_demovfs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"unregister_demovfs"</literal></expr></argument>, <argument><expr><name>unregister_demovfs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>int</name></type> <name>Sqlitetest_demovfs_Init</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>TCL_OK</name></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>
</unit>
