<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/build.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the SQLite parser
** when syntax rules are reduced.  The routines in this file handle the
** following kinds of SQL syntax:
**
**     CREATE TABLE
**     DROP TABLE
**     CREATE INDEX
**     DROP INDEX
**     creating ID lists
**     BEGIN TRANSACTION
**     COMMIT
**     ROLLBACK
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** The TableLock structure is only used by the sqlite3TableLock() and
** codeTableLocks() functions.
*/</comment>
<struct>struct <name>TableLock</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>               <comment type="block">/* The database containing the table to be locked */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iTab</name></decl>;</decl_stmt>             <comment type="block">/* The root page of the table to be locked */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isWriteLock</name></decl>;</decl_stmt>        <comment type="block">/* True for write lock.  False for a read lock */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLockName</name></decl>;</decl_stmt> <comment type="block">/* Name of the table */</comment>
}</block>;</struct>

<comment type="block">/*
** Record the fact that we want to lock a table at run-time.  
**
** The table to be locked has root page iTab and is found in database iDb.
** A read or a write lock can be taken depending on isWritelock.
**
** This routine just records the fact that the lock is desired.  The
** code to make the lock occur is generated by a later call to
** codeTableLocks() which occurs during sqlite3FinishCoding().
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>lockTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,           <comment type="block">/* Index of the database containing the table to lock */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iTab</name></decl></parameter>,         <comment type="block">/* Root page number of the table to be locked */</comment>
  <parameter><decl><type><name>u8</name></type> <name>isWriteLock</name></decl></parameter>,    <comment type="block">/* True for a write lock */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>  <comment type="block">/* Name of the table to be locked */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TableLock</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pToplevel</name> <operator>=</operator> <call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>nTableLock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>aTableLock</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name><operator>==</operator><name>iDb</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTab</name></name><operator>==</operator><name>iTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isWriteLock</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>isWriteLock</name></name> <operator>||</operator> <name>isWriteLock</name><operator>)</operator></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>nBytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TableLock</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>nTableLock</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>aTableLock</name></name> <operator>=</operator>
      <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>aTableLock</name></name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pToplevel</name><operator>-&gt;</operator><name>aTableLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>aTableLock</name><index>[<expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nTableLock</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isWriteLock</name></name> <operator>=</operator> <name>isWriteLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zLockName</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nTableLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3TableLock</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,           <comment type="block">/* Index of the database containing the table to lock */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>iTab</name></decl></parameter>,         <comment type="block">/* Root page number of the table to be locked */</comment>
  <parameter><decl><type><name>u8</name></type> <name>isWriteLock</name></decl></parameter>,    <comment type="block">/* True for a write lock */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>  <comment type="block">/* Name of the table to be locked */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3BtreeSharable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lockTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>isWriteLock</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Code an OP_TableLock instruction for each table locked by the
** statement (configured by calls to sqlite3TableLock()).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeTableLocks</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVdbe</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTableLock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>TableLock</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aTableLock</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>p1</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>pVdbe</name></expr></argument>, <argument><expr><name>OP_TableLock</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>isWriteLock</name></name></expr></argument>,
                      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLockName</name></name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>codeTableLocks</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return TRUE if the given yDbMask object is empty - if it contains no
** 1 bits.  This routine is used by the DbMaskAllZero() and DbMaskNotZero()
** macros when SQLITE_MAX_ATTACHED is greater than 30.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_ATTACHED</name><operator>&gt;</operator><literal type="number">30</literal></expr></cpp:if>
<function><type><name>int</name></type> <name>sqlite3DbMaskAllZero</name><parameter_list>(<parameter><decl><type><name>yDbMask</name></type> <name>m</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yDbMask</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is called after a single SQL statement has been
** parsed and a VDBE program to execute that statement has been
** prepared.  This routine puts the finishing touches on the
** VDBE program and resets the pParse structure for the next
** parse.
**
** Note that if an error occurred, it might be the case that
** no VDBE code was generated.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FinishCoding</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pToplevel</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Begin by generating some termination code at the end of the
  ** vdbe program
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name> 
       <operator>||</operator> <call><name>sqlite3VdbeAssertMayAbort</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>mayAbort</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Returning</name> <modifier>*</modifier></type><name>pReturning</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pReturning</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>addrRewind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pReturning</name><operator>-&gt;</operator><name>nRetCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addrRewind</name> <operator>=</operator>
           <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>pReturning</name><operator>-&gt;</operator><name>iRetCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reg</name> <operator>=</operator> <name><name>pReturning</name><operator>-&gt;</operator><name>iRetReg</name></name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pReturning</name><operator>-&gt;</operator><name>nRetCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pReturning</name><operator>-&gt;</operator><name>iRetCur</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name><name>pReturning</name><operator>-&gt;</operator><name>iRetCur</name></name></expr></argument>, <argument><expr><name>addrRewind</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrRewind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTableLock</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3UserAuthInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>auth</name><operator>.</operator><name>authLevel</name></name><operator>&lt;</operator><name>UAUTH_User</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"user not authenticated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_AUTH_USER</name></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The cookie mask contains one bit for each database file open.
    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are
    ** set for each database that is used.  Generate code to start a
    ** transaction on each used database and to verify the schema cookie
    ** on each used database.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_Init</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>cookieMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
        <argument><expr><name>OP_Transaction</name></expr></argument>,                    <comment type="block">/* Opcode */</comment>
        <argument><expr><name>iDb</name></expr></argument>,                               <comment type="block">/* P1 */</comment>
        <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>writeMask</name></name></expr></argument>,<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* P2 */</comment>
        <argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name></expr></argument>,            <comment type="block">/* P3 */</comment>
        <argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>iGeneration</name></name></expr></argument>               <comment type="block">/* P4 */</comment>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator>
            <literal type="string">"usesStmtJournal=%d"</literal><operator>,</operator> <name><name>pParse</name><operator>-&gt;</operator><name>mayAbort</name></name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>++</operator><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr> )</condition>;</do>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVtabLock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vtab</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>apVtabLock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VBegin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>vtab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVtabLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Once all the cookies have been verified and transactions opened, 
    ** obtain the required table-locks. This is a no-op unless the 
    ** shared-cache feature is enabled.
    */</comment>
    <expr_stmt><expr><call><name>codeTableLocks</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize any AUTOINCREMENT data structures required.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3AutoincrementBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Code constant expressions that where factored out of inner loops.
    **
    ** The pConstExpr list might also contain expressions that we simply
    ** want to keep around until the Parse object is deleted.  Such
    ** expressions have iConstExprReg==0.  Do not generate code for
    ** those expressions, of course.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEL</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEL</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iReg</name> <init>= <expr><name><name>pEL</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>iConstExprReg</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pEL</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Returning</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pReturning</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRet</name><operator>-&gt;</operator><name>nRetCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>iRetCur</name></name></expr></argument>, <argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>nRetCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finally, jump back to the beginning of the executable code. */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Get the VDBE program ready for execution
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* A minimum of one cursor is required if autoincrement is used
    *  See ticket [a696379c1f08866] */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMakeReady</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Run the parser and code generator recursively in order to generate
** code for the SQL statement given onto the end of the pParse context
** currently under construction.  Notes:
**
**   *  The final OP_Halt is not appended and other initialization
**      and finalization steps are omitted because those are handling by the
**      outermost parser.
**
**   *  Built-in SQL functions always take precedence over application-defined
**      SQL functions.  In other words, it is not possible to override a
**      built-in function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3NestedParse</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>savedDbFlags</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>saveBuf</name><index>[<expr><name>PARSE_TAIL_SZ</name></expr>]</index></name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>&lt;</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Nesting should only be of limited depth */</comment>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* This can result either from an OOM or because the formatted string
    ** exceeds SQLITE_LIMIT_LENGTH.  In the latter case, we need to set
    ** an error */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>saveBuf</name></expr></argument>, <argument><expr><call><name>PARSE_TAIL</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PARSE_TAIL_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>PARSE_TAIL</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PARSE_TAIL_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_PreferBuiltin</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RunParser</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>=</operator> <name>savedDbFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PARSE_TAIL</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>saveBuf</name></expr></argument>, <argument><expr><name>PARSE_TAIL_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
<comment type="block">/*
** Return TRUE if zTable is the name of the system table that stores the
** list of users and their access credentials.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3UserAuthTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr><literal type="string">"sqlite_user"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Locate the in-memory structure that describes a particular database
** table given the name of that table and (optionally) the name of the
** database containing the table.  Return NULL if not found.
**
** If zDatabase is 0, all databases are searched for the table and the
** first matching table is returned.  (No checking for duplicate table
** names is done.)  The search order is TEMP first, then MAIN, then any
** auxiliary databases added using the ATTACH command.
**
** See also sqlite3LocateTable().
*/</comment>
<function><type><name>Table</name> <modifier>*</modifier></type><name>sqlite3FindTable</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDatabase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* All mutexes are required for schema access.  Make sure we hold them. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zDatabase</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
  <comment type="block">/* Only the admin user is allowed to know that the sqlite_user table
  ** exists */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>auth</name><operator>.</operator><name>authLevel</name></name><operator>&lt;</operator><name>UAUTH_Admin</name> <operator>&amp;&amp;</operator> <call><name>sqlite3UserAuthTable</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>zDatabase</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zDatabase</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* No match against the official names.  But always match "main"
      ** to schema 0 as a legacy fallback. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zDatabase</name></expr></argument>,<argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>PREFERRED_TEMP_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>||</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>PREFERRED_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>||</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>LEGACY_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, 
                              <argument><expr><name>LEGACY_TEMP_SCHEMA_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>PREFERRED_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>,
                              <argument><expr><name>LEGACY_SCHEMA_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Match against TEMP first */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* The main database is second */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Attached databases are in order of attachment */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>PREFERRED_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>LEGACY_SCHEMA_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>PREFERRED_TEMP_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, 
                            <argument><expr><name>LEGACY_TEMP_SCHEMA_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Locate the in-memory structure that describes a particular database
** table given the name of that table and (optionally) the name of the
** database containing the table.  Return NULL if not found.  Also leave an
** error message in pParse-&gt;zErrMsg.
**
** The difference between this routine and sqlite3FindTable() is that this
** routine leaves an error message in pParse-&gt;zErrMsg where
** sqlite3FindTable() does not.
*/</comment>
<function><type><name>Table</name> <modifier>*</modifier></type><name>sqlite3LocateTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* context in which to report errors */</comment>
  <parameter><decl><type><name>u32</name></type> <name>flags</name></decl></parameter>,             <comment type="block">/* LOCATE_VIEW or LOCATE_NOERR */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,     <comment type="block">/* Name of the table we are looking for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbase</name></decl></parameter>     <comment type="block">/* Name of the database.  Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Read the database schema. If an error occurs, leave an error message
  ** and code in pParse and return NULL. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_SchemaKnownOk</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <comment type="block">/* If zName is the not the name of a table in the schema created using
    ** CREATE, then check to see if it is the name of an virtual table that
    ** can be an eponymous virtual table. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_NO_VTAB</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><operator>(</operator><name>Module</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pMod</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"pragma_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pMod</name> <operator>=</operator> <call><name>sqlite3PragmaVtabRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pMod</name> <operator>&amp;&amp;</operator> <call><name>sqlite3VtabEponymousTableInit</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>LOCATE_NOERR</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_NO_VTAB</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <name>LOCATE_VIEW</name></expr> ?</condition><then> <expr><literal type="string">"no such view"</literal></expr> </then><else>: <expr><literal type="string">"no such table"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDbase</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s.%s"</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>zDbase</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Locate the table identified by *p.
**
** This is a wrapper around sqlite3LocateTable(). The difference between
** sqlite3LocateTable() and this function is that this function restricts
** the search to schema (p-&gt;pSchema) if it is not NULL. p-&gt;pSchema may be
** non-NULL if it is part of a view or trigger program definition. See
** sqlite3FixSrcList() for details.
*/</comment>
<function><type><name>Table</name> <modifier>*</modifier></type><name>sqlite3LocateTableItem</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>zDatabase</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zDatabase</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the preferred table name for system tables.  Translate legacy
** names into the new preferred names, as appropriate.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3PreferredTableName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>LEGACY_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>PREFERRED_SCHEMA_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>LEGACY_TEMP_SCHEMA_TABLE</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>PREFERRED_TEMP_SCHEMA_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Locate the in-memory structure that describes 
** a particular index given the name of that index
** and the name of the database that contains the index.
** Return NULL if not found.
**
** If zDatabase is 0, all databases are searched for the
** table and the first matching index is returned.  (No checking
** for duplicate index names is done.)  The search order is
** TEMP first, then MAIN, then any auxiliary databases added
** using the ATTACH command.
*/</comment>
<function><type><name>Index</name> <modifier>*</modifier></type><name>sqlite3FindIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <comment type="block">/* All mutexes are required for schema access.  Make sure we hold them. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zDb</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>OMIT_TEMPDB</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name><operator>&lt;</operator><literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name>i</name><operator>^</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>  <comment type="block">/* Search TEMP before MAIN */</comment>
    <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <call><name>sqlite3DbIsNamed</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reclaim the memory used by an index
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FreeIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ANALYZE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3DeleteIndexSamples</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zColAff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>isResized</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>azColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiRowEst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** For the index called zIdxName which is found in the database iDb,
** unlike that index from its Table then remove the index from
** the index hash table and free all memory structures associated
** with the index.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UnlinkAndDeleteIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdxName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>pIndex</name></name><operator>==</operator><name>pIndex</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>pIndex</name></name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <comment type="block">/* Justification of ALWAYS();  The index must be on the list of
      ** indices. */</comment>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>!=</operator><name>pIndex</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name>pIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3FreeIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Look through the list of open database files in db-&gt;aDb[] and if
** any have been closed, remove them from the list.  Reallocate the
** db-&gt;aDb[] structure to a smaller size, if possible.
**
** Entry 0 (the "main" database) and entry 1 (the "temp" database)
** are never candidates for being collapsed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CollapseDatabaseArray</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>Db</name></name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name>i</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>&lt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name></name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Reset the schema for the database at index iDb.  Also reset the
** TEMP schema.  The reset is deferred if db-&gt;nSchemaLock is not zero.
** Deferred resets may be run by calling with iDb&lt;0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResetOneSchema</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DbSetProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>DB_ResetWanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DbSetProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DB_ResetWanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DBFLAG_SchemaKnownOk</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>DbHasProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>DB_ResetWanted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3SchemaClear</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Erase all schema information from all attached databases (including
** "main" and "temp") for a single database connection.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResetAllSchemasOfConnection</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3SchemaClear</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>DbSetProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>DB_ResetWanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DBFLAG_SchemaChange</name><operator>|</operator><name>DBFLAG_SchemaKnownOk</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabUnlockList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CollapseDatabaseArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called when a commit occurs.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CommitInternalChanges</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the expression associated with a column.  This is usually
** the DEFAULT value, but might also be the expression that computes
** the value for a generated column.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ColumnSetExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,      <comment type="block">/* The table containing the column */</comment>
  <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,     <comment type="block">/* The column to receive the new DEFAULT expression */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>       <comment type="block">/* The new default expression */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&lt;</operator><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name> <operator>=</operator> <ternary><condition><expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the expression associated with a column.  The expression might be
** the DEFAULT clause or the AS clause of a generated column.
** Return NULL if the column has no associated expression.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ColumnExpr</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&lt;</operator><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the collating sequence name for a column.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ColumnSetColl</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zColl</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_HASTYPE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nColl</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>nColl</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><name>nColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_HASCOLL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the collating squence name for a column
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ColumnColl</name><parameter_list>(<parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_HASCOLL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_HASTYPE</name></expr> )</condition><block>{<block_content>
    <do>do<block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete memory allocated for the column names of a table or view (the
** Table.aCol[] array).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeleteColumnNames</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pCol</name> <operator>=</operator> <name><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name><operator>==</operator><call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remove the memory data structures associated with the given
** Table.  No changes are made to disk by this routine.
**
** This routine just deletes the data structure.  It does not unlink
** the table data structure from the hash table.  But it does destroy
** memory structures of the indices and foreign keys associated with 
** the table.
**
** The db parameter is optional.  It is needed if the Table object 
** contains lookaside memory.  (Table objects in the schema do not use
** lookaside memory, but some ephemeral Table objects do.)  Or the
** db parameter can be used with db-&gt;pnBytesFreed to measure the memory
** used by the Table object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>SQLITE_NOINLINE</name></type> <name>deleteTable</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Record the number of outstanding lookaside allocations in schema Tables
  ** prior to doing any free() operations. Since schema Tables do not use
  ** lookaside, this number should not change. 
  **
  ** If malloc has already failed, it may be that it failed while allocating
  ** a Table object that was going to be marked ephemeral. So do not check
  ** that no lookaside memory is used in this case either. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLookaside</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTable</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nLookaside</name> <operator>=</operator> <call><name>sqlite3LookasideUsed</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Delete all indices associated with this table. */</comment>
  <for>for<control>(<init><expr><name>pIndex</name> <operator>=</operator> <name><name>pTable</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIndex</name></expr>;</condition> <incr><expr><name>pIndex</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTable</name><operator>-&gt;</operator><name>pSchema</name></name>
         <operator>||</operator> <operator>(</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>idxType</name></name><operator>!=</operator><name>SQLITE_IDXTYPE_APPDEF</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt> 
      <macro><name>TESTONLY</name> <argument_list>( <argument>Index *pOld =</argument> )</argument_list></macro> <expr_stmt><expr><call><name>sqlite3HashInsert</name><argument_list>(
         <argument><expr><operator>&amp;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOld</name><operator>==</operator><name>pIndex</name> <operator>||</operator> <name>pOld</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3FreeIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3FkDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUAL_TABLE</name></cpp:ifndef>
  <if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VtabClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Delete the Table structure itself.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3DeleteColumnNames</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zColAff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify that no lookaside memory was used by schema tables */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nLookaside</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nLookaside</name><operator>==</operator><call><name>sqlite3LookasideUsed</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3DeleteTable</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Do not delete the table until the reference count reaches zero. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTable</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>--</operator><name><name>pTable</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>deleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Unlink the given table from the hash tables and the delete the
** table structure with all its indices and foreign keys.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UnlinkAndDeleteTable</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTabName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTabName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>zTabName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Zero-length table names are allowed */</comment>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given a token, return a string that consists of the text of that
** token.  Space to hold the returned string
** is obtained from sqliteMalloc() and must be freed by the calling
** function.
**
** Any quotation marks (ex:  "name", 'name', [name], or `name`) that
** surround the body of the token are removed.
**
** Tokens are often just pointers into the original SQL text and so
** are not \000 terminated and are not persistent.  The returned string
** is \000 terminated and is persistent.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3NameFromToken</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open the sqlite_schema table stored in database number iDb for
** writing. The table is opened using cursor 0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3OpenSchemaTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>SCHEMA_ROOT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LEGACY_SCHEMA_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SCHEMA_ROOT</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parameter zName points to a nul-terminated buffer containing the name
** of a database ("main", "temp" or the name of an attached db). This
** function returns the index of the named database in db-&gt;aDb[], or
** -1 if the named db cannot be found.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3FindDbName</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Database number */</comment>
  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr><operator>,</operator> <expr><name>pDb</name><operator>=</operator><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pDb</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <comment type="block">/* "main" is always an acceptable alias for the primary database
      ** even if it has been renamed using SQLITE_DBCONFIG_MAINDBNAME. */</comment>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The token *pName contains the name of a database (either "main" or
** "temp" or the name of an attached db). This routine returns the
** index of the named database in db-&gt;aDb[], or -1 if the named db 
** does not exist.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3FindDb</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                               <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                         <comment type="block">/* Name we are searching for */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The table or view or trigger name is passed to this routine via tokens
** pName1 and pName2. If the table name was fully qualified, for example:
**
** CREATE TABLE xxx.yyy (...);
** 
** Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if
** the table name is not fully qualified, i.e.:
**
** CREATE TABLE yyy(...);
**
** Then pName1 is set to "yyy" and pName2 is "".
**
** This routine sets the *ppUnqual pointer to point at the token (pName1 or
** pName2) that stores the unqualified table name.  The index of the
** database "xxx" is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3TwoPartName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName1</name></decl></parameter>,      <comment type="block">/* The "xxx" in the name "xxx.yyy" or "xxx" */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName2</name></decl></parameter>,      <comment type="block">/* The "yyy" in the name "xxx.yyy" */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier><modifier>*</modifier></type><name>pUnqual</name></decl></parameter>     <comment type="block">/* Write the unqualified object name here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                    <comment type="block">/* Database holding the object */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName2</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pName2</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"corrupt database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pUnqual</name> <operator>=</operator> <name>pName2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDb</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unknown database %T"</literal></expr></argument>, <argument><expr><name>pName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>||</operator> <name>IN_SPECIAL_PARSE</name>
             <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pUnqual</name> <operator>=</operator> <name>pName1</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>iDb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** True if PRAGMA writable_schema is ON
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WritableSchema</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>SQLITE_WriteSchema</name><operator>|</operator><name>SQLITE_Defensive</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>SQLITE_WriteSchema</name><operator>|</operator><name>SQLITE_Defensive</name><operator>)</operator><operator>)</operator><operator>==</operator>
               <name>SQLITE_WriteSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>SQLITE_WriteSchema</name><operator>|</operator><name>SQLITE_Defensive</name><operator>)</operator><operator>)</operator><operator>==</operator>
               <name>SQLITE_Defensive</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>SQLITE_WriteSchema</name><operator>|</operator><name>SQLITE_Defensive</name><operator>)</operator><operator>)</operator><operator>==</operator>
               <operator>(</operator><name>SQLITE_WriteSchema</name><operator>|</operator><name>SQLITE_Defensive</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>SQLITE_WriteSchema</name><operator>|</operator><name>SQLITE_Defensive</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SQLITE_WriteSchema</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is used to check if the UTF-8 string zName is a legal
** unqualified name for a new schema object (table, index, view or
** trigger). All names are legal except those that begin with the string
** "sqlite_" (in upper, lower or mixed case). This portion of the namespace
** is reserved for internal use.
**
** When parsing the sqlite_schema table, this routine also checks to
** make sure the "type", "name", and "tbl_name" columns are consistent
** with the SQL.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CheckObjectName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,            <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,        <comment type="block">/* Name of the object to check */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>,        <comment type="block">/* Type of this object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTblName</name></decl></parameter>      <comment type="block">/* Parent table name for triggers and indexes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>
   <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>imposterTable</name></name>
   <operator>||</operator> <operator>!</operator><name><name>sqlite3Config</name><operator>.</operator><name>bExtraSchemaChecks</name></name></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Skip these error checks for writable_schema=ON */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>azInit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
     <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>azInit</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>
     <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTblName</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>azInit</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* corruptSchema() will supply the error */</comment>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>)</operator>
     <operator>||</operator> <operator>(</operator><call><name>sqlite3ReadOnlyShadowTables</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3ShadowTableName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"object name reserved for internal use: %s"</literal></expr></argument>,
                      <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the PRIMARY KEY index of a table
*/</comment>
<function><type><name>Index</name> <modifier>*</modifier></type><name>sqlite3PrimaryKeyIndex</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content/>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert an table column number into a index column number.  That is,
** for the column iCol in the table (as defined by the CREATE TABLE statement)
** find the (first) offset of that column in index pIdx.  Or return -1
** if column iCol is not used in index pIdx.
*/</comment>
<function><type><name>i16</name></type> <name>sqlite3TableColumnToIndex</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>i16</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
<comment type="block">/* Convert a storage column number into a table column number.
**
** The storage column number (0,1,2,....) is the index of the value
** as it appears in the record on disk.  The true column number
** is the index (0,1,2,...) of the column in the CREATE TABLE statement.
**
** The storage column number is less than the table column number if
** and only there are VIRTUAL columns to the left.
**
** If SQLITE_OMIT_GENERATED_COLUMNS, this routine is a no-op macro.
*/</comment>
<function><type><name>i16</name></type> <name>sqlite3StorageColumnToTable</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>i16</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>iCol</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
<comment type="block">/* Convert a table column number into a storage column number.
**
** The storage column number (0,1,2,....) is the index of the value
** as it appears in the record on disk.  Or, if the input column is
** the N-th virtual column (zero-based) then the storage number is
** the number of non-virtual columns in the table plus N.  
**
** The true column number is the index (0,1,2,...) of the column in
** the CREATE TABLE statement.
**
** If the input column is a VIRTUAL column, then it should not appear
** in storage.  But the value sometimes is cached in registers that
** follow the range of registers used to construct storage.  This
** avoids computing the same VIRTUAL column multiple times, and provides
** values for use by OP_Param opcodes in triggers.  Hence, if the
** input column is a VIRTUAL table, put it after all the other columns.
**
** In the following, N means "normal column", S means STORED, and
** V means VIRTUAL.  Suppose the CREATE TABLE has columns like this:
**
**        CREATE TABLE ex(N,S,V,N,S,V,N,S,V);
**                     -- 0 1 2 3 4 5 6 7 8
**
** Then the mapping from this function is as follows:
**
**    INPUTS:     0 1 2 3 4 5 6 7 8
**    OUTPUTS:    0 1 6 2 3 7 4 5 8
**
** So, in other words, this routine shifts all the virtual columns to
** the end.
**
** If SQLITE_OMIT_GENERATED_COLUMNS then there are no virtual columns and
** this routine is a no-op macro.  If the pTab does not have any virtual
** columns, then this routine is no-op that always return iCol.  If iCol
** is negative (indicating the ROWID column) then this routine return iCol.
*/</comment>
<function><type><name>i16</name></type> <name>sqlite3TableColumnToStorage</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>i16</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i16</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>iCol</name></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* iCol is a virtual column itself */</comment>
    <return>return <expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name> <operator>+</operator> <name>i</name> <operator>-</operator> <name>n</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* iCol is a normal or stored column */</comment>
    <return>return <expr><name>n</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Insert a single OP_JournalMode query opcode in order to force the
** prepared statement to return false for sqlite3_stmt_readonly().  This
** is used by CREATE TABLE IF NOT EXISTS and similar if the table already
** exists, so that the prepared statement for CREATE TABLE IF NOT EXISTS
** will return false for sqlite3_stmt_readonly() even if that statement
** is a read-only no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3ForceNotReadOnly</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iReg</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_JournalMode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>PAGER_JOURNALMODE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Begin constructing a new table representation in memory.  This is
** the first of several action routines that get called in response
** to a CREATE TABLE statement.  In particular, this routine is called
** after seeing tokens "CREATE" and "TABLE" and the table name. The isTemp
** flag is true if the table should be stored in the auxiliary database
** file instead of in the main database file.  This is normally the case
** when the "TEMP" or "TEMPORARY" keyword occurs in between
** CREATE and TABLE.
**
** The new table record is initialized and put in pParse-&gt;pNewTable.
** As more of the CREATE TABLE statement is parsed, additional action
** routines will be called to add more information to this record.
** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine
** is called to complete the construction of the new table record.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StartTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName1</name></decl></parameter>,   <comment type="block">/* First part of the name of the table or view */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName2</name></decl></parameter>,   <comment type="block">/* Second part of the name of the table or view */</comment>
  <parameter><decl><type><name>int</name></type> <name>isTemp</name></decl></parameter>,      <comment type="block">/* True if this is a TEMP table */</comment>
  <parameter><decl><type><name>int</name></type> <name>isView</name></decl></parameter>,      <comment type="block">/* True if this is a VIEW */</comment>
  <parameter><decl><type><name>int</name></type> <name>isVirtual</name></decl></parameter>,   <comment type="block">/* True if this is a VIRTUAL table */</comment>
  <parameter><decl><type><name>int</name></type> <name>noErr</name></decl></parameter>        <comment type="block">/* Do nothing if table already exists */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* The name of the new table */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>         <comment type="block">/* Database number to create the table in */</comment>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl>;</decl_stmt>    <comment type="block">/* Unqualified name of the table to create */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Special case:  Parsing the sqlite_schema or sqlite_temp_schema schema */</comment>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pName</name> <operator>=</operator> <name>pName1</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The common case */</comment>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>isTemp</name> <operator>&amp;&amp;</operator> <name><name>pName2</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If creating a temp table, the name may not be qualified. Unless 
      ** the database name is "temp" anyway.  */</comment>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"temporary table name must be unqualified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>isTemp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iDb</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RenameTokenMap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zName</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name></name> <operator>=</operator> <operator>*</operator><name>pName</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isView</name></expr>?</condition><then><expr><literal type="string">"view"</literal></expr></then><else>:<expr><literal type="string">"table"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>begin_table_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>isTemp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isTemp</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isTemp</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isView</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isView</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aCode</name><index>[]</index></name> <init>= <expr><block>{
       <expr><name>SQLITE_CREATE_TABLE</name></expr>,
       <expr><name>SQLITE_CREATE_TEMP_TABLE</name></expr>,
       <expr><name>SQLITE_CREATE_VIEW</name></expr>,
       <expr><name>SQLITE_CREATE_TEMP_VIEW</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>isTemp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>begin_table_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isVirtual</name> <operator>&amp;&amp;</operator> <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>aCode</name><index>[<expr><name>isTemp</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>isView</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>begin_table_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make sure the new table name does not collide with an existing
  ** index or table name in the same database.  Issue an error message if
  ** it does. The exception is if the statement being parsed was passed
  ** to an sqlite3_declare_vtab() call. In that case only the column names
  ** and types will be used, so there is no need to test for namespace
  ** collisions.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>IN_SPECIAL_PARSE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>begin_table_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTable</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTable</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>noErr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s %T already exists"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><ternary><condition><expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="string">"view"</literal></expr> </then><else>: <expr><literal type="string">"table"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ForceNotReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <goto>goto <name>begin_table_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"there is already an index named %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>begin_table_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pTable</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>begin_table_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nTabRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEFAULT_ROWEST</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_ROWEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">200</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1048576</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name> <operator>=</operator> <name>pTable</name></expr>;</expr_stmt>

  <comment type="block">/* Begin generating the code that will insert the table record into
  ** the schema table.  Note in particular that we must go ahead
  ** and allocate the record number for the table entry now.  Before any
  ** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause
  ** indices to be created and the table record must come before the 
  ** indices.  Hence, the record number for the table must be allocated
  ** now.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fileFormat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>reg1</name></decl>, <decl><type ref="prev"/><name>reg2</name></decl>, <decl><type ref="prev"/><name>reg3</name></decl>;</decl_stmt>
    <comment type="block">/* nullRow[] is an OP_Record encoding of a row containing 5 NULLs */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>nullRow</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">6</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>isVirtual</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If the file format and encoding in the database have not been set, 
    ** set them now.
    */</comment>
    <expr_stmt><expr><name>reg1</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>regRowid</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reg2</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>regRoot</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reg3</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ReadCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>reg3</name></expr></argument>, <argument><expr><name>BTREE_FILE_FORMAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fileFormat</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_LegacyFileFmt</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then>
                  <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>SQLITE_MAX_FILE_FORMAT</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>BTREE_FILE_FORMAT</name></expr></argument>, <argument><expr><name>fileFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>BTREE_TEXT_ENCODING</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This just creates a place-holder record in the sqlite_schema table.
    ** The record created does not contain anything yet.  It will be replaced
    ** by the real entry in code generated at sqlite3EndTable().
    **
    ** The rowid for the new entry is left in register pParse-&gt;regRowid.
    ** The root page number of the new table is left in reg pParse-&gt;regRoot.
    ** The rowid and root page number values are needed by the code that
    ** sqlite3EndTable will generate.
    */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>isView</name> <operator>||</operator> <name>isVirtual</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>addrCrTab</name></name> <operator>=</operator>
         <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CreateBtree</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>, <argument><expr><name>BTREE_INTKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenSchemaTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>reg3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nullRow</name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg3</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Normal (non-error) return. */</comment>
  <return>return;</return>

  <comment type="block">/* If an error occurs, we jump here */</comment>
<label><name>begin_table_error</name>:</label>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Set properties of a table column based on the (magical)
** name of the column.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_HIDDEN_COLUMNS</name></expr></cpp:if>
<function><type><name>void</name></type> <name>sqlite3ColumnPropertiesFromName</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><literal type="string">"__hidden__"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_HIDDEN</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_HasHidden</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pTab</name> <operator>&amp;&amp;</operator> <name>pCol</name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCol</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_HIDDEN</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_OOOHidden</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Name of the special TEMP trigger used to implement RETURNING.  The
** name begins with "sqlite_" so that it is guaranteed not to collide
** with any application-generated triggers.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURNING_TRIGGER_NAME</name></cpp:macro>  <cpp:value>"sqlite_returning"</cpp:value></cpp:define>

<comment type="block">/*
** Clean up the data structures associated with the RETURNING clause.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3DeleteReturning</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Returning</name> <modifier>*</modifier></type><name>pRet</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Hash</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>trigHash</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>RETURNING_TRIGGER_NAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>pReturnEL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add the RETURNING clause to the parse currently underway.
**
** This routine creates a special TEMP trigger that will fire for each row
** of the DML statement.  That TEMP trigger contains a single SELECT
** statement with a result set that is the argument of the RETURNING clause.
** The trigger has the Trigger.bReturning flag and an opcode of
** TK_RETURNING instead of TK_SELECT, so that the trigger code generator
** knows to handle it specially.  The TEMP trigger is automatically
** removed at the end of the parse.
**
** When this routine is called, we do not yet know if the RETURNING clause
** is attached to a DELETE, INSERT, or UPDATE, so construct it as a
** RETURNING trigger instead.  It will then be converted into the appropriate
** type on the first call to sqlite3TriggersExist().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddReturning</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Returning</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTrigger</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot use RETURNING in a trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pReturning</name></name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pReturnEL</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
     <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3DeleteReturning</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>earlyCleanup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <name>RETURNING_TRIGGER_NAME</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_RETURNING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>tr_tm</name></name> <operator>=</operator> <name>TRIGGER_AFTER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>bReturning</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>pSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>pTabSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name><operator>.</operator><name>step_list</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>retTStep</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTStep</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_RETURNING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTStep</name><operator>.</operator><name>pTrig</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>retTStep</name><operator>.</operator><name>pExprList</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>trigHash</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>RETURNING_TRIGGER_NAME</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>RETURNING_TRIGGER_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name></name></expr></argument>)</argument_list></call>
          <operator>==</operator><operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>retTrig</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a new column to the table currently being constructed.
**
** The parser calls this routine once for each column declaration
** in a CREATE TABLE statement.  sqlite3StartTable() gets called
** first to get things going.  Then this routine is called for each
** column.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>sName</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>sType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>hName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><name>COLTYPE_CUSTOM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>szEst</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>affinity</name> <init>= <expr><name>SQLITE_AFF_BLOB</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many columns on %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DequoteToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Because keywords GENERATE ALWAYS can be converted into indentifiers
  ** by the parser, we can sometimes end up with a typename that ends
  ** with "generated always".  Check for this case and omit the surplus
  ** text. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">16</literal>
   <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>sType</name><operator>.</operator><name>z</name></name><operator>+</operator><operator>(</operator><name><name>sType</name><operator>.</operator><name>n</name></name><operator>-</operator><literal type="number">6</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"always"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sType</name><operator>.</operator><name>n</name></name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>sType</name><operator>.</operator><name>z</name><index>[<expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">9</literal>
     <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>sType</name><operator>.</operator><name>z</name></name><operator>+</operator><operator>(</operator><name><name>sType</name><operator>.</operator><name>n</name></name><operator>-</operator><literal type="number">9</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"generated"</literal></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sType</name><operator>.</operator><name>n</name></name> <operator>-=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>sType</name><operator>.</operator><name>z</name><index>[<expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check for standard typenames.  For standard typenames we will
  ** set the Column.eType field rather than storing the typename after
  ** the column name, in order to save space. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DequoteToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_STDTYPE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
       <if_stmt><if>if<condition>( <expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>==</operator><name><name>sqlite3StdTypeLen</name><index>[<expr><name>i</name></expr>]</index></name>
        <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>sType</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>sqlite3StdType</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sType</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
       )</condition><block>{<block_content>
         <expr_stmt><expr><name><name>sType</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
         <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
         <expr_stmt><expr><name>affinity</name> <operator>=</operator> <name><name>sqlite3StdTypeAffinity</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
         <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>&lt;=</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szEst</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
         <break>break;</break>
       </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>sName</name><operator>.</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>sType</name><operator>.</operator><name>n</name></name> <operator>+</operator> <operator>(</operator><name><name>sType</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3RenameTokenMap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>sName</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>sName</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name><name>sName</name><operator>.</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hName</name> <operator>=</operator> <call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hName</name><operator>==</operator><name>hName</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"duplicate column name: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name> <operator>=</operator> <name>hName</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ColumnPropertiesFromName</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <if_stmt><if>if<condition>( <expr><name><name>sType</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is no type specified, columns have the default affinity
    ** 'BLOB' with a default size of 4 bytes. */</comment>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <name>affinity</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>szEst</name></name> <operator>=</operator> <name>szEst</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">4</literal><operator>&gt;=</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szSorterRef</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_SORTERREF</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <name>z</name> <operator>+</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>sType</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>sType</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zType</name><index>[<expr><name><name>sType</name><operator>.</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_HASTYPE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nNVCol</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>constraintName</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.  A "NOT NULL" constraint has
** been seen on a column.  This routine sets the notNull flag on
** the column currently under construction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddNotNull</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>onError</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_HasNotNull</name></expr>;</expr_stmt>

  <comment type="block">/* Set the uniqNotNull flag on any UNIQUE or PK indexes already created
  ** on this column.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_UNIQUE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name>OE_None</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Scan the column type name zType (length nType) and return the
** associated affinity type.
**
** This routine does a case-independent search of zType for the 
** substrings in the following table. If one of the substrings is
** found, the corresponding affinity is returned. If zType contains
** more than one of the substrings, entries toward the top of 
** the table take priority. For example, if zType is 'BLOBINT', 
** SQLITE_AFF_INTEGER is returned.
**
** Substring     | Affinity
** --------------------------------
** 'INT'         | SQLITE_AFF_INTEGER
** 'CHAR'        | SQLITE_AFF_TEXT
** 'CLOB'        | SQLITE_AFF_TEXT
** 'TEXT'        | SQLITE_AFF_TEXT
** 'BLOB'        | SQLITE_AFF_BLOB
** 'REAL'        | SQLITE_AFF_REAL
** 'FLOA'        | SQLITE_AFF_REAL
** 'DOUB'        | SQLITE_AFF_REAL
**
** If none of the substrings in the above table are found,
** SQLITE_AFF_NUMERIC is returned.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3AffinityType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name> <init>= <expr><name>SQLITE_AFF_NUMERIC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zChar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zIn</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>sqlite3UpperToLower</name><index>[<expr><operator>(</operator><operator>*</operator><name>zIn</name><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'c'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'h'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'a'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'r'</literal><operator>)</operator></expr> )</condition><block>{<block_content>             <comment type="block">/* CHAR */</comment>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_TEXT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zChar</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'c'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'l'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'o'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'b'</literal><operator>)</operator></expr> )</condition><block>{<block_content>       <comment type="block">/* CLOB */</comment>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_TEXT</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'t'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'e'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'x'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'t'</literal><operator>)</operator></expr> )</condition><block>{<block_content>       <comment type="block">/* TEXT */</comment>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_TEXT</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'b'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'l'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'o'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'b'</literal><operator>)</operator>          <comment type="block">/* BLOB */</comment>
        <operator>&amp;&amp;</operator> <operator>(</operator><name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name> <operator>||</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_REAL</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'('</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zChar</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'r'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'e'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'a'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'l'</literal><operator>)</operator>          <comment type="block">/* REAL */</comment>
        <operator>&amp;&amp;</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_REAL</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'f'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'l'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'o'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'a'</literal><operator>)</operator>          <comment type="block">/* FLOA */</comment>
        <operator>&amp;&amp;</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_REAL</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>h</name><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'d'</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'o'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'u'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'b'</literal><operator>)</operator>          <comment type="block">/* DOUB */</comment>
        <operator>&amp;&amp;</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_REAL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>h</name><operator>&amp;</operator><literal type="number">0x00FFFFFF</literal><operator>)</operator><operator>==</operator><operator>(</operator><operator>(</operator><literal type="char">'i'</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><operator>(</operator><literal type="char">'n'</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="char">'t'</literal><operator>)</operator></expr> )</condition><block>{<block_content>    <comment type="block">/* INT */</comment>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* If pCol is not NULL, store an estimate of the field size.  The
  ** estimate is scaled so that the size of an integer is 1.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* default size is approx 4 bytes */</comment>
    <if_stmt><if>if<condition>( <expr><name>aff</name><operator>&lt;</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zChar</name></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name><name>zChar</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zChar</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <comment type="block">/* BLOB(k), VARCHAR(k), CHAR(k) -&gt; r=(k/4+1) */</comment>
            <expr_stmt><expr><call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name>zChar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zChar</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>   <comment type="block">/* BLOB, TEXT, CLOB -&gt; r=5  (approx 20 bytes)*/</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szSorterRef</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_SORTERREF</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>/</operator><literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;</operator><literal type="number">255</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>szEst</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>aff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The expression is the default value for the most recently added column
** of the table currently under construction.
**
** Default value expressions must be constant.  Raise an exception if this
** is not the case.
**
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddDefaultValue</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,           <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,             <comment type="block">/* The parsed expression of the default value */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl></parameter>,      <comment type="block">/* Start of the default value text */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>         <comment type="block">/* First character past end of defaut value text */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>isInit</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name><operator>!=</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3ExprIsConstantOrFunction</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>isInit</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"default value of column [%s] is not constant"</literal></expr></argument>,
          <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot use DEFAULT on a generated column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* A copy of pExpr is used instead of the original, as pExpr contains
      ** tokens that point to volatile memory.
      */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDfltExpr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_SPAN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <call><name>sqlite3DbSpanDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>EP_Skip</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDfltExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ColumnSetExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>pDfltExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RenameExprUnmap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Backwards Compatibility Hack:
** 
** Historical versions of SQLite accepted strings as column names in
** indexes and PRIMARY KEY constraints and in UNIQUE constraints.  Example:
**
**     CREATE TABLE xyz(a,b,c,d,e,PRIMARY KEY('a'),UNIQUE('b','c' COLLATE trim)
**     CREATE INDEX abc ON xyz('c','d' DESC,'e' COLLATE nocase DESC);
**
** This is goofy.  But to preserve backwards compatibility we continue to
** accept it.  This routine does the necessary conversion.  It converts
** the expression given in its argument from a TK_STRING into a TK_ID
** if the expression is just a TK_STRING with an optional COLLATE clause.
** If the expression is anything other than TK_STRING, the expression is
** unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3StringToId</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_STRING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ID</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_STRING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ID</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Tag the given column as being part of the PRIMARY KEY
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>makeColumnPartOfPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_PRIMKEY</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr><literal type="string">"generated columns cannot be part of the PRIMARY KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>          
</block_content>}</block></function>

<comment type="block">/*
** Designate the PRIMARY KEY for the table.  pList is a list of names 
** of columns that form the primary key.  If pList is NULL, then the
** most recently added column of the table is the primary key.
**
** A table can have at most one primary key.  If the table already has
** a primary key (and this is the second primary key) then create an
** error.
**
** If the PRIMARY KEY is on a single column whose datatype is INTEGER,
** then we will try to use that column as the rowid.  Set the Table.iPKey
** field of the table under construction to be the index of the
** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is
** no INTEGER PRIMARY KEY.
**
** If the key is not an INTEGER PRIMARY KEY, then create a unique
** index for the key.  No index is created for INTEGER PRIMARY KEYs.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddPrimaryKey</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,  <comment type="block">/* List of field names to be indexed */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,      <comment type="block">/* What to do with a uniqueness conflict */</comment>
  <parameter><decl><type><name>int</name></type> <name>autoInc</name></decl></parameter>,      <comment type="block">/* True if the AUTOINCREMENT keyword is present */</comment>
  <parameter><decl><type><name>int</name></type> <name>sortOrder</name></decl></parameter>     <comment type="block">/* SQLITE_SO_ASC or SQLITE_SO_DESC */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>primary_key_exit</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasPrimaryKey</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"table \"%s\" has more than one primary key"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>primary_key_exit</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_HasPrimaryKey</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>makeColumnPartOfPrimaryKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCExpr</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StringToId</name><argument_list>(<argument><expr><name>pCExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCName</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pCExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zCName</name> <operator>=</operator> <name><name>pCExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zCName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>makeColumnPartOfPrimaryKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>==</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <name>pCol</name>
   <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name><operator>==</operator><name>COLTYPE_INTEGER</name>
   <operator>&amp;&amp;</operator> <name>sortOrder</name><operator>!=</operator><name>SQLITE_SO_DESC</name></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name> <operator>&amp;&amp;</operator> <name>pList</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCExpr</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument>, <argument><expr><name>pCExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>keyConf</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>onError</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>autoInc</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>autoInc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>autoInc</name><operator>*</operator><name>TF_Autoincrement</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iPkSortOrder</name></name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3HasExplicitNulls</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>autoInc</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"AUTOINCREMENT is only allowed on an "</literal>
       <literal type="string">"INTEGER PRIMARY KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CreateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sortOrder</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>primary_key_exit</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a new CHECK constraint to the table currently under construction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddCheckConstraint</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCheckExpr</name></decl></parameter>,   <comment type="block">/* The check expression */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl></parameter>, <comment type="block">/* Opening "(" */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>    <comment type="block">/* Closing ")" */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IN_DECLARE_VTAB</name>
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3BtreeIsReadonly</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>, <argument><expr><name>pCheckExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>constraintName</name><operator>.</operator><name>n</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprListSetName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>constraintName</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Token</name></type> <name>t</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>zStart</name><operator>++</operator></expr>;</init> <condition><expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>zStart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>zStart</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <while>while<condition>( <expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>zEnd</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name><name>t</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>zStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>t</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name><name>t</name><operator>.</operator><name>z</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprListSetName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pCheckExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the collation function of the most recently parsed table column
** to the CollSeq given.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddCollateType</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>              <comment type="block">/* Dequoted name of collation sequence */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>IN_RENAME_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zColl</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zColl</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ColumnSetColl</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* If the column is declared as "&lt;name&gt; PRIMARY KEY COLLATE &lt;type&gt;",
    ** then an index may have been created on this column before the
    ** collation type was added. Correct this if it is the case.
    */</comment>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>i</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Change the most recently parsed column to be a GENERATED ALWAYS AS
** column.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddGenerated</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pType</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><name>COLFLAG_VIRTUAL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* generated column in an CREATE TABLE IF NOT EXISTS that already exists */</comment>
    <goto>goto <name>generated_done</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_DECLARE_VTAB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"virtual tables cannot use computed columns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>generated_done</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>generated_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pType</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pType</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><literal type="string">"virtual"</literal></expr></argument>,<argument><expr><name><name>pType</name><operator>-&gt;</operator><name>z</name></name></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* no-op */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pType</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><literal type="string">"stored"</literal></expr></argument>,<argument><expr><name><name>pType</name><operator>-&gt;</operator><name>z</name></name></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>COLFLAG_STORED</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <goto>goto <name>generated_error</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>COLFLAG_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>eType</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TF_HasVirtual</name><operator>==</operator><name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TF_HasStored</name><operator>==</operator><name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>eType</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>makeColumnPartOfPrimaryKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* For the error message */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ColumnSetExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <goto>goto <name>generated_done</name>;</goto>

<label><name>generated_error</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"error in generated column \"%s\""</literal></expr></argument>,
                  <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>generated_done</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Throw and error for the GENERATED ALWAYS AS clause if the
  ** SQLITE_OMIT_GENERATED_COLUMNS compile-time option is used. */</comment>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"generated columns not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will increment the schema cookie.
**
** The schema cookie is used to determine when the schema for the
** database changes.  After each schema change, the cookie value
** changes.  When a process first reads the schema it records the
** cookie.  Thereafter, whenever it goes to access the database,
** it checks the cookie to make sure the schema has not changed
** since it was last read.
**
** This plan is not completely bullet-proof.  It is possible for
** the schema to change multiple times and for the cookie to be
** set back to prior value.  But schema changes are infrequent
** and the probability of hitting the same cookie value is only
** 1 chance in 2^32.  So we're safe enough.
**
** IMPLEMENTATION-OF: R-34230-56049 SQLite automatically increments
** the schema-version whenever the schema changes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ChangeCookie</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>BTREE_SCHEMA_VERSION</name></expr></argument>, 
                   <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Measure the number of characters needed to output the given
** identifier.  The number returned includes any quotes used
** but does not include the null terminator.
**
** The estimate is conservative.  It might be larger that what is
** really needed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>identLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>z</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The first parameter is a pointer to an output buffer. The second 
** parameter is a pointer to an integer that contains the offset at
** which to write into the output buffer. This function copies the
** nul-terminated string pointed to by the third parameter, zSignedIdent,
** to the specified offset in the buffer and updates *pIdx to refer
** to the first byte after the last byte written before returning.
** 
** If the string zSignedIdent consists entirely of alpha-numeric
** characters, does not begin with a digit and is not an SQL keyword,
** then it is copied to the output buffer exactly as it is. Otherwise,
** it is quoted using double-quotes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>identPut</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zSignedIdent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIdent</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zSignedIdent</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>needQuote</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>*</operator><name>pIdx</name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3Isalnum</name><argument_list>(<argument><expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>needQuote</name> <operator>=</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zIdent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
            <operator>||</operator> <call><name>sqlite3KeywordCode</name><argument_list>(<argument><expr><name>zIdent</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>!=</operator><name>TK_ID</name>
            <operator>||</operator> <name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal>
            <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>needQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>needQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate a CREATE TABLE statement appropriate for the given
** table.  Memory to hold the text of the statement is obtained
** from sqliteMalloc() and must be freed by the calling function.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>createTableStmt</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zSep2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pCol</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aCol</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>identLength</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>identLength</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">50</literal></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep2</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"\n  "</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep2</name> <operator>=</operator> <literal type="string">",\n  "</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <literal type="string">"\n)"</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">35</literal> <operator>+</operator> <literal type="number">6</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>identPut</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zStmt</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pCol</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>azType</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/* SQLITE_AFF_BLOB    */</comment> <expr><literal type="string">""</literal></expr>,
        <comment type="block">/* SQLITE_AFF_TEXT    */</comment> <expr><literal type="string">" TEXT"</literal></expr>,
        <comment type="block">/* SQLITE_AFF_NUMERIC */</comment> <expr><literal type="string">" NUM"</literal></expr>,
        <comment type="block">/* SQLITE_AFF_INTEGER */</comment> <expr><literal type="string">" INT"</literal></expr>,
        <comment type="block">/* SQLITE_AFF_REAL    */</comment> <expr><literal type="string">" REAL"</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name><operator>-</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <name>zSep2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>identPut</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>-</operator><name>SQLITE_AFF_BLOB</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>-</operator><name>SQLITE_AFF_BLOB</name> <operator>&lt;</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name>azType</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <name><name>azType</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name> <operator>-</operator> <name>SQLITE_AFF_BLOB</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_BLOB</name> 
            <operator>||</operator> <name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>k</name><operator>&lt;=</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name><operator>-</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resize an Index object to hold N columns total.  Return SQLITE_OK
** on success and SQLITE_NOMEM on an OOM error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resizeIndexObject</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExtra</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&gt;=</operator><name>N</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>isResized</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><name>N</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zExtra</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zExtra</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zExtra</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>zExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zExtra</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>N</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zExtra</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiRowLogEst</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiRowLogEst</name></name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>*</operator><operator>)</operator><name>zExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zExtra</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>N</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zExtra</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>*</operator><operator>)</operator><name>zExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zExtra</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>N</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zExtra</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>isResized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Estimate the total row width for a table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>estimateTableWidth</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>wTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Column</name> <modifier>*</modifier></type><name>pTabCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr><operator>,</operator> <expr><name>pTabCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTabCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>wTable</name> <operator>+=</operator> <name><name>pTabCol</name><operator>-&gt;</operator><name>szEst</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>wTable</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>wTable</name><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Estimate the average size of a row for an index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>estimateIndexWidth</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>wIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Column</name> <modifier>*</modifier></type><name>aCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>i16</name></type> <name>x</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wIndex</name> <operator>+=</operator> <ternary><condition><expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>aCol</name><index>[<expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>szEst</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>szIdxRow</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>wIndex</name><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if column number x is any of the first nCol entries of aiCol[].
** This is used to determine if the column number x appears in any of the
** first nCol entries of an index.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasColumn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>i16</name> <modifier>*</modifier></type><name>aiCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>nCol</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>*</operator><operator>(</operator><name>aiCol</name><operator>++</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if any of the first nKey entries of index pIdx exactly
** match the iCol-th entry of pPk.  pPk is always a WITHOUT ROWID
** PRIMARY KEY index.  pIdx is an index on the same table.  pIdx may
** or may not be the same index as pPk.
**
** The first nKey entries of pIdx are guaranteed to be ordinary columns,
** not a rowid or expression.
**
** This routine differs from hasColumn() in that both the column and the
** collating sequence must match for this routine, but for hasColumn() only
** the column name must match.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isDupColumn</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>&lt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&lt;</operator><call><name>MAX</name><argument_list>(<argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>,<argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>idxType</name></name><operator>==</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_WithoutRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>pTable</name></name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPk</name><operator>==</operator><name>pIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>!=</operator><name>XN_ROWID</name> <operator>&amp;&amp;</operator> <name>j</name><operator>!=</operator><name>XN_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nKey</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>j</name> 
     <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Recompute the colNotIdxed field of the Index.
**
** colNotIdxed is a bitmask that has a 0 bit representing each indexed
** columns that are within the first 63 columns of the table and a 1 for
** all other bits (all columns that are not in the index).  The
** high-order bit of colNotIdxed is always 1.  All unindexed columns
** of the table have a 1.
**
** 2019-10-24:  For the purpose of this computation, virtual columns are
** not considered to be covered by the index, even if they are in the
** index, because we do not trust the logic in whereIndexExprTrans() to be
** able to find all instances of a reference to the indexed table column
** and convert them into references to the index.  Hence we always want
** the actual table at hand in order to recompute the virtual column, if
** necessary.
**
** The colNotIdxed mask is AND-ed with the SrcList.a[].colUsed mask
** to determine if the index is covering index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recomputeColumnsNotIndexed</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>colNotIdxed</name></name> <operator>=</operator> <operator>~</operator><name>m</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>colNotIdxed</name></name><operator>&gt;&gt;</operator><literal type="number">63</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See note-20221022-a */</comment>
</block_content>}</block></function>

<comment type="block">/*
** This routine runs at the end of parsing a CREATE TABLE statement that
** has a WITHOUT ROWID clause.  The job of this routine is to convert both
** internal schema data structures and the generated VDBE code so that they
** are appropriate for a WITHOUT ROWID table instead of a rowid table.
** Changes include:
**
**     (1)  Set all columns of the PRIMARY KEY schema object to be NOT NULL.
**     (2)  Convert P3 parameter of the OP_CreateBtree from BTREE_INTKEY 
**          into BTREE_BLOBKEY.
**     (3)  Bypass the creation of the sqlite_schema table entry
**          for the PRIMARY KEY as the primary key index is now
**          identified by the sqlite_schema table entry of the table itself.
**     (4)  Set the Index.tnum of the PRIMARY KEY Index object in the
**          schema to the rootpage from the main table.
**     (5)  Add all table columns to the PRIMARY KEY Index object
**          so that the PRIMARY KEY is a covering index.  The surplus
**          columns are part of KeyInfo.nAllField and are not used for
**          sorting or lookup or uniqueness checks.
**     (6)  Replace the rowid tail on all automatically generated UNIQUE
**          indices with the PRIMARY KEY columns.
**
** For virtual tables, only (1) is performed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>convertToWithoutRowidTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Mark every PRIMARY KEY column as NOT NULL (except for imposter tables)
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>imposterTable</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><name>OE_None</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>notNull</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_HasNotNull</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Convert the P3 operand of the OP_CreateBtree opcode from BTREE_INTKEY
  ** into BTREE_BLOBKEY.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>addrCrTab</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>addrCrTab</name></name></expr></argument>, <argument><expr><name>BTREE_BLOBKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the PRIMARY KEY index.  Or, if this table was originally
  ** an INTEGER PRIMARY KEY table, create a new PRIMARY KEY index. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Token</name></type> <name>ipkToken</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3TokenInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ipkToken</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
                  <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ipkToken</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TF_WithoutRowid</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iPkSortOrder</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CreateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>keyConf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                       <argument><expr><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TF_WithoutRowid</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
    ** Remove all redundant columns from the PRIMARY KEY.  For example, change
    ** "PRIMARY KEY(a,b,a,b,c,b,c,d)" into just "PRIMARY KEY(a,b,c,d)".  Later
    ** code assumes the PRIMARY KEY contains no repeated columns.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>isDupColumn</name><argument_list>(<argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>nColumn</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>hasColumn</name><argument_list>(<argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>isCovering</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>imposterTable</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>uniqNotNull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nPk</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>

  <comment type="block">/* Bypass the creation of the PRIMARY KEY btree and the sqlite_schema
  ** table entry. This is only required if currently generating VDBE
  ** code for a CREATE TABLE (not when parsing one as part of reading
  ** a database schema).  */</comment>
  <if_stmt><if>if<condition>( <expr><name>v</name> <operator>&amp;&amp;</operator> <name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeOpcode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The root page of the PRIMARY KEY is the table root page */</comment>
  <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr>;</expr_stmt>

  <comment type="block">/* Update the in-memory representation of all UNIQUE indices by converting
  ** the final rowid column into one or more columns of the PRIMARY KEY.
  */</comment>
  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isDupColumn</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>hasColumn</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This index is a superset of the primary key */</comment>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>resizeIndexObject</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isDupColumn</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>hasColumn</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPk</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* See ticket https://www.sqlite.org/src/info/bba7b69f9849b5bf */</comment>
          <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>bAscKeyBug</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&gt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>+</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&gt;=</operator><name>j</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Add all table columns to the PRIMARY KEY index
  */</comment>
  <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>hasColumn</name><argument_list>(<argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nExtra</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>resizeIndexObject</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>nPk</name><operator>+</operator><name>nExtra</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name>nPk</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>hasColumn</name><argument_list>(<argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nColumn</name></name><operator>==</operator><name>j</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name><operator>&lt;=</operator><name>j</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recomputeColumnsNotIndexed</name><argument_list>(<argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Return true if pTab is a virtual table and zName is a shadow table name
** for that virtual table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsShadowTableOf</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                    <comment type="block">/* Length of zName */</comment>
  <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>                 <comment type="block">/* Module for the virtual table */</comment>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zName</name><index>[<expr><name>nName</name></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>Module</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMod</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xShadowName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xShadowName</name></name><argument_list>(<argument><expr><name>zName</name><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Table pTab is a virtual table.  If it the virtual table implementation
** exists and has an xShadowName method, then loop over all other ordinary
** tables within the same schema looking for shadow tables of pTab, and mark
** any shadow tables seen using the TF_Shadow flag.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MarkAllShadowTablesOf</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                    <comment type="block">/* Length of pTab-&gt;zName */</comment>
  <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>                 <comment type="block">/* Module for the virtual table */</comment>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>                  <comment type="block">/* For looping through the symbol table */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>Module</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMod</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xShadowName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>k</name></expr>;</condition> <incr><expr><name>k</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pOther</name> <init>= <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOther</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pOther</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOther</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Shadow</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name><name>pOther</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pOther</name><operator>-&gt;</operator><name>zName</name><index>[<expr><name>nName</name></expr>]</index></name><operator>==</operator><literal type="char">'_'</literal>
     <operator>&amp;&amp;</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xShadowName</name></name><argument_list>(<argument><expr><name><name>pOther</name><operator>-&gt;</operator><name>zName</name></name><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOther</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Shadow</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Return true if zName is a shadow table name in the current database
** connection.
**
** zName is temporarily modified while this routine is running, but is
** restored to its original value prior to this routine returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ShadowTableName</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTail</name></decl>;</decl_stmt>                  <comment type="block">/* Pointer to the last "_" in zName */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                  <comment type="block">/* Table that zName is a shadow of */</comment>
  <expr_stmt><expr><name>zTail</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTail</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>zTail</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>zTail</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3IsShadowTableOf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Mark all nodes of an expression as EP_Immutable, indicating that
** they should not be changed.  Expressions attached to a table or
** index definition are tagged this way to help ensure that we do
** not pass them into code generator routines by mistake.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>markImmutableExprStep</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markExprListImmutable</name><parameter_list>(<parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>markImmutableExprStep</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markExprListImmutable</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* no-op */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>


<comment type="block">/*
** This routine is called to report the final ")" that terminates
** a CREATE TABLE statement.
**
** The table structure that other action routines have been building
** is added to the internal hash tables, assuming no errors have
** occurred.
**
** An entry for the table is made in the schema table on disk, unless
** this is a temporary table or db-&gt;init.busy==1.  When db-&gt;init.busy==1
** it means we are reading the sqlite_schema table because we just
** connected to the database or because the sqlite_schema table has
** recently changed, so the entry for this table already exists in
** the sqlite_schema table.  We do not want to create it again.
**
** If the pSelect argument is not NULL, it means that this routine
** was called to create a table generated from a 
** "CREATE TABLE ... AS SELECT ..." statement.  The column names of
** the new table will match the result set of the SELECT.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3EndTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pCons</name></decl></parameter>,           <comment type="block">/* The ',' token after the last column defn. */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,            <comment type="block">/* The ')' before options in the CREATE TABLE */</comment>
  <parameter><decl><type><name>u32</name></type> <name>tabOpts</name></decl></parameter>,            <comment type="block">/* Extra table options. Usually 0. */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>         <comment type="block">/* Select from a "CREATE ... AS SELECT" */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                 <comment type="block">/* The new table */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database in which the table lives */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>              <comment type="block">/* An implied index of the table */</comment>

  <if_stmt><if>if<condition>( <expr><name>pEnd</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pSelect</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSelect</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ShadowTableName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Shadow</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the db-&gt;init.busy is 1 it means we are reading the SQL off the
  ** "sqlite_schema" or "sqlite_temp_schema" table on the disk.
  ** So do not write to the disk again.  Extract the root page number
  ** for the table from the db-&gt;init.newTnum field.  (The page number
  ** should have been put there by the sqliteOpenCb routine.)
  **
  ** If the root page number is 1, that means this is the sqlite_schema
  ** table itself.  So mark it read-only.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pSelect</name> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tnum</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Readonly</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Special processing for tables that include the STRICT keyword:
  **
  **   *  Do not allow custom column datatypes.  Every column must have
  **      a datatype that is one of INT, INTEGER, REAL, TEXT, or BLOB.
  **
  **   *  If a PRIMARY KEY is defined, other than the INTEGER PRIMARY KEY,
  **      then all columns of the PRIMARY KEY must have a NOT NULL
  **      constraint.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>tabOpts</name> <operator>&amp;</operator> <name>TF_Strict</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Strict</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name><operator>==</operator><name>COLTYPE_CUSTOM</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_HASTYPE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
            <argument><expr><literal type="string">"unknown datatype for %s.%s: \"%s\""</literal></expr></argument>,
            <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><call><name>sqlite3ColumnType</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"missing datatype for %s.%s"</literal></expr></argument>,
                          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>eCType</name></name><operator>==</operator><name>COLTYPE_ANY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iPKey</name></name><operator>!=</operator><name>ii</name>
       <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>==</operator> <name>OE_None</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_HasNotNull</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>    
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasPrimaryKey</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasPrimaryKey</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Special processing for WITHOUT ROWID Tables */</comment>
  <if_stmt><if>if<condition>( <expr><name>tabOpts</name> <operator>&amp;</operator> <name>TF_WithoutRowid</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
          <argument><expr><literal type="string">"AUTOINCREMENT not allowed on WITHOUT ROWID tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasPrimaryKey</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"PRIMARY KEY missing on table %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_WithoutRowid</name> <operator>|</operator> <name>TF_NoVisibleRowid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>convertToWithoutRowidTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>tabOpts</name> <operator>&amp;</operator> <name>TF_RandomRowid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_WithoutRowid</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
          <argument><expr><literal type="string">"AUTOINCREMENT not allowed on RANDOM ROWID tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_RandomRowid</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <comment type="block">/* Resolve names in all CHECK constraint expressions.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pCheck</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ResolveSelfReference</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NC_IsCheck</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If errors are seen, delete the CHECK constraints now, else they might
      ** actually be used if PRAGMA writable_schema=ON is set. */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>markExprListImmutable</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_CHECK) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>nNG</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>colFlags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>colFlags</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveSelfReference</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NC_GenCol</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* If there are errors in resolving the expression, change the
          ** expression to a NULL.  This prevents code generators that operate
          ** on the expression from inserting extra parts into the expression
          ** tree that have been allocated from lookaside memory, which is
          ** illegal in a schema and will lead to errors or heap corruption
          ** when the database connection closes. */</comment>
          <expr_stmt><expr><call><name>sqlite3ColumnSetExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, 
               <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nNG</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nNG</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"must have at least one non-generated column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Estimate the average row size for the table and for all implied indices */</comment>
  <expr_stmt><expr><call><name>estimateTableWidth</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>estimateIndexWidth</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If not initializing, then create a record for the new table
  ** in the schema table of the database.
  **
  ** If this is a TEMPORARY table, write the entry into the auxiliary
  ** file instead of into the main database file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>    <comment type="block">/* "view" or "table" */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zType2</name></decl>;</decl_stmt>   <comment type="block">/* "VIEW" or "TABLE" */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmt</name></decl>;</decl_stmt>    <comment type="block">/* Text of the CREATE TABLE or CREATE VIEW statement */</comment>

    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 
    ** Initialize zType for the new view or table.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* A regular table */</comment>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"table"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType2</name> <operator>=</operator> <literal type="string">"TABLE"</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* A view */</comment>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"view"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType2</name> <operator>=</operator> <literal type="string">"VIEW"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT
    ** statement to populate the new table. The root-page number for the
    ** new table is in register pParse-&gt;regRoot.
    **
    ** Once the SELECT has been coded by sqlite3Select(), it is in a
    ** suitable state to query for the column names and types to be used
    ** by the new table.
    **
    ** A shared-cache write-lock is not required to write to the new table,
    ** as a schema-lock must have already been obtained to create it. Since
    ** a schema-lock excludes all other database users, the write-lock would
    ** be redundant.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>    <comment type="block">/* Where the SELECT should store results */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regYield</name></decl>;</decl_stmt>       <comment type="block">/* Register holding co-routine entry-point */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>        <comment type="block">/* Top of the co-routine */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regRec</name></decl>;</decl_stmt>         <comment type="block">/* A record to be insert into the new table */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>       <comment type="block">/* Rowid of the next row to insert */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrInsLoop</name></decl>;</decl_stmt>    <comment type="block">/* Top of the loop for inserting rows */</comment>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pSelTab</name></decl>;</decl_stmt>     <comment type="block">/* A table that describes the SELECT results */</comment>

      <if_stmt><if>if<condition>( <expr><name>IN_SPECIAL_PARSE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>regYield</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regRec</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>regRoot</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_P2ISREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pSelTab</name> <operator>=</operator> <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSelTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nNVCol</name></name> <operator>=</operator> <name><name>pSelTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <name><name>pSelTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSelTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSelTab</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeEndCoroutine</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrInsLoop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>nSdst</name></name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInsLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInsLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute the complete text of the CREATE statement */</comment>
    <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>createTableStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pEnd2</name> <init>= <expr><ternary><condition><expr><name>tabOpts</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>sLastToken</name></name></expr> </then><else>: <expr><name>pEnd</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pEnd2</name><operator>-&gt;</operator><name>z</name></name> <operator>-</operator> <name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pEnd2</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">';'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>pEnd2</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
          <argument><expr><literal type="string">"CREATE %s %.*s"</literal></expr></argument>, <argument><expr><name>zType2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* A slot for the record has already been allocated in the 
    ** schema table.  We just need to update that slot with all
    ** the information we've collected.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr><literal type="string">"UPDATE %Q."</literal> <name>LEGACY_SCHEMA_TABLE</name>
      <literal type="string">" SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q"</literal>
      <literal type="string">" WHERE rowid=#%d"</literal></expr></argument>,
      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>,
      <argument><expr><name>zType</name></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
      <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>regRoot</name></name></expr></argument>,
      <argument><expr><name>zStmt</name></expr></argument>,
      <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>regRowid</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <comment type="block">/* Check to see if we need to create an sqlite_sequence table for
    ** keeping track of autoincrement keys.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>IN_SPECIAL_PARSE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
          <argument><expr><literal type="string">"CREATE TABLE %Q.sqlite_sequence(name,seq)"</literal></expr></argument>,
          <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Reparse everything to update our internal data structures */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>,
           <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tbl_name='%q' AND type!='trigger'"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Add the table to the in-memory representation of the database.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOld</name> <operator>=</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOld</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name>pOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Malloc must have failed inside HashInsert() */</comment>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>

    <comment type="block">/* If this is the magic sqlite_sequence table used by autoincrement,
    ** then record a pointer to this table in the main database structure
    ** so that INSERT can find the table easily.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pSelect</name> <operator>&amp;&amp;</operator> <call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCons</name> <operator>&amp;&amp;</operator> <name>pEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pCons</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name> <operator>=</operator> <literal type="number">13</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pCons</name><operator>-&gt;</operator><name>z</name></name> <operator>-</operator> <name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
<comment type="block">/*
** The parser calls this routine in order to create a new VIEW
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CreateView</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pBegin</name></decl></parameter>,     <comment type="block">/* The CREATE token that begins the statement */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName1</name></decl></parameter>,     <comment type="block">/* The token that holds the name of the view */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName2</name></decl></parameter>,     <comment type="block">/* The token that holds the name of the view */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pCNames</name></decl></parameter>, <comment type="block">/* Optional list of view column names */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,   <comment type="block">/* A SELECT statement that will become the new view */</comment>
  <parameter><decl><type><name>int</name></type> <name>isTemp</name></decl></parameter>,        <comment type="block">/* TRUE for a TEMPORARY view */</comment>
  <parameter><decl><type><name>int</name></type> <name>noErr</name></decl></parameter>          <comment type="block">/* Suppress error messages if VIEW already exists */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>sEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbFixer</name></type> <name>sFix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"parameters are not allowed in views"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>create_view_fail</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3StartTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><name>isTemp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>create_view_fail</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Legacy versions of SQLite allowed the use of the magic "rowid" column
  ** on a view, even though views do not have rowids.  The following flag
  ** setting fixes this problem.  But the fix can be disabled by compiling
  ** with -DSQLITE_ALLOW_ROWID_IN_VIEW in case there are legacy apps that
  ** depend upon the old buggy behavior. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifndef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_NoVisibleRowid</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3FixInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sFix</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="string">"view"</literal></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FixSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sFix</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>create_view_fail</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Make a copy of the entire SELECT statement that defines the view.
  ** This will force all the Expr.token.z values to be dynamically
  ** allocated rather than point to the input string - which means that
  ** they will persist after the current sqlite3_exec() call returns.
  */</comment>
  <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_View</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCNames</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eTabType</name></name> <operator>=</operator> <name>TABTYP_VIEW</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>create_view_fail</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Locate the end of the CREATE VIEW statement.  Make sEnd point to
  ** the end.
  */</comment>
  <expr_stmt><expr><name>sEnd</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>sLastToken</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sEnd</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>sEnd</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sEnd</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">';'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sEnd</name><operator>.</operator><name>z</name></name> <operator>+=</operator> <name><name>sEnd</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sEnd</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>sEnd</name><operator>.</operator><name>z</name></name> <operator>-</operator> <name><name>pBegin</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pBegin</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <expr_stmt><expr><name><name>sEnd</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sEnd</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* Use sqlite3EndTable() to add the view to the schema table */</comment>
  <expr_stmt><expr><call><name>sqlite3EndTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>create_view_fail</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RenameExprlistUnmap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIEW */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** The Table structure pTable is really a VIEW.  Fill in the names of
** the columns of the view in the pTable structure.  Return the number
** of errors.  If an error is seen leave an error message in pParse-&gt;zErrMsg.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>viewGetColumnNames</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pSelTab</name></decl>;</decl_stmt>   <comment type="block">/* A fake table from which we get the result set */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>     <comment type="block">/* Copy of the SELECT that implements the view */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of errors encountered */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Database connection for malloc errors */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_xauth</name></type> <name>xAuth</name></decl>;</decl_stmt>       <comment type="block">/* Saved xAuth pointer */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabCallConnect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <comment type="block">/* A positive nCol means the columns names for this view are
  ** already known.  This routine is not called unless either the
  ** table is virtual or nCol is zero.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A negative nCol is a special marker meaning that we are currently
  ** trying to compute the column names.  If we enter this routine with
  ** a negative nCol, it means two or more views form a loop, like this:
  **
  **     CREATE VIEW one AS SELECT * FROM two;
  **     CREATE VIEW two AS SELECT * FROM one;
  **
  ** Actually, the error above is now caught prior to reaching this point.
  ** But the following test is still important as it does come up
  ** in the following:
  ** 
  **     CREATE TABLE main.ex1(a);
  **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;
  **     SELECT * FROM temp.ex1;
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"view %s is circularly defined"</literal></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we get this far, it means we need to compute the table names.
  ** Note that the call to sqlite3ResultSetOfSelect() will expand any
  ** "*" elements in the results set of the view and will assign cursors
  ** to the elements of the FROM clause.  But we do not want these changes
  ** to be permanent.  So the computation is done on a copy of the SELECT
  ** statement that defines the view.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSel</name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSel</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>eParseMode</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSelect</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nSelect</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name> <operator>=</operator> <name>PARSE_MODE_NORMAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>DisableLookaside</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <expr_stmt><expr><name>xAuth</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelTab</name> <operator>=</operator> <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <name>xAuth</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>pSelTab</name> <operator>=</operator> <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <name>nTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nSelect</name></name> <operator>=</operator> <name>nSelect</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSelTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nErr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTable</name><operator>-&gt;</operator><name>pCheck</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* CREATE VIEW name(arglist) AS ...
      ** The names of the columns in the table are taken from
      ** arglist which is stored in pTable-&gt;pCheck.  The pCheck field
      ** normally holds CHECK constraints on an ordinary table, but for
      ** a VIEW it holds the list of column names.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3ColumnsFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>, 
                                 <argument><expr><operator>&amp;</operator><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SelectAddColumnTypeAndCollation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>,
                                               <argument><expr><name>SQLITE_AFF_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* CREATE VIEW name AS...  without an argument list.  Construct
      ** the column names from the SELECT statement that defines the view.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name><name>pSelTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <name><name>pSelTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <operator>(</operator><name><name>pSelTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_NOINSERT</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSelTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSelTab</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nNVCol</name></name> <operator>=</operator> <name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>EnableLookaside</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name> <operator>=</operator> <name>eParseMode</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>nErr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>schemaFlags</name></name> <operator>|=</operator> <name>DB_UnresetViews</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DeleteColumnNames</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIEW */</comment>
  <return>return <expr><name>nErr</name></expr>;</return>  
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3ViewGetColumnNames</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>viewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
<comment type="block">/*
** Clear the column names from every VIEW in database idx.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqliteViewResetAll</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>DbHasProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>DB_UnresetViews</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition><incr><expr><name>i</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DeleteColumnNames</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>DbClearProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>DB_UnresetViews</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>sqliteViewResetAll</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIEW */</comment>

<comment type="block">/*
** This function is called by the VDBE to adjust the internal schema
** used by SQLite when the btree layer moves a table root page. The
** root-page of a table or index in database iDb has changed from iFrom
** to iTo.
**
** Ticket #1728:  The symbol table might still contain information
** on tables and/or indices that are the process of being deleted.
** If you are unlucky, one of those deleted indices or tables might
** have the same rootpage number as the real table or index that is
** being moved.  So we cannot stop searching after the first match 
** because the first match might be for one of the deleted indices
** or tables and not the table/index that is actually being moved.
** We must continue looping until all tables and indices with
** rootpage==iFrom have been converted to have a rootpage of iTo
** in order to be certain that we got the right one.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3RootPageMoved</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iFrom</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iTo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>pElem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name>iFrom</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name> <operator>=</operator> <name>iTo</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name>iFrom</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name> <operator>=</operator> <name>iTo</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write code to erase the table with root-page iTable from database iDb.
** Also write code to modify the sqlite_schema table and internal schema
** if a root-page of another table is moved by the btree-layer whilst
** erasing iTable (this can happen with an auto-vacuum database).
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyRootPage</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"corrupt schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Destroy</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <comment type="block">/* OP_Destroy stores an in integer r1. If this integer
  ** is non-zero, then it is the root page number of a table moved to
  ** location iTable. The following code modifies the sqlite_schema table to
  ** reflect this.
  **
  ** The "#NNN" in the SQL is a special constant that means whatever value
  ** is in register NNN.  See grammar rules associated with the TK_REGISTER
  ** token for additional information.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
     <argument><expr><literal type="string">"UPDATE %Q."</literal> <name>LEGACY_SCHEMA_TABLE</name>
     <literal type="string">" SET rootpage=%d WHERE #%d AND rootpage=#%d"</literal></expr></argument>,
     <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write VDBE code to erase table pTab and all associated indices on disk.
** Code to update the sqlite_schema tables and internal schema definitions
** in case a root-page belonging to another table is moved by the btree layer
** is also added (this can happen with an auto-vacuum database).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM
  ** is not defined), then it is important to call OP_Destroy on the
  ** table and index root-pages in order, starting with the numerically 
  ** largest root-page number. This guarantees that none of the root-pages
  ** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the
  ** following were coded:
  **
  ** OP_Destroy 4 0
  ** ...
  ** OP_Destroy 5 0
  **
  ** and root page 5 happened to be the largest root-page number in the
  ** database, then root page 5 would be moved to page 4 by the 
  ** "OP_Destroy 4 0" opcode. The subsequent "OP_Destroy 5 0" would hit
  ** a free-list page.
  */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iTab</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iDestroyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iLargest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>iDestroyed</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iTab</name><operator>&lt;</operator><name>iDestroyed</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iLargest</name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>iIdx</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iDestroyed</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iIdx</name><operator>&lt;</operator><name>iDestroyed</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name>iIdx</name><operator>&gt;</operator><name>iLargest</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iLargest</name> <operator>=</operator> <name>iIdx</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>iLargest</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>destroyRootPage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iLargest</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDestroyed</name> <operator>=</operator> <name>iLargest</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Remove entries from the sqlite_statN tables (for N in (1,2,3))
** after a DROP INDEX or DROP TABLE command.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3ClearStatTables</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,               <comment type="block">/* The database number */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>,     <comment type="block">/* "idx" or "tbl" */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>      <comment type="block">/* Name of index or table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zTab</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="string">"sqlite_stat%d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><literal type="string">"DELETE FROM %Q.%s WHERE %s=%Q"</literal></expr></argument>,
        <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to drop a table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CodeDropTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isView</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Drop all triggers associated with the table being dropped. Code
  ** is generated to remove entries from sqlite_schema and/or
  ** sqlite_temp_schema if required.
  */</comment>
  <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggerList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pTrigger</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTrigger</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>||</operator> 
        <name><name>pTrigger</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DropTriggerPtr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <name><name>pTrigger</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
  <comment type="block">/* Remove any entries of the sqlite_sequence table associated with
  ** the table being dropped. This is done before the table is dropped
  ** at the btree level, in case the sqlite_sequence table needs to
  ** move as a result of the drop (can happen in auto-vacuum mode).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr><literal type="string">"DELETE FROM %Q.sqlite_sequence WHERE name=%Q"</literal></expr></argument>,
      <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Drop all entries in the schema table that refer to the
  ** table. The program name loops through the schema table and deletes
  ** every row that refers to a table of the same name as the one being
  ** dropped. Triggers are handled separately because a trigger can be
  ** created in the temp database that refers to a table in another
  ** database.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"DELETE FROM %Q."</literal> <name>LEGACY_SCHEMA_TABLE</name>
      <literal type="string">" WHERE tbl_name=%Q and type!='trigger'"</literal></expr></argument>,
      <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>destroyTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remove the table entry from SQLite's internal schema and modify
  ** the schema cookie.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VDestroy</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTable</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqliteViewResetAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if shadow tables should be read-only in the current
** context.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ReadOnlyShadowTables</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_Defensive</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeExec</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3VtabInSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if it is not allowed to drop the given table
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tableMayNotBeDropped</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"stat"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"parameters"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Shadow</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ReadOnlyShadowTables</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Eponymous</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called to do the work of a DROP TABLE statement.
** pName is the name of the table to be dropped.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DropTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isView</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_drop_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_drop_table</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>noErr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isView</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isView</name><operator>==</operator><name>LOCATE_VIEW</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>isView</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pName</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>noErr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>noErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3CodeVerifyNamedSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ForceNotReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pTab is a virtual table, call ViewGetColumnNames() to ensure
  ** it is initialized.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_drop_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
      <goto>goto <name>exit_drop_table</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>isView</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>iDb</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>SQLITE_DROP_TEMP_VIEW</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>SQLITE_DROP_VIEW</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>SQLITE_DROP_VTABLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zArg2</name> <operator>=</operator> <call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>pMod</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>iDb</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>SQLITE_DROP_TEMP_TABLE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>SQLITE_DROP_TABLE</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zArg2</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_drop_table</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_drop_table</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><call><name>tableMayNotBeDropped</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %s may not be dropped"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <comment type="block">/* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used
  ** on a table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isView</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"use DROP TABLE to delete table %s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name> <operator>&amp;&amp;</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"use DROP VIEW to delete view %s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Generate code to remove the table from the schema table
  ** on disk.
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ClearStatTables</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="string">"tbl"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3FkDropTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeDropTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>isView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>exit_drop_table</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called to create a new foreign key on the table
** currently under construction.  pFromCol determines which columns
** in the current table point to the foreign key.  If pFromCol==0 then
** connect the key to the last column inserted.  pTo is the name of
** the table referred to (a.k.a the "parent" table).  pToCol is a list
** of tables in the parent pTo table.  flags contains all
** information about the conflict resolution algorithms specified
** in the ON DELETE, ON UPDATE and ON INSERT clauses.
**
** An FKey structure is created and added to the table currently
** under construction in the pParse-&gt;pNewTable field.
**
** The foreign key is set for IMMEDIATE processing.  A subsequent call
** to sqlite3DeferForeignKey() might change this to DEFERRED.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CreateForeignKey</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pFromCol</name></decl></parameter>,  <comment type="block">/* Columns in this table that point to other table */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>,          <comment type="block">/* Name of the other table */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pToCol</name></decl></parameter>,    <comment type="block">/* Columns in the other table */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>            <comment type="block">/* Conflict resolution algorithms. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pNextTo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>IN_DECLARE_VTAB</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fk_end</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFromCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fk_end</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pToCol</name> <operator>&amp;&amp;</operator> <name><name>pToCol</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"foreign key on %s"</literal>
         <literal type="string">" should reference only one column of table %T"</literal></expr></argument>,
         <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>fk_end</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pToCol</name> <operator>&amp;&amp;</operator> <name><name>pToCol</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>pFromCol</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><literal type="string">"number of columns in foreign key does not match the number of "</literal>
        <literal type="string">"columns in the referenced table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>fk_end</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>pFromCol</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFKey</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nCol</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pTo</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pToCol</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pToCol</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pToCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pFKey</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>fk_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pNextFrom</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RenameTokenMap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name><name>pTo</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>+=</operator> <name><name>pTo</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFromCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFrom</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>, <argument><expr><name><name>pFromCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><literal type="string">"unknown column \"%s\" in foreign key definition"</literal></expr></argument>, 
          <argument><expr><name><name>pFromCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>fk_end</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pFromCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pToCol</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pToCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCol</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pToCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pToCol</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>            <comment type="block">/* ON DELETE action */</comment>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal> <operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* ON UPDATE action */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNextTo</name> <operator>=</operator> <operator>(</operator><name>FKey</name> <operator>*</operator><operator>)</operator><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>fkeyHash</name></name></expr></argument>, 
      <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pFKey</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNextTo</name><operator>==</operator><name>pFKey</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>fk_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNextTo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNextTo</name><operator>-&gt;</operator><name>pPrevTo</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name></name> <operator>=</operator> <name>pNextTo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNextTo</name><operator>-&gt;</operator><name>pPrevTo</name></name> <operator>=</operator> <name>pFKey</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Link the foreign key to the table as the last step.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name> <operator>=</operator> <name>pFKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>fk_end</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_FOREIGN_KEY) */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFromCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED
** clause is seen as part of a foreign key definition.  The isDeferred
** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.
** The behavior of the most recently created foreign key is adjusted
** accordingly.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeferForeignKey</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isDeferred</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pFKey</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isDeferred</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isDeferred</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* EV: R-30323-21917 */</comment>
  <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>isDeferred</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will erase and refill index *pIdx.  This is
** used to initialize a newly created index or to recompute the
** content of an index in response to a REINDEX command.
**
** if memRootPage is not negative, it means that the index is newly
** created.  The register specified by memRootPage contains the
** root page number of the index.  If memRootPage is negative, then
** the index already exists and must be cleared before being refilled and
** the root page number of the index is taken from pIndex-&gt;tnum.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3RefillIndex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>memRootPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The table that is indexed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>     <comment type="block">/* Btree cursor used for pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>     <comment type="block">/* Btree cursor used for pIndex */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSorter</name></decl>;</decl_stmt>                   <comment type="block">/* Cursor opened by OpenSorter (if in use) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>                     <comment type="block">/* Address of top of loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr2</name></decl>;</decl_stmt>                     <comment type="block">/* Address to jump to for next iteration */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>tnum</name></decl>;</decl_stmt>                     <comment type="block">/* Root page of index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPartIdxLabel</name></decl>;</decl_stmt>             <comment type="block">/* Jump to this label to skip a row */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                       <comment type="block">/* Generate code into this virtual machine */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>                 <comment type="block">/* KeyInfo for index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>                 <comment type="block">/* Register holding assembled index record */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_REINDEX</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument> )</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Require a write-lock on the table to perform this operation */</comment>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>memRootPage</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>tnum</name> <operator>=</operator> <operator>(</operator><name>Pgno</name><operator>)</operator><name>memRootPage</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>tnum</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>sqlite3KeyInfoOfIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKey</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open the sorter cursor if we are to use one. */</comment>
  <expr_stmt><expr><name>iSorter</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterOpen</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator>
                    <call><name>sqlite3KeyInfoRef</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open the table. Loop through all rows of the table, inserting index
  ** records into the sorter. */</comment>
  <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3GenerateIndexKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pIndex</name></expr></argument>,<argument><expr><name>iTab</name></expr></argument>,<argument><expr><name>regRecord</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>iPartIdxLabel</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterInsert</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ResolvePartIdxLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iPartIdxLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>memRootPage</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Clear</name></expr></argument>, <argument><expr><name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, 
                    <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_BULKCSR</name><operator>|</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name>memRootPage</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><name>OPFLAG_P2ISREG</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterSort</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j2</name> <init>= <expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>addr2</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterCompare</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>, <argument><expr><name>j2</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>,
                         <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3UniqueConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Most CREATE INDEX and REINDEX statements that are not UNIQUE can not
    ** abort. The exception is if one of the indexed expressions contains a
    ** user function that throws an exception when it is evaluated. But the
    ** overhead of adding a statement journal to a CREATE INDEX statement is
    ** very small (since most of the pages written do not contain content that
    ** needs to be restored if the statement aborts), so we call 
    ** sqlite3MayAbort() for all CREATE INDEX statements.  */</comment>
    <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr2</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterData</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIndex</name><operator>-&gt;</operator><name>bAscKeyBug</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This OP_SeekEnd opcode makes index insert for a REINDEX go much
    ** faster by avoiding unnecessary seeks.  But the optimization does
    ** not work for UNIQUE constraint indexes on WITHOUT ROWID tables
    ** with DESC primary keys, since those indexes have there keys in
    ** a different order from the main table.
    ** See ticket: https://www.sqlite.org/src/info/bba7b69f9849b5bf
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekEnd</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterNext</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iSorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate heap space to hold an Index object with nCol columns.
**
** Increase the allocation size to provide an extra nExtra bytes
** of 8-byte aligned space after the Index object and return a
** pointer to this extra space in *ppExtra.
*/</comment>
<function><type><name>Index</name> <modifier>*</modifier></type><name>sqlite3AllocateIndexObject</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,         <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>i16</name></type> <name>nCol</name></decl></parameter>,            <comment type="block">/* Total number of columns in the index */</comment>
  <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>,          <comment type="block">/* Number of bytes of extra space to alloc */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExtra</name></decl></parameter>       <comment type="block">/* Pointer to the "extra" space */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* Allocated index object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>           <comment type="block">/* Bytes of space for Index object + arrays */</comment>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>              <comment type="block">/* Index structure  */</comment>
          <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr></argument>)</argument_list></call> <operator>+</operator>         <comment type="block">/* Index.azColl     */</comment>
          <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator>     <comment type="block">/* Index.aiRowLogEst   */</comment>
                 <sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name> <operator>+</operator>            <comment type="block">/* Index.aiColumn   */</comment>
                 <sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* Index.aSortOrder */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name> <operator>+</operator> <name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pExtra</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><operator>+</operator><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>azColl</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pExtra</name></expr>;</expr_stmt> <expr_stmt><expr><name>pExtra</name> <operator>+=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiRowLogEst</name></name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>*</operator><operator>)</operator><name>pExtra</name></expr>;</expr_stmt> <expr_stmt><expr><name>pExtra</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiColumn</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>*</operator><operator>)</operator><name>pExtra</name></expr>;</expr_stmt>       <expr_stmt><expr><name>pExtra</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSortOrder</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pExtra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>=</operator> <name>nCol</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppExtra</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator> <operator>+</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If expression list pList contains an expression that was parsed with
** an explicit "NULLS FIRST" or "NULLS LAST" clause, leave an error in
** pParse and return non-zero. Otherwise, return zero.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3HasExplicitNulls</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bNulls</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>sf</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unsupported use of NULLS %s"</literal></expr></argument>, 
            <argument><expr><ternary><condition><expr><operator>(</operator><name>sf</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>sf</name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"FIRST"</literal></expr> </then><else>: <expr><literal type="string">"LAST"</literal></expr></else></ternary></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new index for an SQL table.  pName1.pName2 is the name of the index 
** and pTblList is the name of the table that is to be indexed.  Both will 
** be NULL for a primary key or an index that is created to satisfy a
** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse-&gt;pNewTable
** as the table to be indexed.  pParse-&gt;pNewTable is a table that is
** currently being constructed by a CREATE TABLE statement.
**
** pList is a list of columns to be indexed.  pList will be NULL if this
** is a primary key or unique-constraint on the most recent column added
** to the table currently under construction.  
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CreateIndex</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* All information about this parse */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName1</name></decl></parameter>,     <comment type="block">/* First part of index name. May be NULL */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName2</name></decl></parameter>,     <comment type="block">/* Second part of index name. May be NULL */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTblName</name></decl></parameter>, <comment type="block">/* Table to index. Use pParse-&gt;pNewTable if 0 */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,   <comment type="block">/* A list of columns to be indexed */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,       <comment type="block">/* OE_Abort, OE_Ignore, OE_Replace, or OE_None */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>,     <comment type="block">/* The CREATE token that begins this statement */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pPIWhere</name></decl></parameter>,    <comment type="block">/* WHERE clause for partial indices */</comment>
  <parameter><decl><type><name>int</name></type> <name>sortOrder</name></decl></parameter>,     <comment type="block">/* Sort order of primary key when pList==NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>ifNotExist</name></decl></parameter>,    <comment type="block">/* Omit error if index already exists */</comment>
  <parameter><decl><type><name>u8</name></type> <name>idxType</name></decl></parameter>         <comment type="block">/* The index type */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Table to be indexed */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* The index to be created */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Name of the index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>           <comment type="block">/* Number of characters in zName */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbFixer</name></type> <name>sFix</name></decl>;</decl_stmt>        <comment type="block">/* For assigning database names to pTable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sortOrderMask</name></decl>;</decl_stmt>   <comment type="block">/* 1 to honor DESC in index.  0 to ignore. */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>             <comment type="block">/* The specific table containing the indexed database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>             <comment type="block">/* Index of the database that is being written */</comment>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Unqualified name of the index to create */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pListItem</name></decl>;</decl_stmt> <comment type="block">/* For looping over pList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Space allocated for zExtra[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtraCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of extra columns needed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Extra space after the Index object */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* PRIMARY KEY index for WITHOUT ROWID tables */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_DECLARE_VTAB</name> <operator>&amp;&amp;</operator> <name>idxType</name><operator>!=</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3HasExplicitNulls</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Find the table that is to be indexed.  Return early if not found.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pTblName</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>

    <comment type="block">/* Use the two-part index name to determine the database 
    ** to search for the table. 'Fix' the table name to this db
    ** before looking up the table.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName1</name> <operator>&amp;&amp;</operator> <name>pName2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name> <operator>&amp;&amp;</operator> <name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TEMPDB</name></cpp:ifndef>
    <comment type="block">/* If the index name was unqualified, check if the table
    ** is a temp table. If so, set the database to 1. Do not do this
    ** if initialising a database schema.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTblName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pName2</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pTab</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iDb</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>sqlite3FixInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sFix</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3FixSrcList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sFix</name></expr></argument>, <argument><expr><name>pTblName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Because the parser constructs pTblName from a single identifier,
      ** sqlite3FixSrcList can never fail. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTblName</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pTab</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
           <argument><expr><literal type="string">"cannot create a TEMP index on non-TEMP table \"%s\""</literal></expr></argument>,
           <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>exit_create_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStart</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name>pTblName</name><operator>!=</operator><literal type="number">0</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
       <operator>&amp;&amp;</operator> <call><name>sqlite3UserAuthTable</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %s may not be indexed"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"views may not be indexed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"virtual tables may not be indexed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/*
  ** Find the name of the index.  Make sure there is not already another
  ** index or table with the same name.  
  **
  ** Exception:  If we are reading the names of permanent indices from the
  ** sqlite_schema table (because some other process changed the schema) and
  ** one of the index names collides with the name of a temporary table or
  ** index, then we will continue to process this index.
  **
  ** If pName==0 it means that we are
  ** dealing with a primary key or UNIQUE constraint.  We have to invent our
  ** own name.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"index"</literal></expr></argument>,<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_create_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"there is already a table named %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>exit_create_index</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>ifNotExist</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"index %s already exists"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ForceNotReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <goto>goto <name>exit_create_index</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pLoop</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr><operator>,</operator> <expr><name>n</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>pLoop</name></expr>;</condition> <incr><expr><name>pLoop</name><operator>=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_autoindex_%s_%d"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_create_index</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Automatic index names generated from within sqlite3_declare_vtab()
    ** must have names that are distinct from normal automatic index names.
    ** The following statement converts "sqlite3_autoindex..." into
    ** "sqlite3_butoindex..." in order to make the names distinct.
    ** The "vtab_err.test" test demonstrates the need of this statement. */</comment>
    <if_stmt><if>if<condition>( <expr><name>IN_SPECIAL_PARSE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zName</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Check for authorization to create an index.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_create_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>SQLITE_CREATE_INDEX</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>iDb</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <name>SQLITE_CREATE_TEMP_INDEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_create_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If pList==0, it means this routine was called to make a primary
  ** key out of the last column added to the table under construction.
  ** So create a fake list to simulate this.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Token</name></type> <name>prevCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_UNIQUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TokenInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prevCol</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
              <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListSetSortOrder</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>sortOrder</name></expr></argument>, <argument><expr><name>SQLITE_SO_UNDEFINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListCheckLength</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Figure out how many bytes of space are required to store explicitly
  ** specified collation sequence names.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtra</name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* 
  ** Allocate the index structure. 
  */</comment>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nExtraCol</name> <operator>=</operator> <ternary><condition><expr><name>pPk</name></expr> ?</condition><then> <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>+</operator> <name>nExtraCol</name> <operator>&lt;=</operator> <literal type="number">32767</literal></expr></argument> <comment type="block">/* Fits in i16 */</comment> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <call><name>sqlite3AllocateIndexObject</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>+</operator> <name>nExtraCol</name></expr></argument>,
                                      <argument><expr><name>nName</name> <operator>+</operator> <name>nExtra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_create_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiRowLogEst</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>zExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zExtra</name> <operator>+=</operator> <name>nName</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>onError</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>onError</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>uniqNotNull</name></name> <operator>=</operator> <name>onError</name><operator>!=</operator><name>OE_None</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>idxType</name></name> <operator>=</operator> <name>idxType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPIWhere</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ResolveSelfReference</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>NC_PartIdx</name></expr></argument>, <argument><expr><name>pPIWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name> <operator>=</operator> <name>pPIWhere</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPIWhere</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if we should honor DESC requests on index columns
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name><operator>&gt;=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sortOrderMask</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Honor DESC */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>sortOrderMask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* Ignore DESC */</comment>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Analyze the list of expressions that form the terms of the index and
  ** report any errors.  In the common case where the expression is exactly
  ** a table column, store that column in aiColumn[].  For general expressions,
  ** populate pIndex-&gt;aColExpr and store XN_EXPR (-2) in aiColumn[].
  **
  ** TODO: Issue a warning if two or more columns of the index are identical.
  ** TODO: Issue a warning if the table primary key is used as part of the
  ** index key.
  */</comment>
  <expr_stmt><expr><name>pListItem</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pListItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCExpr</name></decl>;</decl_stmt>                  <comment type="block">/* The i-th index expression */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>requestedSortOrder</name></decl>;</decl_stmt>        <comment type="block">/* ASC or DESC on the i-th expression */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>             <comment type="block">/* Collation sequence name */</comment>

    <expr_stmt><expr><call><name>sqlite3StringToId</name><argument_list>(<argument><expr><name><name>pListItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ResolveSelfReference</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>NC_IdxExpr</name></expr></argument>, <argument><expr><name><name>pListItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pCExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pListItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"expressions prohibited in PRIMARY KEY and "</literal>
                                <literal type="string">"UNIQUE constraints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit_create_index</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>XN_EXPR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>XN_EXPR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>uniqNotNull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>bHasExpr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pCExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;=</operator><literal type="number">0x7fff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>uniqNotNull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>bHasVCol</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>bHasExpr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>j</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>zColl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pListItem</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nColl</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pListItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zColl</name> <operator>=</operator> <name><name>pListItem</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nColl</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExtra</name><operator>&gt;=</operator><name>nColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zExtra</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><name>nColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zColl</name> <operator>=</operator> <name>zExtra</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zExtra</name> <operator>+=</operator> <name>nColl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtra</name> <operator>-=</operator> <name>nColl</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zColl</name> <operator>=</operator> <call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColl</name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_create_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>zColl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>requestedSortOrder</name> <operator>=</operator> <name><name>pListItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>sortOrderMask</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>requestedSortOrder</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Append the table key to the end of the index.  For WITHOUT ROWID
  ** tables (when pPk!=0) this will be the declared PRIMARY KEY.  For
  ** normal tables (when pPk==0) this will be the rowid.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>isDupColumn</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nColumn</name></name><operator>--</operator></expr>;</expr_stmt> 
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>hasColumn</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name></name></expr></argument>,<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DefaultRowEst</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>estimateIndexWidth</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If this index contains every column of its table, then mark
  ** it as a covering index */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> 
      <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recomputeColumnsNotIndexed</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTblName</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>isCovering</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>isCovering</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This routine has been called to create an automatic index as a
    ** result of a PRIMARY KEY or UNIQUE clause on a column definition, or
    ** a PRIMARY KEY or UNIQUE clause following the column definitions.
    ** i.e. one of:
    **
    ** CREATE TABLE t(x PRIMARY KEY, y);
    ** CREATE TABLE t(x, y, UNIQUE(x, y));
    **
    ** Either way, check to see if the table already has such an index. If
    ** so, don't bother creating this one. This only applies to
    ** automatically created indices. Users can do as they wish with
    ** explicit indices.
    **
    ** Two UNIQUE or PRIMARY KEY constraints are considered equivalent
    ** (and thus suppressing the second one) even if they have different
    ** sort orders.
    **
    ** If there are different collating sequences or if the columns of
    ** the constraint occur in different orders, then the constraints are
    ** considered distinct and both result in separate indices.
    */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>idxType</name></name><operator>!=</operator><name>SQLITE_IDXTYPE_APPDEF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>!=</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>k</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>k</name></expr>]</index></name><operator>!=</operator><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>k</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>z1</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>z2</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>k</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name><name>pIndex</name><operator>-&gt;</operator><name>onError</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* This constraint creates the same index as a previous
          ** constraint specified somewhere in the CREATE TABLE statement.
          ** However the ON CONFLICT clauses are different. If both this 
          ** constraint and the previous equivalent constraint have explicit
          ** ON CONFLICT clauses this is an error. Otherwise, use the
          ** explicitly specified behavior for the index.
          */</comment>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Default</name> <operator>||</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Default</name><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
                <argument><expr><literal type="string">"conflicting ON CONFLICT clauses specified"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>onError</name></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>idxType</name><operator>==</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>idxType</name></name> <operator>=</operator> <name>idxType</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewIndex</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewIndex</name></name> <operator>=</operator> <name>pIndex</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <goto>goto <name>exit_create_index</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Link the new Index structure to its table and to the other
    ** in-memory database structures. 
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>IN_SPECIAL_PARSE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTblName</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3IndexHasDuplicateRootPage</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"invalid rootpage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          <goto>goto <name>exit_create_index</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr></argument>, 
          <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name>pIndex</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Malloc must have failed */</comment>
        <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit_create_index</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
    </block_content>}</block></if>

    <comment type="block">/* If this is the initial CREATE INDEX statement (or CREATE TABLE if the
    ** index is an implied index for a UNIQUE or PRIMARY KEY constraint) then
    ** emit code to allocate the index rootpage on disk and make an entry for
    ** the index in the sqlite_schema table and populate the index with
    ** content.  But, do not do this if we are simply reading the sqlite_schema
    ** table to parse the schema, or if this index is the PRIMARY KEY index
    ** of a WITHOUT ROWID table.
    **
    ** If pTblName==0 it means this index is generated as an implied PRIMARY KEY
    ** or UNIQUE index in a CREATE TABLE statement.  Since the table
    ** has just been created, it contains no data and the index initialization
    ** step can be skipped.
    */</comment>
    <if type="elseif">else if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pTblName</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmt</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iMem</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_create_index</name>;</goto></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Create the rootpage for the index using CreateIndex. But before
      ** doing so, code a Noop instruction and store its address in 
      ** Index.tnum. This is required in case this index is actually a 
      ** PRIMARY KEY and the table is actually a WITHOUT ROWID table. In 
      ** that case the convertToWithoutRowidTable() routine will replace
      ** the Noop with a Goto to jump over the VDBE code generated below. */</comment>
      <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name> <operator>=</operator> <operator>(</operator><name>Pgno</name><operator>)</operator><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Noop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CreateBtree</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr><name>BTREE_BLOBKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Gather the complete text of the CREATE INDEX statement into
      ** the zStmt variable
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pStart</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>sLastToken</name><operator>.</operator><name>z</name></name> <operator>-</operator> <name><name>pName</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator> <operator>+</operator> <name><name>pParse</name><operator>-&gt;</operator><name>sLastToken</name><operator>.</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pName</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">';'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* A named index with an explicit CREATE INDEX statement */</comment>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE%s INDEX %.*s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>onError</name><operator>==</operator><name>OE_None</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" UNIQUE"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* An automatic index created by a PRIMARY KEY or UNIQUE constraint */</comment>
        <comment type="block">/* zStmt = sqlite3MPrintf(""); */</comment>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Add an entry in sqlite_schema for this index
      */</comment>
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
         <argument><expr><literal type="string">"INSERT INTO %Q."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" VALUES('index',%Q,%Q,#%d,%Q);"</literal></expr></argument>,
         <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>,
         <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
         <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
         <argument><expr><name>iMem</name></expr></argument>,
         <argument><expr><name>zStmt</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Fill the index with data and reparse the schema. Code an OP_Expire
      ** to invalidate all pre-compiled statements.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>pTblName</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RefillIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>,
            <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"name='%q' AND type='index'"</literal></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Expire</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>||</operator> <name>pTblName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name> <operator>=</operator> <name>pIndex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewIndex</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewIndex</name></name> <operator>=</operator> <name>pIndex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clean up before exiting */</comment>
<label><name>exit_create_index</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pIndex</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3FreeIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Ensure all REPLACE indexes on pTab are at the end of the pIndex list.
    ** The list was already ordered when this routine was entered, so at this
    ** point at most a single index (the newly added index) will be out of
    ** order.  So we have to reorder at most one index. */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFrom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pThis</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ppFrom</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><operator>(</operator><name>pThis</name> <operator>=</operator> <operator>*</operator><name>ppFrom</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ppFrom</name><operator>=</operator><operator>&amp;</operator><name><name>pThis</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name>OE_Replace</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>pNext</name> <operator>=</operator> <name><name>pThis</name><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name>OE_Replace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppFrom</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pThis</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pNext</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pThis</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ppFrom</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNext</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <break>break;</break>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* Verify that all REPLACE indexes really are now at the end
    ** of the index list.  In other words, no other index type ever
    ** comes after a REPLACE index on the list. */</comment>
    <for>for<control>(<init><expr><name>pThis</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pThis</name></expr>;</condition> <incr><expr><name>pThis</name><operator>=</operator><name><name>pThis</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name>OE_Replace</name>
           <operator>||</operator> <name><name>pThis</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>pThis</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pPIWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTblName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Fill the Index.aiRowEst[] array with default information - information
** to be used when we have not run the ANALYZE command.
**
** aiRowEst[0] is supposed to contain the number of elements in the index.
** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the
** number of rows in the table that match any particular value of the
** first column of the index.  aiRowEst[2] is an estimate of the number
** of rows that match any particular combination of the first 2 columns
** of the index.  And so forth.  It must always be the case that
*
**           aiRowEst[N]&lt;=aiRowEst[N-1]
**           aiRowEst[N]&gt;=1
**
** Apart from that, we have little to go on besides intuition as to
** how aiRowEst[] should be initialized.  The numbers generated here
** are based on typical values found in actual indices.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DefaultRowEst</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
               <comment type="block">/*                10,  9,  8,  7,  6 */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LogEst</name></type> <name><name>aVal</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">33</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">26</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiRowLogEst</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Indexes with default row estimates should not have stat1 data */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>hasStat1</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the first entry (number of rows in the index) to the estimated 
  ** number of rows in the table, or half the number of rows in the table
  ** for a partial index.
  **
  ** 2020-05-27:  If some of the stat data is coming from the sqlite_stat1
  ** table but other parts we are having to guess at, then do not let the
  ** estimated number of rows in the table be less than 1000 (LogEst 99).
  ** Failure to do this can cause the indexes for which we do not have
  ** stat1 data to be ignored by the query planner.
  */</comment>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">99</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">99</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <name>x</name> <operator>=</operator> <literal type="number">99</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>x</name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">10</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

  <comment type="block">/* Estimate that a[1] is 10, a[2] is 9, a[3] is 8, a[4] is 7, a[5] is
  ** 6 and each subsequent value (if any) is 5.  */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><name>nCopy</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nCopy</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt>                    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">23</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine will drop an existing named index.  This routine
** implements the DROP INDEX statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DropIndex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ifExists</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_drop_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Never called with prior non-OOM errors */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_drop_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIndex</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>ifExists</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such index: %S"</literal></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3CodeVerifyNamedSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ForceNotReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>idxType</name></name><operator>!=</operator><name>SQLITE_IDXTYPE_APPDEF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"index associated with UNIQUE "</literal>
      <literal type="string">"or PRIMARY KEY constraint cannot be dropped"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_index</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><name>SQLITE_DROP_INDEX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_drop_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>iDb</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>=</operator> <name>SQLITE_DROP_TEMP_INDEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>exit_drop_index</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Generate code to remove the index and from the schema table */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
       <argument><expr><literal type="string">"DELETE FROM %Q."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" WHERE name=%Q AND type='index'"</literal></expr></argument>,
       <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ClearStatTables</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>destroyRootPage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropIndex</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>exit_drop_index</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pArray is a pointer to an array of objects. Each object in the
** array is szEntry bytes in size. This routine uses sqlite3DbRealloc()
** to extend the array so that there is space for a new object at the end.
**
** When this function is called, *pnEntry contains the current size of
** the array (in entries - so the allocation is ((*pnEntry) * szEntry) bytes
** in total).
**
** If the realloc() is successful (i.e. if no OOM condition occurs), the
** space allocated for the new object is zeroed, *pnEntry updated to
** reflect the new size of the array and a pointer to the new allocation
** returned. *pIdx is set to the index of the new array entry in this case.
**
** Otherwise, if the realloc() fails, *pIdx is set to -1, *pnEntry remains
** unchanged and a copy of pArray returned.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3ArrayAllocate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,      <comment type="block">/* Connection to notify of malloc failures */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArray</name></decl></parameter>,     <comment type="block">/* Array of objects.  Might be reallocated */</comment>
  <parameter><decl><type><name>int</name></type> <name>szEntry</name></decl></parameter>,      <comment type="block">/* Size of each object in the array */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnEntry</name></decl></parameter>,     <comment type="block">/* Number of objects currently in use */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>         <comment type="block">/* Write the index of a new slot here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><operator>*</operator><name>pIdx</name> <operator>=</operator> <operator>*</operator><name>pnEntry</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>n</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>sz</name><operator>*</operator><name>szEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pIdx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>pArray</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pArray</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pArray</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>n</name> <operator>*</operator> <name>szEntry</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>szEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>*</operator><name>pnEntry</name></expr>;</expr_stmt>
  <return>return <expr><name>pArray</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append a new element to the given IdList.  Create a new IdList if
** need be.
**
** A new IdList is returned, or NULL if malloc() fails.
*/</comment>
<function><type><name>IdList</name> <modifier>*</modifier></type><name>sqlite3IdListAppend</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdList</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>,
                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdList</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pList</name><operator>-&gt;</operator><name>nId</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nId</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RenameTokenMap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete an IdList.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3IdListDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>eU4</name></name><operator>!=</operator><name>EU4_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* EU4_EXPR mode is not currently used */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the index in pList of the identifier named zId.  Return -1
** if not found.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IdListIndex</name><parameter_list>(<parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Maximum size of a SrcList object.
** The SrcList object is used to represent the FROM clause of a
** SELECT statement, and the query planner cannot deal with more
** than 64 tables in a join.  So any value larger than 64 here
** is sufficient for most uses.  Smaller values, like say 10, are
** appropriate for small and memory-limited applications.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_MAX_SRCLIST</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MAX_SRCLIST</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Expand the space allocated for the given SrcList object by
** creating nExtra new slots beginning at iStart.  iStart is zero based.
** New slots are zeroed.
**
** For example, suppose a SrcList initially contains two entries: A,B.
** To append 3 new entries onto the end, do this:
**
**    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);
**
** After the call above it would contain:  A, B, nil, nil, nil.
** If the iStart argument had been 1 instead of 2, then the result
** would have been:  A, nil, nil, nil, B.  To prepend the new slots,
** the iStart value would be 0.  The result then would
** be: nil, nil, nil, A, B.
**
** If a memory allocation fails or the SrcList becomes too large, leave
** the original SrcList unchanged, return NULL, and leave an error message
** in pParse.
*/</comment>
<function><type><name>SrcList</name> <modifier>*</modifier></type><name>sqlite3SrcListEnlarge</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context into which errors are reported */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,     <comment type="block">/* The SrcList to be enlarged */</comment>
  <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>,        <comment type="block">/* Number of new slots to add to pSrc-&gt;a[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>         <comment type="block">/* Index in pSrc-&gt;a[] of first new slot */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity checking on calling parameters */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStart</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExtra</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStart</name><operator>&lt;=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate additional space if needed */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>+</operator><name>nExtra</name><operator>&gt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>+</operator><name>nExtra</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>+</operator><name>nExtra</name><operator>&gt;=</operator><name>SQLITE_MAX_SRCLIST</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many FROM clause terms, max: %d"</literal></expr></argument>,
                      <argument><expr><name>SQLITE_MAX_SRCLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nAlloc</name><operator>&gt;</operator><name>SQLITE_MAX_SRCLIST</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>SQLITE_MAX_SRCLIST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pSrc</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nAlloc</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nAlloc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Move existing slots that come after the newly inserted slots
  ** out of the way */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name>iStart</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>+</operator><name>nExtra</name></expr>]</index></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>+=</operator> <name>nExtra</name></expr>;</expr_stmt>

  <comment type="block">/* Zero the newly allocated slots */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iStart</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iStart</name><operator>+</operator><name>nExtra</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Return a pointer to the enlarged SrcList */</comment>
  <return>return <expr><name>pSrc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Append a new table name to the given SrcList.  Create a new SrcList if
** need be.  A new entry is created in the SrcList even if pTable is NULL.
**
** A SrcList is returned, or NULL if there is an OOM error or if the
** SrcList grows to large.  The returned
** SrcList might be the same as the SrcList that was input or it might be
** a new one.  If an OOM error does occurs, then the prior value of pList
** that is input to this routine is automatically freed.
**
** If pDatabase is not null, it means that the table has an optional
** database name prefix.  Like this:  "database.table".  The pDatabase
** points to the table name and the pTable points to the database name.
** The SrcList.a[].zName field is filled with the table name which might
** come from pTable (if pDatabase is NULL) or from pDatabase.  
** SrcList.a[].zDatabase is filled with the database name from pTable,
** or with NULL if no database is specified.
**
** In other words, if call like this:
**
**         sqlite3SrcListAppend(D,A,B,0);
**
** Then B is a table name and the database name is unspecified.  If called
** like this:
**
**         sqlite3SrcListAppend(D,A,B,C);
**
** Then C is the table name and B is the database name.  If C is defined
** then so is B.  In other words, we never have a case where:
**
**         sqlite3SrcListAppend(D,A,0,C);
**
** Both pTable and pDatabase are assumed to be quoted.  They are dequoted
** before being added to the SrcList.
*/</comment>
<function><type><name>SrcList</name> <modifier>*</modifier></type><name>sqlite3SrcListAppend</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing context, in which errors are reported */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,     <comment type="block">/* Append to this SrcList. NULL creates a new SrcList */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>,      <comment type="block">/* Table to append */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pDatabase</name></decl></parameter>    <comment type="block">/* Database of the table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDatabase</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pTable</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Cannot have C without B */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SrcList</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3SrcListEnlarge</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDatabase</name> <operator>&amp;&amp;</operator> <name><name>pDatabase</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pDatabase</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDatabase</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Assign VdbeCursor index numbers to all tables in a SrcList
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListAssignCursors</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete an entire SrcList including all its substructure.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called by the parser to add a new term to the
** end of a growing FROM clause.  The "p" parameter is the part of
** the FROM clause that has already been constructed.  "p" is NULL
** if this is the first term of the FROM clause.  pTable and pDatabase
** are the name of the table and database named in the FROM clause term.
** pDatabase is NULL if the database name qualifier is missing - the
** usual case.  If the term has an alias, then pAlias points to the
** alias token.  If the term is a subquery, then pSubquery is the
** SELECT statement that the subquery encodes.  The pTable and
** pDatabase parameters are NULL for subqueries.  The pOn and pUsing
** parameters are the content of the ON and USING clauses.
**
** Return a new SrcList which encodes is the FROM with the new
** term added.
*/</comment>
<function><type><name>SrcList</name> <modifier>*</modifier></type><name>sqlite3SrcListAppendFromTerm</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* The left part of the FROM clause already seen */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>,          <comment type="block">/* Name of the table to add to the FROM clause */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pDatabase</name></decl></parameter>,       <comment type="block">/* Name of the database containing pTable */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pAlias</name></decl></parameter>,          <comment type="block">/* The right-hand side of the AS subexpression */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSubquery</name></decl></parameter>,      <comment type="block">/* A subquery used in place of a table name */</comment>
  <parameter><decl><type><name>OnOrUsing</name> <modifier>*</modifier></type><name>pOnUsing</name></decl></parameter>     <comment type="block">/* Either the ON clause or the USING clause */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name> <operator>&amp;&amp;</operator> <name>pOnUsing</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pOnUsing</name><operator>-&gt;</operator><name>pOn</name></name> <operator>||</operator> <name><name>pOnUsing</name><operator>-&gt;</operator><name>pUsing</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"a JOIN clause is required before %s"</literal></expr></argument>, 
      <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pOnUsing</name><operator>-&gt;</operator><name>pOn</name></name></expr> ?</condition><then> <expr><literal type="string">"ON"</literal></expr> </then><else>: <expr><literal type="string">"USING"</literal></expr></else></ternary><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>append_from_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><name>pDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>append_from_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pTable</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>pDatabase</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pDatabase</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pDatabase</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pDatabase</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>pDatabase</name></expr> </then><else>: <expr><name>pTable</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3RenameTokenMap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pAlias</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAlias</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubquery</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <name>pSubquery</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSubquery</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_NestedFrom</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOnUsing</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOnUsing</name><operator>-&gt;</operator><name>pOn</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOnUsing</name><operator>-&gt;</operator><name>pUsing</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOnUsing</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOnUsing</name><operator>-&gt;</operator><name>pUsing</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name> <operator>=</operator> <name><name>pOnUsing</name><operator>-&gt;</operator><name>pUsing</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name> <operator>=</operator> <name><name>pOnUsing</name><operator>-&gt;</operator><name>pOn</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>

<label><name>append_from_error</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ClearOnOrUsing</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOnUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an INDEXED BY or NOT INDEXED clause to the most recently added 
** element of the source-list passed as the second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListIndexedBy</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pIndexedBy</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIndexedBy</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>pIndexedBy</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIndexedBy</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pIndexedBy</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* A "NOT INDEXED" clause was supplied. See parse.y 
      ** construct "indexed_opt" for details. */</comment>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pIndexedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No collision on union u2 */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Append the contents of SrcList p2 to SrcList p1 and return the resulting
** SrcList. Or, if an error occurs, return NULL. In all cases, p1 and p2
** are deleted by this function.
*/</comment> 
<function><type><name>SrcList</name> <modifier>*</modifier></type><name>sqlite3SrcListAppendList</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name> <operator>&amp;&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3SrcListEnlarge</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>nSrc</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SrcItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>|=</operator> <operator>(</operator><name>JT_LTORJ</name> <operator>&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add the list of function arguments to the SrcList entry for a
** table-valued-function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListFuncArgs</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** When building up a FROM clause in the parser, the join operator
** is initially attached to the left operand.  But the code generator
** expects the join operator to be on the right operand.  This routine
** Shifts all join operators from left to right for an entire FROM
** clause.
**
** Example: Suppose the join is like this:
**
**           A natural cross join B
**
** The operator is "natural cross join".  The A and B operands are stored
** in p-&gt;a[0] and p-&gt;a[1], respectively.  The parser initially stores the
** operator with A.  This routine shifts that operator over to B.
**
** Additional changes:
**
**   *   All tables to the left of the right-most RIGHT JOIN are tagged with
**       JT_LTORJ (mnemonic: Left Table Of Right Join) so that the
**       code generator can easily tell that the table is part of
**       the left operand of at least one RIGHT JOIN.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListShiftJoinType</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pParse</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>allFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>allFlags</name> <operator>|=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>--</operator><name>i</name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* All terms to the left of a RIGHT JOIN should be tagged with the
    ** JT_LTORJ flags */</comment>
    <if_stmt><if>if<condition>( <expr><name>allFlags</name> <operator>&amp;</operator> <name>JT_RIGHT</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name><operator>&amp;</operator><name>JT_RIGHT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>|=</operator> <name>JT_LTORJ</name></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>--</operator><name>i</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition>;</do>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate VDBE code for a BEGIN statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BeginTransaction</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_TRANSACTION</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>v</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>!=</operator><name>TK_DEFERRED</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>eTxnType</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeIsReadonly</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eTxnType</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Read txn */</comment>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>type</name><operator>==</operator><name>TK_EXCLUSIVE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eTxnType</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* Exclusive txn */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>eTxnType</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Write txn */</comment>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Transaction</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>eTxnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AutoCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate VDBE code for a COMMIT or ROLLBACK statement.
** Code for ROLLBACK is generated if eType==TK_ROLLBACK.  Otherwise
** code is generated for a COMMIT.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3EndTransaction</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isRollback</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>TK_COMMIT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>TK_END</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>TK_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isRollback</name> <operator>=</operator> <name>eType</name><operator>==</operator><name>TK_ROLLBACK</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_TRANSACTION</name></expr></argument>, 
       <argument><expr><ternary><condition><expr><name>isRollback</name></expr> ?</condition><then> <expr><literal type="string">"ROLLBACK"</literal></expr> </then><else>: <expr><literal type="string">"COMMIT"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AutoCommit</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>isRollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the parser when it parses a command to create,
** release or rollback an SQL savepoint. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Savepoint</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>az</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"BEGIN"</literal></expr>, <expr><literal type="string">"RELEASE"</literal></expr>, <expr><literal type="string">"ROLLBACK"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>SAVEPOINT_BEGIN</name> <operator>&amp;&amp;</operator> <name>SAVEPOINT_RELEASE</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>SAVEPOINT_ROLLBACK</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>v</name> <operator>||</operator> <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_SAVEPOINT</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Savepoint</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make sure the TEMP database is open and available for use.  Return
** the number of errors.  Leave any error messages in the pParse structure.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3OpenTempDatabase</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pBt</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= 
          <expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator>
          <name>SQLITE_OPEN_CREATE</name> <operator>|</operator>
          <name>SQLITE_OPEN_EXCLUSIVE</name> <operator>|</operator>
          <name>SQLITE_OPEN_DELETEONCLOSE</name> <operator>|</operator>
          <name>SQLITE_OPEN_TEMP_DB</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unable to open a temporary database "</literal>
        <literal type="string">"file for storing temporary tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pBt</name> <operator>=</operator> <name>pBt</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_NOMEM</name><operator>==</operator><call><name>sqlite3BtreeSetPageSize</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nextPagesize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Record the fact that the schema cookie will need to be verified
** for database iDb.  The code to actually verify the schema cookie
** will occur at the end of the top-level VDBE and will be generated
** later, by sqlite3FinishCoding().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3CodeVerifySchemaAtToplevel</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>iDb</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&lt;</operator><name>SQLITE_MAX_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>cookieMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>DbMaskSet</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>cookieMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>OMIT_TEMPDB</name> <operator>&amp;&amp;</operator> <name>iDb</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OpenTempDatabase</name><argument_list>(<argument><expr><name>pToplevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3CodeVerifySchema</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3CodeVerifySchemaAtToplevel</name><argument_list>(<argument><expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** If argument zDb is NULL, then call sqlite3CodeVerifySchema() for each 
** attached database. Otherwise, invoke it for the database named zDb only.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CodeVerifyNamedSchema</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>zDb</name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zDbSName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Generate VDBE code that prepares for doing an operation that
** might change the database.
**
** This routine starts a new transaction if we are not already within
** a transaction.  If we are already within a transaction, then a checkpoint
** is set if the setStatement parameter is true.  A checkpoint should
** be set for operations that might fail (due to a constraint) part of
** the way through and which will need to undo some writes without having to
** rollback the whole transaction.  For operations where all constraints
** can be checked before any changes are made to the database, it is never
** necessary to undo a write and the checkpoint should not be set.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BeginWriteOperation</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setStatement</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3CodeVerifySchemaAtToplevel</name><argument_list>(<argument><expr><name>pToplevel</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DbMaskSet</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>writeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>isMultiWrite</name></name> <operator>|=</operator> <name>setStatement</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Indicate that the statement currently under construction might write
** more than one entry (example: deleting one row then inserting another,
** inserting multiple rows in a table, or inserting a row and index entries.)
** If an abort occurs after some of these writes have completed, then it will
** be necessary to undo the completed writes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MultiWrite</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>isMultiWrite</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** The code generator calls this routine if is discovers that it is
** possible to abort a statement prior to completion.  In order to 
** perform this abort without corrupting the database, we need to make
** sure that the statement is protected by a statement transaction.
**
** Technically, we only need to set the mayAbort flag if the
** isMultiWrite flag was previously set.  There is a time dependency
** such that the abort must occur after the multiwrite.  This makes
** some statements involving the REPLACE conflict resolution algorithm
** go a little faster.  But taking advantage of this time dependency
** makes it more difficult to prove that the code is correct (in 
** particular, it prevents us from writing an effective
** implementation of sqlite3AssertMayAbort()) and so we have chosen
** to take the safe route and skip the optimization.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MayAbort</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>mayAbort</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Code an OP_Halt that causes the vdbe to return an SQLITE_CONSTRAINT
** error. The onError parameter determines which (if any) of the statement
** and/or current transaction is rolled back.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3HaltConstraint</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>,      <comment type="block">/* extended error code */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,      <comment type="block">/* Constraint type */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p4</name></decl></parameter>,         <comment type="block">/* Error message */</comment>
  <parameter><decl><type><name>i8</name></type> <name>p4type</name></decl></parameter>,        <comment type="block">/* P4_STATIC or P4_TRANSIENT */</comment>
  <parameter><decl><type><name>u8</name></type> <name>p5Errmsg</name></decl></parameter>       <comment type="block">/* P5_ErrMsg type */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>errCode</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>errCode</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p4</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p5Errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Code an OP_Halt due to UNIQUE or PRIMARY KEY constraint violation.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UniqueConstraint</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,      <comment type="block">/* Constraint type */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>       <comment type="block">/* The index that triggers the constraint */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>errMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
                      <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>, <argument><expr><literal type="string">"index '%q'"</literal></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
    <argument><expr><ternary><condition><expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>SQLITE_CONSTRAINT_PRIMARYKEY</name></expr> 
                            </then><else>: <expr><name>SQLITE_CONSTRAINT_UNIQUE</name></expr></else></ternary></expr></argument>,
    <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>, <argument><expr><name>P5_ConstraintUnique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Code an OP_Halt due to non-unique rowid.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RowidConstraint</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,      <comment type="block">/* Conflict resolution algorithm */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>       <comment type="block">/* The table with the non-unique rowid */</comment> 
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                          <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT_PRIMARYKEY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"%s.rowid"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT_ROWID</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>,
                        <argument><expr><name>P5_ConstraintUnique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if pIndex uses the collating sequence pColl.  Return
** true if it does and false if it does not.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>collationMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zColl</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Recompute all indices of pTab that use the collating sequence pColl.
** If pColl==0 then recompute all indices of pTab.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reindexTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>              <comment type="block">/* An index associated with pTab */</comment>

    <for>for<control>(<init><expr><name>pIndex</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIndex</name></expr>;</condition> <incr><expr><name>pIndex</name><operator>=</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zColl</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>collationMatch</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3RefillIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Recompute all indices of all tables in all databases where the
** indices use the collating sequence pColl.  If pColl==0 then recompute
** all indices everywhere.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reindexDatabases</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* A single database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                    <comment type="block">/* The database index number */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>                <comment type="block">/* For looping over tables in pDb */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                <comment type="block">/* A table in the database */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Needed for schema access */</comment>
  <for>for<control>(<init><expr><name>iDb</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pDb</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr>;</init> <condition><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>iDb</name><operator>++</operator></expr><operator>,</operator> <expr><name>pDb</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</init>  <condition><expr><name>k</name></expr>;</condition> <incr><expr><name>k</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <operator>(</operator><name>Table</name><operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>reindexTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Generate code for the REINDEX command.
**
**        REINDEX                            -- 1
**        REINDEX  &lt;collation&gt;               -- 2
**        REINDEX  ?&lt;database&gt;.?&lt;tablename&gt;  -- 3
**        REINDEX  ?&lt;database&gt;.?&lt;indexname&gt;  -- 4
**
** Form 1 causes all indices in all attached databases to be rebuilt.
** Form 2 rebuilds all indices in all databases that use the named
** collating function.  Forms 3 and 4 rebuild the named index or all
** indices associated with the named table.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3Reindex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName1</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>             <comment type="block">/* Collating sequence to be reindexed, or NULL */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                    <comment type="block">/* Name of a table or index */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>            <comment type="block">/* Name of the database */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                <comment type="block">/* A table in the database */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>              <comment type="block">/* An index associated with pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                    <comment type="block">/* The database index number */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pObjName</name></decl>;</decl_stmt>            <comment type="block">/* Name of the table or index to be reindexed */</comment>

  <comment type="block">/* Read the database schema. If an error occurs, leave an error message
  ** and code in pParse and return NULL. */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pName1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>reindexDatabases</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pName2</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pName2</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pName1</name><operator>-&gt;</operator><name>z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zColl</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zColl</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColl</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>reindexDatabases</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pObjName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pObjName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>reindexTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIndex</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3RefillIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unable to identify the object to be reindexed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return a KeyInfo structure that is appropriate for the given Index.
**
** The caller should invoke sqlite3KeyInfoUnref() on the returned object
** when it has finished using it.
*/</comment>
<function><type><name>KeyInfo</name> <modifier>*</modifier></type><name>sqlite3KeyInfoOfIndex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>nCol</name><operator>-</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pKey</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pKey</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>zColl</name><operator>==</operator><name>sqlite3StrBINARY</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                        <expr><call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pKey</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_ERROR_MISSING_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>bNoQuery</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Deactivate the index because it contains an unknown collating
        ** sequence.  The only way to reactive the index is to reload the
        ** schema.  Adding the missing collating sequence later does not
        ** reactive the index.  The application had the chance to register
        ** the missing index using the collation-needed callback.  For
        ** simplicity, SQLite will not give the application a second chance.
        */</comment>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>bNoQuery</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR_RETRY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pKey</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
<comment type="block">/*
** Create a new CTE object
*/</comment>
<function><type><name>Cte</name> <modifier>*</modifier></type><name>sqlite3CteNew</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>,           <comment type="block">/* Name of the common-table */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pArglist</name></decl></parameter>,     <comment type="block">/* Optional column name list for the table */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>,         <comment type="block">/* Query used to initialize the table */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eM10d</name></decl></parameter>                <comment type="block">/* The MATERIALIZED flag */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Cte</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pArglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <name>pQuery</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pCols</name></name> <operator>=</operator> <name>pArglist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eM10d</name></name> <operator>=</operator> <name>eM10d</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clear information from a Cte object, but do not deallocate storage
** for the object itself.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cteClear</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Cte</name> <modifier>*</modifier></type><name>pCte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCte</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the contents of the CTE object passed as the second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CteDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Cte</name> <modifier>*</modifier></type><name>pCte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCte</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cteClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** This routine is invoked once per CTE by the parser while parsing a 
** WITH clause.  The CTE described by teh third argument is added to
** the WITH clause of the second argument.  If the second argument is
** NULL, then a new WITH argument is created.
*/</comment>
<function><type><name>With</name> <modifier>*</modifier></type><name>sqlite3WithAdd</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name></decl></parameter>,            <comment type="block">/* Existing WITH clause, or NULL */</comment>
  <parameter><decl><type><name>Cte</name> <modifier>*</modifier></type><name>pCte</name></decl></parameter>               <comment type="block">/* CTE to add to the WITH clause */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pCte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pWith</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check that the CTE name is unique within this WITH clause. If
  ** not, store an error in the Parse structure. */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name> <operator>&amp;&amp;</operator> <name>pWith</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWith</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pWith</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"duplicate WITH table name: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pWith</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pWith</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWith</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pWith</name><operator>-&gt;</operator><name>nCte</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWith</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pWith</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pNew</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zName</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CteDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pWith</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nCte</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>pCte</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the contents of the With object passed as the second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WithDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pWith</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWith</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>cteClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWith</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWith</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_CTE) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LIBSQL_ENABLE_WASM_RUNTIME</name></cpp:ifdef>

<function><type><name>void</name></type> <name>libsql_create_function</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>,      <comment type="block">/* Function name */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pLang</name></decl></parameter>,      <comment type="block">/* Language of the function */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pBody</name></decl></parameter>,      <comment type="block">/* Body of the function */</comment>
  <parameter><decl><type><name>int</name></type> <name>isBlob</name></decl></parameter>,        <comment type="block">/* If the input token is blob */</comment>
  <parameter><decl><type><name>int</name></type> <name>noErr</name></decl></parameter>          <comment type="block">/* Suppress error messages if FUNCTION already exists */</comment>
)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pLang</name><operator>-&gt;</operator><name>n</name></name> <operator>!=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><literal type="string">"wasm"</literal></expr></argument>, <argument><expr><name><name>pLang</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"The only supported language for user-defined functions is 'wasm'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>Token</name></type> <name>table</name> <init>= <expr><block>{<expr><literal type="string">"libsql_wasm_func_table"</literal></expr>, <expr><literal type="number">22</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>name</name> <init>= <expr><block>{<expr><literal type="string">"name"</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>body</name> <init>= <expr><block>{<expr><literal type="string">"body"</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pParsedBody</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>src_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>isBlob</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pParsedBody</name> <operator>=</operator> <call><name>sqlite3HexToBlob</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pBody</name><operator>-&gt;</operator><name>z</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pBody</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src_size</name> <operator>=</operator> <operator>(</operator><name><name>pBody</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>pParsedBody</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src_size</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>SrcList</name><modifier>*</modifier></type> <name>tab_list</name> <init>= <expr><call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tab_list</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate tab list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>IdList</name><modifier>*</modifier></type> <name>id_list</name> <init>= <expr><call><name>sqlite3IdListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>id_list</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate id list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>tab_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>id_list</name> <operator>=</operator> <call><name>sqlite3IdListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>id_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>ExprList</name><modifier>*</modifier></type> <name>expr_list</name> <init>= <expr><call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_STRING</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr_list</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate expr list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>tab_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>id_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>Token</name></type> <name>parsed_text</name> <init>= <expr><block>{
    <expr><operator>.</operator><name>z</name> <operator>=</operator> <name>pParsedBody</name></expr>,
    <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>src_size</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>expr_list</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>expr_list</name></expr></argument>, <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>isBlob</name></expr> ?</condition><then> <expr><name>TK_BLOB</name></expr> </then><else>: <expr><name>TK_STRING</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>isBlob</name></expr> ?</condition><then> <expr><name>pBody</name></expr> </then><else>: <expr><operator>&amp;</operator><name>parsed_text</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>Select</name><modifier>*</modifier></type> <name>select</name> <init>= <expr><call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>expr_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SF_Values</name><operator>|</operator><name>SF_MultiValue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>select</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate select"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>tab_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>id_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>expr_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3Insert</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>tab_list</name></expr></argument>, <argument><expr><name>select</name></expr></argument>, <argument><expr><name>id_list</name></expr></argument>, <argument><expr><ternary><condition><expr><name>noErr</name></expr> ?</condition><then> <expr><name>OE_Ignore</name></expr> </then><else>: <expr><name>OE_Default</name></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// AddWasmFunc operation</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pAddFuncData</name> <init>= <expr><call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pAddFuncData</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pAddFuncData</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pAddFuncData</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate function name and body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pAddFuncData</name> <operator>+</operator> <name><name>pName</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pParsedBody</name></expr></argument>, <argument><expr><name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OP_CreateWasmFunc</name></expr></argument>, <argument><expr><name>noErr</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>src_size</name></expr></argument>, <argument><expr><name>pAddFuncData</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pParsedBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>libsql_drop_function</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>,      <comment type="block">/* Function name */</comment>
  <parameter><decl><type><name>int</name></type> <name>noErr</name></decl></parameter>          <comment type="block">/* Suppress error messages if FUNCTION does not exist */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>table</name> <init>= <expr><block>{<expr><literal type="string">"libsql_wasm_func_table"</literal></expr>, <expr><literal type="number">22</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name><modifier>*</modifier></type> <name>tab_list</name> <init>= <expr><call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tab_list</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate tab list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>name</name> <init>= <expr><block>{<expr><literal type="string">"name"</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name><modifier>*</modifier></type> <name>where</name> <init>= <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>,
                             <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_STRING</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3DeleteFrom</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>tab_list</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zName</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OP_DropWasmFunc</name></expr></argument>, <argument><expr><name>noErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif></unit>
