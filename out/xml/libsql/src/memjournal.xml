<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/memjournal.c"><comment type="block">/*
** 2008 October 7
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to implement an in-memory rollback journal.
** The in-memory rollback journal is used to journal transactions for
** ":memory:" databases and when the journal_mode=MEMORY pragma is used.
**
** Update:  The in-memory journal is also used to temporarily cache
** smaller journals that are not critical for power-loss recovery.
** For example, statement journals that are not too big will be held
** entirely in memory, thus reducing the number of file I/O calls, and
** more importantly, reducing temporary file creation events.  If these
** journals become too large for memory, they are spilled to disk.  But
** in the common case, they are usually small and no file I/O needs to
** occur.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/* Forward references to internal structures */</comment>
<typedef>typedef <type><name><name>struct</name> <name>MemJournal</name></name></type> <name>MemJournal</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FilePoint</name></name></type> <name>FilePoint</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FileChunk</name></name></type> <name>FileChunk</name>;</typedef>

<comment type="block">/*
** The rollback journal is composed of a linked list of these structures.
**
** The zChunk array is always at least 8 bytes in size - usually much more.
** Its actual size is stored in the MemJournal.nChunkSize variable.
*/</comment>
<struct>struct <name>FileChunk</name> <block>{
  <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>               <comment type="block">/* Next chunk in the journal */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>zChunk</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>                   <comment type="block">/* Content of this chunk */</comment>
}</block>;</struct>

<comment type="block">/*
** By default, allocate this many bytes of memory for each FileChunk object.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEMJOURNAL_DFLT_FILECHUNKSIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/*
** For chunk size nChunkSize, return the number of bytes that should
** be allocated for each FileChunk structure.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fileChunkSize</name><parameter_list>(<parameter><type><name>nChunkSize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(FileChunk) + ((nChunkSize)-8))</cpp:value></cpp:define>

<comment type="block">/*
** An instance of this object serves as a cursor into the rollback journal.
** The cursor can be either for reading or writing.
*/</comment>
<struct>struct <name>FilePoint</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iOffset</name></decl>;</decl_stmt>          <comment type="block">/* Offset from the beginning of the file */</comment>
  <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>              <comment type="block">/* Specific chunk into which cursor points */</comment>
}</block>;</struct>

<comment type="block">/*
** This structure is a subclass of sqlite3_file. Each open memory-journal
** is an instance of this class.
*/</comment>
<struct>struct <name>MemJournal</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pMethod</name></decl>;</decl_stmt> <comment type="block">/* Parent class. MUST BE FIRST */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChunkSize</name></decl>;</decl_stmt>                 <comment type="block">/* In-memory chunk-size */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nSpill</name></decl>;</decl_stmt>                     <comment type="block">/* Bytes of data before flushing */</comment>
  <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>              <comment type="block">/* Head of in-memory chunk-list */</comment>
  <decl_stmt><decl><type><name>FilePoint</name></type> <name>endpoint</name></decl>;</decl_stmt>             <comment type="block">/* Pointer to the end of the file */</comment>
  <decl_stmt><decl><type><name>FilePoint</name></type> <name>readpoint</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to the end of the last xRead() */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                      <comment type="block">/* xOpen flags */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>              <comment type="block">/* The "real" underlying VFS */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJournal</name></decl>;</decl_stmt>           <comment type="block">/* Name of the journal file */</comment>
}</block>;</struct>

<comment type="block">/*
** Read data from the in-memory journal file.  This is the implementation
** of the sqlite3_vfs.xRead method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>,    <comment type="block">/* The journal file from which to read */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,            <comment type="block">/* Put the results here */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,              <comment type="block">/* Number of bytes to read */</comment>
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>     <comment type="block">/* Begin reading at this offset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name> <operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><name>zBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> <init>= <expr><name>iAmt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iChunkOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iAmt</name><operator>+</operator><name>iOfst</name><operator>)</operator><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>iOffset</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>pChunk</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>iOffset</name></name><operator>!=</operator><name>iOfst</name> <operator>||</operator> <name>iOfst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pChunk</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> 
        <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pChunk</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>iOff</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name><operator>)</operator><operator>&lt;=</operator><name>iOfst</name></expr>;</condition>
        <incr><expr><name>pChunk</name><operator>=</operator><name><name>pChunk</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>
    )</control><block>{<block_content>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>pChunk</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChunk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>iChunkOffset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOfst</name><operator>%</operator><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name><operator>)</operator></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSpace</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name> <operator>-</operator> <name>iChunkOffset</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nRead</name></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name> <operator>-</operator> <name>iChunkOffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pChunk</name><operator>-&gt;</operator><name>zChunk</name></name> <operator>+</operator> <name>iChunkOffset</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOut</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRead</name> <operator>-=</operator> <name>iSpace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iChunkOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block> while<condition>( <expr><name>nRead</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>pChunk</name><operator>=</operator><name><name>pChunk</name><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nRead</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <ternary><condition><expr><name>pChunk</name></expr> ?</condition><then> <expr><name>iOfst</name><operator>+</operator><name>iAmt</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>pChunk</name></name> <operator>=</operator> <name>pChunk</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the list of FileChunk structures headed at MemJournal.pFirst.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memjrnlFreeChunks</name><parameter_list>(<parameter><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pFirst</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pFirst</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for> 
</block_content>}</block></function>

<comment type="block">/*
** Flush the contents of memory to a real file on disk.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlCreateFile</name><parameter_list>(<parameter><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pReal</name> <init>= <expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemJournal</name></type> <name>copy</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemJournal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name><name>copy</name><operator>.</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>copy</name><operator>.</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name>pReal</name></expr></argument>, <argument><expr><name><name>copy</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nChunk</name> <init>= <expr><name><name>copy</name><operator>.</operator><name>nChunkSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>copy</name><operator>.</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iOff</name> <operator>+</operator> <name>nChunk</name> <operator>&gt;</operator> <name><name>copy</name><operator>.</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nChunk</name> <operator>=</operator> <name><name>copy</name><operator>.</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name> <operator>-</operator> <name>iOff</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pReal</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pIter</name><operator>-&gt;</operator><name>zChunk</name></name></expr></argument>, <argument><expr><name>nChunk</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name>nChunk</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* No error has occurred. Free the in-memory buffers. */</comment>
      <expr_stmt><expr><call><name>memjrnlFreeChunks</name><argument_list>(<argument><expr><name><name>copy</name><operator>.</operator><name>pFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If an error occurred while creating or writing to the file, restore
    ** the original before returning. This way, SQLite uses the in-memory
    ** journal data to roll back changes made to the internal page-cache
    ** before this function was called.  */</comment>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pReal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Write data to the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>,    <comment type="block">/* The journal file into which to write */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,      <comment type="block">/* Take data to be written from here */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,              <comment type="block">/* Number of bytes to write */</comment>
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>     <comment type="block">/* Begin writing at this offset into the file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name> <operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><name>iAmt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zWrite</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the file should be created now, create it and write the new data
  ** into the file on disk. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSpill</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iAmt</name><operator>+</operator><name>iOfst</name><operator>)</operator><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSpill</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>memjrnlCreateFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pJfd</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if>

  <comment type="block">/* If the contents of this write should be stored in memory */</comment>
  <else>else<block>{<block_content>
    <comment type="block">/* An in-memory journal file should only ever be appended to. Random
    ** access writes are not required. The only exception to this is when
    ** the in-memory journal is being used by a connection using the
    ** atomic-write optimization. In this case the first 28 bytes of the
    ** journal file may be written as part of committing the transaction. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOfst</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iOfst</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iOfst</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memjrnlTruncate</name><argument_list>(<argument><expr><name>pJfd</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iOfst</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name><operator>&gt;</operator><name>iAmt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pFirst</name><operator>-&gt;</operator><name>zChunk</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><name>nWrite</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pChunk</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>pChunk</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iChunkOffset</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name><operator>%</operator><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iSpace</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nWrite</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name> <operator>-</operator> <name>iChunkOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChunk</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>iChunkOffset</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iChunkOffset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* New chunk is required to extend the file. */</comment>
          <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><call><name>fileChunkSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block>{<block_content>
            <return>return <expr><name>SQLITE_IOERR_NOMEM_BKPT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pChunk</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pChunk</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>pChunk</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChunk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pChunk</name><operator>-&gt;</operator><name>zChunk</name></name> <operator>+</operator> <name>iChunkOffset</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><name>iSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zWrite</name> <operator>+=</operator> <name>iSpace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nWrite</name> <operator>-=</operator> <name>iSpace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name> <operator>+=</operator> <name>iSpace</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate the in-memory file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name> <operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>pChunk</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>pChunk</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>size</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FileChunk</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>size</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memjrnlFreeChunks</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iOff</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memjrnlFreeChunks</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>pChunk</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>pChunk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readpoint</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name> <operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memjrnlFreeChunks</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync the file.
**
** If the real file has been created, call its xSync method. Otherwise, 
** syncing an in-memory journal is a no-op. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>pJfd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Query the size of the file in bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memjrnlFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name> <operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <operator>(</operator><name>sqlite_int64</name><operator>)</operator> <name><name>p</name><operator>-&gt;</operator><name>endpoint</name><operator>.</operator><name>iOffset</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Table of methods for MemJournal sqlite3_file object.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>sqlite3_io_methods</name></name></type> <name>MemJournalMethods</name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>,                <comment type="block">/* iVersion */</comment>
  <expr><name>memjrnlClose</name></expr>,     <comment type="block">/* xClose */</comment>
  <expr><name>memjrnlRead</name></expr>,      <comment type="block">/* xRead */</comment>
  <expr><name>memjrnlWrite</name></expr>,     <comment type="block">/* xWrite */</comment>
  <expr><name>memjrnlTruncate</name></expr>,  <comment type="block">/* xTruncate */</comment>
  <expr><name>memjrnlSync</name></expr>,      <comment type="block">/* xSync */</comment>
  <expr><name>memjrnlFileSize</name></expr>,  <comment type="block">/* xFileSize */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xLock */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xUnlock */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xCheckReservedLock */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xFileControl */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xSectorSize */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xDeviceCharacteristics */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xShmMap */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xShmLock */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xShmBarrier */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xShmUnmap */</comment>
  <expr><literal type="number">0</literal></expr>,                <comment type="block">/* xFetch */</comment>
  <expr><literal type="number">0</literal></expr>                 <comment type="block">/* xUnfetch */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* 
** Open a journal file. 
**
** The behaviour of the journal file depends on the value of parameter 
** nSpill. If nSpill is 0, then the journal file is always create and 
** accessed using the underlying VFS. If nSpill is less than zero, then
** all content is always stored in main-memory. Finally, if nSpill is a
** positive value, then the journal file is initially created in-memory
** but may be flushed to disk later on. In this case the journal file is
** flushed to disk either when it grows larger than nSpill bytes in size,
** or when sqlite3JournalCreate() is called.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JournalOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,         <comment type="block">/* The VFS to use for actual file I/O */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,         <comment type="block">/* Name of the journal file */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>,        <comment type="block">/* Preallocated, blank file handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                 <comment type="block">/* Opening flags */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSpill</name></decl></parameter>                 <comment type="block">/* Bytes buffered before opening the file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name><operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name> <operator>||</operator> <name>nSpill</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_EXCLUSIVE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Zero the file-handle object. If nSpill was passed zero, initialize
  ** it using the sqlite3OsOpen() function of the underlying VFS. In this
  ** case none of the code in this module is executed as a result of calls
  ** made on the journal file-handle.  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemJournal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSpill</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pJfd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nSpill</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name> <operator>=</operator> <name>nSpill</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <name>MEMJOURNAL_DFLT_FILECHUNKSIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileChunk</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MEMJOURNAL_DFLT_FILECHUNKSIZE</name><operator>==</operator><call><name>fileChunkSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChunkSize</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pJfd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>sqlite3_io_methods</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>MemJournalMethods</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSpill</name></name> <operator>=</operator> <name>nSpill</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zJournal</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open an in-memory journal file.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MemJournalOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3JournalOpen</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pJfd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ATOMIC_WRITE</name></expr></argument>)</argument_list></call> \
 <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** If the argument p points to a MemJournal structure that is not an 
** in-memory-only journal file (i.e. is one that was opened with a +ve
** nSpill parameter or as SQLITE_OPEN_MAIN_JOURNAL), and the underlying 
** file has not yet been created, create it now.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JournalCreate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJfd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemJournal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MemJournal</name><operator>*</operator><operator>)</operator><name>pJfd</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pJfd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><operator>&amp;</operator><name>MemJournalMethods</name> <operator>&amp;&amp;</operator> <operator>(</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
     <name><name>p</name><operator>-&gt;</operator><name>nSpill</name></name><operator>&gt;</operator><literal type="number">0</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
     <comment type="block">/* While this appears to not be possible without ATOMIC_WRITE, the
     ** paths are complex, so it seems prudent to leave the test in as
     ** a NEVER(), in case our analysis is subtly flawed. */</comment>
     <call><name>NEVER</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSpill</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></cpp:ifdef>
     <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_JOURNAL</name><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memjrnlCreateFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The file-handle passed as the only argument is open on a journal file.
** Return true if this "journal file" is currently stored in heap memory,
** or false otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JournalIsInMemory</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><operator>&amp;</operator><name>MemJournalMethods</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return the number of bytes required to store a JournalFile that uses vfs
** pVfs to create the underlying on-disk files.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JournalSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MemJournal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
