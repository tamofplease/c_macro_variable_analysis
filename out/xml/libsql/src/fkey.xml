<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/fkey.c"><comment type="block">/*
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used by the compiler to add foreign key
** support to compiled SQL statements.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>

<comment type="block">/*
** Deferred and Immediate FKs
** --------------------------
**
** Foreign keys in SQLite come in two flavours: deferred and immediate.
** If an immediate foreign key constraint is violated,
** SQLITE_CONSTRAINT_FOREIGNKEY is returned and the current
** statement transaction rolled back. If a 
** deferred foreign key constraint is violated, no action is taken 
** immediately. However if the application attempts to commit the 
** transaction before fixing the constraint violation, the attempt fails.
**
** Deferred constraints are implemented using a simple counter associated
** with the database handle. The counter is set to zero each time a 
** database transaction is opened. Each time a statement is executed 
** that causes a foreign key violation, the counter is incremented. Each
** time a statement is executed that removes an existing violation from
** the database, the counter is decremented. When the transaction is
** committed, the commit fails if the current value of the counter is
** greater than zero. This scheme has two big drawbacks:
**
**   * When a commit fails due to a deferred foreign key constraint, 
**     there is no way to tell which foreign constraint is not satisfied,
**     or which row it is not satisfied for.
**
**   * If the database contains foreign key violations when the 
**     transaction is opened, this may cause the mechanism to malfunction.
**
** Despite these problems, this approach is adopted as it seems simpler
** than the alternatives.
**
** INSERT operations:
**
**   I.1) For each FK for which the table is the child table, search
**        the parent table for a match. If none is found increment the
**        constraint counter.
**
**   I.2) For each FK for which the table is the parent table, 
**        search the child table for rows that correspond to the new
**        row in the parent table. Decrement the counter for each row
**        found (as the constraint is now satisfied).
**
** DELETE operations:
**
**   D.1) For each FK for which the table is the child table, 
**        search the parent table for a row that corresponds to the 
**        deleted row in the child table. If such a row is not found, 
**        decrement the counter.
**
**   D.2) For each FK for which the table is the parent table, search 
**        the child table for rows that correspond to the deleted row 
**        in the parent table. For each found increment the counter.
**
** UPDATE operations:
**
**   An UPDATE command requires that all 4 steps above are taken, but only
**   for FK constraints for which the affected columns are actually 
**   modified (values must be compared at runtime).
**
** Note that I.1 and D.1 are very similar operations, as are I.2 and D.2.
** This simplifies the implementation a bit.
**
** For the purposes of immediate FK constraints, the OR REPLACE conflict
** resolution is considered to delete rows before the new row is inserted.
** If a delete caused by OR REPLACE violates an FK constraint, an exception
** is thrown, even if the FK constraint would be satisfied after the new 
** row is inserted.
**
** Immediate constraints are usually handled similarly. The only difference 
** is that the counter used is stored as part of each individual statement
** object (struct Vdbe). If, after the statement has run, its immediate
** constraint counter is greater than zero,
** it returns SQLITE_CONSTRAINT_FOREIGNKEY
** and the statement transaction is rolled back. An exception is an INSERT
** statement that inserts a single row only (no triggers). In this case,
** instead of using a counter, an exception is thrown immediately if the
** INSERT violates a foreign key constraint. This is necessary as such
** an INSERT does not open a statement transaction.
**
** TODO: How should dropping a table be handled? How should renaming a 
** table be handled?
**
**
** Query API Notes
** ---------------
**
** Before coding an UPDATE or DELETE row operation, the code-generator
** for those two operations needs to know whether or not the operation
** requires any FK processing and, if so, which columns of the original
** row are required by the FK processing VDBE code (i.e. if FKs were
** implemented using triggers, which of the old.* columns would be 
** accessed). No information is required by the code-generator before
** coding an INSERT operation. The functions used by the UPDATE/DELETE
** generation code to query for this information are:
**
**   sqlite3FkRequired() - Test to see if FK processing is required.
**   sqlite3FkOldmask()  - Query for the set of required old.* columns.
**
**
** Externally accessible module functions
** --------------------------------------
**
**   sqlite3FkCheck()    - Check for foreign key violations.
**   sqlite3FkActions()  - Code triggers for ON UPDATE/ON DELETE actions.
**   sqlite3FkDelete()   - Delete an FKey structure.
*/</comment>

<comment type="block">/*
** VDBE Calling Convention
** -----------------------
**
** Example:
**
**   For the following INSERT statement:
**
**     CREATE TABLE t1(a, b INTEGER PRIMARY KEY, c);
**     INSERT INTO t1 VALUES(1, 2, 3.1);
**
**   Register (x):        2    (type integer)
**   Register (x+1):      1    (type integer)
**   Register (x+2):      NULL (type NULL)
**   Register (x+3):      3.1  (type real)
*/</comment>

<comment type="block">/*
** A foreign key constraint requires that the key columns in the parent
** table are collectively subject to a UNIQUE or PRIMARY KEY constraint.
** Given that pParent is the parent table for foreign key constraint pFKey, 
** search the schema for a unique index on the parent key columns. 
**
** If successful, zero is returned. If the parent key is an INTEGER PRIMARY 
** KEY column, then output variable *ppIdx is set to NULL. Otherwise, *ppIdx 
** is set to point to the unique index. 
** 
** If the parent key consists of a single column (the foreign key constraint
** is not a composite foreign key), output variable *paiCol is set to NULL.
** Otherwise, it is set to point to an allocated array of size N, where
** N is the number of columns in the parent key. The first element of the
** array is the index of the child table column that is mapped by the FK
** constraint to the parent table column stored in the left-most column
** of index *ppIdx. The second element of the array is the index of the
** child table column that corresponds to the second left-most column of
** *ppIdx, and so on.
**
** If the required index cannot be found, either because:
**
**   1) The named parent key columns do not exist, or
**
**   2) The named parent key columns do exist, but are not subject to a
**      UNIQUE or PRIMARY KEY constraint, or
**
**   3) No parent key columns were provided explicitly as part of the
**      foreign key definition, and the parent table does not have a
**      PRIMARY KEY, or
**
**   4) No parent key columns were provided explicitly as part of the
**      foreign key definition, and the PRIMARY KEY of the parent table 
**      consists of a different number of columns to the child key in 
**      the child table.
**
** then non-zero is returned, and a "foreign key mismatch" error loaded
** into pParse. If an OOM error occurs, non-zero is returned and the
** pParse-&gt;db-&gt;mallocFailed flag is set.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3FkLocateIndex</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context to store any error in */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>,                 <comment type="block">/* Parent table of FK constraint pFKey */</comment>
  <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl></parameter>,                    <comment type="block">/* Foreign key to find index for */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIdx</name></decl></parameter>,                  <comment type="block">/* OUT: Unique index on parent table */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>paiCol</name></decl></parameter>                    <comment type="block">/* OUT: Map of index columns in pFKey */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Value to return via *ppIdx */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Value to return via *paiCol */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Number of columns in parent key */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKey</name> <init>= <expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zCol</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Name of left-most parent key column */</comment>

  <comment type="block">/* The caller is responsible for zeroing output parameters. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ppIdx</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ppIdx</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>paiCol</name> <operator>||</operator> <operator>*</operator><name>paiCol</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a non-composite (single column) foreign key, check if it 
  ** maps to the INTEGER PRIMARY KEY of table pParent. If so, leave *ppIdx 
  ** and *paiCol set to zero and return early. 
  **
  ** Otherwise, for a composite foreign key (more than one column), allocate
  ** space for the aiCol array (returned via output parameter *paiCol).
  ** Non-composite foreign keys do not require the aiCol array.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The FK maps to the IPK if any of the following are true:
    **
    **   1) There is an INTEGER PRIMARY KEY column and the FK is implicitly 
    **      mapped to the primary key of table pParent, or
    **   2) The FK is explicitly mapped to a column declared as INTEGER
    **      PRIMARY KEY.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pParent</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zKey</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pParent</name><operator>-&gt;</operator><name>iPKey</name></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>paiCol</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCol</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aiCol</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nCol</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aiCol</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>paiCol</name> <operator>=</operator> <name>aiCol</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pParent</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><name>nCol</name> <operator>&amp;&amp;</operator> <call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
      <comment type="block">/* pIdx is a UNIQUE index (or a PRIMARY KEY) and has the right number
      ** of columns. If each indexed column corresponds to a foreign key
      ** column of pFKey, then this index is a winner.  */</comment>

      <if_stmt><if>if<condition>( <expr><name>zKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If zKey is NULL, then this foreign key is implicitly mapped to 
        ** the PRIMARY KEY of table pParent. The PRIMARY KEY index may be 
        ** identified by the test.  */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>aiCol</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr>;</expr_stmt></block_content></block></for>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* If zKey is non-NULL, then this foreign key was declared to
        ** map to an explicit list of columns in table pParent. Check if this
        ** index matches those columns. Also, check that the index uses
        ** the default collation sequences for each column. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>i16</name></type> <name>iCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Index of column in parent tbl */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDfltColl</name></decl>;</decl_stmt>            <comment type="block">/* Def. collation for column */</comment>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdxCol</name></decl>;</decl_stmt>                    <comment type="block">/* Name of indexed column */</comment>

          <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* No foreign keys against expression indexes */</comment>

          <comment type="block">/* If the index uses a collation sequence that is different from
          ** the default collation sequence for the column, this index is
          ** unusable. Bail out early in this case.  */</comment>
          <expr_stmt><expr><name>zDfltColl</name> <operator>=</operator> <call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zDfltColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zDfltColl</name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zDfltColl</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <expr_stmt><expr><name>zIdxCol</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCol</name></expr></argument>, <argument><expr><name>zIdxCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>aiCol</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nCol</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nCol</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>      <comment type="block">/* pIdx is usable */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pIdx</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>disableTriggers</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
           <argument><expr><literal type="string">"foreign key mismatch - \"%w\" referencing \"%w\""</literal></expr></argument>,
           <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppIdx</name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when a row is inserted into or deleted from the 
** child table of foreign key constraint pFKey. If an SQL UPDATE is executed 
** on the child table of pFKey, this function is invoked twice for each row
** affected - once to "delete" the old row, and then again to "insert" the
** new row.
**
** Each time it is called, this function generates VDBE code to locate the
** row in the parent table that corresponds to the row being inserted into 
** or deleted from the child table. If the parent row can be found, no 
** special action is taken. Otherwise, if the parent row can *not* be
** found in the parent table:
**
**   Operation | FK type   | Action taken
**   --------------------------------------------------------------------------
**   INSERT      immediate   Increment the "immediate constraint counter".
**
**   DELETE      immediate   Decrement the "immediate constraint counter".
**
**   INSERT      deferred    Increment the "deferred constraint counter".
**
**   DELETE      deferred    Decrement the "deferred constraint counter".
**
** These operations are identified in the comment at the top of this file 
** (fkey.c) as "I.1" and "D.1".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fkLookupParent</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,              <comment type="block">/* Index of database housing pTab */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,          <comment type="block">/* Parent table of FK pFKey */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,          <comment type="block">/* Unique index on parent key columns in pTab */</comment>
  <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl></parameter>,          <comment type="block">/* Foreign key constraint */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCol</name></decl></parameter>,           <comment type="block">/* Map from parent key columns to child table columns */</comment>
  <parameter><decl><type><name>int</name></type> <name>regData</name></decl></parameter>,          <comment type="block">/* Address of array containing child table row */</comment>
  <parameter><decl><type><name>int</name></type> <name>nIncr</name></decl></parameter>,            <comment type="block">/* Increment constraint counter by this */</comment>
  <parameter><decl><type><name>int</name></type> <name>isIgnore</name></decl></parameter>          <comment type="block">/* If true, pretend pTab contains all NULL values */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                                    <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>         <comment type="block">/* Vdbe to add code to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Cursor number to use */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOk</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* jump here if parent key found */</comment>

  <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
    <argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name>
      <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pToplevel</name></name> 
      <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>OE_Abort</name></expr> </then><else>: <expr><name>OE_Ignore</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If nIncr is less than zero, then check at runtime if there are any
  ** outstanding constraints to resolve. If there are not, there is no need
  ** to check if deleting this row resolves any outstanding violations.
  **
  ** Check if any of the key columns in the child table row are NULL. If 
  ** any are, then the constraint is considered satisfied. No need to 
  ** search for a matching row in the parent table.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nIncr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkIfZero</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iReg</name> <init>= <expr><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>,<argument><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>regData</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>isIgnore</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If pIdx is NULL, then the parent key is the INTEGER PRIMARY KEY
      ** column of the parent table (table pTab).  */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iMustBeInt</name></decl>;</decl_stmt>               <comment type="block">/* Address of MustBeInt instruction */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regTemp</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
      <comment type="block">/* Invoke MustBeInt to coerce the child key value to an integer (i.e. 
      ** apply the affinity of the parent key). If this fails, then there
      ** is no matching parent key. Before using MustBeInt, make a copy of
      ** the value. Otherwise, the value inserted into the child key column
      ** will have INTEGER affinity applied to it, which may not be correct.  */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, 
        <argument><expr><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>,<argument><expr><name><name>aiCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>regData</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMustBeInt</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <comment type="block">/* If the parent table is the same as the child table, and we are about
      ** to increment the constraint-counter (i.e. this is an INSERT operation),
      ** then check if the row being inserted matches itself. If so, do not
      ** increment the constraint-counter.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name> <operator>&amp;&amp;</operator> <name>nIncr</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  
      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iMustBeInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>regTemp</name> <init>= <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, 
               <argument><expr><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>, <argument><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>regData</name></expr></argument>,
               <argument><expr><name>regTemp</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
  
      <comment type="block">/* If the parent table is the same as the child table, and we are about
      ** to increment the constraint-counter (i.e. this is an INSERT operation),
      ** then check if the row being inserted matches itself. If so, do not
      ** increment the constraint-counter. 
      **
      ** If any of the parent-key values are NULL, then the row cannot match 
      ** itself. So set JUMPIFNULL to make sure we do the OP_Found if any
      ** of the parent-key values are NULL (at this point it is known that
      ** none of the child key values are).
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name> <operator>&amp;&amp;</operator> <name>nIncr</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iJump</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nCol</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iChild</name> <init>= <expr><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>,<argument><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>
                              <operator>+</operator><literal type="number">1</literal><operator>+</operator><name>regData</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iParent</name> <init>= <expr><literal type="number">1</literal><operator>+</operator><name>regData</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>iParent</name> <operator>+=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>,
                                                 <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
            <comment type="block">/* The parent key is a composite key that includes the IPK column */</comment>
            <expr_stmt><expr><name>iParent</name> <operator>=</operator> <name>regData</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ne</name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>, <argument><expr><name>iJump</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regTemp</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pToplevel</name></name> 
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name></expr> 
  )</condition><block>{<block_content>
    <comment type="block">/* Special case: If this is an INSERT statement that will insert exactly
    ** one row into the table, raise a constraint immediately instead of
    ** incrementing a counter. This is necessary as the VM code is being
    ** generated for will not open a statement transaction.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nIncr</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr></argument>,
        <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>, <argument><expr><name>P5_ConstraintFK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nIncr</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkCounter</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name></expr></argument>, <argument><expr><name>nIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return an Expr object that refers to a memory register corresponding
** to column iCol of table pTab.
**
** regBase is the first of an array of register that contains the data
** for pTab.  regBase itself holds the rowid.  regBase+1 holds the first
** column.  regBase+2 holds the second column, and so forth.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>exprTableRegister</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,       <comment type="block">/* The table whose content is at r[regBase]... */</comment>
  <parameter><decl><type><name>int</name></type> <name>regBase</name></decl></parameter>,       <comment type="block">/* Contents of table pTab */</comment>
  <parameter><decl><type><name>i16</name></type> <name>iCol</name></decl></parameter>           <comment type="block">/* Which column of pTab is desired */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_REGISTER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>regBase</name> <operator>+</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>iCol</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zColl</name> <operator>=</operator> <call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>regBase</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return an Expr object that refers to column iCol of table pTab which
** has cursor iCur.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>exprTableColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,      <comment type="block">/* The database connection */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,      <comment type="block">/* The table whose column is desired */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>,      <comment type="block">/* The open cursor on the table */</comment>
  <parameter><decl><type><name>i16</name></type> <name>iCol</name></decl></parameter>          <comment type="block">/* The column that is wanted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iCursor</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to generate code executed when a row is deleted
** from the parent table of foreign key constraint pFKey and, if pFKey is 
** deferred, when a row is inserted into the same table. When generating
** code for an SQL UPDATE operation, this function may be called twice -
** once to "delete" the old row and once to "insert" the new row.
**
** Parameter nIncr is passed -1 when inserting a row (as this may decrease
** the number of FK violations in the db) or +1 when deleting one (as this
** may increase the number of FK constraint problems).
**
** The code generated by this function scans through the rows in the child
** table that correspond to the parent table row being deleted or inserted.
** For each child row found, one of the following actions is taken:
**
**   Operation | FK type   | Action taken
**   --------------------------------------------------------------------------
**   DELETE      immediate   Increment the "immediate constraint counter".
**
**   INSERT      immediate   Decrement the "immediate constraint counter".
**
**   DELETE      deferred    Increment the "deferred constraint counter".
**
**   INSERT      deferred    Decrement the "deferred constraint counter".
**
** These operations are identified in the comment at the top of this file 
** (fkey.c) as "I.2" and "D.2".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fkScanChildren</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                  <comment type="block">/* The child table to be scanned */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* The parent table */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                    <comment type="block">/* Index on parent covering the foreign key */</comment>
  <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl></parameter>,                    <comment type="block">/* The foreign key linking pSrc to pTab */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCol</name></decl></parameter>,                     <comment type="block">/* Map from pIdx cols to child table cols */</comment>
  <parameter><decl><type><name>int</name></type> <name>regData</name></decl></parameter>,                    <comment type="block">/* Parent row data starts here */</comment>
  <parameter><decl><type><name>int</name></type> <name>nIncr</name></decl></parameter>                       <comment type="block">/* Amount to increment deferred counter by */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* WHERE clause to scan with */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNameContext</name></decl>;</decl_stmt>       <comment type="block">/* Context used to resolve WHERE clause */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>              <comment type="block">/* Context used by sqlite3WhereXXX() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFkIfZero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Address of OP_FkIfZero */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name><operator>==</operator><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nIncr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iFkIfZero</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkIfZero</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create an Expr object representing an SQL expression like:
  **
  **   &lt;parent-key1&gt; = &lt;child-key1&gt; AND &lt;parent-key2&gt; = &lt;child-key2&gt; ...
  **
  ** The collation sequence used for the comparison should be that of
  ** the parent key columns. The affinity of the parent key column should
  ** be applied to each child key value before the comparison takes place.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>                  <comment type="block">/* Value from parent table row */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>                 <comment type="block">/* Column ref to child table */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pEq</name></decl>;</decl_stmt>                    <comment type="block">/* Expression (pLeft = pRight) */</comment>
    <decl_stmt><decl><type><name>i16</name></type> <name>iCol</name></decl>;</decl_stmt>                     <comment type="block">/* Index of column in child table */</comment> 
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>             <comment type="block">/* Name of column in child table */</comment>

    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <ternary><condition><expr><name>pIdx</name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>exprTableRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <ternary><condition><expr><name>aiCol</name></expr> ?</condition><then> <expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFrom</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCol</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEq</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If the child table is the same as the parent table, then add terms
  ** to the WHERE clause that prevent this entry from being scanned.
  ** The added WHERE clause terms are like this:
  **
  **     $current_rowid!=rowid
  **     NOT( $current_a==a AND $current_b==b AND ... )
  **
  ** The first form is used for rowid tables.  The second form is used
  ** for WITHOUT ROWID tables. In the second form, the *parent* key is
  ** (a,b,...). Either the parent or primary key could be used to 
  ** uniquely identify the current row, but the parent key is more convenient
  ** as the required values have already been loaded into registers
  ** by the caller.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name> <operator>&amp;&amp;</operator> <name>nIncr</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNe</name></decl>;</decl_stmt>                    <comment type="block">/* Expression (pLeft != pRight) */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>                  <comment type="block">/* Value from parent table row */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>                 <comment type="block">/* Column ref to child table */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>exprTableRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>exprTableColumn</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNe</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_NE</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pEq</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pAll</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>i16</name></type> <name>iCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>exprTableRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pEq</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_IS</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pAll</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAll</name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>pNe</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_NOT</name></expr></argument>, <argument><expr><name>pAll</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pNe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Resolve the references in the WHERE clause. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNameContext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNameContext</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNameContext</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNameContext</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create VDBE to loop through the entries in pSrc that match the WHERE
  ** clause. For each row found, increment either the deferred or immediate
  ** foreign key constraint counter. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkCounter</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name></expr></argument>, <argument><expr><name>nIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pWInfo</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clean up the WHERE clause constructed above. */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFkIfZero</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHereOrPopInst</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iFkIfZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function returns a linked list of FKey objects (connected by
** FKey.pNextTo) holding all children of table pTab.  For example,
** given the following schema:
**
**   CREATE TABLE t1(a PRIMARY KEY);
**   CREATE TABLE t2(b REFERENCES t1(a);
**
** Calling this function with table "t1" as an argument returns a pointer
** to the FKey structure representing the foreign key constraint on table
** "t2". Calling this function with "t2" as the argument would return a
** NULL pointer (as there are no FK constraints for which t2 is the parent
** table).
*/</comment>
<function><type><name>FKey</name> <modifier>*</modifier></type><name>sqlite3FkReferences</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>FKey</name> <operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>fkeyHash</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second argument is a Trigger structure allocated by the 
** fkActionTrigger() routine. This function deletes the Trigger structure
** and all of its sub-components.
**
** The Trigger structure or any of its sub-components may be allocated from
** the lookaside buffer belonging to database handle dbMem.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fkTriggerDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbMem</name></decl></parameter>, <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TriggerStep</name> <modifier>*</modifier></type><name>pStep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>step_list</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>dbMem</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>dbMem</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>dbMem</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>dbMem</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>dbMem</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear the apTrigger[] cache of CASCADE triggers for all foreign keys
** in a particular database.  This needs to happen when the schema
** changes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FkClearTriggerCache</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>k</name></expr>;</condition> <incr><expr><name>k</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>pFKey</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fkTriggerDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fkTriggerDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to generate code that runs when table pTab is
** being dropped from the database. The SrcList passed as the second argument
** to this function contains a single entry guaranteed to resolve to
** table pTab.
**
** Normally, no code is required. However, if either
**
**   (a) The table is the parent table of a FK constraint, or
**   (b) The table is the child table of a deferred FK constraint and it is
**       determined at runtime that there are outstanding deferred FK 
**       constraint violations in the database,
**
** then the equivalent of "DELETE FROM &lt;tbl&gt;" is executed before dropping
** the table from the database. Triggers are disabled while running this
** DELETE, but foreign key actions are not.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FkDropTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSkip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>                  <comment type="block">/* VDBE has already been allocated */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Search for a deferred foreign key constraint for which this table
      ** is the child table. If one cannot be found, return without 
      ** generating any VDBE code. If one can be found, then jump over
      ** the entire DELETE if there are no outstanding deferred constraints
      ** when this statement is run.  */</comment>
      <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>isDeferred</name></name> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iSkip</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkIfZero</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iSkip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>disableTriggers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DeleteFrom</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>disableTriggers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* If the DELETE has generated immediate foreign key constraint 
    ** violations, halt the VDBE and return an error at this point, before
    ** any modifications to the schema are made. This is because statement
    ** transactions are not able to rollback schema changes.  
    **
    ** If the SQLITE_DeferFKs flag is set, then this is not required, as
    ** the statement transaction will not be rolled back even if FK
    ** constraints are violated.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkIfZero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr></argument>,
          <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>, <argument><expr><name>P5_ConstraintFK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iSkip</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iSkip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** The second argument points to an FKey object representing a foreign key
** for which pTab is the child table. An UPDATE statement against pTab
** is currently being processed. For each column of the table that is 
** actually updated, the corresponding element in the aChange[] array
** is zero or greater (if a column is unmodified the corresponding element
** is set to -1). If the rowid column is modified by the UPDATE statement
** the bChngRowid argument is non-zero.
**
** This function returns true if any of the columns that are part of the
** child key for FK constraint *p are modified.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fkChildIsModified</name><parameter_list>(
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Table being updated */</comment>
  <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                        <comment type="block">/* Foreign key for which pTab is the child */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aChange</name></decl></parameter>,                   <comment type="block">/* Array indicating modified columns */</comment>
  <parameter><decl><type><name>int</name></type> <name>bChngRowid</name></decl></parameter>                  <comment type="block">/* True if rowid is modified by this update */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iChildKey</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aChange</name><index>[<expr><name>iChildKey</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iChildKey</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>&amp;&amp;</operator> <name>bChngRowid</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second argument points to an FKey object representing a foreign key
** for which pTab is the parent table. An UPDATE statement against pTab
** is currently being processed. For each column of the table that is 
** actually updated, the corresponding element in the aChange[] array
** is zero or greater (if a column is unmodified the corresponding element
** is set to -1). If the rowid column is modified by the UPDATE statement
** the bChngRowid argument is non-zero.
**
** This function returns true if any of the columns that are part of the
** parent key for FK constraint *p are modified.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fkParentIsModified</name><parameter_list>(
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, 
  <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aChange</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bChngRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKey</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCol</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>iKey</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iKey</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iKey</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aChange</name><index>[<expr><name>iKey</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iKey</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>&amp;&amp;</operator> <name>bChngRowid</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iKey</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zKey</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the parser passed as the first argument is being
** used to code a trigger that is really a "SET NULL" action belonging
** to trigger pFKey.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isSetNullAction</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTop</name><operator>-&gt;</operator><name>pTriggerPrg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pTop</name><operator>-&gt;</operator><name>pTriggerPrg</name><operator>-&gt;</operator><name>pTrigger</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>p</name><operator>==</operator><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>OE_SetNull</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>p</name><operator>==</operator><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>OE_SetNull</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when inserting, deleting or updating a row of
** table pTab to generate VDBE code to perform foreign key constraint 
** processing for the operation.
**
** For a DELETE operation, parameter regOld is passed the index of the
** first register in an array of (pTab-&gt;nCol+1) registers containing the
** rowid of the row being deleted, followed by each of the column values
** of the row being deleted, from left to right. Parameter regNew is passed
** zero in this case.
**
** For an INSERT operation, regOld is passed zero and regNew is passed the
** first register of an array of (pTab-&gt;nCol+1) registers containing the new
** row data.
**
** For an UPDATE operation, this function is called twice. Once before
** the original record is deleted from the table using the calling convention
** described for DELETE. Then again after the original record is deleted
** but before the new record is inserted using the INSERT convention. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FkCheck</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Row is being deleted from this table */</comment> 
  <parameter><decl><type><name>int</name></type> <name>regOld</name></decl></parameter>,                     <comment type="block">/* Previous row data is stored here */</comment>
  <parameter><decl><type><name>int</name></type> <name>regNew</name></decl></parameter>,                     <comment type="block">/* New row data is stored here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aChange</name></decl></parameter>,                   <comment type="block">/* Array indicating UPDATEd columns (or 0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>bChngRowid</name></decl></parameter>                  <comment type="block">/* True if rowid is UPDATEd */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>                    <comment type="block">/* Used to iterate through FKs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                        <comment type="block">/* Index of database containing pTab */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Name of database containing pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isIgnoreErrors</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>disableTriggers</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Exactly one of regOld and regNew should be non-zero. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>regOld</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>regNew</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If foreign-keys are disabled, this function is a no-op. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>

  <comment type="block">/* Loop through all the foreign key constraints for which pTab is the
  ** child table (the table that the foreign key definition is part of).  */</comment>
  <for>for<control>(<init><expr><name>pFKey</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTo</name></decl>;</decl_stmt>                   <comment type="block">/* Parent table of foreign key pFKey */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Index on key columns in pTo */</comment>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bIgnore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>aChange</name> 
     <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>fkChildIsModified</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aChange</name></expr></argument>, <argument><expr><name>bChngRowid</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find the parent table of this foreign key. Also find a unique index 
    ** on the parent key columns in the parent table. If either of these 
    ** schema items cannot be located, set an error in pParse and return 
    ** early.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>disableTriggers</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTo</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pTo</name> <operator>=</operator> <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTo</name> <operator>||</operator> <call><name>sqlite3FkLocateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aiFree</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isIgnoreErrors</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>regOld</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regNew</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isIgnoreErrors</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If isIgnoreErrors is true, then a table is being dropped. In this
        ** case SQLite runs a "DELETE FROM xxx" on the table being dropped
        ** before actually dropping it in order to check FK constraints.
        ** If the parent table of an FK constraint on the current table is
        ** missing, behave as if it is empty. i.e. decrement the relevant
        ** FK counter for each row of the current table with non-NULL keys.
        */</comment>
        <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iJump</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iFromCol</name></decl>, <decl><type ref="prev"/><name>iReg</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>iFromCol</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>,<argument><expr><name>iFromCol</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>regOld</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>iJump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkCounter</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>aiFree</name> <operator>&amp;&amp;</operator> <name>pIdx</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>aiFree</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aiCol</name> <operator>=</operator> <name>aiFree</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFrom</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aiCol</name> <operator>=</operator> <operator>&amp;</operator><name>iCol</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
      <comment type="block">/* Request permission to read the parent key columns. If the 
      ** authorization callback returns SQLITE_IGNORE, behave as if any
      ** values read from the parent table are NULL. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rcauth</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><name><name>pTo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><ternary><condition><expr><name>pIdx</name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>pTo</name><operator>-&gt;</operator><name>iPKey</name></name></expr></else></ternary></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rcauth</name> <operator>=</operator> <call><name>sqlite3AuthReadCol</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bIgnore</name> <operator>=</operator> <operator>(</operator><name>rcauth</name><operator>==</operator><name>SQLITE_IGNORE</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <comment type="block">/* Take a shared-cache advisory read-lock on the parent table. Allocate 
    ** a cursor to use to search the unique index on the parent key columns 
    ** in the parent table.  */</comment>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>regOld</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* A row is being removed from the child table. Search for the parent.
      ** If the parent does not exist, removing the child row resolves an 
      ** outstanding foreign key constraint violation. */</comment>
      <expr_stmt><expr><call><name>fkLookupParent</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>, <argument><expr><name>regOld</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>bIgnore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>regNew</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isSetNullAction</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* A row is being added to the child table. If a parent row cannot
      ** be found, adding the child row has violated the FK constraint. 
      **
      ** If this operation is being performed as part of a trigger program
      ** that is actually a "SET NULL" action belonging to this very 
      ** foreign key, then omit this scan altogether. As all child key
      ** values are guaranteed to be NULL, it is not possible for adding
      ** this row to cause an FK violation.  */</comment>
      <expr_stmt><expr><call><name>fkLookupParent</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>bIgnore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aiFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Loop through all the foreign key constraints that refer to this table.
  ** (the "child" constraints) */</comment>
  <for>for<control>(<init><expr><name>pFKey</name> <operator>=</operator> <call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Foreign key index for pFKey */</comment>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>aChange</name> <operator>&amp;&amp;</operator> <call><name>fkParentIsModified</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aChange</name></expr></argument>, <argument><expr><name>bChngRowid</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pToplevel</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regOld</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regNew</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Inserting a single row into a parent table cannot cause (or fix)
      ** an immediate foreign key violation. So do nothing in this case.  */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>sqlite3FkLocateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aiCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isIgnoreErrors</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aiCol</name> <operator>||</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a SrcList structure containing the child table.  We need the
    ** child table as a SrcList for sqlite3WhereBegin() */</comment>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSrc</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  
      <if_stmt><if>if<condition>( <expr><name>regNew</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fkScanChildren</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>regOld</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>eAction</name> <init>= <expr><name><name>pFKey</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>aChange</name><operator>!=</operator><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fkScanChildren</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>, <argument><expr><name>regOld</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* If this is a deferred FK constraint, or a CASCADE or SET NULL
        ** action applies, then any foreign key violations caused by
        ** removing the parent key will be rectified by the action trigger.
        ** So do not set the "may-abort" flag in this case.
        **
        ** Note 1: If the FK is declared "ON UPDATE CASCADE", then the
        ** may-abort flag will eventually be set on this statement anyway
        ** (when this function is called as part of processing the UPDATE
        ** within the action trigger).
        **
        ** Note 2: At first glance it may seem like SQLite could simply omit
        ** all OP_FkCounter related scans when either CASCADE or SET NULL
        ** applies. The trouble starts if the CASCADE or SET NULL action 
        ** trigger causes other triggers or action rules attached to the 
        ** child table to fire. In these cases the fk constraint counters
        ** might be set incorrectly if any OP_FkCounter related scans are 
        ** omitted.  */</comment>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name> <operator>&amp;&amp;</operator> <name>eAction</name><operator>!=</operator><name>OE_Cascade</name> <operator>&amp;&amp;</operator> <name>eAction</name><operator>!=</operator><name>OE_SetNull</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMN_MASK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x)&gt;31) ? 0xffffffff : ((u32)1&lt;&lt;(x)))</cpp:value></cpp:define>

<comment type="block">/*
** This function is called before generating code to update or delete a 
** row contained in table pTab.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3FkOldmask</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>                     <comment type="block">/* Table being modified */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name> <operator>&amp;&amp;</operator> <call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>COLUMN_MASK</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3FkLocateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pIdx</name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>COLUMN_MASK</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>mask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called before generating code to update or delete a 
** row contained in table pTab. If the operation is a DELETE, then
** parameter aChange is passed a NULL value. For an UPDATE, aChange points
** to an array of size N, where N is the number of columns in table pTab.
** If the i'th column is not modified by the UPDATE, then the corresponding 
** entry in the aChange[] array is set to -1. If the column is modified,
** the value is 0 or greater. Parameter chngRowid is set to true if the
** UPDATE statement modifies the rowid fields of the table.
**
** If any foreign key processing will be required, this function returns
** non-zero. If there is no foreign key related processing, this function 
** returns zero.
**
** For an UPDATE, this function returns 2 if:
**
**   * There are any FKs for which pTab is the child and the parent table
**     and any FK processing at all is required (even of a different FK), or
**
**   * the UPDATE modifies one or more parent keys for which the action is
**     not "NO ACTION" (i.e. is CASCADE, SET DEFAULT or SET NULL).
**
** Or, assuming some other foreign key processing is required, 1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3FkRequired</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Table being modified */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aChange</name></decl></parameter>,                   <comment type="block">/* Non-NULL for UPDATE operations */</comment>
  <parameter><decl><type><name>int</name></type> <name>chngRowid</name></decl></parameter>                   <comment type="block">/* True for UPDATE that affects rowid */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eRet</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Value to return if bHaveFK is true */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveFK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* If FK processing is required */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name> <operator>&amp;&amp;</operator> <call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aChange</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* A DELETE operation. Foreign key processing is required if the 
      ** table in question is either the child or parent table for any 
      ** foreign key constraint.  */</comment>
      <expr_stmt><expr><name>bHaveFK</name> <operator>=</operator> <operator>(</operator><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* This is an UPDATE. Foreign key processing is only required if the
      ** operation modifies one or more child or parent key columns. */</comment>
      <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

      <comment type="block">/* Check if any child key columns are being modified. */</comment>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>fkChildIsModified</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>aChange</name></expr></argument>, <argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eRet</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>bHaveFK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <comment type="block">/* Check if any parent key columns are being modified. */</comment>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>fkParentIsModified</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>aChange</name></expr></argument>, <argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name>OE_None</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>bHaveFK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><name>bHaveFK</name></expr> ?</condition><then> <expr><name>eRet</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when an UPDATE or DELETE operation is being 
** compiled on table pTab, which is the parent table of foreign-key pFKey.
** If the current operation is an UPDATE, then the pChanges parameter is
** passed a pointer to the list of columns being modified. If it is a
** DELETE, pChanges is passed a NULL pointer.
**
** It returns a pointer to a Trigger structure containing a trigger
** equivalent to the ON UPDATE or ON DELETE action specified by pFKey.
** If the action is "NO ACTION" then a NULL pointer is returned (these actions
** require no special handling by the triggers sub-system, code for them is
** created by fkScanChildren()).
**
** For example, if pFKey is the foreign key and pTab is table "p" in 
** the following schema:
**
**   CREATE TABLE p(pk PRIMARY KEY);
**   CREATE TABLE c(ck REFERENCES p ON DELETE CASCADE);
**
** then the returned trigger structure is equivalent to:
**
**   CREATE TRIGGER ... DELETE ON p BEGIN
**     DELETE FROM c WHERE ck = old.pk;
**   END;
**
** The returned pointer is cached as part of the foreign key object. It
** is eventually freed along with the rest of the foreign key object by 
** sqlite3FkDelete().
*/</comment>
<function><type><specifier>static</specifier> <name>Trigger</name> <modifier>*</modifier></type><name>fkActionTrigger</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Table being updated or deleted from */</comment>
  <parameter><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl></parameter>,                    <comment type="block">/* Foreign key to get action for */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pChanges</name></decl></parameter>              <comment type="block">/* Change-list for UPDATE, NULL for DELETE */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>action</name></decl>;</decl_stmt>                     <comment type="block">/* One of OE_None, OE_Cascade etc. */</comment>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>              <comment type="block">/* Trigger definition to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iAction</name> <init>= <expr><operator>(</operator><name>pChanges</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>    <comment type="block">/* 1 for UPDATE, 0 for DELETE */</comment>

  <expr_stmt><expr><name>action</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>iAction</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>action</name><operator>==</operator><name>OE_Restrict</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><name>iAction</name></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>action</name><operator>!=</operator><name>OE_None</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pTrigger</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFrom</name></decl>;</decl_stmt>            <comment type="block">/* Name of child table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nFrom</name></decl>;</decl_stmt>                    <comment type="block">/* Length in bytes of zFrom */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Parent key index for this FK */</comment>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* child table cols -&gt; parent key cols */</comment>
    <decl_stmt><decl><type><name>TriggerStep</name> <modifier>*</modifier></type><name>pStep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* First (only) step of trigger program */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* WHERE clause of trigger step */</comment>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Changes list if ON UPDATE CASCADE */</comment>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* If RESTRICT, "SELECT RAISE(...)" */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Iterator variable */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* WHEN clause for the trigger */</comment>

    <if_stmt><if>if<condition>( <expr><call><name>sqlite3FkLocateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aiCol</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aiCol</name> <operator>||</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Token</name></type> <name>tOld</name> <init>= <expr><block>{ <expr><literal type="string">"old"</literal></expr>, <expr><literal type="number">3</literal></expr> }</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* Literal "old" token */</comment>
      <decl_stmt><decl><type><name>Token</name></type> <name>tNew</name> <init>= <expr><block>{ <expr><literal type="string">"new"</literal></expr>, <expr><literal type="number">3</literal></expr> }</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* Literal "new" token */</comment>
      <decl_stmt><decl><type><name>Token</name></type> <name>tFromCol</name></decl>;</decl_stmt>             <comment type="block">/* Name of column in child table */</comment>
      <decl_stmt><decl><type><name>Token</name></type> <name>tToCol</name></decl>;</decl_stmt>               <comment type="block">/* Name of column in parent table */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iFromCol</name></decl>;</decl_stmt>               <comment type="block">/* Idx of column in child table */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pEq</name></decl>;</decl_stmt>                  <comment type="block">/* tFromCol = OLD.tToCol */</comment>

      <expr_stmt><expr><name>iFromCol</name> <operator>=</operator> <ternary><condition><expr><name>aiCol</name></expr> ?</condition><then> <expr><name><name>aiCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFrom</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFromCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TokenInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tToCol</name></expr></argument>,
                   <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><ternary><condition><expr><name>pIdx</name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></else></ternary></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TokenInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tFromCol</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iFromCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Create the expression "OLD.zToCol = zFromCol". It is important
      ** that the "OLD.zToCol" term is on the LHS of the = operator, so
      ** that the affinity and collation sequence associated with the
      ** parent table are used for the comparison. */</comment>
      <expr_stmt><expr><name>pEq</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>,
          <argument><expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, 
            <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tToCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tFromCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* For ON UPDATE, construct the next term of the WHEN clause.
      ** The final WHEN clause will be like this:
      **
      **    WHEN NOT(old.col1 IS new.col1 AND ... AND old.colN IS new.colN)
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>pChanges</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pEq</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_IS</name></expr></argument>,
            <argument><expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, 
              <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tToCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, 
              <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tToCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pWhen</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhen</name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  
      <if_stmt><if>if<condition>( <expr><name>action</name><operator>!=</operator><name>OE_Restrict</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>action</name><operator>!=</operator><name>OE_Cascade</name> <operator>||</operator> <name>pChanges</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>action</name><operator>==</operator><name>OE_Cascade</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, 
            <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tToCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>action</name><operator>==</operator><name>OE_SetDflt</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>aCol</name></name> <operator>+</operator> <name>iFromCol</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDflt</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pDflt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>pDflt</name> <operator>=</operator> <call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>pDflt</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDflt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprListSetName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tFromCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aiCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>zFrom</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>action</name><operator>==</operator><name>OE_Restrict</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Token</name></type> <name>tFrom</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Token</name></type> <name>tDb</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRaise</name></decl>;</decl_stmt> 

      <expr_stmt><expr><name><name>tFrom</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>zFrom</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tFrom</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>nFrom</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tDb</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tDb</name><operator>.</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>tDb</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>pRaise</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_RAISE</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN KEY constraint failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRaise</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRaise</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRaise</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tFrom</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>pWhere</name></expr></argument>,
          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable lookaside memory allocation */</comment>
    <expr_stmt><expr><name>DisableLookaside</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <operator>(</operator><name>Trigger</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Trigger</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>         <comment type="block">/* struct Trigger */</comment>
        <sizeof>sizeof<argument_list>(<argument><expr><name>TriggerStep</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>     <comment type="block">/* Single step in trigger program */</comment>
        <name>nFrom</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>                 <comment type="block">/* Space for pStep-&gt;zTarget */</comment>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTrigger</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pStep</name> <operator>=</operator> <name><name>pTrigger</name><operator>-&gt;</operator><name>step_list</name></name> <operator>=</operator> <operator>(</operator><name>TriggerStep</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTrigger</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pStep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pWhen</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pWhen</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_NOT</name></expr></argument>, <argument><expr><name>pWhen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTrigger</name><operator>-&gt;</operator><name>pWhen</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhen</name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Re-enable the lookaside buffer, if it was disabled earlier. */</comment>
    <expr_stmt><expr><name>EnableLookaside</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fkTriggerDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStep</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTrigger</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>( <expr><name>action</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OE_Restrict</name></expr>:</case>
        <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_SELECT</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OE_Cascade</name></expr>:</case> 
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pChanges</name></expr> )</condition><block>{<block_content> 
          <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_DELETE</name></expr>;</expr_stmt> 
          <break>break;</break> 
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
      <default>default:</default>
        <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_UPDATE</name></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>pTrig</name></name> <operator>=</operator> <name>pTrigger</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTrigger</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTrigger</name><operator>-&gt;</operator><name>pTabSchema</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><name>iAction</name></expr>]</index></name> <operator>=</operator> <name>pTrigger</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTrigger</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pChanges</name></expr> ?</condition><then> <expr><name>TK_UPDATE</name></expr> </then><else>: <expr><name>TK_DELETE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pTrigger</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when deleting or updating a row to implement
** any required CASCADE, SET NULL or SET DEFAULT actions.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FkActions</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Table being updated or deleted from */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pChanges</name></decl></parameter>,             <comment type="block">/* Change-list for UPDATE, NULL for DELETE */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOld</name></decl></parameter>,                     <comment type="block">/* Address of array containing old row */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aChange</name></decl></parameter>,                   <comment type="block">/* Array indicating UPDATEd columns (or 0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>bChngRowid</name></decl></parameter>                  <comment type="block">/* True if rowid is UPDATEd */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* If foreign-key support is enabled, iterate through all FKs that 
  ** refer to table pTab. If there is an action associated with the FK 
  ** for this operation (either update or delete), invoke the associated 
  ** trigger sub-program.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>                  <comment type="block">/* Iterator variable */</comment>
    <for>for<control>(<init><expr><name>pFKey</name> <operator>=</operator> <call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>aChange</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>fkParentIsModified</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>aChange</name></expr></argument>, <argument><expr><name>bChngRowid</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pAct</name> <init>= <expr><call><name>fkActionTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pAct</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3CodeRowTriggerDirect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAct</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regOld</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_TRIGGER */</comment>

<comment type="block">/*
** Free all memory associated with foreign key definitions attached to
** table pTab. Remove the deleted foreign keys from the Schema.fkeyHash
** hash table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FkDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>                    <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>                    <comment type="block">/* Copy of pFKey-&gt;pNextFrom */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pFKey</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove the FK from the fkeyHash hash table. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFKey</name><operator>-&gt;</operator><name>pPrevTo</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pPrevTo</name><operator>-&gt;</operator><name>pNextTo</name></name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name><operator>-&gt;</operator><name>zTo</name></name></expr> </then><else>: <expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>fkeyHash</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFKey</name><operator>-&gt;</operator><name>pNextTo</name><operator>-&gt;</operator><name>pPrevTo</name></name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pPrevTo</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* EV: R-30323-21917 Each foreign key constraint in SQLite is
    ** classified as either immediate or deferred.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>isDeferred</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Delete any triggers created to implement actions for this FK. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
    <expr_stmt><expr><call><name>fkTriggerDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fkTriggerDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>apTrigger</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_FOREIGN_KEY */</comment>
</unit>
