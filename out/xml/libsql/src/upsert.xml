<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/upsert.c"><comment type="block">/*
** 2018-04-12
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement various aspects of UPSERT
** processing and handling of the Upsert object.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UPSERT</name></cpp:ifndef>
<comment type="block">/*
** Free a list of Upsert objects
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>SQLITE_NOINLINE</name></type> <name>upsertDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pToFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>p</name></expr> )</condition>;</do>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3UpsertDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>upsertDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Duplicate an Upsert object.
*/</comment>
<function><type><name>Upsert</name> <modifier>*</modifier></type><name>sqlite3UpsertDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3UpsertNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
           <argument><expr><call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertSet</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUpsertWhere</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>sqlite3UpsertDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr></argument>)</argument_list></call></expr></argument>
         )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new Upsert object.
*/</comment>
<function><type><name>Upsert</name> <modifier>*</modifier></type><name>sqlite3UpsertNew</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Determines which memory allocator to use */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pTarget</name></decl></parameter>,     <comment type="block">/* Target argument to ON CONFLICT, or NULL */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTargetWhere</name></decl></parameter>,    <comment type="block">/* Optional WHERE clause on the target */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>,        <comment type="block">/* UPDATE columns, or NULL for a DO NOTHING */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,          <comment type="block">/* WHERE clause for the ON CONFLICT UPDATE */</comment>
  <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pNext</name></decl></parameter>          <comment type="block">/* Next ON CONFLICT clause in the list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Upsert</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTargetWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3UpsertDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUpsertTarget</name></name> <operator>=</operator> <name>pTarget</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name> <operator>=</operator> <name>pTargetWhere</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUpsertSet</name></name> <operator>=</operator> <name>pSet</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUpsertWhere</name></name> <operator>=</operator> <name>pWhere</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>isDoUpdate</name></name> <operator>=</operator> <name>pSet</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNextUpsert</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Analyze the ON CONFLICT clause described by pUpsert.  Resolve all
** symbols in the conflict-target.
**
** Return SQLITE_OK if everything works, or an error code is something
** is wrong.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3UpsertAnalyzeTarget</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>, <comment type="block">/* Table into which we are inserting */</comment>
  <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>    <comment type="block">/* The ON CONFLICT clauses */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>            <comment type="block">/* That table into which we are inserting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                 <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCursor</name></decl>;</decl_stmt>            <comment type="block">/* Cursor used by pTab */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>            <comment type="block">/* One of the indexes of pTab */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pTarget</name></decl>;</decl_stmt>      <comment type="block">/* The conflict-target clause */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>            <comment type="block">/* One term of the conflict-target clause */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>        <comment type="block">/* Context for resolving symbolic names */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name><name>sCol</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>           <comment type="block">/* Index column converted into an Expr */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nClause</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Counter of ON CONFLICT clauses */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUpsert</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Resolve all symbolic names in the conflict-target clause, which
  ** includes both the list of columns and the optional partial-index
  ** WHERE clause.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>pUpsert</name> <operator>&amp;&amp;</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr>;</condition>
        <incr><expr><name>pUpsert</name><operator>=</operator><name><name>pUpsert</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr><operator>,</operator> <expr><name>nClause</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  
    <comment type="block">/* Check to see if the conflict target matches the rowid. */</comment>  
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTarget</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCursor</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>pTerm</name> <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>op</name><operator>==</operator><name>TK_COLUMN</name>
     <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>XN_ROWID</name></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* The conflict-target is the rowid of the primary table */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertIdx</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Initialize sCol[0..1] to be an expression parse tree for a
    ** single column of an index.  The sCol[0] node will be the TK_COLLATE
    ** operator and sCol[1] will be the TK_COLUMN operator.  Code below
    ** will populate the specific collation and column number values
    ** prior to comparing against the conflict-target expression.
    */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sCol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>TK_COLLATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pLeft</name> <operator>=</operator> <operator>&amp;</operator><name><name>sCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>TK_COLUMN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iTable</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  
    <comment type="block">/* Check for matches against other indexes */</comment>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>, <decl><type ref="prev"/><name>nn</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTarget</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name></expr></argument>,
                               <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><name>iCursor</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nn</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nn</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name>ii</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>bHasExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pLeft</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pLeft</name> <operator>=</operator> <operator>&amp;</operator><name><name>sCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iColumn</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nn</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name><name>pTarget</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>iCursor</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <break>break;</break>  <comment type="block">/* Column ii of the index matches column jj of target */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&gt;=</operator><name>nn</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* The target contains no match for column jj of the index */</comment>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><name>nn</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Column ii of the index did not match any term of the conflict target.
        ** Continue the search with the next index. */</comment>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertIdx</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertIdx</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zWhich</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nClause</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pNextUpsert</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zWhich</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zWhich</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zWhich</name></expr></argument>,<argument><expr><literal type="string">"%r "</literal></expr></argument>, <argument><expr><name>nClause</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%sON CONFLICT clause does not match any "</literal>
                              <literal type="string">"PRIMARY KEY or UNIQUE constraint"</literal></expr></argument>, <argument><expr><name>zWhich</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if pUpsert is the last ON CONFLICT clause with a
** conflict target, or if pUpsert is followed by another ON CONFLICT
** clause that targets the INTEGER PRIMARY KEY.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3UpsertNextIsIPK</name><parameter_list>(<parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pUpsert</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNext</name><operator>-&gt;</operator><name>pUpsertTarget</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNext</name><operator>-&gt;</operator><name>pUpsertIdx</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the list of ON CONFLICT clauses described by pUpsert, and
** a particular index pIdx, return a pointer to the particular ON CONFLICT
** clause that applies to the index.  Or, if the index is not subject to
** any ON CONFLICT clause, return NULL.
*/</comment>
<function><type><name>Upsert</name> <modifier>*</modifier></type><name>sqlite3UpsertOfIndex</name><parameter_list>(<parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>(
      <expr><name>pUpsert</name>
   <operator>&amp;&amp;</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertIdx</name></name><operator>!=</operator><name>pIdx</name></expr>
  )</condition><block>{<block_content>
     <expr_stmt><expr><name>pUpsert</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pUpsert</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate bytecode that does an UPDATE as part of an upsert.
**
** If pIdx is NULL, then the UNIQUE constraint that failed was the IPK.
** In this case parameter iCur is a cursor open on the table b-tree that
** currently points to the conflicting table row. Otherwise, if pIdx
** is not NULL, then pIdx is the constraint that failed and iCur is a
** cursor points to the conflicting row.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UpsertDoUpdate</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* The parsing and code-generating context */</comment>
  <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>,      <comment type="block">/* The ON CONFLICT clause for the upsert */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,          <comment type="block">/* The table being updated */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,          <comment type="block">/* The UNIQUE constraint that failed */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>              <comment type="block">/* Cursor for pIdx (or pTab if pIdx==NULL) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>            <comment type="block">/* FROM clause for the UPDATE */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><name>pUpsert</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUpsert</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>iDataCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUpsert</name> <operator>=</operator> <call><name>sqlite3UpsertOfIndex</name><argument_list>(<argument><expr><name>pTop</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Begin DO UPDATE of UPSERT"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name> <operator>&amp;&amp;</operator> <name>iCur</name><operator>!=</operator><name>iDataCur</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxRowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekRowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iPk</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPk</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>iPk</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s.%s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator>
                    <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>zCnName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_CORRUPT</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
            <argument><expr><literal type="string">"corrupt database"</literal></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* pUpsert does not own pTop-&gt;pUpsertSrc - the outer INSERT statement does.
  ** So we have to make a copy before passing it down into sqlite3Update() */</comment>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTop</name><operator>-&gt;</operator><name>pUpsertSrc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* excluded.* columns of type REAL need to be converted to a hard real */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name><name>pTop</name><operator>-&gt;</operator><name>regData</name></name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3Update</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertSet</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertWhere</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"End DO UPDATE of UPSERT"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UPSERT */</comment>
</unit>
