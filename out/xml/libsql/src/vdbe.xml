<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/vdbe.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** The code in this file implements the function that runs the
** bytecode of a prepared statement.
**
** Various scripts scan this source file in order to generate HTML
** documentation, headers files, or other derived files.  The formatting
** of the code in this file is, therefore, important.  See other comments
** in this file for details.  If in doubt, do not deviate from existing
** commenting and indentation practices when changing or adding code.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LIBSQL_ENABLE_WASM_RUNTIME</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ext/udf/wasm_bindings.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Invoke this macro on memory cells just prior to changing the
** value of the cell.  This macro verifies that shallow copies are
** not misused.  A shallow copy of a string or blob just copies a
** pointer to the string or blob, not the content.  If the original
** is changed while the copy is still in use, the string or blob might
** be changed out from under the copy.  This macro verifies that nothing
** like that ever happens.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>memAboutToChange</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3VdbeMemAboutToChange(P,M)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>memAboutToChange</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following global variable is incremented every time a cursor
** moves, either by the OP_SeekXX, OP_Next, or OP_Prev opcodes.  The test
** procedures use this information to make sure that indices are
** working correctly.  This variable has no function other than to
** help verify the correct operation of the library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_search_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** When this global variable is positive, it gets decremented once before
** each instruction in the VDBE.  When it reaches zero, the u1.isInterrupted
** field of the sqlite3 structure is set in order to simulate an interrupt.
**
** This facility is used for testing purposes only.  It does not function
** in an ordinary build.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_interrupt_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable is incremented each type the OP_Sort opcode
** is executed.  The test procedures use this information to make sure that
** sorting is occurring or not occurring at appropriate times.   This variable
** has no function other than to help verify the correct operation of the
** library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sort_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable records the size of the largest MEM_Blob
** or MEM_Str that has been used by a VDBE opcode.  The test procedures
** use this information to make sure that the zero-blob functionality
** is working correctly.   This variable has no function other than to
** help verify the correct operation of the library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_max_blobsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateMaxBlobsize</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><name>sqlite3_max_blobsize</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sqlite3_max_blobsize</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This macro evaluates to true if either the update hook or the preupdate
** hook are enabled for database connect DB.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_UPDATE_HOOK</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((DB)-&gt;xPreUpdateCallback||(DB)-&gt;xUpdateCallback)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_UPDATE_HOOK</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((DB)-&gt;xUpdateCallback)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable is incremented each time the OP_Found opcode
** is executed. This is used to test whether or not the foreign key
** operation implemented using OP_FkIsZero is working. This variable
** has no function other than to help verify the correct operation of the
** library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_found_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Test a register to see if it exceeds the current maximum blob size.
** If it does, record the new maximum blob size.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_UNTESTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_MAX_BLOBSIZE</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>updateMaxBlobsize(P)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_MAX_BLOBSIZE</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/* This routine provides a convenient place to set a breakpoint during
** tracing with PRAGMA vdbe_trace=on.  The breakpoint fires right after
** each opcode is printed.  Variables "pc" (program counter) and pOp are
** available to add conditionals to the breakpoint.  GDB example:
**
**         break test_trace_breakpoint if pc=22
**
** Other useful labels for breakpoints include:
**   test_addop_breakpoint(pc,pOp)
**   sqlite3CorruptError(lineno)
**   sqlite3MisuseError(lineno)
**   sqlite3CantopenError(lineno)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_trace_breakpoint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Invoke the VDBE coverage callback, if that callback is defined.  This
** feature is used for test suite validation only and does not appear an
** production builds.
**
** M is the type of branch.  I is the direction taken for this instance of
** the branch.
**
**   M: 2 - two-way branch (I=0: fall-thru   1: jump                )
**      3 - two-way + NULL (I=0: fall-thru   1: jump      2: NULL   )
**      4 - OP_Jump        (I=0: jump p1     1: jump p2   2: jump p3)
**
** In other words, if M is 2, then I is either 0 (for fall-through) or
** 1 (for when the branch is taken).  If M is 3, the I is 0 for an
** ordinary fall-through, I is 1 if the branch was taken, and I is 2 
** if the result of comparison is NULL.  For M=3, I=2 the jump may or
** may not be taken, depending on the SQLITE_JUMPIFNULL flags in p5.
** When M is 4, that means that an OP_Jump is being run.  I is 0, 1, or 2
** depending on if the operands are less than, equal, or greater than.
**
** iSrcLine is the source code line (from the __LINE__ macro) that
** generated the VDBE instruction combined with flag bits.  The source
** code line number is in the lower 24 bits of iSrcLine and the upper
** 8 bytes are flags.  The lower three bits of the flags indicate
** values for I that should never occur.  For example, if the branch is
** always taken, the flags should be 0x05 since the fall-through and
** alternate branch are never taken.  If a branch is never taken then
** flags should be 0x06 since only the fall-through approach is allowed.
**
** Bit 0x08 of the flags indicates an OP_Jump opcode that is only
** interested in equal or not-equal.  In other words, I==0 and I==2
** should be treated as equivalent
**
** Since only a line number is retained, not the filename, this macro
** only works for amalgamation builds.  But that is ok, since these macros
** should be no-ops except for special builds used to measure test coverage.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_VDBE_COVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>VdbeBranchTaken</name><parameter_list>(<parameter><type><name>I</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>VdbeBranchTaken</name><parameter_list>(<parameter><type><name>I</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vdbeTakeBranch(pOp-&gt;iSrcLine,I,M)</cpp:value></cpp:define>
  <function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeTakeBranch</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>iSrcLine</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>I</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>M</name></decl></parameter>)</parameter_list><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>mNever</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>I</name><operator>&lt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 0: fall through,  1: taken,  2: alternate taken */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>M</name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 2: two-way branch, 3: three-way branch, 4: OP_Jump */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>I</name><operator>&lt;</operator><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* I can only be 2 if M is 3 or 4 */</comment>
    <comment type="block">/* Transform I from a integer [0,1,2] into a bitmask of [1,2,4] */</comment>
    <expr_stmt><expr><name>I</name> <operator>=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>I</name></expr>;</expr_stmt>
    <comment type="block">/* The upper 8 bits of iSrcLine are flags.  The lower three bits of
    ** the flags indicate directions that the branch can never go.  If
    ** a branch really does go in one of those directions, assert right
    ** away. */</comment>
    <expr_stmt><expr><name>mNever</name> <operator>=</operator> <name>iSrcLine</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>I</name> <operator>&amp;</operator> <name>mNever</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xVdbeBranch</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/*NO_TEST*/</comment>
    <comment type="block">/* Invoke the branch coverage callback with three arguments:
    **    iSrcLine - the line number of the VdbeCoverage() macro, with
    **               flags removed.
    **    I        - Mask of bits 0x07 indicating which cases are are
    **               fulfilled by this instance of the jump.  0x01 means
    **               fall-thru, 0x02 means taken, 0x04 means NULL.  Any
    **               impossible cases (ex: if the comparison is never NULL)
    **               are filled in automatically so that the coverage
    **               measurement logic does not flag those impossible cases
    **               as missed coverage.
    **    M        - Type of jump.  Same as M argument above
    */</comment>
    <expr_stmt><expr><name>I</name> <operator>|=</operator> <name>mNever</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>M</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>I</name> <operator>|=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>M</name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>I</name> <operator>|=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mNever</name><operator>&amp;</operator><literal type="number">0x08</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>I</name><operator>&amp;</operator><literal type="number">0x05</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>I</name> <operator>|=</operator> <literal type="number">0x05</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/*NO_TEST*/</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xVdbeBranch</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pVdbeBranchArg</name></name></expr></argument>,
                                    <argument><expr><name>iSrcLine</name><operator>&amp;</operator><literal type="number">0xffffff</literal></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** An ephemeral string value (signified by the MEM_Ephem flag) contains
** a pointer to a dynamically allocated string where some other entity
** is responsible for deallocating that string.  Because the register
** does not control the string, it might be deleted without the register
** knowing it.
**
** This routine converts an ephemeral string into a dynamically allocated
** string that the register itself controls.  In other words, it
** converts an MEM_Ephem string into a string with P.z==P.zMalloc.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Deephemeralize</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>if( ((P)-&gt;flags&amp;MEM_Ephem)!=0 \
       &amp;&amp; sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}</cpp:value></cpp:define>

<comment type="block">/* Return true if the cursor was opened using the OP_OpenSorter opcode. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isSorter</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;eCurType==CURTYPE_SORTER)</cpp:value></cpp:define>

<comment type="block">/*
** Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL
** if we run out of memory.
*/</comment>
<function><type><specifier>static</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>allocateCursor</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,              <comment type="block">/* The virtual machine */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,             <comment type="block">/* Index of the new VdbeCursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>,           <comment type="block">/* Number of fields in the table or index */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eCurType</name></decl></parameter>           <comment type="block">/* Type of the new cursor */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* Find the memory cell that will be used to store the blob of memory
  ** required for this VdbeCursor structure. It is convenient to use a 
  ** vdbe memory cell to manage the memory allocation required for a
  ** VdbeCursor structure for the following reasons:
  **
  **   * Sometimes cursor numbers are used for a couple of different
  **     purposes in a vdbe program. The different uses might require
  **     different sized allocations. Memory cells provide growable
  **     allocations.
  **
  **   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can
  **     be freed lazily via the sqlite3_release_memory() API. This
  **     minimizes the number of malloc calls made by the system.
  **
  ** The memory cell for cursor 0 is aMem[0]. The rest are allocated from
  ** the top of the register space.  Cursor 1 is at Mem[p-&gt;nMem-1].
  ** Cursor 2 is at Mem[p-&gt;nMem-2]. And so forth.
  */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><ternary><condition><expr><name>iCur</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name>iCur</name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> 
      <call><name>ROUND8P</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nField</name> <operator>+</operator> 
      <operator>(</operator><ternary><condition><expr><name>eCurType</name><operator>==</operator><name>CURTYPE_BTREE</name></expr>?</condition><then><expr><call><name>sqlite3BtreeCursorSize</name><argument_list>()</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCur</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content> <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeFreeCursorNN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* There used to be a call to sqlite3VdbeMemClearAndResize() to make sure
  ** the pMem used to hold space for the cursor has enough storage available
  ** in pMem-&gt;zMalloc.  But for the special case of the aMem[] entries used
  ** to hold cursors, it is faster to in-line the logic. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Undefined</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&lt;</operator><name>nByte</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>=</operator> <name>pCx</name> <operator>=</operator> <operator>(</operator><name>VdbeCursor</name><operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>,<argument><expr><name>pAltCursor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>eCurType</name></name> <operator>=</operator> <name>eCurType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>aOffset</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCx</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eCurType</name><operator>==</operator><name>CURTYPE_BTREE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name> <operator>=</operator> <operator>(</operator><name>BtCursor</name><operator>*</operator><operator>)</operator>
        <operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><call><name>ROUND8P</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeCursorZero</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pCx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The string in pRec is known to look like an integer and to have a
** floating point value of rValue.  Return true and set *piValue to the
** integer value if the string is in range to be an integer.  Otherwise,
** return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>alsoAnInt</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rValue</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>iValue</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>iValue</name> <operator>=</operator> <call><name>sqlite3RealToI64</name><argument_list>(<argument><expr><name>rValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3RealSameAsInt</name><argument_list>(<argument><expr><name>rValue</name></expr></argument>,<argument><expr><name>iValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piValue</name> <operator>=</operator> <name>iValue</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>piValue</name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to convert a value into a numeric representation if we can
** do so without loss of information.  In other words, if the string
** looks like a number, convert it into a number.  If it does not
** look like a number, leave it alone.
**
** If the bTryForInt flag is true, then extra effort is made to give
** an integer representation.  Strings that look like floating point
** values but which have no fractional component (example: '48.00')
** will have a MEM_Int representation when bTryForInt is true.
**
** If bTryForInt is false, then if the input string contains a decimal
** point or exponential notation, the result is only MEM_Real, even
** if there is an exact integer representation of the quantity.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>applyNumericAffinity</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bTryForInt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>rValue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><name><name>pRec</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rValue</name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>alsoAnInt</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>rValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>rValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bTryForInt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* TEXT-&gt;NUMERIC is many-&gt;one.  Hence, it is important to invalidate the
  ** string representation after computing a numeric equivalent, because the
  ** string representation might not be the canonical representation for the
  ** numeric value.  Ticket [343634942dd54ab57b7024] 2018-01-31. */</comment>
  <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Str</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Processing is determine by the affinity parameter:
**
** SQLITE_AFF_INTEGER:
** SQLITE_AFF_REAL:
** SQLITE_AFF_NUMERIC:
**    Try to convert pRec to an integer representation or a 
**    floating-point representation if an integer representation
**    is not possible.  Note that the integer representation is
**    always preferred, even if the affinity is REAL, because
**    an integer representation is more space efficient on disk.
**
** SQLITE_AFF_TEXT:
**    Convert pRec to a text representation.
**
** SQLITE_AFF_BLOB:
** SQLITE_AFF_NONE:
**    No-op.  pRec is unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>applyAffinity</name><parameter_list>(
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>,          <comment type="block">/* The value to apply affinity to */</comment>
  <parameter><decl><type><name>char</name></type> <name>affinity</name></decl></parameter>,      <comment type="block">/* The affinity to be applied */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>              <comment type="block">/* Use this text encoding */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_INTEGER</name> <operator>||</operator> <name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name>
             <operator>||</operator> <name>affinity</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Only attempt the conversion to TEXT if there is an integer or real
    ** representation (blob and NULL do not get converted) but no string
    ** representation.  It would be harmless to repeat the conversion if 
    ** there is already a string rep, but it is pointless to waste those
    ** CPU cycles. */</comment>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content> <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Try to convert the type of a function argument or a result column
** into a numeric representation.  Use either INTEGER or REAL whichever
** is appropriate.  But only do the conversion if it is possible without
** loss of information and return the revised type of the argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_value_numeric_type</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>eType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Exported version of applyAffinity(). This one works on sqlite3_value*, 
** not the internal Mem* type.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueApplyAffinity</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name></type> <name>affinity</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pMem currently only holds a string type (or maybe a BLOB that we can
** interpret as a string if we want to).  Compute its corresponding
** numeric type, if has one.  Set the pMem-&gt;u.r and pMem-&gt;u.i fields
** accordingly.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name> <name>SQLITE_NOINLINE</name></type> <name>computeNumericType</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>MEM_Int</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>ix</name></expr>;</expr_stmt>
      <return>return <expr><name>MEM_Int</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>MEM_Real</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>ix</name></expr>;</expr_stmt>
    <return>return <expr><name>MEM_Int</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>MEM_Real</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the numeric type for pMem, either MEM_Int or MEM_Real or both or
** none.  
**
** Unlike applyNumericAffinity(), this routine does not modify pMem-&gt;flags.
** But it does set pMem-&gt;u.r and pMem-&gt;u.i appropriately.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>numericType</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Null</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Null</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>computeNumericType</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</return>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Write a nice string representation of the contents of cell pMem
** into buffer zBuf, length nBuf.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemPrettyPrint</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>encnames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"(X)"</literal></expr>, <expr><literal type="string">"(8)"</literal></expr>, <expr><literal type="string">"(16LE)"</literal></expr>, <expr><literal type="string">"(16BE)"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>&amp;</operator><name>MEM_Blob</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'z'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Static</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Ephem</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%cx["</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">25</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">25</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>z</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>z</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal><operator>||</operator><name>z</name></expr></argument>&gt;</argument_list></name><literal type="number">126</literal><operator>)</operator></expr>?</condition><then><expr><literal type="char">'.'</literal></expr></then><else>:<expr><name>z</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>,<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"+%dz"</literal></expr></argument>,<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>c</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'z'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Static</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Ephem</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" %c%d["</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">25</literal> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="number">0x20</literal><operator>&amp;&amp;</operator><name>c</name><operator>&lt;=</operator><literal type="number">0x7f</literal><operator>)</operator></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"]%s"</literal></expr></argument>, <argument><expr><name><name>encnames</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Print the value of a register for tracing purposes:
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memTracePrint</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Undefined</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" undefined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> ?</condition><then> <expr><literal type="string">" NULL-nochng"</literal></expr> </then><else>: <expr><literal type="string">" NULL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" si:%lld"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" ir:%lld"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" i:%lld"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" r:%.17g"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (rowset)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemPrettyPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Subtype</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" subtype=0x%02x"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eSubtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>registerTrace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"R[%d] = "</literal></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memTracePrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pScopyFrom</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" &lt;== R[%d]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>-</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><operator>-</operator><name>iReg</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/**/</comment> <function><type><name>void</name></type> <name>sqlite3PrintMem</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memTracePrint</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Show the values of all registers in the virtual machine.  Used for
** interactive debugging.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeRegisterDump</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>aMem</name></name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTER_TRACE</name><parameter_list>(<parameter><type><name>R</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if(db-&gt;flags&amp;SQLITE_VdbeTrace)registerTrace(R,M)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTER_TRACE</name><parameter_list>(<parameter><type><name>R</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** This function is only called from within an assert() expression. It
** checks that the sqlite3.nTransaction variable is correctly set to
** the number of non-transaction savepoints currently in the 
** linked list starting at sqlite3.pSavepoint.
** 
** Usage:
**
**     assert( checkSavepointCount(db) );
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkSavepointCount</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>+</operator> <name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the register of pOp-&gt;p2 after first preparing it to be
** overwritten with an integer value.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>Mem</name> <modifier>*</modifier></type><name>out2PrereleaseWithClear</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <return>return <expr><name>pOut</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Mem</name> <modifier>*</modifier></type><name>out2Prerelease</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
    <return>return <expr><call><name>out2PrereleaseWithClear</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <return>return <expr><name>pOut</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compute a bloom filter hash using pOp-&gt;p4.i registers from aMem[] beginning
** with pOp-&gt;p3.  Return the hash.
*/</comment>
<function><type><specifier>static</specifier> <name>u64</name></type> <name>filterHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>aMem</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr><operator>,</operator> <expr><name>mx</name><operator>=</operator><name>i</name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>h</name> <operator>+=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the symbolic name for the data type of a pMem
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vdbeMemTypeName</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azTypes</name><index>[]</index></name> <init>= <expr><block>{
      <comment type="block">/* SQLITE_INTEGER */</comment> <expr><literal type="string">"INT"</literal></expr>,
      <comment type="block">/* SQLITE_FLOAT   */</comment> <expr><literal type="string">"REAL"</literal></expr>,
      <comment type="block">/* SQLITE_TEXT    */</comment> <expr><literal type="string">"TEXT"</literal></expr>,
      <comment type="block">/* SQLITE_BLOB    */</comment> <expr><literal type="string">"BLOB"</literal></expr>,
      <comment type="block">/* SQLITE_NULL    */</comment> <expr><literal type="string">"NULL"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>azTypes</name><index>[<expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LIBSQL_ENABLE_WASM_RUNTIME</name></cpp:ifdef>
<function_decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>try_instantiate_wasm_function</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSrcBody</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBody</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg_buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>deregister_wasm_function</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Execute as much of a VDBE program as we can.
** This is the core of sqlite3_step().  
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeExec</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                    <comment type="block">/* The VDBE */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Copy of p-&gt;aOp */</comment>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><name>aOp</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Current operation */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOrigOp</name></decl>;</decl_stmt>               <comment type="block">/* Value of pOp at the top of the loop */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtraDelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Verifies FORDELETE and AUXDELETE flags */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Value to return */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* The database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>resetSchemaOnFault</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Reset schema after an error if positive */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>encoding</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* The database encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCompare</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Result of last comparison */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nVmStep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of virtual machine steps */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u64</name></type> <name>nProgressLimit</name></decl>;</decl_stmt>        <comment type="block">/* Invoke xProgress() when nVmStep reaches this */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>aMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Copy of p-&gt;aMem */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* 1st input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* 2nd input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* 3rd input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Output operand */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u64</name></type> <name>start</name></decl>;</decl_stmt>                 <comment type="block">/* CPU clock count at start of opcode */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block" format="doxygen">/*** INSERT STACK UNION HERE ***/</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_RUN_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3_step() verifies this */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iPrior</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_VM_STEP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nProgressLimit</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>-</operator> <operator>(</operator><name>iPrior</name> <operator>%</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nProgressLimit</name> <operator>=</operator> <name>LARGEST_UINT64</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */</comment>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCurrentTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_interrupt</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIOTraceSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_VdbeListing</name><operator>|</operator><name>SQLITE_VdbeEQP</name><operator>|</operator><name>SQLITE_VdbeTrace</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>once</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbePrintSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeListing</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VDBE Program Listing:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeEQP</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Explain</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>once</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VDBE Query Plan:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>once</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VDBE Trace:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>pOp</name><operator>=</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name></expr>]</index></name></expr>;</init> <condition><expr><literal type="number">1</literal></expr>;</condition> <incr><expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* Errors are detected by individual opcodes, with an immediate
    ** jumps to abort_due_to_error. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&gt;=</operator><name>aOp</name> <operator>&amp;&amp;</operator> <name>pOp</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <ternary><condition><expr><name>sqlite3NProfileCnt</name></expr> ?</condition><then> <expr><name>sqlite3NProfileCnt</name></expr> </then><else>: <expr><call><name>sqlite3Hwtime</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>nVmStep</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name><operator>-</operator><name>aOp</name><operator>)</operator></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Only allow tracing if SQLITE_DEBUG is defined.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>test_trace_breakpoint</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr></argument>,<argument><expr><name>pOp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      

    <comment type="block">/* Check to see if we need to simulate an interrupt.  This only happens
    ** if we have a special test build.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>sqlite3_interrupt_count</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sqlite3_interrupt_count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sqlite3_interrupt_count</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Sanity checking on other operands */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>opProperty</name> <init>= <expr><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>opProperty</name> <operator>&amp;</operator> <name>OPFLG_IN1</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>opProperty</name> <operator>&amp;</operator> <name>OPFLG_IN2</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>opProperty</name> <operator>&amp;</operator> <name>OPFLG_IN3</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>opProperty</name> <operator>&amp;</operator> <name>OPFLG_OUT2</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>opProperty</name> <operator>&amp;</operator> <name>OPFLG_OUT3</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>pOrigOp</name> <operator>=</operator> <name>pOp</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
    <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>

<comment type="block" format="doxygen">/*****************************************************************************
** What follows is a massive switch statement where each case implements a
** separate instruction in the virtual machine.  If we follow the usual
** indentation conventions, each case should be indented by 6 spaces.  But
** that is a lot of wasted space on the left margin.  So the code within
** the switch statement will break with convention and be flush-left. Another
** big comment (similar to this one) will mark the point in the code where
** we transition back to normal indentation.
**
** The formatting of each case is important.  The makefile for SQLite
** generates two C files "opcodes.h" and "opcodes.c" by scanning this
** file looking for lines that begin with "case OP_".  The opcodes.h files
** will be filled with #defines that give unique integer values to each
** opcode and the opcodes.c file is filled with an array of strings where
** each string is the symbolic name for the corresponding opcode.  If the
** case statement is followed by a comment of the form "/# same as ... #/"
** that comment is used to determine the particular value of the opcode.
**
** Other keywords in the comment that follows each case are used to
** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].
** Keywords include: in1, in2, in3, out2, out3.  See
** the mkopcodeh.awk script for additional information.
**
** Documentation about VDBE opcodes is generated by scanning this file
** for lines of that contain "Opcode:".  That line and all subsequent
** comment lines are used in the generation of the opcode.html documentation
** file.
**
** SUMMARY:
**
**     Formatting is important to scripts that scan this file.
**     Do not deviate from the formatting style currently in use.
**
*****************************************************************************/</comment>

<comment type="block">/* Opcode:  Goto * P2 * * *
**
** An unconditional jump to address P2.
** The next instruction executed will be 
** the one at index P2 from the beginning of
** the program.
**
** The P1 parameter is not actually used by this opcode.  However, it
** is sometimes set to 1 instead of 0 as a hint to the command-line shell
** that this Goto is the bottom of a loop and that the lines from P2 down
** to the current line should be indented for EXPLAIN output.
*/</comment>
<case>case <expr><name>OP_Goto</name></expr>:</case> <block>{<block_content>             <comment type="block">/* jump */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* In debuggging mode, when the p5 flags is set on an OP_Goto, that
  ** means we should really jump back to the preceeding OP_ReleaseReg
  ** instruction. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_ReleaseReg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>check_for_interrupt</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>jump_to_p2_and_check_for_interrupt</name>:</label>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Opcodes that are used as the bottom of a loop (OP_Next, OP_Prev,
  ** OP_VNext, or OP_SorterNext) all jump here upon
  ** completion.  Check to see if sqlite3_interrupt() has been called
  ** or if the progress callback needs to be invoked. 
  **
  ** This code uses unstructured "goto" statements and does not look clean.
  ** But that is not due to sloppy coding habits. The code is written this
  ** way for performance, to avoid having to run the interrupt and progress
  ** checks on every opcode.  This helps sqlite3_step() to run about 1.5%
  ** faster according to "valgrind --tool=cachegrind" */</comment>
<label><name>check_for_interrupt</name>:</label>
  <if_stmt><if>if<condition>( <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_interrupt</name>;</goto></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <comment type="block">/* Call the progress callback if it is configured and the required number
  ** of VDBE ops have been executed (either since this invocation of
  ** sqlite3VdbeExec() or since last time the progress callback was called).
  ** If the progress callback returns non-zero, exit the virtual machine with
  ** a return code SQLITE_ABORT.
  */</comment>
  <while>while<condition>( <expr><name>nVmStep</name><operator>&gt;=</operator><name>nProgressLimit</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nProgressLimit</name> <operator>+=</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nProgressLimit</name> <operator>=</operator> <name>LARGEST_UINT64</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  Gosub P1 P2 * * *
**
** Write the current address onto register P1
** and then jump to address P2.
*/</comment>
<case>case <expr><name>OP_Gosub</name></expr>:</case> <block>{<block_content>            <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name><operator>-</operator><name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode:  Return P1 P2 P3 * *
**
** Jump to the address stored in register P1.  If P1 is a return address
** register, then this accomplishes a return from a subroutine.
**
** If P3 is 1, then the jump is only taken if register P1 holds an integer
** values, otherwise execution falls through to the next opcode, and the
** OP_Return becomes a no-op. If P3 is 0, then register P1 must hold an
** integer or else an assert() is raised.  P3 should be set to 1 when
** this opcode is used in combination with OP_BeginSubrtn, and set to 0
** otherwise.
**
** The value in register P1 is unchanged by this opcode.
**
** P2 is not used by the byte-code engine.  However, if P2 is positive
** and also less than the current address, then the "EXPLAIN" output
** formatter in the CLI will indent all opcodes from the P2 opcode up
** to be not including the current Return.   P2 should be the first opcode
** in the subroutine from which this opcode is returning.  Thus the P2
** value is a byte-code indentation hint.  See tag-20220407a in
** wherecode.c and shell.c.
*/</comment>
<case>case <expr><name>OP_Return</name></expr>:</case> <block>{<block_content>           <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: InitCoroutine P1 P2 P3 * *
**
** Set up register P1 so that it will Yield to the coroutine
** located at address P3.
**
** If P2!=0 then the coroutine implementation immediately follows
** this opcode.  So jump over the coroutine implementation to
** address P2.
**
** See also: EndCoroutine
*/</comment>
<case>case <expr><name>OP_InitCoroutine</name></expr>:</case> <block>{<block_content>     <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>  <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* Most jump operations do a goto to this spot in order to update
  ** the pOp pointer. */</comment>
<label><name>jump_to_p2</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* There are never any jumps to instruction 0 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Jumps must be in range */</comment>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  EndCoroutine P1 * * * *
**
** The instruction at the address in register P1 is a Yield.
** Jump to the P2 parameter of that Yield.
** After the jump, register P1 becomes undefined.
**
** See also: InitCoroutine
*/</comment>
<case>case <expr><name>OP_EndCoroutine</name></expr>:</case> <block>{<block_content>           <comment type="block">/* in1 */</comment>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pCaller</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCaller</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCaller</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Yield</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCaller</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCaller</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pCaller</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  Yield P1 P2 * * *
**
** Swap the program counter with the value in register P1.  This
** has the effect of yielding to a coroutine.
**
** If the coroutine that is launched by this instruction ends with
** Yield or Return then continue to the next instruction.  But if
** the coroutine launched by this instruction ends with
** EndCoroutine, then jump to P2 rather than continuing with the
** next instruction.
**
** See also: InitCoroutine
*/</comment>
<case>case <expr><name>OP_Yield</name></expr>:</case> <block>{<block_content>            <comment type="block">/* in1, jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pcDest</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcDest</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>pcDest</name></expr>]</index></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  HaltIfNull  P1 P2 P3 P4 P5
** Synopsis: if r[P3]=null halt
**
** Check the value in register P3.  If it is NULL then Halt using
** parameter P1, P2, and P4 as if this were a Halt instruction.  If the
** value in register P3 is not NULL, then this routine is a no-op.
** The P5 parameter should be 1.
*/</comment>
<case>case <expr><name>OP_HaltIfNull</name></expr>:</case> <block>{<block_content>      <comment type="block">/* in3 */</comment>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3VdbeAssertAbortable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <comment type="block">/* Fall through into OP_Halt */</comment>
  <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
</block_content>}</block>

<comment type="block">/* Opcode:  Halt P1 P2 * P4 P5
**
** Exit immediately.  All open cursors, etc are closed
** automatically.
**
** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),
** or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).
** For errors, it can be some other value.  If P1!=0 then P2 will determine
** whether or not to rollback the current transaction.  Do not rollback
** if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,
** then back out all changes that have occurred during this execution of the
** VDBE, but do not rollback the transaction. 
**
** If P4 is not null then it is an error message string.
**
** P5 is a value between 0 and 4, inclusive, that modifies the P4 string.
**
**    0:  (no change)
**    1:  NOT NULL contraint failed: P4
**    2:  UNIQUE constraint failed: P4
**    3:  CHECK constraint failed: P4
**    4:  FOREIGN KEY constraint failed: P4
**
** If P5 is not zero and P4 is NULL, then everything after the ":" is
** omitted.
**
** There is an implied "Halt 0 0 0" instruction inserted at the very end of
** every program.  So a jump past the last instruction of the program
** is the same as executing Halt.
*/</comment>
<case>case <expr><name>OP_Halt</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pcx</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3VdbeAssertAbortable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Halt the sub-program. Return control to the parent frame. */</comment>
    <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcx</name> <operator>=</operator> <call><name>sqlite3VdbeFrameRestore</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Instruction pcx is the OP_Program that invoked the sub-program 
      ** currently being halted. If the p2 instruction of this OP_Halt
      ** instruction is set to OE_Ignore, then the sub-program is throwing
      ** an IGNORE exception. In this case jump to the address specified
      ** as the p2 of the calling OP_Program.  */</comment>
      <expr_stmt><expr><name>pcx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>pcx</name></expr>]</index></name><operator>.</operator><name>p2</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMem</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>pcx</name></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>azType</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"NOT NULL"</literal></expr>, <expr><literal type="string">"UNIQUE"</literal></expr>, <expr><literal type="string">"CHECK"</literal></expr>,
                                             <expr><literal type="string">"FOREIGN KEY"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s constraint failed"</literal></expr></argument>, <argument><expr><name><name>azType</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%z: %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pcx</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="string">"abort at %d in [%s]: %s"</literal></expr></argument>, <argument><expr><name>pcx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>SQLITE_DONE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <goto>goto <name>vdbe_return</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Integer P1 P2 * * *
** Synopsis: r[P2]=P1
**
** The 32-bit integer value P1 is written into register P2.
*/</comment>
<case>case <expr><name>OP_Integer</name></expr>:</case> <block>{<block_content>         <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Int64 * P2 * P4 *
** Synopsis: r[P2]=P4
**
** P4 is a pointer to a 64-bit integer value.
** Write that value into register P2.
*/</comment>
<case>case <expr><name>OP_Int64</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/* Opcode: Real * P2 * P4 *
** Synopsis: r[P2]=P4
**
** P4 is a pointer to a 64-bit floating point value.
** Write that value into register P2.
*/</comment>
<case>case <expr><name>OP_Real</name></expr>:</case> <block>{<block_content>            <comment type="block">/* same as TK_FLOAT, out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pReal</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: String8 * P2 * P4 *
** Synopsis: r[P2]='P4'
**
** P4 points to a nul terminated UTF-8 string. This opcode is transformed 
** into a String opcode before it is executed for the first time.  During
** this transformation, the length of string P4 is computed and stored
** as the P1 parameter.
*/</comment>
<case>case <expr><name>OP_String8</name></expr>:</case> <block>{<block_content>         <comment type="block">/* same as TK_STRING, out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>encoding</name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_TOOBIG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>too_big</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOut</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>==</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Static</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_DYNAMIC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_DYNAMIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pOut</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_String</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Fall through to the next case, OP_String */</comment>
  <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
</block_content>}</block>
  
<comment type="block">/* Opcode: String P1 P2 P3 P4 P5
** Synopsis: r[P2]='P4' (len=P1)
**
** The string value P4 of length P1 (bytes) is stored in register P2.
**
** If P3 is not zero and the content of register P3 is equal to P5, then
** the datatype of the register P2 is converted to BLOB.  The content is
** the same sequence of bytes, it is merely interpreted as a BLOB instead
** of a string, as if it had been CAST.  In other words:
**
** if( P3!=0 and reg[P3]==P5 ) reg[P2] := CAST(reg[P2] as BLOB)
*/</comment>
<case>case <expr><name>OP_String</name></expr>:</case> <block>{<block_content>          <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: BeginSubrtn * P2 * * *
** Synopsis: r[P2]=NULL
**
** Mark the beginning of a subroutine that can be entered in-line
** or that can be called using OP_Gosub.  The subroutine should
** be terminated by an OP_Return instruction that has a P1 operand that
** is the same as the P2 operand to this opcode and that has P3 set to 1.
** If the subroutine is entered in-line, then the OP_Return will simply
** fall through.  But if the subroutine is entered using OP_Gosub, then
** the OP_Return will jump back to the first instruction after the OP_Gosub.
**
** This routine works by loading a NULL into the P2 register.  When the
** return address register contains a NULL, the OP_Return instruction is
** a no-op that simply falls through to the next instruction (assuming that
** the OP_Return opcode has a P3 value of 1).  Thus if the subroutine is
** entered in-line, then the OP_Return will cause in-line execution to
** continue.  But if the subroutine is entered via OP_Gosub, then the
** OP_Return will cause a return to the address following the OP_Gosub.
**
** This opcode is identical to OP_Null.  It has a different name
** only to make the byte code easier to read and verify.
*/</comment>
<comment type="block">/* Opcode: Null P1 P2 P3 * *
** Synopsis: r[P2..P3]=NULL
**
** Write a NULL into registers P2.  If P3 greater than P2, then also write
** NULL into register P3 and every register in between P2 and P3.  If P3
** is less than P2 (typically P3 is zero) then only register P2 is
** set to NULL.
**
** If the P1 value is non-zero, then also set the MEM_Cleared flag so that
** NULL values will not compare equal even if SQLITE_NULLEQ is set on
** OP_Ne or OP_Eq.
*/</comment>
<case>case <expr><name>OP_BeginSubrtn</name></expr>:</case>
<case>case <expr><name>OP_Null</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nullFlag</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cnt</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>-</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>nullFlag</name> <operator>=</operator> <ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Cleared</name><operator>)</operator></expr> </then><else>: <expr><name>MEM_Null</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOut</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>nullFlag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cnt</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SoftNull P1 * * * *
** Synopsis: r[P1]=NULL
**
** Set register P1 to have the value NULL as seen by the OP_MakeRecord
** instruction, but do not free any string or blob memory associated with
** the register, so that if the value was a string or blob that was
** previously copied using OP_SCopy, the copies will continue to be valid.
*/</comment>
<case>case <expr><name>OP_SoftNull</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>~</operator><operator>(</operator><name>MEM_Undefined</name><operator>|</operator><name>MEM_AffMask</name><operator>)</operator><operator>)</operator><operator>|</operator><name>MEM_Null</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Blob P1 P2 * P4 *
** Synopsis: r[P2]=P4 (len=P1)
**
** P4 points to a blob of data P1 bytes long.  Store this
** blob in register P2.  If P4 is a NULL pointer, then construct
** a zero-filled blob that is P1 bytes long in P2.
*/</comment>
<case>case <expr><name>OP_Blob</name></expr>:</case> <block>{<block_content>                <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>&lt;=</operator> <name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetZeroBlob</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Variable P1 P2 * P4 *
** Synopsis: r[P2]=parameter(P1,P4)
**
** Transfer the values of bound parameter P1 into register P2
**
** If the parameter is named, then its name appears in P4.
** The P4 value is used by sqlite3_bind_parameter_name().
*/</comment>
<case>case <expr><name>OP_Variable</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pVar</name></decl>;</decl_stmt>       <comment type="block">/* Value being transferred */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><call><name>sqlite3VListNumToName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVList</name></name></expr></argument>,<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVar</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Static</name><operator>|</operator><name>MEM_FromBind</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Move P1 P2 P3 * *
** Synopsis: r[P2@P3]=r[P1@P3]
**
** Move the P3 values in register P1..P1+P3-1 over into
** registers P2..P2+P3-1.  Registers P1..P1+P3-1 are
** left holding a NULL.  It is an error for register ranges
** P1..P1+P3-1 and P2..P2+P3-1 to overlap.  It is an error
** for P3 to be less than 1.
*/</comment>
<case>case <expr><name>OP_Move</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>           <comment type="block">/* Number of registers left to copy */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>          <comment type="block">/* Register to copy from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>          <comment type="block">/* Register to copy to */</comment>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>p2</name> <operator>||</operator> <name>p2</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>p1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name><operator>&lt;=</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name><operator>&lt;=</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pScopyFrom</name><operator>==</operator><name>pIn1</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pScopyFrom</name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p2</name><operator>++</operator></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><operator>--</operator><name>n</name></expr> )</condition>;</do>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Copy P1 P2 P3 * P5
** Synopsis: r[P2@P3+1]=r[P1@P3+1]
**
** Make a copy of registers P1..P1+P3 into registers P2..P2+P3.
**
** If the 0x0002 bit of P5 is set then also clear the MEM_Subtype flag in the
** destination.  The 0x0001 bit of P5 indicates that this Copy opcode cannot
** be merged.  The 0x0001 bit is used by the query planner and does not
** come into play during query execution.
**
** This instruction makes a deep copy of the value.  A duplicate
** is made of any string or blob constant.  See also OP_SCopy.
*/</comment>
<case>case <expr><name>OP_Copy</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name><operator>!=</operator><name>pIn1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Subtype</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>  <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <literal type="number">0x0002</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Subtype</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>n</name><operator>--</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pOut</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SCopy P1 P2 * * *
** Synopsis: r[P2]=r[P1]
**
** Make a shallow copy of register P1 into register P2.
**
** This instruction makes a shallow copy of the value.  If the value
** is a string or blob, then the copy is only a pointer to the
** original and hence if the original changes so will the copy.
** Worse, if the original is deallocated, the copy becomes invalid.
** Thus the program must guarantee that the original will not change
** during the lifetime of the copy.  Use OP_Copy to make a complete
** copy.
*/</comment>
<case>case <expr><name>OP_SCopy</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name><operator>!=</operator><name>pIn1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <name>pIn1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>mScopyFlags</name></name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IntCopy P1 P2 * * *
** Synopsis: r[P2]=r[P1]
**
** Transfer the integer value held in register P1 into register P2.
**
** This is an optimized version of SCopy that works only for integer
** values.
*/</comment>
<case>case <expr><name>OP_IntCopy</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: FkCheck * * * * *
**
** Halt with an SQLITE_CONSTRAINT error if there are any unresolved
** foreign key constraint violations.  If there are no foreign key
** constraint violations, this is a no-op.
**
** FK constraint violations are also checked when the prepared statement
** exits.  This opcode is used to raise foreign key constraint errors prior
** to returning results such as a row change count or the result of a 
** RETURNING clause.
*/</comment>
<case>case <expr><name>OP_FkCheck</name></expr>:</case> <block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ResultRow P1 P2 * * *
** Synopsis: output=r[P1@P2]
**
** The registers P1 through P1+P2-1 contain a single row of
** results. This opcode causes the sqlite3_step() call to terminate
** with an SQLITE_ROW return code and it sets up the sqlite3_stmt
** structure to provide access to the r(P1)..r(P1+P2-1) values as
** the result row.
*/</comment>
<case>case <expr><name>OP_ResultRow</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator><operator>|</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The registers in the result will not be used again when the
      ** prepared statement restarts.  This is because sqlite3_column()
      ** APIs might have caused type conversions of made other changes to
      ** the register values.  Therefore, we can go ahead and break any
      ** OP_SCopy dependencies. */</comment>
      <expr_stmt><expr><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pScopyFrom</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <name>SQLITE_TRACE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xV2</name></name><argument_list>(<argument><expr><name>SQLITE_TRACE_ROW</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_return</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Concat P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]+r[P1]
**
** Add the text in register P1 onto the end of the text in
** register P2 and store the result in register P3.
** If either the P1 or P2 text are NULL then store NULL in P3.
**
**   P3 = P2 || P1
**
** It is illegal for P1 and P3 to be the same register. Sometimes,
** if P3 is the same register as P2, the implementation is able
** to avoid a memcpy().
*/</comment>
<case>case <expr><name>OP_Concat</name></expr>:</case> <block>{<block_content>           <comment type="block">/* same as TK_CONCAT, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name></decl>;</decl_stmt>          <comment type="block">/* Total size of the output string or blob */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags1</name></decl>;</decl_stmt>         <comment type="block">/* Initial flags for P1 */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags2</name></decl>;</decl_stmt>         <comment type="block">/* Initial flags for P2 */</comment>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pOut</name><operator>==</operator><name>pIn2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name><operator>!=</operator><name>pOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags1</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags1</name> <operator>&amp;</operator> <name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>|</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>flags1</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_Str</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>flags1</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_Str</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>flags2</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags2</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>flags2</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_Str</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags2</name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>flags2</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_Str</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pOut</name><operator>==</operator><name>pIn2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>!=</operator><name>pIn2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>flags2</name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags1</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>encoding</name><operator>&gt;</operator><name>SQLITE_UTF8</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nByte</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Add P1 P2 P3 * *
** Synopsis: r[P3]=r[P1]+r[P2]
**
** Add the value in register P1 to the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Multiply P1 P2 P3 * *
** Synopsis: r[P3]=r[P1]*r[P2]
**
**
** Multiply the value in register P1 by the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Subtract P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]-r[P1]
**
** Subtract the value in register P1 from the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Divide P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]/r[P1]
**
** Divide the value in register P1 by the value in register P2
** and store the result in register P3 (P3=P2/P1). If the value in 
** register P1 is zero, then the result is NULL. If either input is 
** NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Remainder P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]%r[P1]
**
** Compute the remainder after integer register P2 is divided by 
** register P1 and store the result in register P3. 
** If the value in register P1 is zero the result is NULL.
** If either operand is NULL, the result is NULL.
*/</comment>
<case>case <expr><name>OP_Add</name></expr>:</case>                   <comment type="block">/* same as TK_PLUS, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Subtract</name></expr>:</case>              <comment type="block">/* same as TK_MINUS, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Multiply</name></expr>:</case>              <comment type="block">/* same as TK_STAR, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Divide</name></expr>:</case>                <comment type="block">/* same as TK_SLASH, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Remainder</name></expr>:</case> <block>{<block_content>           <comment type="block">/* same as TK_REM, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>type1</name></decl>;</decl_stmt>      <comment type="block">/* Numeric type of left operand */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>type2</name></decl>;</decl_stmt>      <comment type="block">/* Numeric type of right operand */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name></decl>;</decl_stmt>         <comment type="block">/* Integer value of left operand */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iB</name></decl>;</decl_stmt>         <comment type="block">/* Integer value of right operand */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rA</name></decl>;</decl_stmt>      <comment type="block">/* Real value of left operand */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rB</name></decl>;</decl_stmt>      <comment type="block">/* Real value of right operand */</comment>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>type1</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>type2</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>type1</name> <operator>&amp;</operator> <name>type2</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<label><name>int_math</name>:</label>
    <expr_stmt><expr><name>iA</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iB</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Add</name></expr>:</case>       <if_stmt><if>if<condition>( <expr><call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iB</name></expr></argument>,<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>  <break>break;</break>
      <case>case <expr><name>OP_Subtract</name></expr>:</case>  <if_stmt><if>if<condition>( <expr><call><name>sqlite3SubInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iB</name></expr></argument>,<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>  <break>break;</break>
      <case>case <expr><name>OP_Multiply</name></expr>:</case>  <if_stmt><if>if<condition>( <expr><call><name>sqlite3MulInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iB</name></expr></argument>,<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>  <break>break;</break>
      <case>case <expr><name>OP_Divide</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iB</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iB</name> <operator>/=</operator> <name>iA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iB</name> <operator>%=</operator> <name>iA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><operator>(</operator><name>type1</name> <operator>|</operator> <name>type2</name><operator>)</operator> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>arithmetic_result_is_null</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>type1</name> <operator>=</operator> <call><name>numericType</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <call><name>numericType</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>type1</name> <operator>&amp;</operator> <name>type2</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_math</name>;</goto></block_content></block></if></if_stmt>
<label><name>fp_math</name>:</label>
    <expr_stmt><expr><name>rA</name> <operator>=</operator> <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rB</name> <operator>=</operator> <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Add</name></expr>:</case>         <expr_stmt><expr><name>rB</name> <operator>+=</operator> <name>rA</name></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>OP_Subtract</name></expr>:</case>    <expr_stmt><expr><name>rB</name> <operator>-=</operator> <name>rA</name></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>OP_Multiply</name></expr>:</case>    <expr_stmt><expr><name>rB</name> <operator>*=</operator> <name>rA</name></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>OP_Divide</name></expr>:</case> <block>{<block_content>
        <comment type="block">/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */</comment>
        <if_stmt><if>if<condition>( <expr><name>rA</name><operator>==</operator><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rB</name> <operator>/=</operator> <name>rA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>iA</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iB</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rB</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>iB</name> <operator>%</operator> <name>iA</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>rB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>rB</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>arithmetic_result_is_null</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>rB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>

<label><name>arithmetic_result_is_null</name>:</label>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: CollSeq P1 * * P4
**
** P4 is a pointer to a CollSeq object. If the next call to a user function
** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will
** be returned. This is used by the built-in min(), max() and nullif()
** functions.
**
** If P1 is not zero, then it is a register that a subsequent min() or
** max() aggregate will set to 1 if the current row is not the minimum or
** maximum.  The P1 register is initialized to 0 by this instruction.
**
** The interface used by the implementation of the aforementioned functions
** to retrieve the collation sequence set by this opcode is not available
** publicly.  Only built-in functions have access to this feature.
*/</comment>
<case>case <expr><name>OP_CollSeq</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: BitAnd P1 P2 P3 * *
** Synopsis: r[P3]=r[P1]&amp;r[P2]
**
** Take the bit-wise AND of the values in register P1 and P2 and
** store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: BitOr P1 P2 P3 * *
** Synopsis: r[P3]=r[P1]|r[P2]
**
** Take the bit-wise OR of the values in register P1 and P2 and
** store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: ShiftLeft P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]&lt;&lt;r[P1]
**
** Shift the integer value in register P2 to the left by the
** number of bits specified by the integer in register P1.
** Store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: ShiftRight P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]&gt;&gt;r[P1]
**
** Shift the integer value in register P2 to the right by the
** number of bits specified by the integer in register P1.
** Store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<case>case <expr><name>OP_BitAnd</name></expr>:</case>                 <comment type="block">/* same as TK_BITAND, in1, in2, out3 */</comment>
<case>case <expr><name>OP_BitOr</name></expr>:</case>                  <comment type="block">/* same as TK_BITOR, in1, in2, out3 */</comment>
<case>case <expr><name>OP_ShiftLeft</name></expr>:</case>              <comment type="block">/* same as TK_LSHIFT, in1, in2, out3 */</comment>
<case>case <expr><name>OP_ShiftRight</name></expr>:</case> <block>{<block_content>           <comment type="block">/* same as TK_RSHIFT, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>uA</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iA</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iB</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>OP_BitAnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iA</name> <operator>&amp;=</operator> <name>iB</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>OP_BitOr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iA</name> <operator>|=</operator> <name>iB</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iB</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_ShiftRight</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_ShiftLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If shifting by a negative amount, shift in the other direction */</comment>
    <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_ShiftRight</name><operator>==</operator><name>OP_ShiftLeft</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>OP_ShiftLeft</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iB</name> <operator>=</operator> <ternary><condition><expr><name>iB</name><operator>&gt;</operator><operator>(</operator><operator>-</operator><literal type="number">64</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>iB</name></expr> </then><else>: <expr><literal type="number">64</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&gt;=</operator><literal type="number">64</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iA</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iA</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_ShiftLeft</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iA</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uA</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>OP_ShiftLeft</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>uA</name> <operator>&lt;&lt;=</operator> <name>iB</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>uA</name> <operator>&gt;&gt;=</operator> <name>iB</name></expr>;</expr_stmt>
        <comment type="block">/* Sign-extend on a right shift of a negative number */</comment>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>uA</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">0xffffffff</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>|</operator><literal type="number">0xffffffff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal><operator>-</operator><name>iB</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uA</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iA</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iA</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AddImm  P1 P2 * * *
** Synopsis: r[P1]=r[P1]+P2
** 
** Add the constant P2 to the value in register P1.
** The result is always an integer.
**
** To force any register to be an integer, just add 0.
*/</comment>
<case>case <expr><name>OP_AddImm</name></expr>:</case> <block>{<block_content>            <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: MustBeInt P1 P2 * * *
** 
** Force the value in register P1 to be an integer.  If the value
** in P1 is not an integer and cannot be converted into an integer
** without data loss, then jump immediately to P2, or if P2==0
** raise an SQLITE_MISMATCH exception.
*/</comment>
<case>case <expr><name>OP_MustBeInt</name></expr>:</case> <block>{<block_content>            <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISMATCH</name></expr>;</expr_stmt>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <goto>goto <name>jump_to_p2</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/* Opcode: RealAffinity P1 * * * *
**
** If register P1 holds an integer convert it to a real value.
**
** This opcode is used when extracting information from a column that
** has REAL affinity.  Such column values may still be stored as
** integers, for space efficiency, but after extraction we want them
** to have only a real value.
*/</comment>
<case>case <expr><name>OP_RealAffinity</name></expr>:</case> <block>{<block_content>                  <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRealify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
<comment type="block">/* Opcode: Cast P1 P2 * * *
** Synopsis: affinity(r[P1])
**
** Force the value in register P1 to be the type defined by P2.
** 
** &lt;ul&gt;
** &lt;li&gt; P2=='A' &amp;rarr; BLOB
** &lt;li&gt; P2=='B' &amp;rarr; TEXT
** &lt;li&gt; P2=='C' &amp;rarr; NUMERIC
** &lt;li&gt; P2=='D' &amp;rarr; INTEGER
** &lt;li&gt; P2=='E' &amp;rarr; REAL
** &lt;/ul&gt;
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
<case>case <expr><name>OP_Cast</name></expr>:</case> <block>{<block_content>                  <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><name>SQLITE_AFF_BLOB</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><name>SQLITE_AFF_REAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemCast</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>

<comment type="block">/* Opcode: Eq P1 P2 P3 P4 P5
** Synopsis: IF r[P3]==r[P1]
**
** Compare the values in register P1 and P3.  If reg(P3)==reg(P1) then
** jump to address P2. 
**
** The SQLITE_AFF_MASK portion of P5 must be an affinity character -
** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made 
** to coerce both inputs according to this affinity before the
** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric
** affinity is used. Note that the affinity conversions are stored
** back into the input registers P1 and P3.  So this opcode can cause
** persistent changes to registers P1 and P3.
**
** Once any conversions have taken place, and neither value is NULL, 
** the values are compared. If both values are blobs then memcmp() is
** used to determine the results of the comparison.  If both values
** are text, then the appropriate collating function specified in
** P4 is used to do the comparison.  If P4 is not specified then
** memcmp() is used to compare text string.  If both values are
** numeric, then a numeric comparison is used. If the two values
** are of different types, then numbers are considered less than
** strings and strings are considered less than blobs.
**
** If SQLITE_NULLEQ is set in P5 then the result of comparison is always either
** true or false and is never NULL.  If both operands are NULL then the result
** of comparison is true.  If either operand is NULL then the result is false.
** If neither operand is NULL the result is the same as it would be if
** the SQLITE_NULLEQ flag were omitted from P5.
**
** This opcode saves the result of comparison for use by the new
** OP_Jump opcode.
*/</comment>
<comment type="block">/* Opcode: Ne P1 P2 P3 P4 P5
** Synopsis: IF r[P3]!=r[P1]
**
** This works just like the Eq opcode except that the jump is taken if
** the operands in registers P1 and P3 are not equal.  See the Eq opcode for
** additional information.
*/</comment>
<comment type="block">/* Opcode: Lt P1 P2 P3 P4 P5
** Synopsis: IF r[P3]&lt;r[P1]
**
** Compare the values in register P1 and P3.  If reg(P3)&lt;reg(P1) then
** jump to address P2.
**
** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or
** reg(P3) is NULL then the take the jump.  If the SQLITE_JUMPIFNULL 
** bit is clear then fall through if either operand is NULL.
**
** The SQLITE_AFF_MASK portion of P5 must be an affinity character -
** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made 
** to coerce both inputs according to this affinity before the
** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric
** affinity is used. Note that the affinity conversions are stored
** back into the input registers P1 and P3.  So this opcode can cause
** persistent changes to registers P1 and P3.
**
** Once any conversions have taken place, and neither value is NULL, 
** the values are compared. If both values are blobs then memcmp() is
** used to determine the results of the comparison.  If both values
** are text, then the appropriate collating function specified in
** P4 is  used to do the comparison.  If P4 is not specified then
** memcmp() is used to compare text string.  If both values are
** numeric, then a numeric comparison is used. If the two values
** are of different types, then numbers are considered less than
** strings and strings are considered less than blobs.
**
** This opcode saves the result of comparison for use by the new
** OP_Jump opcode.
*/</comment>
<comment type="block">/* Opcode: Le P1 P2 P3 P4 P5
** Synopsis: IF r[P3]&lt;=r[P1]
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is less than or equal to the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Gt P1 P2 P3 P4 P5
** Synopsis: IF r[P3]&gt;r[P1]
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is greater than the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Ge P1 P2 P3 P4 P5
** Synopsis: IF r[P3]&gt;=r[P1]
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is greater than or equal to the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<case>case <expr><name>OP_Eq</name></expr>:</case>               <comment type="block">/* same as TK_EQ, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Ne</name></expr>:</case>               <comment type="block">/* same as TK_NE, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Lt</name></expr>:</case>               <comment type="block">/* same as TK_LT, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Le</name></expr>:</case>               <comment type="block">/* same as TK_LE, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Gt</name></expr>:</case>               <comment type="block">/* same as TK_GT, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Ge</name></expr>:</case> <block>{<block_content>             <comment type="block">/* same as TK_GE, jump, in1, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>res2</name></decl>;</decl_stmt>      <comment type="block">/* Result of the comparison of pIn1 against pIn3 */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>      <comment type="block">/* Affinity to use for comparison */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags1</name></decl>;</decl_stmt>         <comment type="block">/* Copy of initial value of pIn1-&gt;flags */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags3</name></decl>;</decl_stmt>         <comment type="block">/* Copy of initial value of pIn3-&gt;flags */</comment>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags1</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags3</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>flags3</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_AFF_MASK</name><operator>)</operator><operator>!=</operator><name>SQLITE_AFF_TEXT</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Common case of comparison of two integers */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&gt;</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3aGTb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>jump_to_p2</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&lt;</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3aLTb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>jump_to_p2</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3aEQb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>jump_to_p2</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>|</operator> <name>flags3</name><operator>)</operator><operator>&amp;</operator><name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* One or both operands are NULL */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If SQLITE_NULLEQ is set (which will only happen if the operator is
      ** OP_Eq or OP_Ne) then take the jump or not depending on whether
      ** or not both operands are null.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Cleared</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_JUMPIFNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_JUMPIFNULL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name><operator>&amp;</operator><name>flags3</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>flags3</name><operator>&amp;</operator><name>MEM_Cleared</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Operands are equal */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Operands are not equal */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* SQLITE_NULLEQ is clear and at least one operand is NULL,
      ** then the result is always NULL.
      ** The jump is taken if the SQLITE_JUMPIFNULL bit is set.
      */</comment>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_JUMPIFNULL</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>jump_to_p2</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* Operands are not equal */</comment>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Neither operand is NULL and we couldn't do the special high-speed
    ** integer comparison case.  So do a general-case comparison. */</comment>
    <expr_stmt><expr><name>affinity</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_AFF_MASK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>|</operator> <name>flags3</name><operator>)</operator><operator>&amp;</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags3</name><operator>==</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>flags3</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags3</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags1</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>flags1</name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags1</name> <operator>=</operator> <operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_TypeMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_TypeMask</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pIn1</name><operator>==</operator><name>pIn3</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags3</name> <operator>=</operator> <name>flags1</name> <operator>|</operator> <name>MEM_Str</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags3</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>flags3</name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags3</name> <operator>=</operator> <operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_TypeMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_TypeMask</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_COLLSEQ</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* At this point, res is negative, zero, or positive if reg[P1] is
  ** less than, equal to, or greater than reg[P3], respectively.  Compute
  ** the answer to this operator in res2, depending on what the comparison
  ** operator actually is.  The next block of code depends on the fact
  ** that the 6 comparison operators are consecutive integers in this
  ** order:  NE, EQ, GT, LE, LT, GE */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_Eq</name><operator>==</operator><name>OP_Ne</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_Gt</name><operator>==</operator><name>OP_Ne</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_Le</name><operator>==</operator><name>OP_Ne</name><operator>+</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_Lt</name><operator>==</operator><name>OP_Ne</name><operator>+</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_Ge</name><operator>==</operator><name>OP_Ne</name><operator>+</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res2</name> <operator>=</operator> <name><name>sqlite3aLTb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res2</name> <operator>=</operator> <name><name>sqlite3aEQb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>res2</name> <operator>=</operator> <name><name>sqlite3aGTb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

  <comment type="block">/* Undo any changes made by applyAffinity() to the input registers. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags3</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags1</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res2</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res2</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ElseEq * P2 * * *
**
** This opcode must follow an OP_Lt or OP_Gt comparison operator.  There
** can be zero or more OP_ReleaseReg opcodes intervening, but no other
** opcodes are allowed to occur between this instruction and the previous
** OP_Lt or OP_Gt. 
**
** If result of an OP_Eq comparison on the same two operands as the
** prior OP_Lt or OP_Gt would have been true, then jump to P2.
** If the result of an OP_Eq comparison on the two previous
** operands would have been false or NULL, then fall through.
*/</comment>
<case>case <expr><name>OP_ElseEq</name></expr>:</case> <block>{<block_content>       <comment type="block">/* same as TK_ESCAPE, jump */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Verify the preconditions of this opcode - that it follows an OP_Lt or
  ** OP_Gt with zero or more intervening OP_ReleaseReg opcodes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iAddr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>iAddr</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iAddr</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><name>iAddr</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_ReleaseReg</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aOp</name><index>[<expr><name>iAddr</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Lt</name> <operator>||</operator> <name><name>aOp</name><index>[<expr><name>iAddr</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>iCompare</name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCompare</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: Permutation * * * P4 *
**
** Set the permutation used by the OP_Compare operator in the next
** instruction.  The permutation is stored in the P4 operand.
**
** The permutation is only valid for the next opcode which must be
** an OP_Compare that has the OPFLAG_PERMUTE bit set in P5.
**
** The first integer in the P4 integer array is the length of the array
** and does not become part of the permutation.
*/</comment>
<case>case <expr><name>OP_Permutation</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INTARRAY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Compare</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>&amp;</operator> <name>OPFLAG_PERMUTE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Compare P1 P2 P3 P4 P5
** Synopsis: r[P1@P3] &lt;-&gt; r[P2@P3]
**
** Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this
** vector "A") and in reg(P2)..reg(P2+P3-1) ("B").  Save the result of
** the comparison for use by the next OP_Jump instruct.
**
** If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is
** determined by the most recent OP_Permutation operator.  If the
** OPFLAG_PERMUTE bit is clear, then register are compared in sequential
** order.
**
** P4 is a KeyInfo structure that defines collating sequences and sort
** orders for the comparison.  The permutation applies to registers
** only.  The KeyInfo elements are used sequentially.
**
** The comparison is a sort comparison, so NULLs compare equal,
** NULLs are less than numbers, numbers are less than strings,
** and strings are less than blobs.
**
** This opcode must be immediately followed by an OP_Jump opcode.
*/</comment>
<case>case <expr><name>OP_Compare</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>    <comment type="block">/* Collating sequence to use on this term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRev</name></decl>;</decl_stmt>          <comment type="block">/* True for DESCENDING sort order */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aPermute</name></decl>;</decl_stmt>     <comment type="block">/* The permutation */</comment>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_PERMUTE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aPermute</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&gt;</operator><name>aOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Permutation</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p4type</name><operator>==</operator><name>P4_INTARRAY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aPermute</name> <operator>=</operator> <name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>ai</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aPermute</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>aPermute</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>aPermute</name><index>[<expr><name>k</name></expr>]</index></name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>mx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mx</name> <operator>=</operator> <name><name>aPermute</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>+</operator><name>mx</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>+</operator><name>mx</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <ternary><condition><expr><name>aPermute</name></expr> ?</condition><then> <expr><name><name>aPermute</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>(</operator><name>u32</name><operator>)</operator><name>i</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p1</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p2</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCompare</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator> 
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <operator>-</operator><name>iCompare</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bRev</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <operator>-</operator><name>iCompare</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Jump</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Jump P1 P2 P3 * *
**
** Jump to the instruction at address P1, P2, or P3 depending on whether
** in the most recent OP_Compare instruction the P1 vector was less than
** equal to, or greater than the P2 vector, respectively.
**
** This opcode must immediately follow an OP_Compare opcode.
*/</comment>
<case>case <expr><name>OP_Jump</name></expr>:</case> <block>{<block_content>             <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&gt;</operator><name>aOp</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Compare</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCompare</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iCompare</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: And P1 P2 P3 * *
** Synopsis: r[P3]=(r[P1] &amp;&amp; r[P2])
**
** Take the logical AND of the values in registers P1 and P2 and
** write the result into register P3.
**
** If either P1 or P2 is 0 (false) then the result is 0 even if
** the other input is NULL.  A NULL and true or two NULLs give
** a NULL output.
*/</comment>
<comment type="block">/* Opcode: Or P1 P2 P3 * *
** Synopsis: r[P3]=(r[P1] || r[P2])
**
** Take the logical OR of the values in register P1 and P2 and
** store the answer in register P3.
**
** If either P1 or P2 is nonzero (true) then the result is 1 (true)
** even if the other input is NULL.  A NULL and false or two NULLs
** give a NULL output.
*/</comment>
<case>case <expr><name>OP_And</name></expr>:</case>              <comment type="block">/* same as TK_AND, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Or</name></expr>:</case> <block>{<block_content>             <comment type="block">/* same as TK_OR, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>v1</name></decl>;</decl_stmt>    <comment type="block">/* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>v2</name></decl>;</decl_stmt>    <comment type="block">/* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */</comment>

  <expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>sqlite3VdbeBooleanValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>sqlite3VdbeBooleanValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_And</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>and_logic</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <name><name>and_logic</name><index>[<expr><name>v1</name><operator>*</operator><literal type="number">3</literal><operator>+</operator><name>v2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>or_logic</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <name><name>or_logic</name><index>[<expr><name>v1</name><operator>*</operator><literal type="number">3</literal><operator>+</operator><name>v2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v1</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IsTrue P1 P2 P3 P4 *
** Synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4
**
** This opcode implements the IS TRUE, IS FALSE, IS NOT TRUE, and
** IS NOT FALSE operators.
**
** Interpret the value in register P1 as a boolean value.  Store that
** boolean (a 0 or 1) in register P2.  Or if the value in register P1 is 
** NULL, then the P3 is stored in register P2.  Invert the answer if P4
** is 1.
**
** The logic is summarized like this:
**
** &lt;ul&gt; 
** &lt;li&gt; If P3==0 and P4==0  then  r[P2] := r[P1] IS TRUE
** &lt;li&gt; If P3==1 and P4==1  then  r[P2] := r[P1] IS FALSE
** &lt;li&gt; If P3==0 and P4==1  then  r[P2] := r[P1] IS NOT TRUE
** &lt;li&gt; If P3==1 and P4==0  then  r[P2] := r[P1] IS NOT FALSE
** &lt;/ul&gt;
*/</comment>
<case>case <expr><name>OP_IsTrue</name></expr>:</case> <block>{<block_content>               <comment type="block">/* in1, out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>,
      <argument><expr><call><name>sqlite3VdbeBooleanValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Not P1 P2 * * *
** Synopsis: r[P2]= !r[P1]
**
** Interpret the value in register P1 as a boolean value.  Store the
** boolean complement in register P2.  If the value in register P1 is 
** NULL, then a NULL is stored in P2.
*/</comment>
<case>case <expr><name>OP_Not</name></expr>:</case> <block>{<block_content>                <comment type="block">/* same as TK_NOT, in1, out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>!</operator><call><name>sqlite3VdbeBooleanValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: BitNot P1 P2 * * *
** Synopsis: r[P2]= ~r[P1]
**
** Interpret the content of register P1 as an integer.  Store the
** ones-complement of the P1 value into register P2.  If P1 holds
** a NULL then store a NULL in P2.
*/</comment>
<case>case <expr><name>OP_BitNot</name></expr>:</case> <block>{<block_content>             <comment type="block">/* same as TK_BITNOT, in1, out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>~</operator><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Once P1 P2 * * *
**
** Fall through to the next instruction the first time this opcode is
** encountered on each invocation of the byte-code program.  Jump to P2
** on the second and all subsequent encounters during the same invocation.
**
** Top-level programs determine first invocation by comparing the P1
** operand against the P1 operand on the OP_Init opcode at the beginning
** of the program.  If the P1 values differ, then fall through and make
** the P1 of this opcode equal to the P1 of OP_Init.  If P1 values are
** the same then take the jump.
**
** For subprograms, there is a bitmask in the VdbeFrame that determines
** whether or not the jump should be taken.  The bitmask is necessary
** because the self-altering code trick does not work for recursive
** triggers.
*/</comment>
<case>case <expr><name>OP_Once</name></expr>:</case> <block>{<block_content>             <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iAddr</name></decl>;</decl_stmt>                <comment type="block">/* Address of this instruction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Init</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iAddr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name><operator>-&gt;</operator><name>aOnce</name><index>[<expr><name>iAddr</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>iAddr</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name><operator>-&gt;</operator><name>aOnce</name><index>[<expr><name>iAddr</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>iAddr</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p1</name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: If P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is true.  The value
** is considered true if it is numeric and non-zero.  If the value
** in P1 is NULL then take the jump if and only if P3 is non-zero.
*/</comment>
<case>case <expr><name>OP_If</name></expr>:</case>  <block>{<block_content>               <comment type="block">/* jump, in1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3VdbeBooleanValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IfNot P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is False.  The value
** is considered false if it has a numeric value of zero.  If the value
** in P1 is NULL then take the jump if and only if P3 is non-zero.
*/</comment>
<case>case <expr><name>OP_IfNot</name></expr>:</case> <block>{<block_content>            <comment type="block">/* jump, in1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>!</operator><call><name>sqlite3VdbeBooleanValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>!</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IsNull P1 P2 * * *
** Synopsis: if r[P1]==NULL goto P2
**
** Jump to P2 if the value in register P1 is NULL.
*/</comment>
<case>case <expr><name>OP_IsNull</name></expr>:</case> <block>{<block_content>            <comment type="block">/* same as TK_ISNULL, jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IsType P1 P2 P3 P4 P5
** Synopsis: if typeof(P1.P3) in P5 goto P2
**
** Jump to P2 if the type of a column in a btree is one of the types specified
** by the P5 bitmask.
**
** P1 is normally a cursor on a btree for which the row decode cache is
** valid through at least column P3.  In other words, there should have been
** a prior OP_Column for column P3 or greater.  If the cursor is not valid,
** then this opcode might give spurious results.
** The the btree row has fewer than P3 columns, then use P4 as the
** datatype.
**
** If P1 is -1, then P3 is a register number and the datatype is taken
** from the value in that register.
**
** P5 is a bitmask of data types.  SQLITE_INTEGER is the least significant
** (0x01) bit. SQLITE_FLOAT is the 0x02 bit. SQLITE_TEXT is 0x04.
** SQLITE_BLOB is 0x08.  SQLITE_NULL is 0x10.
**
** Take the jump to address P2 if and only if the datatype of the
** value determined by P1 and P3 corresponds to one of the bits in the
** P5 bitmask.
**
*/</comment>
<case>case <expr><name>OP_IsType</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>typeMask</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>serialType</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>serialType</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serialType</name><operator>&gt;=</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>serialType</name><operator>&amp;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>typeMask</name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>   <comment type="block">/* SQLITE_TEXT */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>typeMask</name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>   <comment type="block">/* SQLITE_BLOB */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>aMask</name><index>[]</index></name> <init>= <expr><block>{
           <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x2</literal></expr>,
           <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x10</literal></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">6</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">7</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serialType</name><operator>==</operator><literal type="number">11</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typeMask</name> <operator>=</operator> <name><name>aMask</name><index>[<expr><name>serialType</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>typeMask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x01</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x02</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x04</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x08</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typeMask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x01</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x02</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x04</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x08</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeMask</name><operator>==</operator><literal type="number">0x10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><operator>(</operator><name>typeMask</name> <operator>&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>typeMask</name> <operator>&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ZeroOrNull P1 P2 P3 * *
** Synopsis: r[P2] = 0 OR NULL
**
** If all both registers P1 and P3 are NOT NULL, then store a zero in
** register P2.  If either registers P1 or P3 are NULL then put
** a NULL in register P2.
*/</comment>
<case>case <expr><name>OP_ZeroOrNull</name></expr>:</case> <block>{<block_content>            <comment type="block">/* in1, in2, out2, in3 */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>aMem</name> <operator>+</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>aMem</name> <operator>+</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: NotNull P1 P2 * * *
** Synopsis: if r[P1]!=NULL goto P2
**
** Jump to P2 if the value in register P1 is not NULL.  
*/</comment>
<case>case <expr><name>OP_NotNull</name></expr>:</case> <block>{<block_content>            <comment type="block">/* same as TK_NOTNULL, jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IfNullRow P1 P2 P3 * *
** Synopsis: if P1.nullRow then r[P3]=NULL, goto P2
**
** Check the cursor P1 to see if it is currently pointing at a NULL row.
** If it is, then set register P3 to NULL and jump immediately to P2.
** If P1 is not on a NULL row, then fall through without making any
** changes.
**
** If P1 is not an open cursor, then this opcode is a no-op.
*/</comment>
<case>case <expr><name>OP_IfNullRow</name></expr>:</case> <block>{<block_content>         <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>aMem</name> <operator>+</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifdef>
<comment type="block">/* Opcode: Offset P1 P2 P3 * *
** Synopsis: r[P3] = sqlite_offset(P1)
**
** Store in register r[P3] the byte offset into the database file that is the
** start of the payload for the record at which that cursor P1 is currently
** pointing.
**
** P2 is the column number for the argument to the sqlite_offset() function.
** This opcode does not use P2 itself, but the P2 value is used by the
** code generator.  The P1, P2, and P3 operands to this opcode are the
** same as for OP_Column.
**
** This opcode is only available if SQLite is compiled with the
** -DSQLITE_ENABLE_OFFSET_SQL_FUNC option.
*/</comment>
<case>case <expr><name>OP_Offset</name></expr>:</case> <block>{<block_content>          <comment type="block">/* out3 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>    <comment type="block">/* The VDBE cursor */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pC</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_BTREE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeFinishMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeEof</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><call><name>sqlite3BtreeOffset</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_OFFSET_SQL_FUNC */</comment>

<comment type="block">/* Opcode: Column P1 P2 P3 P4 P5
** Synopsis: r[P3]=PX cursor P1 column P2
**
** Interpret the data that cursor P1 points to as a structure built using
** the MakeRecord instruction.  (See the MakeRecord opcode for additional
** information about the format of the data.)  Extract the P2-th column
** from this record.  If there are less than (P2+1) 
** values in the record, extract a NULL.
**
** The value extracted is stored in register P3.
**
** If the record contains fewer than P2 fields, then extract a NULL.  Or,
** if the P4 argument is a P4_MEM use the value of the P4 argument as
** the result.
**
** If the OPFLAG_LENGTHARG bit is set in P5 then the result is guaranteed
** to only be used by the length() function or the equivalent.  The content
** of large blobs is not loaded, thus saving CPU cycles.  If the
** OPFLAG_TYPEOFARG bit is set then the result will only be used by the
** typeof() function or the IS NULL or IS NOT NULL operators or the
** equivalent.  In this case, all content loading can be omitted.
*/</comment>
<case>case <expr><name>OP_Column</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>p2</name></decl>;</decl_stmt>            <comment type="block">/* column number to retrieve */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>    <comment type="block">/* The VDBE cursor */</comment>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>   <comment type="block">/* The B-Tree cursor corresponding to pC */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aOffset</name></decl>;</decl_stmt>      <comment type="block">/* aOffset[i] is offset to start of data for i-th column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>           <comment type="block">/* The length of the serialized data for the column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pDest</name></decl>;</decl_stmt>        <comment type="block">/* Where to write the extracted value */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>sMem</name></decl>;</decl_stmt>          <comment type="block">/* For storing the record being decoded */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>   <comment type="block">/* Part of the record being decoded */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zHdr</name></decl>;</decl_stmt>    <comment type="block">/* Next unparsed byte of the header */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zEndHdr</name></decl>;</decl_stmt> <comment type="block">/* Pointer to first byte after the header */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>offset64</name></decl>;</decl_stmt>      <comment type="block">/* 64-bit offset */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>t</name></decl>;</decl_stmt>             <comment type="block">/* A type code from the record header */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pReg</name></decl>;</decl_stmt>         <comment type="block">/* PseudoTable input register */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>

<label><name>op_column_restart</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pC</name><operator>-&gt;</operator><name>nField</name></name>
       <operator>||</operator> <operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_PSEUDO</name> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOffset</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aOffset</name><operator>==</operator><name><name>pC</name><operator>-&gt;</operator><name>aType</name></name><operator>+</operator><name><name>pC</name><operator>-&gt;</operator><name>nField</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_PSEUDO</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name></expr> )</condition><block>{<block_content>                <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_PSEUDO</name> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* For the special case of as pseudo-cursor, the seekResult field
        ** identifies the register that holds the record */</comment>
        <expr_stmt><expr><name>pReg</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pReg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <name><name>pReg</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pReg</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pDest</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>op_column_out</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>iMap</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>aAltMap</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iMap</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>aAltMap</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>p2</name></expr>]</index></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr>  )</condition><block>{<block_content>
          <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pAltCursor</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>iMap</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>op_column_restart</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeFinishMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeHandleMovedCursor</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
        <goto>goto <name>op_column_restart</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <call><name>sqlite3BtreePayloadFetch</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name><operator>&lt;=</operator><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Maximum page size is 64KiB */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aRow</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name> <operator>=</operator> <call><name>sqlite3GetVarint32</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name><operator>&lt;</operator><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>      <comment type="block">/*OPTIMIZATION-IF-FALSE*/</comment>
      <comment type="block">/* pC-&gt;aRow does not have to hold the entire row, but it does at least
      ** need to cover the header of the record.  If pC-&gt;aRow does not contain
      ** the complete header, then set it to zero, forcing the header to be
      ** dynamically allocated. */</comment>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* Make sure a corrupt database has not given us an oversize header.
      ** Do this now to avoid an oversize memory allocation.
      **
      ** Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte
      ** types use so much data space that there can only be 4096 and 32 of
      ** them, respectively.  So the maximum header length results from a
      ** 3-byte type for each of the maximum of 32768 columns plus three
      ** extra bytes for the header length itself.  32768*3 + 3 = 98307.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">98307</literal> <operator>||</operator> <name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name></expr> )</condition><block>{<block_content>
        <goto>goto <name>op_column_corrupt</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* This is an optimization.  By skipping over the first few tests
      ** (ex: pC-&gt;nHdrParsed&lt;=p2) in the next section, we achieve a
      ** measurable performance gain.
      **
      ** This branch is taken even if aOffset[0]==0.  Such a record is never
      ** generated by SQLite, and could be considered corruption, but we
      ** accept it for historical reasons.  When aOffset[0]==0, the code this
      ** branch jumps to reads past the end of the record, but never more
      ** than a few bytes.  Even if the record occurs at the end of the page
      ** content area, the "page header" comes after the page content and so
      ** this overread is harmless.  Similar overreads can occur for a corrupt
      ** database file.
      */</comment>
      <expr_stmt><expr><name>zData</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name><operator>&lt;=</operator><name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* Conditional skipped */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>op_column_read_header</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeHandleMovedCursor</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <goto>goto <name>op_column_restart</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure at least the first p2+1 entries of the header have been
  ** parsed and valid information is in aOffset[] and pC-&gt;aType[].
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name><operator>&lt;=</operator><name>p2</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is more header available for parsing in the record, try
    ** to extract additional fields up through the p2+1-th field 
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name><operator>&lt;</operator><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Make sure zData points to enough of the record to cover the header. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sMem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtreeZeroOffset</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>,<argument><expr><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zData</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>sMem</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zData</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
  
      <comment type="block">/* Fill in pC-&gt;aType[i] and aOffset[i] values through the p2-th field. */</comment>
    <label><name>op_column_read_header</name>:</label>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset64</name> <operator>=</operator> <name><name>aOffset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zHdr</name> <operator>=</operator> <name>zData</name> <operator>+</operator> <name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zEndHdr</name> <operator>=</operator> <name>zData</name> <operator>+</operator> <name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>zHdr</name><operator>&gt;=</operator><name>zEndHdr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name> <operator>=</operator> <name><name>zHdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zHdr</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>offset64</name> <operator>+=</operator> <call><name>sqlite3VdbeOneByteSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zHdr</name> <operator>+=</operator> <call><name>sqlite3GetVarint32</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>offset64</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>aOffset</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>offset64</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name>i</name><operator>&lt;=</operator><name>p2</name> <operator>&amp;&amp;</operator> <name>zHdr</name><operator>&lt;</operator><name>zEndHdr</name></expr> )</condition>;</do>

      <comment type="block">/* The record is corrupt if any of the following are true:
      ** (1) the bytes of the header extend past the declared header size
      ** (2) the entire header was used but not all data was used
      ** (3) the end of the data extends beyond the end of the record.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zHdr</name><operator>&gt;=</operator><name>zEndHdr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zHdr</name><operator>&gt;</operator><name>zEndHdr</name> <operator>||</operator> <name>offset64</name><operator>!=</operator><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name><operator>)</operator><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>offset64</name> <operator>&gt;</operator> <name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>zHdr</name> <operator>=</operator> <name>zEndHdr</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <goto>goto <name>op_column_corrupt</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>zHdr</name> <operator>-</operator> <name>zData</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If after trying to extract new entries from the header, nHdrParsed is
    ** still not up to p2, that means that the record has fewer than p2
    ** columns.  So the result will be either the default value or a NULL.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name><operator>&lt;=</operator><name>p2</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pDest</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_MEM</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pMem</name></name></expr></argument>, <argument><expr><name>MEM_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <goto>goto <name>op_column_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Extract the content for the p2+1-th column.  Control can only
  ** reach this point if aOffset[p2], aOffset[p2+1], and pC-&gt;aType[p2] are
  ** all valid.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&lt;</operator><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>t</name><operator>==</operator><name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name><operator>&gt;=</operator><name><name>aOffset</name><index>[<expr><name>p2</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is the common case where the desired content fits on the original
    ** page - where the content is not on an overflow page */</comment>
    <expr_stmt><expr><name>zData</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>+</operator> <name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>t</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><name>zData</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* If the column value is a string, we need a persistent value, not
      ** a MEM_Ephem value.  This branch is a fast short-cut that is equivalent
      ** to calling sqlite3VdbeSerialGet() and sqlite3VdbeDeephemeralize().
      */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>aFlag</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>MEM_Blob</name></expr>, <expr><name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>len</name> <operator>=</operator> <operator>(</operator><name>t</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>&lt;</operator> <name>len</name><operator>+</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>too_big</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>aFlag</name><index>[<expr><name>t</name><operator>&amp;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
    <comment type="block">/* This branch happens only when content is on overflow pages */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_LENGTHARG</name><operator>|</operator><name>OPFLAG_TYPEOFARG</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>t</name><operator>&gt;=</operator><literal type="number">12</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>t</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_TYPEOFARG</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>len</name> <operator>=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* Content is irrelevant for
      **    1. the typeof() function,
      **    2. the length(X) function if X is a blob, and
      **    3. if the content length is zero.
      ** So we might as well use bogus content rather than reading
      ** content from disk. 
      **
      ** Although sqlite3VdbeSerialGet() may read at most 8 bytes from the
      ** buffer passed to it, debugging function VdbeMemPrettyPrint() may
      ** read more.  Use the global constant sqlite3CtypeMap[] as the array,
      ** as that array is 256 bytes long (plenty for VdbeMemPrettyPrint())
      ** and it begins with a bunch of zeros.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>sqlite3CtypeMap</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>too_big</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name><name>pDest</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Ephem</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>op_column_out</name>:</label>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

<label><name>op_column_corrupt</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></else></if_stmt>
</block_content>}</block>

<comment type="block">/* Opcode: TypeCheck P1 P2 P3 P4 *
** Synopsis: typecheck(r[P1@P2])
**
** Apply affinities to the range of P2 registers beginning with P1.
** Take the affinities from the Table object in P4.  If any value
** cannot be coerced into the correct type, then raise an error.
**
** This opcode is similar to OP_Affinity except that this opcode
** forces the register type to the Table column type.  This is used
** to implement "strict affinity".
**
** GENERATED ALWAYS AS ... STATIC columns are only checked if P3
** is zero.  When P3 is non-zero, no type checking occurs for
** static generated columns.  Virtual columns are computed at query time
** and so they are never checked.
**
** Preconditions:
**
** &lt;ul&gt;
** &lt;li&gt; P2 should be the number of non-virtual columns in the
**      table of P4.
** &lt;li&gt; Table P4 should be a STRICT table.
** &lt;/ul&gt;
**
** If any precondition is false, an assertion fault occurs.
*/</comment>
<case>case <expr><name>OP_TypeCheck</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>aCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_TABLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Strict</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <switch>switch<condition>( <expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eCType</name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>COLTYPE_BLOB</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>vdbe_type_error</name>;</goto></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>COLTYPE_INTEGER</name></expr>:</case>
        <case>case <expr><name>COLTYPE_INT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>vdbe_type_error</name>;</goto></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>COLTYPE_TEXT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>vdbe_type_error</name>;</goto></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>COLTYPE_REAL</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* When applying REAL affinity, if the result is still an MEM_Int
            ** that will fit in 6 bytes, then change the type to MEM_IntReal
            ** so that we keep the high-resolution integer value but know that
            ** the type really wants to be REAL. */</comment>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">140737488355328LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">140737488355327LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><operator>-</operator><literal type="number">140737488355328LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><operator>-</operator><literal type="number">140737488355329LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;=</operator><literal type="number">140737488355327LL</literal> <operator>&amp;&amp;</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><operator>-</operator><literal type="number">140737488355328LL</literal></expr>)</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_IntReal</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Int</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Int</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <goto>goto <name>vdbe_type_error</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <default>default:</default> <block>{<block_content>
          <comment type="block">/* COLTYPE_ANY.  Accept anything. */</comment>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pIn1</name><operator>-</operator><name>aMem</name><operator>)</operator></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name> <operator>==</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

<label><name>vdbe_type_error</name>:</label>
  <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot store %s value in %s column %s.%s"</literal></expr></argument>,
     <argument><expr><call><name>vdbeMemTypeName</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sqlite3StdType</name><index>[<expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eCType</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,
     <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT_DATATYPE</name></expr>;</expr_stmt>
  <goto>goto <name>abort_due_to_error</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Affinity P1 P2 * P4 *
** Synopsis: affinity(r[P1@P2])
**
** Apply affinities to a range of P2 registers starting with P1.
**
** P4 is a string that is P2 characters long. The N-th character of the
** string indicates the column affinity that should be used for the N-th
** memory cell in the range.
*/</comment>
<case>case <expr><name>OP_Affinity</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAffinity</name></decl>;</decl_stmt>   <comment type="block">/* The affinity to be applied */</comment>

  <expr_stmt><expr><name>zAffinity</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAffinity</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAffinity</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> <comment type="block">/*exit-by-break*/</comment> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name> <operator>&lt;=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>SQLITE_AFF_NONE</name> <operator>||</operator> <call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>SQLITE_AFF_REAL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* When applying REAL affinity, if the result is still an MEM_Int
      ** that will fit in 6 bytes, then change the type to MEM_IntReal
      ** so that we keep the high-resolution integer value but know that
      ** the type really wants to be REAL. */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">140737488355328LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">140737488355327LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><operator>-</operator><literal type="number">140737488355328LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><operator>-</operator><literal type="number">140737488355329LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;=</operator><literal type="number">140737488355327LL</literal> <operator>&amp;&amp;</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><operator>-</operator><literal type="number">140737488355328LL</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_IntReal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Int</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Int</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pIn1</name><operator>-</operator><name>aMem</name><operator>)</operator></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zAffinity</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: MakeRecord P1 P2 P3 P4 *
** Synopsis: r[P3]=mkrec(r[P1@P2])
**
** Convert P2 registers beginning with P1 into the [record format]
** use as a data record in a database table or as a key
** in an index.  The OP_Column opcode can decode the record later.
**
** P4 may be a string that is P2 characters long.  The N-th character of the
** string indicates the column affinity that should be used for the N-th
** field of the index key.
**
** The mapping from character to affinity is given by the SQLITE_AFF_
** macros defined in sqliteInt.h.
**
** If P4 is NULL then all index fields have the affinity BLOB.
**
** The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM
** compile-time option is enabled:
**
**   * If SQLITE_ENABLE_NULL_TRIM is enabled, then the P5 is the index
**     of the right-most table that can be null-trimmed.
**
**   * If SQLITE_ENABLE_NULL_TRIM is omitted, then P5 has the value
**     OPFLAG_NOCHNG_MAGIC if the OP_MakeRecord opcode is allowed to
**     accept no-change records with serial_type 10.  This value is
**     only used inside an assert() and does not affect the end result.
*/</comment>
<case>case <expr><name>OP_MakeRecord</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>             <comment type="block">/* The new record */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nData</name></decl>;</decl_stmt>             <comment type="block">/* Number of bytes of data space */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHdr</name></decl>;</decl_stmt>              <comment type="block">/* Number of bytes of header space */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name></decl>;</decl_stmt>             <comment type="block">/* Data space required for this record */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nZero</name></decl>;</decl_stmt>             <comment type="block">/* Number of zero bytes at the end of the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVarint</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes in a varint */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>       <comment type="block">/* Type field */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pData0</name></decl>;</decl_stmt>           <comment type="block">/* First field to be combined into the record */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>            <comment type="block">/* Last field of the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>            <comment type="block">/* Number of fields in the record */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAffinity</name></decl>;</decl_stmt>       <comment type="block">/* The affinity string for the record */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* Length of a field */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zHdr</name></decl>;</decl_stmt>              <comment type="block">/* Where to write next byte of the header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zPayload</name></decl>;</decl_stmt>          <comment type="block">/* Where to write next byte of the payload */</comment>

  <comment type="block">/* Assuming the record contains N fields, the record format looks
  ** like this:
  **
  ** ------------------------------------------------------------------------
  ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 | 
  ** ------------------------------------------------------------------------
  **
  ** Data(0) is taken from register P1.  Data(1) comes from register P1+1
  ** and so forth.
  **
  ** Each type field is a varint representing the serial type of the 
  ** corresponding data element (see sqlite3VdbeSerialType()). The
  ** hdr-size field is also a varint which is the offset from the beginning
  ** of the record to data0.
  */</comment>
  <expr_stmt><expr><name>nData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Number of bytes of data space */</comment>
  <expr_stmt><expr><name>nHdr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>          <comment type="block">/* Number of bytes of header space */</comment>
  <expr_stmt><expr><name>nZero</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Number of zero bytes at the end of the record */</comment>
  <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zAffinity</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>nField</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData0</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> <operator>=</operator> <operator>&amp;</operator><name><name>pData0</name><index>[<expr><name>nField</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Identify the output register */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Apply the requested affinity to all inputs
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData0</name><operator>&lt;=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zAffinity</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pData0</name></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>SQLITE_AFF_REAL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_IntReal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Int</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pRec</name><operator>-</operator><name>aMem</name><operator>)</operator></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zAffinity</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRec</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pRec</name><operator>&lt;=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NULL_TRIM</name></cpp:ifdef>
  <comment type="block">/* NULLs can be safely trimmed from the end of the record, as long as
  ** as the schema format is 2 or more and none of the omitted columns
  ** have a non-NULL default value.  Also, the record must be left with
  ** at least one field.  If P5&gt;0 then it will be one more than the
  ** index of the right-most column with a non-NULL default value */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><name><name>pLast</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nField</name><operator>&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pLast</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nField</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Loop through the elements that will make up the record to figure
  ** out how much space is required for the new record.  After this loop,
  ** the Mem.uTemp field of each term should hold the serial-type that will
  ** be used for that term in the generated record:
  **
  **   Mem.uTemp value    type
  **   ---------------    ---------------
  **      0               NULL
  **      1               1-byte signed integer
  **      2               2-byte signed integer
  **      3               3-byte signed integer
  **      4               4-byte signed integer
  **      5               6-byte signed integer
  **      6               8-byte signed integer
  **      7               IEEE float
  **      8               Integer constant 0
  **      9               Integer constant 1
  **     10,11            reserved for expansion
  **    N&gt;=12 and even    BLOB
  **    N&gt;=13 and odd     text
  **
  ** The following additional values are computed:
  **     nHdr        Number of bytes needed for the record header
  **     nData       Number of bytes of data space needed for the record
  **     nZero       Zero bytes at the end of the record
  */</comment>
  <expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pLast</name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Values with MEM_Null and MEM_Zero are created by xColumn virtual
        ** table methods that never invoke sqlite3_result_xxxxx() while
        ** computing an unchanging column value in an UPDATE statement.
        ** Give such values a special internal-use-only serial-type of 10
        ** so that they can be passed through to xUpdate and have
        ** a true sqlite3_value_nochange(). */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_NULL_TRIM</name></cpp:ifndef>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OPFLAG_NOCHNG_MAGIC</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nHdr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>i</name> <init>= <expr><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>uu</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>uu</name> <operator>=</operator> <operator>~</operator><name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>uu</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nHdr</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">127</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>               <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">128</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">32767</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>             <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">8388607</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">8388608</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">2147483647</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">2147483648LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">140737488355327LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>uu</name><operator>==</operator><literal type="number">140737488355328LL</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>uu</name><operator>&lt;=</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><name>i</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name><operator>&gt;=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">8</literal><operator>+</operator><operator>(</operator><name>u32</name><operator>)</operator><name>uu</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nData</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>uu</name><operator>&lt;=</operator><literal type="number">32767</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nData</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>uu</name><operator>&lt;=</operator><literal type="number">8388607</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nData</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>uu</name><operator>&lt;=</operator><literal type="number">2147483647</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nData</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>uu</name><operator>&lt;=</operator><literal type="number">140737488355327LL</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nData</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nData</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* If the value is IntReal and is going to take up 8 bytes to store
          ** as an integer, then we might as well make it an 8-byte floating
          ** point value */</comment>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_IntReal</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nHdr</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nData</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <operator>(</operator><name>len</name><operator>*</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">12</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>serial_type</name> <operator>+=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nData</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nZero</name> <operator>+=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nData</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <name>serial_type</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRec</name><operator>==</operator><name>pData0</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pRec</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>

  <comment type="block">/* EVIDENCE-OF: R-22564-11647 The header begins with a single varint
  ** which determines the total number of bytes in the header. The varint
  ** value is the size of the header in bytes including the size varint
  ** itself. */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nHdr</name><operator>==</operator><literal type="number">126</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nHdr</name><operator>==</operator><literal type="number">127</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nHdr</name><operator>&lt;=</operator><literal type="number">126</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The common case */</comment>
    <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Rare case of a really large header */</comment>
    <expr_stmt><expr><name>nVarint</name> <operator>=</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <name>nVarint</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVarint</name><operator>&lt;</operator><call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nHdr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>nHdr</name><operator>+</operator><name>nData</name></expr>;</expr_stmt>

  <comment type="block">/* Make sure the output register has a buffer large enough to store 
  ** the new record. The output register (pOp-&gt;p3) is not allowed to
  ** be one of the input registers (because the following call to
  ** sqlite3VdbeMemClearAndResize() could clobber the value before it is used).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>+</operator><name>nZero</name><operator>&lt;=</operator><name><name>pOut</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The output register is already large enough to hold the record.
    ** No error checks or buffer enlargement is required */</comment>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pOut</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Need to make sure that the output is not too big and then enlarge
    ** the output register to hold the full result */</comment>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>+</operator><name>nZero</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <goto>goto <name>too_big</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nZero</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <name>nZero</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Zero</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zHdr</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zPayload</name> <operator>=</operator> <name>zHdr</name> <operator>+</operator> <name>nHdr</name></expr>;</expr_stmt>

  <comment type="block">/* Write the record */</comment>
  <if_stmt><if>if<condition>( <expr><name>nHdr</name><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zHdr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>nHdr</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zHdr</name> <operator>+=</operator> <call><name>sqlite3PutVarint</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>,<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData0</name><operator>&lt;=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pData0</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> <comment type="block">/*exit-by-break*/</comment> )</condition><block>{<block_content>
    <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name></expr>;</expr_stmt>
    <comment type="block">/* EVIDENCE-OF: R-06529-47362 Following the size varint are one or more
    ** additional varints, one per column.
    ** EVIDENCE-OF: R-64536-51728 The values for each column in the record
    ** immediately follow the header. */</comment>
    <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;=</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zHdr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>serial_type</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* NULL value.  No change in zPayload */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>u64</name></type> <name>v</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>i</name> <operator>=</operator> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><literal type="number">1</literal></expr> <comment type="block">/*exit-by-break*/</comment> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zPayload</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zHdr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>serial_type</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">14</literal> <operator>&amp;&amp;</operator> <name><name>pRec</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zPayload</name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zHdr</name> <operator>+=</operator> <call><name>sqlite3PutVarint</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zPayload</name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRec</name><operator>==</operator><name>pLast</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pRec</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nHdr</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zHdr</name> <operator>-</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zPayload</name> <operator>-</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Count P1 P2 P3 * *
** Synopsis: r[P2]=count()
**
** Store the number of entries (an integer value) in the table or index 
** opened by cursor P1 in register P2.
**
** If P3==0, then an exact count is obtained, which involves visiting
** every btree page of the table.  But if P3 is non-zero, an estimate
** is returned based on the current cursor position.  
*/</comment>
<case>case <expr><name>OP_Count</name></expr>:</case> <block>{<block_content>         <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name>eCurType</name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <call><name>sqlite3BtreeRowCountEst</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only used to silence a warning. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCount</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>nEntry</name></expr>;</expr_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Savepoint P1 * * P4 *
**
** Open, release or rollback the savepoint named by parameter P4, depending
** on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN).
** To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE).
** To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).
*/</comment>
<case>case <expr><name>OP_Savepoint</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>                         <comment type="block">/* Value of P1 operand */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Name of savepoint */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pSavepoint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSavepoint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>

  <comment type="block">/* Assert that the p1 parameter is valid. Also that if there is no open
  ** transaction, then there cannot be any savepoints. 
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>==</operator><name>SAVEPOINT_BEGIN</name><operator>||</operator><name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name><operator>||</operator><name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>checkSavepointCount</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>SAVEPOINT_BEGIN</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* A new savepoint cannot be created if there are active write 
      ** statements (i.e. open read/write incremental blob handles).
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot open savepoint - SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <comment type="block">/* This call is Ok even if this savepoint is actually a transaction
      ** savepoint (and therefore should not prompt xSavepoint()) callbacks.
      ** If this is a transaction savepoint being opened, it is guaranteed
      ** that the db-&gt;aVTrans[] array is empty.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_BEGIN</name></expr></argument>,
                                <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>+</operator><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* Create a new savepoint structure. */</comment>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Savepoint</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <comment type="block">/* If there is no open transaction, then mark this as a special
        ** "transaction savepoint". */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Link the new savepoint into the database handle's list. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name> <operator>||</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSavepoint</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Find the named savepoint. If there is no such savepoint, then an
    ** an error is returned to the user.  */</comment>
    <for>for<control>(
      <init><expr><name>pSavepoint</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</init> 
      <condition><expr><name>pSavepoint</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</condition>
      <incr><expr><name>pSavepoint</name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>
    )</control><block>{<block_content>
      <expr_stmt><expr><name>iSavepoint</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pSavepoint</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"no such savepoint: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* It is not possible to release (commit) a savepoint if there are 
      ** active write statements.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot release savepoint - "</literal>
                          <literal type="string">"SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>

      <comment type="block">/* Determine whether or not this is a transaction savepoint. If so,
      ** and this is a RELEASE command, then the current transaction 
      ** is committed. 
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>isTransaction</name> <init>= <expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>isTransaction</name> <operator>&amp;&amp;</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>vdbe_return</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
          <goto>goto <name>vdbe_return</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>isSchemaChange</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>iSavepoint</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>-</operator> <name>iSavepoint</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>isSchemaChange</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_SchemaChange</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTripAllCursors</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>,
                                       <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>,
                                       <argument><expr><name>isSchemaChange</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isSchemaChange</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <goto>goto <name>abort_due_to_error</name>;</goto>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>isSchemaChange</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  
      <comment type="block">/* Regardless of whether this is a RELEASE or ROLLBACK, destroy all 
      ** savepoints nested inside of the savepoint being operated on. */</comment>
      <while>while<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name><operator>!=</operator><name>pSavepoint</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name><name>pTmp</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></while>

      <comment type="block">/* If it is a RELEASE, then destroy the savepoint being operated on 
      ** too. If it is a ROLLBACK TO, then set the number of deferred 
      ** constraint violations present in the database to the value stored
      ** when the savepoint was created.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSavepoint</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isTransaction</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>nDeferredCons</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isTransaction</name> <operator>||</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_HALT_STATE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
    <goto>goto <name>vdbe_return</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AutoCommit P1 P2 * * *
**
** Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll
** back any currently active btree transactions. If there are any active
** VMs (apart from this one), then a ROLLBACK fails.  A COMMIT fails if
** there are active writing VMs or active VMs that use shared cache.
**
** This instruction causes the VM to halt.
*/</comment>
<case>case <expr><name>OP_AutoCommit</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>desiredAutoCommit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRollback</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>desiredAutoCommit</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iRollback</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>desiredAutoCommit</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iRollback</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* At least this one VM is active */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>desiredAutoCommit</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iRollback</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>desiredAutoCommit</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If this instruction implements a COMMIT and other VMs are writing
      ** return an error indicating that the other VMs must complete first. 
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot commit transaction - "</literal>
                          <literal type="string">"SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>vdbe_return</name>;</goto>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>desiredAutoCommit</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><literal type="number">1</literal><operator>-</operator><name>desiredAutoCommit</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
      <goto>goto <name>vdbe_return</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <goto>goto <name>vdbe_return</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>desiredAutoCommit</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"cannot start a transaction within a transaction"</literal></expr></then><else>:<expr><operator>(</operator>
        <ternary><condition><expr><operator>(</operator><name>iRollback</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"cannot rollback - no transaction is active"</literal></expr></then><else>:
                   <expr><literal type="string">"cannot commit - no transaction is active"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/*NOTREACHED*/</comment> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<comment type="block">/* Opcode: Transaction P1 P2 P3 P4 P5
**
** Begin a transaction on database P1 if a transaction is not already
** active.
** If P2 is non-zero, then a write-transaction is started, or if a 
** read-transaction is already active, it is upgraded to a write-transaction.
** If P2 is zero, then a read-transaction is started.  If P2 is 2 or more
** then an exclusive transaction is started.
**
** P1 is the index of the database file on which the transaction is
** started.  Index 0 is the main database file and index 1 is the
** file used for temporary tables.  Indices of 2 or more are used for
** attached databases.
**
** If a write-transaction is started and the Vdbe.usesStmtJournal flag is
** true (this flag is set if the Vdbe may modify more than one row and may
** throw an ABORT exception), a statement transaction may also be opened.
** More specifically, a statement transaction is opened iff the database
** connection is currently not in autocommit mode, or if there are other
** active statements. A statement transaction allows the changes made by this
** VDBE to be rolled back after an error without having to roll back the
** entire transaction. If no error is encountered, the statement transaction
** will automatically commit when the VDBE halts.
**
** If P5!=0 then this opcode also checks the schema cookie against P3
** and the schema generation counter against P4.
** The cookie changes its value whenever the database schema changes.
** This operation is used to detect when that the cookie has changed
** and that the current process needs to reread the schema.  If the schema
** cookie in P3 differs from the schema cookie in the database header or
** if the schema generation counter in P4 differs from the current
** generation counter, then an SQLITE_SCHEMA error is raised and execution
** halts.  The sqlite3_step() wrapper function might then reprepare the
** statement and rerun it from the beginning.
*/</comment>
<case>case <expr><name>OP_Transaction</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_QueryOnly</name><operator>|</operator><name>SQLITE_CorruptRdOnly</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_QueryOnly</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Writes prohibited by the "PRAGMA query_only=TRUE" statement */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Writes prohibited due to a prior SQLITE_CORRUPT in the current
      ** transaction */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_SNAPSHOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_RECOVERY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
        <goto>goto <name>vdbe_return</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name>
     <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TXN_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>++</operator></expr>;</expr_stmt> 
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>+</operator> <name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_BEGIN</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginStmt</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Store the current value of the database handles deferred constraint
      ** counter. If the statement transaction needs to be rolled back,
      ** the value of this counter needs to be restored too.  */</comment>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStmtDefCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStmtDefImmCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name>
   <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>iMeta</name><operator>!=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>iGeneration</name></name><operator>!=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <comment type="block">/*
    ** IMPLEMENTATION-OF: R-03189-51135 As each SQL statement runs, the schema
    ** version is checked to ensure that the schema has not changed since the
    ** SQL statement was prepared.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"database schema has changed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If the schema-cookie from the database file matches the cookie 
    ** stored with the in-memory representation of the schema, do
    ** not reload the schema from the database file.
    **
    ** If virtual-tables are in use, this is not just an optimization.
    ** Often, v-tables store their data in other SQLite tables, which
    ** are queried from within xNext() and other v-table methods using
    ** prepared queries. If such a query is out-of-date, we do not want to
    ** discard the database schema, as the user code implementing the
    ** v-table would have to be ready for the sqlite3_vtab structure itself
    ** to be invalidated whenever sqlite3_step() is called from within 
    ** a v-table method.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name><operator>!=</operator><name>iMeta</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ResetOneSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>

    <comment type="block">/* Set changeCntOn to 0 to prevent the value returned by sqlite3_changes()
    ** from being modified in sqlite3VdbeHalt(). If this statement is
    ** reprepared, changeCntOn will be set again. */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>changeCntOn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ReadCookie P1 P2 P3 * *
**
** Read cookie number P3 from database P1 and write it into register P2.
** P3==1 is the schema version.  P3==2 is the database format.
** P3==3 is the recommended pager cache size, and so forth.  P1==0 is
** the main database file and P1==1 is the database file used to store
** temporary tables.
**
** There must be a read-lock on the database (either a transaction
** must be started or there must be an open cursor) before
** executing this instruction.
*/</comment>
<case>case <expr><name>OP_ReadCookie</name></expr>:</case> <block>{<block_content>               <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCookie</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCookie</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name>SQLITE_N_BTREE_META</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>iCookie</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iMeta</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SetCookie P1 P2 P3 * P5
**
** Write the integer value P3 into cookie number P2 of database P1.
** P2==1 is the schema version.  P2==2 is the database format.
** P2==3 is the recommended pager cache 
** size, and so forth.  P1==0 is the main database file and P1==1 is the 
** database file used to store temporary tables.
**
** A transaction must be started before executing this opcode.
**
** If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal
** schema version is set to P3-P5.  The "PRAGMA schema_version=N" statement
** has P5 set to 1, so that the internal schema version will be different
** from the database schema version, resulting in a schema reset.
*/</comment>
<case>case <expr><name>OP_SetCookie</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name>SQLITE_N_BTREE_META</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* See note about index shifting on OP_ReadCookie */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>BTREE_SCHEMA_VERSION</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* When the schema cookie changes, record the new cookie internally */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>-</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3FkClearTriggerCache</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>BTREE_FILE_FORMAT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Record changes in the file format */</comment>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Invalidate all prepared statements whenever the TEMP database
    ** schema is changed.  Ticket #1644 */</comment>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OpenRead P1 P2 P3 P4 P5
** Synopsis: root=P2 iDb=P3
**
** Open a read-only cursor for the database table whose root page is
** P2 in a database file.  The database file is determined by P3. 
** P3==0 means the main database, P3==1 means the database used for 
** temporary tables, and P3&gt;1 means used the corresponding attached
** database.  Give the new cursor an identifier of P1.  The P1
** values need not be contiguous but all P1 values should be small integers.
** It is an error for P1 to be negative.
**
** Allowed P5 bits:
** &lt;ul&gt;
** &lt;li&gt;  &lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for
**       equality lookups (implemented as a pair of opcodes OP_SeekGE/OP_IdxGT
**       of OP_SeekLE/OP_IdxLT)
** &lt;/ul&gt;
**
** The P4 value may be either an integer (P4_INT32) or a pointer to
** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo 
** object, then table being opened must be an [index b-tree] where the
** KeyInfo object defines the content and collating 
** sequence of that index b-tree. Otherwise, if P4 is an integer 
** value, then the table being opened must be a [table b-tree] with a
** number of columns no less than the value of P4.
**
** See also: OpenWrite, ReopenIdx
*/</comment>
<comment type="block">/* Opcode: ReopenIdx P1 P2 P3 P4 P5
** Synopsis: root=P2 iDb=P3
**
** The ReopenIdx opcode works like OP_OpenRead except that it first
** checks to see if the cursor on P1 is already open on the same
** b-tree and if it is this opcode becomes a no-op.  In other words,
** if the cursor is already open, do not reopen it.
**
** The ReopenIdx opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ
** and with P4 being a P4_KEYINFO object.  Furthermore, the P3 value must
** be the same as every other ReopenIdx or OpenRead for the same cursor
** number.
**
** Allowed P5 bits:
** &lt;ul&gt;
** &lt;li&gt;  &lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for
**       equality lookups (implemented as a pair of opcodes OP_SeekGE/OP_IdxGT
**       of OP_SeekLE/OP_IdxLT)
** &lt;/ul&gt;
**
** See also: OP_OpenRead, OP_OpenWrite
*/</comment>
<comment type="block">/* Opcode: OpenWrite P1 P2 P3 P4 P5
** Synopsis: root=P2 iDb=P3
**
** Open a read/write cursor named P1 on the table or index whose root
** page is P2 (or whose root page is held in register P2 if the
** OPFLAG_P2ISREG bit is set in P5 - see below).
**
** The P4 value may be either an integer (P4_INT32) or a pointer to
** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo 
** object, then table being opened must be an [index b-tree] where the
** KeyInfo object defines the content and collating 
** sequence of that index b-tree. Otherwise, if P4 is an integer 
** value, then the table being opened must be a [table b-tree] with a
** number of columns no less than the value of P4.
**
** Allowed P5 bits:
** &lt;ul&gt;
** &lt;li&gt;  &lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for
**       equality lookups (implemented as a pair of opcodes OP_SeekGE/OP_IdxGT
**       of OP_SeekLE/OP_IdxLT)
** &lt;li&gt;  &lt;b&gt;0x08 OPFLAG_FORDELETE&lt;/b&gt;: This cursor is used only to seek
**       and subsequently delete entries in an index btree.  This is a
**       hint to the storage engine that the storage engine is allowed to
**       ignore.  The hint is not used by the official SQLite b*tree storage
**       engine, but is used by COMDB2.
** &lt;li&gt;  &lt;b&gt;0x10 OPFLAG_P2ISREG&lt;/b&gt;: Use the content of register P2
**       as the root page, not the value of P2 itself.
** &lt;/ul&gt;
**
** This instruction works like OpenRead except that it opens the cursor
** in read/write mode.
**
** See also: OP_OpenRead, OP_ReopenIdx
*/</comment>
<case>case <expr><name>OP_ReopenIdx</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wrFlag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OPFLAG_SEEKEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_KEYINFO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iDb</name></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Guaranteed by the code generator */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>open_cursor_set_hints</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* If the cursor is not currently open or is open on a different
  ** index, then fall through into OP_OpenRead to force a reopen */</comment>
<case>case <expr><name>OP_OpenRead</name></expr>:</case>
<case>case <expr><name>OP_OpenWrite</name></expr>:</case>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OPFLAG_SEEKEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenRead</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_ReopenIdx</name>
          <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ABORT_ROLLBACK</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nField</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_FORDELETE</name><operator>==</operator><name>BTREE_FORDELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wrFlag</name> <operator>=</operator> <name>BTREE_WRCSR</name> <operator>|</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_FORDELETE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>wrFlag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_P2ISREG</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&lt;=</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <comment type="block">/* The p2 value always comes from a prior OP_CreateBtree opcode and
    ** that opcode will always set the p2 value to 2 or more or else fail.
    ** If there were a failure, the prepared statement would have halted
    ** before reaching this instruction. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_KEYINFO</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nField</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Table with INTEGER PRIMARY KEY and nothing else */</comment>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>nField</name></expr></argument>, <argument><expr><name>CURTYPE_BTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>wrFlag</name></name> <operator>=</operator> <name>wrFlag</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name></expr>;</expr_stmt>
  <comment type="block">/* Set the VdbeCursor.isTable variable. Previous versions of
  ** SQLite used to check if the root-page flags were sane at this point
  ** and report database corruption if they were not, but this check has
  ** since moved into the btree layer.  */</comment>  
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>!=</operator><name>P4_KEYINFO</name></expr>;</expr_stmt>

<label><name>open_cursor_set_hints</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_BULKCSR</name><operator>==</operator><name>BTREE_BULKLOAD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_SEEKEQ</name><operator>==</operator><name>BTREE_SEEK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_BULKCSR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;</operator> <name>OPFLAG_SEEKEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeCursorHintFlags</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>,
                               <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_BULKCSR</name><operator>|</operator><name>OPFLAG_SEEKEQ</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OpenDup P1 P2 * * *
**
** Open a new cursor P1 that points to the same ephemeral table as
** cursor P2.  The P2 cursor must have been opened by a prior OP_OpenEphemeral
** opcode.  Only ephemeral cursors may be duplicated.
**
** Duplicate ephemeral cursors are used for self-joins of materialized views.
*/</comment>
<case>case <expr><name>OP_OpenDup</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pOrig</name></decl>;</decl_stmt>    <comment type="block">/* The original cursor to be duplicated */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>      <comment type="block">/* The new cursor */</comment>

  <expr_stmt><expr><name>pOrig</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrig</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrig</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Only ephemeral cursors can be duplicated */</comment>

  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOrig</name><operator>-&gt;</operator><name>nField</name></name></expr></argument>, <argument><expr><name>CURTYPE_BTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isEphemeral</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>isTable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>isOrdered</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>noReuse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOrig</name><operator>-&gt;</operator><name>noReuse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name>BTREE_WRCSR</name></expr></argument>, 
                          <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The sqlite3BtreeCursor() routine can only fail for the first cursor
  ** opened for a database.  Since there is already an open cursor when this
  ** opcode is run, the sqlite3BtreeCursor() cannot fail */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: OpenEphemeral P1 P2 P3 P4 P5
** Synopsis: nColumn=P2
**
** Open a new cursor P1 to a transient table.
** The cursor is always opened read/write even if 
** the main database is read-only.  The ephemeral
** table is deleted automatically when the cursor is closed.
**
** If the cursor P1 is already opened on an ephemeral table, the table
** is cleared (all content is erased).
**
** P2 is the number of columns in the ephemeral table.
** The cursor points to a BTree table if P4==0 and to a BTree index
** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure
** that defines the format of keys in the index.
**
** The P5 parameter can be a mask of the BTREE_* flags defined
** in btree.h.  These flags control aspects of the operation of
** the btree.  The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are
** added automatically.
**
** If P3 is positive, then reg[P3] is modified slightly so that it
** can be used as zero-length data for OP_Insert.  This is an optimization
** that avoids an extra OP_Blob opcode to initialize that register.
*/</comment>
<comment type="block">/* Opcode: OpenAutoindex P1 P2 * P4 *
** Synopsis: nColumn=P2
**
** This opcode works the same as OP_OpenEphemeral.  It has a
** different name to distinguish its use.  Tables created using
** by this opcode will be used for automatically created transient
** indices in joins.
*/</comment>
<case>case <expr><name>OP_OpenAutoindex</name></expr>:</case> 
<case>case <expr><name>OP_OpenEphemeral</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>vfsFlags</name> <init>= 
      <expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator>
      <name>SQLITE_OPEN_CREATE</name> <operator>|</operator>
      <name>SQLITE_OPEN_EXCLUSIVE</name> <operator>|</operator>
      <name>SQLITE_OPEN_DELETEONCLOSE</name> <operator>|</operator>
      <name>SQLITE_OPEN_TRANSIENT_DB</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Make register reg[P3] into a value that can be used as the data
    ** form sqlite3BtreeInsert() where the length of the data is zero. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Only used when number of columns is zero */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenEphemeral</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pCx</name><operator>-&gt;</operator><name>noReuse</name></name> <operator>&amp;&amp;</operator>  <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><name><name>pCx</name><operator>-&gt;</operator><name>nField</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the ephermeral table is already open and has no duplicates from
    ** OP_OpenDup, then erase all existing content so that the table is
    ** empty again, rather than creating a new table. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>seqCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeClearTable</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>CURTYPE_BTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isEphemeral</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, 
                          <argument><expr><name>BTREE_OMIT_JOURNAL</name> <operator>|</operator> <name>BTREE_SINGLE</name> <operator>|</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>,
                          <argument><expr><name>vfsFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If a transient index is required, create it by calling
        ** sqlite3BtreeCreateTable() with the BTREE_BLOBKEY flag before
        ** opening it. If a transient table is required, just use the
        ** automatically created table with root-page 1 (an BLOB_INTKEY table).
        */</comment>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_KEYINFO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCreateTable</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>,
              <argument><expr><name>BTREE_BLOBKEY</name> <operator>|</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><name>SCHEMA_ROOT</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name></expr></argument>, <argument><expr><name>BTREE_WRCSR</name></expr></argument>,
                <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>pgnoRoot</name></name> <operator>=</operator> <name>SCHEMA_ROOT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>, <argument><expr><name>SCHEMA_ROOT</name></expr></argument>, <argument><expr><name>BTREE_WRCSR</name></expr></argument>,
              <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>!=</operator><name>BTREE_UNORDERED</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>pBtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SorterOpen P1 P2 P3 P4 *
**
** This opcode works like OP_OpenEphemeral except that it opens
** a transient index that is specifically designed to sort large
** tables using an external merge-sort algorithm.
**
** If argument P3 is non-zero, then it indicates that the sorter may
** assume that a stable sort considering the first P3 fields of each
** key is sufficient to produce the required results.
*/</comment>
<case>case <expr><name>OP_SorterOpen</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>CURTYPE_SORTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SequenceTest P1 P2 * * *
** Synopsis: if( cursor[P1].ctr++ ) pc = P2
**
** P1 is a sorter cursor. If the sequence counter is currently zero, jump
** to P2. Regardless of whether or not the jump is taken, increment the
** the sequence value.
*/</comment>
<case>case <expr><name>OP_SequenceTest</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>seqCount</name></name><operator>++</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OpenPseudo P1 P2 P3 * *
** Synopsis: P3 columns in r[P2]
**
** Open a new cursor that points to a fake table that contains a single
** row of data.  The content of that one row is the content of memory
** register P2.  In other words, cursor P1 becomes an alias for the 
** MEM_Blob content contained in register P2.
**
** A pseudo-table created by this opcode is used to hold a single
** row output from the sorter so that the row can be decomposed into
** individual columns using the OP_Column opcode.  The OP_Column opcode
** is the only cursor opcode that works with a pseudo-table.
**
** P3 is the number of fields in the records that will be stored by
** the pseudo-table.
*/</comment>
<case>case <expr><name>OP_OpenPseudo</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>CURTYPE_PSEUDO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <comment type="block">/* Give this pseudo-cursor a fake BtCursor pointer so that pCx
  ** can be safely passed to sqlite3VdbeCursorMoveto().  This avoids a test
  ** for pCx-&gt;eCurType==CURTYPE_BTREE inside of sqlite3VdbeCursorMoveto()
  ** which is a performance optimization */</comment>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name> <operator>=</operator> <call><name>sqlite3BtreeFakeValidCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Close P1 * * * *
**
** Close a cursor previously opened as P1.  If P1 is not
** currently open, this instruction is a no-op.
*/</comment>
<case>case <expr><name>OP_Close</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
<comment type="block">/* Opcode: ColumnsUsed P1 * * P4 *
**
** This opcode (which only exists if SQLite was compiled with
** SQLITE_ENABLE_COLUMN_USED_MASK) identifies which columns of the
** table or index for cursor P1 are used.  P4 is a 64-bit integer
** (P4_INT64) in which the first 63 bits are one for each of the
** first 63 columns of the table or index that are actually used
** by the cursor.  The high-order bit is set if any column after
** the 64th is used.
*/</comment>
<case>case <expr><name>OP_ColumnsUsed</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>maskUsed</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>u64</name><operator>*</operator><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: SeekGE P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as the key.  If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the smallest entry that 
** is greater than or equal to the key value. If there are no records 
** greater than or equal to the key and P2 is not zero, then jump to P2.
**
** If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this
** opcode will either land on a record that exactly matches the key, or
** else it will cause a jump to P2.  When the cursor is OPFLAG_SEEKEQ,
** this opcode must be followed by an IdxLE opcode with the same arguments.
** The IdxGT opcode will be skipped if this opcode succeeds, but the
** IdxGT opcode will be used on subsequent loop iterations.  The 
** OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this
** is an equality search.
**
** This opcode leaves the cursor configured to move in forward order,
** from the beginning toward the end.  In other words, the cursor is
** configured to use Next, not Prev.
**
** See also: Found, NotFound, SeekLt, SeekGt, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekGT P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that it points to the smallest entry that 
** is greater than the key value. If there are no records greater than 
** the key and P2 is not zero, then jump to P2.
**
** This opcode leaves the cursor configured to move in forward order,
** from the beginning toward the end.  In other words, the cursor is
** configured to use Next, not Prev.
**
** See also: Found, NotFound, SeekLt, SeekGe, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekLT P1 P2 P3 P4 * 
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the largest entry that 
** is less than the key value. If there are no records less than 
** the key and P2 is not zero, then jump to P2.
**
** This opcode leaves the cursor configured to move in reverse order,
** from the end toward the beginning.  In other words, the cursor is
** configured to use Prev, not Next.
**
** See also: Found, NotFound, SeekGt, SeekGe, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekLE P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that it points to the largest entry that 
** is less than or equal to the key value. If there are no records 
** less than or equal to the key and P2 is not zero, then jump to P2.
**
** This opcode leaves the cursor configured to move in reverse order,
** from the end toward the beginning.  In other words, the cursor is
** configured to use Prev, not Next.
**
** If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this
** opcode will either land on a record that exactly matches the key, or
** else it will cause a jump to P2.  When the cursor is OPFLAG_SEEKEQ,
** this opcode must be followed by an IdxLE opcode with the same arguments.
** The IdxGE opcode will be skipped if this opcode succeeds, but the
** IdxGE opcode will be used on subsequent loop iterations.  The 
** OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this
** is an equality search.
**
** See also: Found, NotFound, SeekGt, SeekGe, SeekLt
*/</comment>
<case>case <expr><name>OP_SeekLT</name></expr>:</case>         <comment type="block">/* jump, in3, group */</comment>
<case>case <expr><name>OP_SeekLE</name></expr>:</case>         <comment type="block">/* jump, in3, group */</comment>
<case>case <expr><name>OP_SeekGE</name></expr>:</case>         <comment type="block">/* jump, in3, group */</comment>
<case>case <expr><name>OP_SeekGT</name></expr>:</case> <block>{<block_content>       <comment type="block">/* jump, in3, group */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>           <comment type="block">/* Comparison result */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oc</name></decl>;</decl_stmt>            <comment type="block">/* Opcode */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>    <comment type="block">/* The cursor to seek */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>  <comment type="block">/* The key to seek for */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>        <comment type="block">/* Number of columns or fields in the key */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>          <comment type="block">/* The rowid we are to seek to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eqOnly</name></decl>;</decl_stmt>        <comment type="block">/* Only interested in == results */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekLE</name> <operator>==</operator> <name>OP_SeekLT</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGE</name> <operator>==</operator> <name>OP_SeekLT</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGT</name> <operator>==</operator> <name>OP_SeekLT</name><operator>+</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isOrdered</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>oc</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>eqOnly</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>flags3</name></decl>, <decl><type ref="prev"/><name>newType</name></decl>;</decl_stmt>
    <comment type="block">/* The OPFLAG_SEEKEQ/BTREE_SEEK_EQ flag is only set on index cursors */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorHasHint</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>BTREE_SEEK_EQ</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
              <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The input value in P3 might be of any type: integer, real, string,
    ** blob, or NULL.  But it needs to be an integer before we can do
    ** the seek, so convert it. */</comment>
    <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags3</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags3</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Get the integer key value */</comment>
    <expr_stmt><expr><name>newType</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt> <comment type="block">/* Record the type after applying numeric affinity */</comment>
    <expr_stmt><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags3</name></expr>;</expr_stmt>  <comment type="block">/* But convert the type back to its original */</comment>

    <comment type="block">/* If the P3 value could not be converted into an integer without
    ** loss of information, then special processing is required... */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>newType</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>newType</name> <operator>&amp;</operator> <name>MEM_Real</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>newType</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator> <operator>||</operator> <name>oc</name><operator>&gt;=</operator><name>OP_SeekGE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>jump_to_p2</name>;</goto>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
          <goto>goto <name>seek_not_found</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the approximation iKey is larger than the actual real search
      ** term, substitute &gt;= for &gt; and &lt; for &lt;=. e.g. if the search term
      ** is 4.9 and the integer approximation 5:
      **
      **        (x &gt;  4.9)    -&gt;     (x &gt;= 5)
      **        (x &lt;= 4.9)    -&gt;     (x &lt;  5)
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGE</name><operator>==</operator><operator>(</operator><name>OP_SeekGT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekLT</name><operator>==</operator><operator>(</operator><name>OP_SeekLE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>OP_SeekLE</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekGT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>oc</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekGT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oc</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>

      <comment type="block">/* If the approximation iKey is smaller than the actual real search
      ** term, substitute &lt;= for &lt; and &gt; for &gt;=.  */</comment>
      <if type="elseif">else if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekLE</name><operator>==</operator><operator>(</operator><name>OP_SeekLT</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGT</name><operator>==</operator><operator>(</operator><name>OP_SeekGE</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>OP_SeekLT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekGE</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>oc</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekLT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTableMoveto</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>iKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>  <comment type="block">/* Used by OP_Delete */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* For a cursor with the OPFLAG_SEEKEQ/BTREE_SEEK_EQ hint, only the
    ** OP_SeekGE and OP_SeekLE opcodes are allowed, and these must be
    ** immediately followed by an OP_IdxGT or OP_IdxLT opcode, respectively,
    ** with the same key.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeCursorHasHint</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>BTREE_SEEK_EQ</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eqOnly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekGE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxLT</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekGE</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekLE</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p2</name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>i</name></name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>i</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nField</name></expr>;</expr_stmt>

    <comment type="block">/* The next line of code computes as follows, only faster:
    **   if( oc==OP_SeekGT || oc==OP_SeekLE ){
    **     r.default_rc = -1;
    **   }else{
    **     r.default_rc = +1;
    **   }
    */</comment>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&amp;</operator> <operator>(</operator><name>oc</name> <operator>-</operator> <name>OP_SeekLT</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekGT</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekLE</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekGE</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekLT</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIndexMoveto</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eqOnly</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>.</operator><name>eqSeen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>seek_not_found</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_search_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>oc</name><operator>&gt;=</operator><name>OP_SeekGE</name></expr> )</condition><block>{<block_content>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>==</operator><name>OP_SeekGE</name> <operator>||</operator> <name>oc</name><operator>==</operator><name>OP_SeekGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>oc</name><operator>==</operator><name>OP_SeekGT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <goto>goto <name>abort_due_to_error</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>==</operator><name>OP_SeekLT</name> <operator>||</operator> <name>oc</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>oc</name><operator>==</operator><name>OP_SeekLT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <goto>goto <name>abort_due_to_error</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* res might be negative because the table is empty.  Check to
      ** see if this is the case.
      */</comment>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3BtreeEof</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>seek_not_found</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eqOnly</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxLT</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Skip the OP_IdxLt or OP_IdxGT that follows */</comment>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: SeekScan  P1 P2 * * P5
** Synopsis: Scan-ahead up to P1 rows
**
** This opcode is a prefix opcode to OP_SeekGE.  In other words, this
** opcode must be immediately followed by OP_SeekGE. This constraint is
** checked by assert() statements.
**
** This opcode uses the P1 through P4 operands of the subsequent
** OP_SeekGE.  In the text that follows, the operands of the subsequent
** OP_SeekGE opcode are denoted as SeekOP.P1 through SeekOP.P4.   Only
** the P1, P2 and P5 operands of this opcode are also used, and  are called
** This.P1, This.P2 and This.P5.
**
** This opcode helps to optimize IN operators on a multi-column index
** where the IN operator is on the later terms of the index by avoiding
** unnecessary seeks on the btree, substituting steps to the next row
** of the b-tree instead.  A correct answer is obtained if this opcode
** is omitted or is a no-op.
**
** The SeekGE.P3 and SeekGE.P4 operands identify an unpacked key which
** is the desired entry that we want the cursor SeekGE.P1 to be pointing
** to.  Call this SeekGE.P3/P4 row the "target".
**
** If the SeekGE.P1 cursor is not currently pointing to a valid row,
** then this opcode is a no-op and control passes through into the OP_SeekGE.
**
** If the SeekGE.P1 cursor is pointing to a valid row, then that row
** might be the target row, or it might be near and slightly before the
** target row, or it might be after the target row.  If the cursor is
** currently before the target row, then this opcode attempts to position
** the cursor on or after the target row by invoking sqlite3BtreeStep()
** on the cursor between 1 and This.P1 times.
**
** The This.P5 parameter is a flag that indicates what to do if the
** cursor ends up pointing at a valid row that is past the target
** row.  If This.P5 is false (0) then a jump is made to SeekGE.P2.  If
** This.P5 is true (non-zero) then a jump is made to This.P2.  The P5==0
** case occurs when there are no inequality constraints to the right of
** the IN constraing.  The jump to SeekGE.P2 ends the loop.  The P5!=0 case
** occurs when there are inequality constraints to the right of the IN
** operator.  In that case, the This.P2 will point either directly to or
** to setup code prior to the OP_IdxGT or OP_IdxGE opcode that checks for
** loop terminate.
**
** Possible outcomes from this opcode:&lt;ol&gt;
**
** &lt;li&gt; If the cursor is initally not pointed to any valid row, then
**      fall through into the subsequent OP_SeekGE opcode.
**
** &lt;li&gt; If the cursor is left pointing to a row that is before the target
**      row, even after making as many as This.P1 calls to
**      sqlite3BtreeNext(), then also fall through into OP_SeekGE.
**
** &lt;li&gt; If the cursor is left pointing at the target row, either because it
**      was at the target row to begin with or because one or more
**      sqlite3BtreeNext() calls moved the cursor to the target row,
**      then jump to This.P2..,
**
** &lt;li&gt; If the cursor started out before the target row and a call to
**      to sqlite3BtreeNext() moved the cursor off the end of the index
**      (indicating that the target row definitely does not exist in the
**      btree) then jump to SeekGE.P2, ending the loop.
**
** &lt;li&gt; If the cursor ends up on a valid row that is past the target row 
**      (indicating that the target row does not exist in the btree) then
**      jump to SeekOP.P2 if This.P5==0 or to This.P2 if This.P5&gt;0.
** &lt;/ol&gt;
*/</comment>
<case>case <expr><name>OP_SeekScan</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nStep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pOp-&gt;p5 is clear, then pOp-&gt;p2 points to the first instruction past the
  ** OP_IdxGT that follows the OP_SeekGE. Otherwise, it points to the first
  ** opcode past the OP_SeekGE itself.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name><operator>-</operator><name>aOp</name><operator>)</operator><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* There are no inequality constraints following the IN constraint. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name><operator>==</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p2</name><operator>==</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>==</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGT</name> 
         <operator>||</operator> <name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* There are inequality constraints.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name><operator>-</operator><name>aOp</name><operator>)</operator><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3BtreeCursorIsValidNN</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
     <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"... cursor not valid - fall through\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nStep</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nStep</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only used to silence a warning. */</comment>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeIdxKeyCompare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <label><name>seekscan_search_fail</name>:</label>
      <comment type="block">/* Jump to SeekGE.P2, ending the loop */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"... %d steps and then skip\n"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>-</operator> <name>nStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name><operator>++</operator></expr>;</expr_stmt>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Jump to This.P2, bypassing the OP_SeekGE opcode */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"... %d steps and then success\n"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>-</operator> <name>nStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>jump_to_p2</name>;</goto>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nStep</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"... fall through after %d steps\n"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nStep</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        <goto>goto <name>seekscan_search_fail</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: SeekHit P1 P2 P3 * *
** Synopsis: set P2&lt;=seekHit&lt;=P3
**
** Increase or decrease the seekHit value for cursor P1, if necessary,
** so that it is no less than P2 and no greater than P3.
**
** The seekHit integer represents the maximum of terms in an index for which
** there is known to be at least one match.  If the seekHit value is smaller
** than the total number of equality terms in an index lookup, then the
** OP_IfNoHope opcode might run to see if the IN loop can be abandoned
** early, thus saving work.  This is part of the IN-early-out optimization.
**
** P1 must be a valid b-tree cursor.
*/</comment>
<case>case <expr><name>OP_SeekHit</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"seekHit changes from %d to %d\n"</literal></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name><operator>&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"seekHit changes from %d to %d\n"</literal></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IfNotOpen P1 P2 * * *
** Synopsis: if( !csr[P1] ) goto P2
**
** If cursor P1 is not open or if P1 is set to a NULL row using the
** OP_NullRow opcode, then jump to instruction P2. Otherwise, fall through.
*/</comment>
<case>case <expr><name>OP_IfNotOpen</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>pCur</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Found P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
** P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
** record.
**
** Cursor P1 is on an index btree.  If the record identified by P3 and P4
** is a prefix of any entry in P1 then a jump is made to P2 and
** P1 is left pointing at the matching entry.
**
** This operation leaves the cursor in a state where it can be
** advanced in the forward direction.  The Next instruction will work,
** but not the Prev instruction.
**
** See also: NotFound, NoConflict, NotExists. SeekGe
*/</comment>
<comment type="block">/* Opcode: NotFound P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
** P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
** record.
** 
** Cursor P1 is on an index btree.  If the record identified by P3 and P4
** is not the prefix of any entry in P1 then a jump is made to P2.  If P1 
** does contain an entry whose prefix matches the P3/P4 record then control
** falls through to the next instruction and P1 is left pointing at the
** matching entry.
**
** This operation leaves the cursor in a state where it cannot be
** advanced in either direction.  In other words, the Next and Prev
** opcodes do not work after this operation.
**
** See also: Found, NotExists, NoConflict, IfNoHope
*/</comment>
<comment type="block">/* Opcode: IfNoHope P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** Register P3 is the first of P4 registers that form an unpacked
** record.  Cursor P1 is an index btree.  P2 is a jump destination.
** In other words, the operands to this opcode are the same as the
** operands to OP_NotFound and OP_IdxGT.
**
** This opcode is an optimization attempt only.  If this opcode always
** falls through, the correct answer is still obtained, but extra works
** is performed.
**
** A value of N in the seekHit flag of cursor P1 means that there exists
** a key P3:N that will match some record in the index.  We want to know
** if it is possible for a record P3:P4 to match some record in the
** index.  If it is not possible, we can skips some work.  So if seekHit
** is less than P4, attempt to find out if a match is possible by running
** OP_NotFound.
**
** This opcode is used in IN clause processing for a multi-column key.
** If an IN clause is attached to an element of the key other than the
** left-most element, and if there are no matches on the most recent
** seek over the whole key, then it might be that one of the key element
** to the left is prohibiting a match, and hence there is "no hope" of
** any match regardless of how many IN clause elements are checked.
** In such a case, we abandon the IN clause search early, using this
** opcode.  The opcode name comes from the fact that the
** jump is taken if there is "no hope" of achieving a match.
**
** See also: NotFound, SeekHit
*/</comment>
<comment type="block">/* Opcode: NoConflict P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
** P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
** record.
** 
** Cursor P1 is on an index btree.  If the record identified by P3 and P4
** contains any NULL value, jump immediately to P2.  If all terms of the
** record are not-NULL then a check is done to determine if any row in the
** P1 index btree has a matching key prefix.  If there are no matches, jump
** immediately to P2.  If there is a match, fall through and leave the P1
** cursor pointing to the matching row.
**
** This opcode is similar to OP_NotFound with the exceptions that the
** branch is always taken if any part of the search key input is NULL.
**
** This operation leaves the cursor in a state where it cannot be
** advanced in either direction.  In other words, the Next and Prev
** opcodes do not work after this operation.
**
** See also: NotFound, Found, NotExists
*/</comment>
<case>case <expr><name>OP_IfNoHope</name></expr>:</case> <block>{<block_content>     <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"seekHit is %d\n"</literal></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <comment type="block">/* Fall through into OP_NotFound */</comment>
  <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
</block_content>}</block>
<case>case <expr><name>OP_NoConflict</name></expr>:</case>     <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_NotFound</name></expr>:</case>       <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_Found</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>alreadyExists</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pIdxKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_NoConflict</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlite3_found_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>r</name><operator>.</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Key values in an array of registers */</comment>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>n</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>ii</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIndexMoveto</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Composite key generated by OP_MakeRecord */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>r</name><operator>.</operator><name>aMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_NoConflict</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>aMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIdxKey</name> <operator>=</operator> <call><name>sqlite3VdbeAllocUnpackedRecord</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIdxKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>aMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>aMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIndexMoveto</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>alreadyExists</name> <operator>=</operator> <operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal><operator>-</operator><name>alreadyExists</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Found</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>alreadyExists</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>alreadyExists</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>alreadyExists</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_NoConflict</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For the OP_NoConflict opcode, take the jump if any of the
      ** input fields are NULL, since any key with a NULL will not
      ** conflict */</comment>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>jump_to_p2</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IfNoHope</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekHit</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SeekRowid P1 P2 P3 * *
** Synopsis: intkey=r[P3]
**
** P1 is the index of a cursor open on an SQL table btree (with integer
** keys).  If register P3 does not contain an integer or if P1 does not
** contain a record with rowid P3 then jump immediately to P2.  
** Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain
** a record with rowid P3 then 
** leave the cursor pointing at that record and fall through to the next
** instruction.
**
** The OP_NotExists opcode performs the same operation, but with OP_NotExists
** the P3 register must be guaranteed to contain an integer value.  With this
** opcode, register P3 might not contain an integer.
**
** The OP_NotFound opcode performs the same operation on index btrees
** (with arbitrary multi-value keys).
**
** This opcode leaves the cursor in a state where it cannot be advanced
** in either direction.  In other words, the Next and Prev opcodes will
** not work following this opcode.
**
** See also: Found, NotFound, NoConflict, SeekRowid
*/</comment>
<comment type="block">/* Opcode: NotExists P1 P2 P3 * *
** Synopsis: intkey=r[P3]
**
** P1 is the index of a cursor open on an SQL table btree (with integer
** keys).  P3 is an integer rowid.  If P1 does not contain a record with
** rowid P3 then jump immediately to P2.  Or, if P2 is 0, raise an
** SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then 
** leave the cursor pointing at that record and fall through to the next
** instruction.
**
** The OP_SeekRowid opcode performs the same operation but also allows the
** P3 register to contain a non-integer value, in which case the jump is
** always taken.  This opcode requires that P3 always contain an integer.
**
** The OP_NotFound opcode performs the same operation on index btrees
** (with arbitrary multi-value keys).
**
** This opcode leaves the cursor in a state where it cannot be advanced
** in either direction.  In other words, the Next and Prev opcodes will
** not work following this opcode.
**
** See also: Found, NotFound, NoConflict, SeekRowid
*/</comment>
<case>case <expr><name>OP_SeekRowid</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>iKey</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Int</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If pIn3-&gt;u.i does not contain an integer, compute iKey as the
    ** integer value of pIn3.  Jump to P2 if pIn3 cannot be converted
    ** into an integer without loss of information.  Take care to avoid
    ** changing the datatype of pIn3, however, as it is used by other
    ** parts of the prepared statement. */</comment>
    <decl_stmt><decl><type><name>Mem</name></type> <name>x</name> <init>= <expr><name><name>pIn3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>x</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <goto>goto <name>notExistsWithKey</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Fall through into OP_NotExists */</comment>
  <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
<case>case <expr><name>OP_NotExists</name></expr>:</case>          <comment type="block">/* jump, in3 */</comment>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
<label><name>notExistsWithKey</name>:</label>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekRowid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name>OP_SeekRowid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTableMoveto</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>res</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>  <comment type="block">/* Used by OP_Delete */</comment>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Sequence P1 P2 * * *
** Synopsis: r[P2]=cursor[P1].ctr++
**
** Find the next available sequence number for cursor P1.
** Write the sequence number into register P2.
** The sequence number on the cursor is incremented after this
** instruction.  
*/</comment>
<case>case <expr><name>OP_Sequence</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name>eCurType</name><operator>!=</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name>seqCount</name><operator>++</operator></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LIBSQL_ENABLE_WASM_RUNTIME</name></cpp:ifdef>
<comment type="block">/* Opcode: CreateWasmFunc P1 P2 P3 P4 *
** Synopsis: addWasmFunc[P4]
**
** Registers a user-defined WebAssembly function created with name stored in P4.
** Name size is stored in P2, and body size in P3. Body can be found right after
** the name's null terminator. P1 means that IF NOT EXISTS was passed.
*/</comment>
<case>case <expr><name>OP_CreateWasmFunc</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err_buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>try_instantiate_wasm_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>+</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err_buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>def</name></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"Registering Wasm function %s failed: %s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>err_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>err_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DropWasmFunc P1 * * P4 *
** Synopsis: dropWasmFunc[P4]
**
** Drops a user-defined WebAssembly function created with name stored in P4.
** P1 means that IF EXISTS was passed
*/</comment>
<case>case <expr><name>OP_DropWasmFunc</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>dropped</name> <init>= <expr><call><name>deregister_wasm_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>dropped</name></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"Function %s was not registered"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: NewRowid P1 P2 P3 * *
** Synopsis: r[P2]=rowid
**
** Get a new integer record number (a.k.a "rowid") used as the key to a table.
** The record number is not previously used as a key in the database
** table that cursor P1 points to.  The new record number is written
** written to register P2.
**
** If P3&gt;0 then P3 is a register in the root frame of this VDBE that holds 
** the largest previously generated record number. No new record numbers are
** allowed to be less than this value. When this value reaches its maximum, 
** an SQLITE_FULL error is generated. The P3 register is updated with the '
** generated record number. This P3 mechanism is used to help implement the
** AUTOINCREMENT feature.
*/</comment>
<case>case <expr><name>OP_NewRowid</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>                 <comment type="block">/* The new rowid */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>        <comment type="block">/* Cursor of table to get the new rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>               <comment type="block">/* Result of an sqlite3BtreeLast() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>               <comment type="block">/* Counter to limit the number of searches */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>             <comment type="block">/* Register holding largest rowid for AUTOINCREMENT */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>     <comment type="block">/* Root frame of VDBE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <block>{<block_content>
    <comment type="block">/* The next rowid or record number (different terms for the same
    ** thing) is obtained in a two-step algorithm.
    **
    ** First we attempt to find the largest existing rowid and add one
    ** to that.  But if the largest existing rowid is already the maximum
    ** positive integer, we have to fall through to the second
    ** probabilistic algorithm
    **
    ** The second algorithm is to select a rowid at random and see if
    ** it already exists in the table.  If it does not exist, we have
    ** succeeded.  If the random rowid does exist, we select a new one
    ** and try again, up to 100 times.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_32BIT_ROWID</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ROWID</name></cpp:macro> <cpp:value>0x7fffffff</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Some compilers complain about constants of the form 0x7fffffffffffffff.
    ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems
    ** to provide the constant while making all compilers happy.
    */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ROWID</name></cpp:macro>  <cpp:value>(i64)( (((u64)0x7fffffff)&lt;&lt;32) | (u64)0xffffffff )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* IMP: R-61914-48074 */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3BtreeIntegerKey</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><name>MAX_ROWID</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* IMP: R-29538-34987 */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>==</operator> <name>LIBSQL_RANDOM_ROWID_MARKER</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Assert that P3 is a valid memory cell. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <comment type="block">/* Assert that P3 is a valid memory cell. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Assert that P3 is a valid memory cell. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mem(P3) holds an integer */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><name>MAX_ROWID</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_FULL</name></expr>;</expr_stmt>   <comment type="block">/* IMP: R-17817-00630 */</comment>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* IMPLEMENTATION-OF: R-07677-41881 If the largest ROWID is equal to the
      ** largest possible integer (9223372036854775807) then the database
      ** engine starts picking positive candidate ROWIDs at random until
      ** it finds one that is not previously used. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* We cannot be in random rowid mode if this is
                             ** an AUTOINCREMENT table. */</comment>
      <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> <operator>&amp;=</operator> <operator>(</operator><name>MAX_ROWID</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Ensure that v is greater than zero */</comment>
      </block_content>}</block>while<condition>(  <expr><operator>(</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTableMoveto</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>v</name></expr></argument>,
                                                 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><operator>++</operator><name>cnt</name><operator>&lt;</operator><literal type="number">100</literal><operator>)</operator></expr>)</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_FULL</name></expr>;</expr_stmt>   <comment type="block">/* IMP: R-38219-53002 */</comment>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* EV: R-40812-03570 */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  </block_content>}</block>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Insert P1 P2 P3 P4 P5
** Synopsis: intkey=r[P3] data=r[P2]
**
** Write an entry into the table of cursor P1.  A new entry is
** created if it doesn't already exist or the data for an existing
** entry is overwritten.  The data is the value MEM_Blob stored in register
** number P2. The key is stored in register P3. The key must
** be a MEM_Int.
**
** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is
** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,
** then rowid is stored for subsequent return by the
** sqlite3_last_insert_rowid() function (otherwise it is unmodified).
**
** If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might
** run faster by avoiding an unnecessary seek on cursor P1.  However,
** the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior
** seeks on the cursor or if the most recent seek used a key equal to P3.
**
** If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an
** UPDATE operation.  Otherwise (if the flag is clear) then this opcode
** is part of an INSERT operation.  The difference is only important to
** the update hook.
**
** Parameter P4 may point to a Table structure, or may be NULL. If it is 
** not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked 
** following a successful insert.
**
** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
** allocated, then ownership of P2 is transferred to the pseudo-cursor
** and register P2 becomes ephemeral.  If the cursor is changed, the
** value of register P2 will then change.  Make sure this does not
** cause any problems.)
**
** This instruction only works on tables.  The equivalent instruction
** for indices is OP_IdxInsert.
*/</comment>
<case>case <expr><name>OP_Insert</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>       <comment type="block">/* MEM cell holding data for the record to be inserted */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>        <comment type="block">/* MEM cell holding key  for the record */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>   <comment type="block">/* Cursor to table into which insert is written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seekResult</name></decl>;</decl_stmt>   <comment type="block">/* Result of prior seek or 0 if no USESEEKRESULT flag */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>  <comment type="block">/* database name - used by the update hook */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>      <comment type="block">/* Table structure - used by update and pre-update hooks */</comment>
  <decl_stmt><decl><type><name>BtreePayload</name></type> <name>x</name></decl>;</decl_stmt>   <comment type="block">/* Payload to be inserted */</comment>

  <expr_stmt><expr><name>pData</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_ISNOOP</name><operator>)</operator> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_TABLE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>&gt;=</operator><name>P4_STATIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pKey</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nKey</name></name> <operator>=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_TABLE</name> <operator>&amp;&amp;</operator> <call><name>HAS_UPDATE_HOOK</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_ISNOOP</name><operator>)</operator> <operator>||</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
  <comment type="block">/* Invoke the pre-update hook, if any */</comment>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xPreUpdateCallback</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_ISUPDATE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbePreUpdateHook</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>pC</name></expr></argument>,<argument><expr><name>SQLITE_INSERT</name></expr></argument>,<argument><expr><name>zDb</name></expr></argument>,<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name><name>x</name><operator>.</operator><name>nKey</name></name></expr></argument>,<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Prevent post-update hook from running in cases when it should not */</comment>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_ISNOOP</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_LASTROWID</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>nKey</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pData</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pData</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pData</name></name> <operator>=</operator> <name><name>pData</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name><name>pData</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>seekResult</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_USESEEKRESULT</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <name><name>pData</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>BTREE_PREFORMAT</name><operator>==</operator><name>OPFLAG_PREFORMAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeInsert</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,
      <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_APPEND</name><operator>|</operator><name>OPFLAG_SAVEPOSITION</name><operator>|</operator><name>OPFLAG_PREFORMAT</name><operator>)</operator><operator>)</operator></expr></argument>, 
      <argument><expr><name>seekResult</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the update-hook if required. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name></expr></argument>,
           <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_ISUPDATE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_UPDATE</name></expr> </then><else>: <expr><name>SQLITE_INSERT</name></expr></else></ternary></expr></argument>,
           <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: RowCell P1 P2 P3 * *
**
** P1 and P2 are both open cursors. Both must be opened on the same type
** of table - intkey or index. This opcode is used as part of copying
** the current row from P2 into P1. If the cursors are opened on intkey
** tables, register P3 contains the rowid to use with the new record in
** P1. If they are opened on index tables, P3 is not used.
**
** This opcode must be followed by either an Insert or InsertIdx opcode
** with the OPFLAG_PREFORMAT flag set to complete the insert operation.
*/</comment>
<case>case <expr><name>OP_RowCell</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pDest</name></decl>;</decl_stmt>              <comment type="block">/* Cursor to write to */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>               <comment type="block">/* Cursor to read from */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>                       <comment type="block">/* Rowid value to insert with */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Insert</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxInsert</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Insert</name>    <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxInsert</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>&amp;</operator> <name>OPFLAG_PREFORMAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iKey</name> <operator>=</operator> <ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> ?</condition><then> <expr><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTransferRow</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>

<comment type="block">/* Opcode: Delete P1 P2 P3 P4 P5
**
** Delete the record at which the P1 cursor is currently pointing.
**
** If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then
** the cursor will be left pointing at  either the next or the previous
** record in the table. If it is left pointing at the next record, then
** the next Next instruction will be a no-op. As a result, in this case
** it is ok to delete a record from within a Next loop. If 
** OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be
** left in an undefined state.
**
** If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this
** delete one of several associated with deleting a table row and all its
** associated index entries.  Exactly one of those deletes is the "primary"
** delete.  The others are all on OPFLAG_FORDELETE cursors or else are
** marked with the AUXDELETE flag.
**
** If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row
** change count is incremented (otherwise not).
**
** P1 must not be pseudo-table.  It has to be a real table with
** multiple rows.
**
** If P4 is not NULL then it points to a Table object. In this case either 
** the update or pre-update hook, or both, may be invoked. The P1 cursor must
** have been positioned using OP_NotFound prior to invoking this opcode in 
** this case. Specifically, if one is configured, the pre-update hook is 
** invoked if P4 is not NULL. The update-hook is invoked if one is configured, 
** P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.
**
** If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address
** of the memory cell that contains the value that the rowid of the row will
** be set to by the update.
*/</comment>
<case>case <expr><name>OP_Delete</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>opflags</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>opflags</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_TABLE</name>
   <operator>&amp;&amp;</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeCursorIsValidNN</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* If p5 is zero, the seek operation that positioned the cursor prior to
    ** OP_Delete will have also set the pC-&gt;movetoTarget field to the rowid of
    ** the row that is being deleted */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name> <init>= <expr><call><name>sqlite3BtreeIntegerKey</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name><operator>==</operator><name>iKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the update-hook or pre-update-hook will be invoked, set zDb to
  ** the name of the db to pass as to it. Also set local pTab to a copy
  ** of p4.pTab. Finally, if p5 is true, indicating that this cursor was
  ** last moved with OP_Next or OP_Prev, not Seek or NotFound, set 
  ** VdbeCursor.movetoTarget to the current rowid.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_TABLE</name> <operator>&amp;&amp;</operator> <call><name>HAS_UPDATE_HOOK</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_SAVEPOSITION</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <call><name>sqlite3BtreeIntegerKey</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
  <comment type="block">/* Invoke the pre-update-hook if required. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>xPreUpdateCallback</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pTab</name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xPreUpdateCallback</name></name> <operator>&amp;&amp;</operator> <name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name>opflags</name> <operator>&amp;</operator> <name>OPFLAG_ISUPDATE</name><operator>)</operator> 
         <operator>||</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> 
         <operator>||</operator> <operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbePreUpdateHook</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>opflags</name> <operator>&amp;</operator> <name>OPFLAG_ISUPDATE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_UPDATE</name></expr> </then><else>: <expr><name>SQLITE_DELETE</name></expr></else></ternary></expr></argument>, 
        <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr></argument>,
        <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>opflags</name> <operator>&amp;</operator> <name>OPFLAG_ISNOOP</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 
  <comment type="block">/* Only flags that can be set are SAVEPOISTION and AUXDELETE */</comment> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>OPFLAG_SAVEPOSITION</name><operator>|</operator><name>OPFLAG_AUXDELETE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_SAVEPOSITION</name><operator>==</operator><name>BTREE_SAVEPOSITION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_AUXDELETE</name><operator>==</operator><name>BTREE_AUXDELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_AUXDELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>wrFlag</name></name> <operator>&amp;</operator> <name>OPFLAG_FORDELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
      <expr_stmt><expr><name>nExtraDelete</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nExtraDelete</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeDelete</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Invoke the update-hook if required. */</comment>
  <if_stmt><if>if<condition>( <expr><name>opflags</name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
          <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <break>break;</break>
</block_content>}</block>
<comment type="block">/* Opcode: ResetCount * * * * *
**
** The value of the change counter is copied to the database handle
** change counter (returned by subsequent calls to sqlite3_changes()).
** Then the VMs internal change counter resets to 0.
** This is used by trigger programs.
*/</comment>
<case>case <expr><name>OP_ResetCount</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SorterCompare P1 P2 P3 P4
** Synopsis: if key(P1)!=trim(r[P3],P4) goto P2
**
** P1 is a sorter cursor. This instruction compares a prefix of the
** record blob in register P3 against a prefix of the entry that 
** the sorter cursor currently points to.  Only the first P4 fields
** of r[P3] and the sorter record are compared.
**
** If either P3 or the sorter contains a NULL in one of their significant
** fields (not counting the P4 fields at the end which are ignored) then
** the comparison is assumed to be equal.
**
** Fall through to next instruction if the two records compare equal to
** each other.  Jump to P2 if they are different.
*/</comment>
<case>case <expr><name>OP_SorterCompare</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKeyCol</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterCompare</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>nKeyCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>

<comment type="block">/* Opcode: SorterData P1 P2 P3 * *
** Synopsis: r[P2]=data
**
** Write into register P2 the current sorter data for sorter cursor P1.
** Then clear the column header cache on cursor P3.
**
** This opcode is normally use to move a record out of the sorter and into
** a register that is the source for a pseudo-table cursor created using
** OpenPseudo.  That pseudo-table cursor is the one that is identified by
** parameter P3.  Clearing the P3 column cache as part of this opcode saves
** us from having to issue a separate NullRow instruction to clear that cache.
*/</comment>
<case>case <expr><name>OP_SorterData</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterRowkey</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>-&gt;</operator><name>cacheStatus</name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: RowData P1 P2 P3 * *
** Synopsis: r[P2]=data
**
** Write into register P2 the complete row content for the row at 
** which cursor P1 is currently pointing.
** There is no interpretation of the data.  
** It is just copied onto the P2 register exactly as 
** it is found in the database file.
**
** If cursor P1 is an index, then the content is the key of the row.
** If cursor P2 is a table, then the content extracted is the data.
**
** If the P1 cursor must be pointing to a valid row (not a NULL row)
** of a real table, not a pseudo-table.
**
** If P3!=0 then this opcode is allowed to make an ephemeral pointer
** into the database page.  That means that the content of the output
** register will be invalidated as soon as the cursor moves - including
** moves caused by other cursors that "save" the current cursors
** position in order that they can write to the same table.  If P3==0
** then a copy of the data is made into memory.  P3!=0 is faster, but
** P3==0 is safer.
**
** If P3!=0 then the content of the P2 register is unsuitable for use
** in OP_Result and any OP_Result will invalidate the P2 register content.
** The P2 register content is invalidated by opcodes like OP_Function or
** by any use of another cursor pointing to the same table.
*/</comment>
<case>case <expr><name>OP_RowData</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>

  <comment type="block">/* The OP_RowData opcodes always follow OP_NotExists or
  ** OP_SeekRowid or OP_Rewind/Op_Next with no intervening instructions
  ** that might invalidate the cursor.
  ** If this where not the case, on of the following assert()s
  ** would fail.  Should this ever change (because of changes in the code
  ** generator) then the fix would be to insert a call to
  ** sqlite3VdbeCursorMoveto().
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtreeZeroOffset</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Rowid P1 P2 * * *
** Synopsis: r[P2]=PX rowid of P1
**
** Store in register P2 an integer which is the key of the table entry that
** P1 is currently point to.
**
** P1 can be either an ordinary table or a virtual table.  There used to
** be a separate OP_VRowid opcode for use with virtual tables, but this
** one opcode now works for both table types.
*/</comment>
<case>case <expr><name>OP_Rowid</name></expr>:</case> <block>{<block_content>                 <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_PSEUDO</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xRowid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xRowid</name></name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCursorRestore</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3BtreeIntegerKey</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: NullRow P1 * * * *
**
** Move the cursor P1 to a null row.  Any OP_Column operations
** that occur while the cursor is on the null row will always
** write a NULL.
**
** If cursor P1 is not previously opened, open it now to a special
** pseudo-cursor that always returns NULL for every column.
*/</comment>
<case>case <expr><name>OP_NullRow</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pC</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the cursor is not already open, create a special kind of
    ** pseudo-cursor that always gives null rows. */</comment>
    <expr_stmt><expr><name>pC</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CURTYPE_PSEUDO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pC</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>noReuse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name> <operator>=</operator> <call><name>sqlite3BtreeFakeValidCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name>OP_NullRow</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SeekEnd P1 * * * *
**
** Position cursor P1 at the end of the btree for the purpose of
** appending a new entry onto the btree.
**
** It is assumed that the cursor is used only for appending and so
** if the cursor is valid, then the cursor must already be pointing
** at the end of the btree and so no changes are made to
** the cursor.
*/</comment>
<comment type="block">/* Opcode: Last P1 P2 * * *
**
** The next use of the Rowid or Column or Prev instruction for P1 
** will refer to the last entry in the database table or index.
** If the table or index is empty and P2&gt;0, then jump immediately to P2.
** If P2 is 0 or if the table or index is not empty, fall through
** to the following instruction.
**
** This opcode leaves the cursor configured to move in reverse order,
** from the end toward the beginning.  In other words, the cursor is
** configured to use Prev, not Next.
*/</comment>
<case>case <expr><name>OP_SeekEnd</name></expr>:</case>
<case>case <expr><name>OP_Last</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeCursorIsValidNN</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IfSmaller P1 P2 P3 * *
**
** Estimate the number of rows in the table P1.  Jump to P2 if that
** estimate is less than approximately 2**(0.1*P3).
*/</comment>
<case>case <expr><name>OP_IfSmaller</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>sz</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeFirst</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3BtreeRowCountEst</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>sz</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: SorterSort P1 P2 * * *
**
** After all records have been inserted into the Sorter object
** identified by P1, invoke this opcode to actually do the sorting.
** Jump to P2 if there are no records to be sorted.
**
** This opcode is an alias for OP_Sort and OP_Rewind that is used
** for Sorter objects.
*/</comment>
<comment type="block">/* Opcode: Sort P1 P2 * * *
**
** This opcode does exactly the same thing as OP_Rewind except that
** it increments an undocumented global variable used for testing.
**
** Sorting is accomplished by writing records into a sorting index,
** then rewinding that index and playing it back from beginning to
** end.  We use the OP_Sort opcode instead of OP_Rewind to do the
** rewinding so that the global variable will be incremented and
** regression tests can determine whether or not the optimizer is
** correctly optimizing out sorts.
*/</comment>
<case>case <expr><name>OP_SorterSort</name></expr>:</case>    <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_Sort</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_sort_count</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3_search_count</name><operator>--</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_SORT</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
  <comment type="block">/* Fall through into OP_Rewind */</comment>
  <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
</block_content>}</block>
<comment type="block">/* Opcode: Rewind P1 P2 * * *
**
** The next use of the Rowid or Column or Next instruction for P1 
** will refer to the first entry in the database table or index.
** If the table or index is empty, jump immediately to P2.
** If the table or index is not empty, fall through to the following 
** instruction.
**
** This opcode leaves the cursor configured to move in forward order,
** from the beginning toward the end.  In other words, the cursor is
** configured to use Next, not Prev.
*/</comment>
<case>case <expr><name>OP_Rewind</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SorterSort</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name>OP_Rewind</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterRewind</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeFirst</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Next P1 P2 P3 * P5
**
** Advance cursor P1 so that it points to the next key/data pair in its
** table or index.  If there are no more key/value pairs then fall through
** to the following instruction.  But if the cursor advance was successful,
** jump immediately to P2.
**
** The Next opcode is only valid following an SeekGT, SeekGE, or
** OP_Rewind opcode used to position the cursor.  Next is not allowed
** to follow SeekLT, SeekLE, or OP_Last.
**
** The P1 cursor must be for a real table, not a pseudo-table.  P1 must have
** been opened prior to this opcode or the program will segfault.
**
** The P3 value is a hint to the btree implementation. If P3==1, that
** means P1 is an SQL index and that this instruction could have been
** omitted if that index had been unique.  P3 is usually 0.  P3 is
** always either 0 or 1.
**
** If P5 is positive and the jump is taken, then event counter
** number P5-1 in the prepared statement is incremented.
**
** See also: Prev
*/</comment>
<comment type="block">/* Opcode: Prev P1 P2 P3 * P5
**
** Back up cursor P1 so that it points to the previous key/data pair in its
** table or index.  If there is no previous key/value pairs then fall through
** to the following instruction.  But if the cursor backup was successful,
** jump immediately to P2.
**
**
** The Prev opcode is only valid following an SeekLT, SeekLE, or
** OP_Last opcode used to position the cursor.  Prev is not allowed
** to follow SeekGT, SeekGE, or OP_Rewind.
**
** The P1 cursor must be for a real table, not a pseudo-table.  If P1 is
** not open then the behavior is undefined.
**
** The P3 value is a hint to the btree implementation. If P3==1, that
** means P1 is an SQL index and that this instruction could have been
** omitted if that index had been unique.  P3 is usually 0.  P3 is
** always either 0 or 1.
**
** If P5 is positive and the jump is taken, then event counter
** number P5-1 in the prepared statement is incremented.
*/</comment>
<comment type="block">/* Opcode: SorterNext P1 P2 * * P5
**
** This opcode works just like OP_Next except that P1 must be a
** sorter object for which the OP_SorterSort opcode has been
** invoked.  This opcode advances the cursor to the next sorted
** record, or jumps to P2 if there are no more sorted records.
*/</comment>
<case>case <expr><name>OP_SorterNext</name></expr>:</case> <block>{<block_content>  <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterNext</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>next_tail</name>;</goto>

<case>case <expr><name>OP_Prev</name></expr>:</case>          <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>SQLITE_STMTSTATUS_AUTOINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekLT</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekLE</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_Last</name>   <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_IfNoHope</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_NullRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>next_tail</name>;</goto>

<case>case <expr><name>OP_Next</name></expr>:</case>          <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>SQLITE_STMTSTATUS_AUTOINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekGT</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekGE</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_Rewind</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_Found</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_NullRow</name><operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekRowid</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_IfNoHope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>next_tail</name>:</label>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_search_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: IdxInsert P1 P2 P3 P4 P5
** Synopsis: key=r[P2]
**
** Register P2 holds an SQL index key made using the
** MakeRecord instructions.  This opcode writes that key
** into the index P1.  Data for the entry is nil.
**
** If P4 is not zero, then it is the number of values in the unpacked
** key of reg(P2).  In that case, P3 is the index of the first register
** for the unpacked key.  The availability of the unpacked key can sometimes
** be an optimization.
**
** If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer
** that this insert is likely to be an append.
**
** If P5 has the OPFLAG_NCHANGE bit set, then the change counter is
** incremented by this instruction.  If the OPFLAG_NCHANGE bit is clear,
** then the change counter is unchanged.
**
** If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might
** run faster by avoiding an unnecessary seek on cursor P1.  However,
** the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior
** seeks on the cursor or if the most recent seek used a key equivalent
** to P2. 
**
** This instruction only works for indices.  The equivalent instruction
** for tables is OP_Insert.
*/</comment>
<case>case <expr><name>OP_IdxInsert</name></expr>:</case> <block>{<block_content>        <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtreePayload</name></type> <name>x</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_PREFORMAT</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nKey</name></name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pKey</name></name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <name>aMem</name> <operator>+</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nMem</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeInsert</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,
       <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_APPEND</name><operator>|</operator><name>OPFLAG_SAVEPOSITION</name><operator>|</operator><name>OPFLAG_PREFORMAT</name><operator>)</operator><operator>)</operator></expr></argument>, 
      <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_USESEEKRESULT</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SorterInsert P1 P2 * * *
** Synopsis: key=r[P2]
**
** Register P2 holds an SQL index key made using the
** MakeRecord instructions.  This opcode writes that key
** into the sorter P1.  Data for the entry is nil.
*/</comment>
<case>case <expr><name>OP_SorterInsert</name></expr>:</case> <block>{<block_content>     <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterWrite</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IdxDelete P1 P2 P3 * P5
** Synopsis: key=r[P2@P3]
**
** The content of P3 registers starting at register P2 form
** an unpacked index key. This opcode removes that entry from the 
** index opened by cursor P1.
**
** If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error
** if no matching index entry is found.  This happens when running
** an UPDATE or DELETE statement and the index entry to be updated
** or deleted is not found.  For some uses of IdxDelete
** (example:  the EXCEPT operator) it does not matter that no matching
** entry is found.  For those cases, P5 is zero.  Also, do not raise
** this (self-correcting and non-critical) error if in writable_schema mode.
*/</comment>
<case>case <expr><name>OP_IdxDelete</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIndexMoveto</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeDelete</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name>BTREE_AUXDELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT_INDEX</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><literal type="string">"index corruption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DeferredSeek P1 * P3 P4 *
** Synopsis: Move P3 to P1.rowid if needed
**
** P1 is an open index cursor and P3 is a cursor on the corresponding
** table.  This opcode does a deferred seek of the P3 table cursor
** to the row that corresponds to the current row of P1.
**
** This is a deferred seek.  Nothing actually happens until
** the cursor is used to read a record.  That way, if no reads
** occur, no unnecessary I/O happens.
**
** P4 may be an array of integers (type P4_INTARRAY) containing
** one entry for each column in the P3 table.  If array entry a(i)
** is non-zero, then reading column a(i)-1 from cursor P3 is 
** equivalent to performing the deferred seek and then reading column i 
** from P1.  This information is stored in P3 and used to redirect
** reads against P3 over to P1, thus possibly avoiding the need to
** seek and read cursor P3.
*/</comment>
<comment type="block">/* Opcode: IdxRowid P1 P2 * * *
** Synopsis: r[P2]=rowid
**
** Write into register P2 an integer which is the last entry in the record at
** the end of the index key pointed to by cursor P1.  This integer should be
** the rowid of the table entry to which this index entry points.
**
** See also: Rowid, MakeRecord.
*/</comment>
<case>case <expr><name>OP_DeferredSeek</name></expr>:</case>
<case>case <expr><name>OP_IdxRowid</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>             <comment type="block">/* The P1 index cursor */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pTabCur</name></decl>;</decl_stmt>        <comment type="block">/* The P2 table cursor (OP_DeferredSeek only) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>rowid</name></decl>;</decl_stmt>                  <comment type="block">/* Rowid that P1 current points to */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name> <operator>||</operator> <call><name>IsNullCursor</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>IsNullCursor</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The IdxRowid and Seek opcodes are combined because of the commonality
  ** of sqlite3VdbeCursorRestore() and sqlite3VdbeIdxRowid(). */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCursorRestore</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* sqlite3VdbeCursorRestore() may fail if the cursor has been disturbed
  ** since it was last positioned and an error (e.g. OOM or an IO error)
  ** occurs while trying to reposition it. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only used to silence a warning. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeIdxRowid</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_DeferredSeek</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTabCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INTARRAY</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pTabCur</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>ub</name><operator>.</operator><name>aAltMap</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>pAltCursor</name></name> <operator>=</operator> <name>pC</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: FinishSeek P1 * * * *
** 
** If cursor P1 was previously moved via OP_DeferredSeek, complete that
** seek operation now, without further delay.  If the cursor seek has
** already occurred, this instruction is a no-op.
*/</comment>
<case>case <expr><name>OP_FinishSeek</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>             <comment type="block">/* The P1 index cursor */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeFinishMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IdxGE P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY.  Compare this key value against the index 
** that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID 
** fields at the end.
**
** If the P1 index entry is greater than or equal to the key value
** then jump to P2.  Otherwise fall through to the next instruction.
*/</comment>
<comment type="block">/* Opcode: IdxGT P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY.  Compare this key value against the index 
** that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID 
** fields at the end.
**
** If the P1 index entry is greater than the key value
** then jump to P2.  Otherwise fall through to the next instruction.
*/</comment>
<comment type="block">/* Opcode: IdxLT P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY or ROWID.  Compare this key value against
** the index that P1 is currently pointing to, ignoring the PRIMARY KEY or
** ROWID on the P1 index.
**
** If the P1 index entry is less than the key value then jump to P2.
** Otherwise fall through to the next instruction.
*/</comment>
<comment type="block">/* Opcode: IdxLE P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY or ROWID.  Compare this key value against
** the index that P1 is currently pointing to, ignoring the PRIMARY KEY or
** ROWID on the P1 index.
**
** If the P1 index entry is less than or equal to the key value then jump
** to P2. Otherwise fall through to the next instruction.
*/</comment>
<case>case <expr><name>OP_IdxLE</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_IdxGT</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_IdxLT</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_IdxGE</name></expr>:</case>  <block>{<block_content>       <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isOrdered</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>&lt;</operator><name>OP_IdxLT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Inlined version of sqlite3VdbeIdxKeyCompare() */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCellKey</name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* nCellKey will always be between 0 and 0xffffffff because of the way
    ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */</comment>
    <if_stmt><if>if<condition>( <expr><name>nCellKey</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>nCellKey</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtreeZeroOffset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>nCellKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
  <comment type="block">/* End of inlined sqlite3VdbeIdxKeyCompare() */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>OP_IdxLE</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_IdxLT</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>OP_IdxGE</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_IdxGT</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_IdxLT</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><name>res</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Destroy P1 P2 P3 * *
**
** Delete an entire database table or index whose root page in the database
** file is given by P1.
**
** The table being destroyed is in the main database file if P3==0.  If
** P3==1 then the table to be clear is in the auxiliary database file
** that is used to store tables create using CREATE TEMPORARY TABLE.
**
** If AUTOVACUUM is enabled then it is possible that another root page
** might be moved into the newly deleted root page in order to keep all
** root pages contiguous at the beginning of the database.  The former
** value of the root page that moved - its value before the move occurred -
** is stored in register P2. If no page movement was required (because the
** table being dropped was already the last one in the database) then a 
** zero is stored in register P2.  If AUTOVACUUM is disabled then a zero 
** is stored in register P2.
**
** This opcode throws an error if there are any active reader VMs when
** it is invoked. This is done to avoid the difficulty associated with 
** updating existing cursors when a root page is moved in an AUTOVACUUM 
** database. This error is thrown even if the database is not an AUTOVACUUM 
** db in order to avoid introducing an incompatibility between autovacuum 
** and non-autovacuum modes.
**
** See also: Clear
*/</comment>
<case>case <expr><name>OP_Destroy</name></expr>:</case> <block>{<block_content>     <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMoved</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name> <operator>&gt;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVDestroy</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMoved</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only to silence a warning. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeDropTable</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iMoved</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>iMoved</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RootPageMoved</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iMoved</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* All OP_Destroy operations occur on the same btree */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>resetSchemaOnFault</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>resetSchemaOnFault</name><operator>==</operator><name>iDb</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>resetSchemaOnFault</name> <operator>=</operator> <name>iDb</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Clear P1 P2 P3
**
** Delete all contents of the database table or index whose root page
** in the database file is given by P1.  But, unlike Destroy, do not
** remove the table or index from the database file.
**
** The table being clear is in the main database file if P2==0.  If
** P2==1 then the table to be clear is in the auxiliary database file
** that is used to store tables create using CREATE TEMPORARY TABLE.
**
** If the P3 value is non-zero, then the row change count is incremented
** by the number of rows in the table being cleared. If P3 is greater
** than zero, then the value stored in register P3 is also incremented
** by the number of rows in the table being cleared.
**
** See also: Destroy
*/</comment>
<case>case <expr><name>OP_Clear</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nChange</name></decl>;</decl_stmt>
 
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nChange</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeClearTable</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>+=</operator> <name>nChange</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <name>nChange</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ResetSorter P1 * * * *
**
** Delete all contents from the ephemeral table or sorter
** that is open on cursor P1.
**
** This opcode only works for cursors used for sorting and
** opened with OP_OpenEphemeral or OP_SorterOpen.
*/</comment>
<case>case <expr><name>OP_ResetSorter</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeSorterReset</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeClearTableOfCursor</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: CreateBtree P1 P2 P3 * *
** Synopsis: r[P2]=root iDb=P1 flags=P3
**
** Allocate a new b-tree in the main database file if P1==0 or in the
** TEMP database file if P1==1 or in an attached database if
** P1&gt;1.  The P3 argument must be 1 (BTREE_INTKEY) for a rowid table
** it must be 2 (BTREE_BLOBKEY) for an index or WITHOUT ROWID table.
** The root page number of the new b-tree is stored in register P2.
*/</comment>
<case>case <expr><name>OP_CreateBtree</name></expr>:</case> <block>{<block_content>          <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pgno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>BTREE_INTKEY</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>BTREE_BLOBKEY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCreateTable</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SqlExec * * * P4 *
**
** Run the SQL statement or statements specified in the P4 string.
*/</comment>
<case>case <expr><name>OP_SqlExec</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSqlExec</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSqlExec</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ParseSchema P1 * * P4 *
**
** Read and parse all entries from the schema table of database P1
** that match the WHERE clause P4.  If P4 is a NULL pointer, then the
** entire schema for P1 is reparsed.
**
** This opcode invokes the parser to create a new virtual machine,
** then runs the new virtual machine.  It is thus a re-entrant opcode.
*/</comment>
<case>case <expr><name>OP_ParseSchema</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>InitData</name></type> <name>initData</name></decl>;</decl_stmt>

  <comment type="block">/* Any prepared statement that invokes this opcode will hold mutexes
  ** on every btree.  This is a prerequisite for invoking 
  ** sqlite3InitCallback().
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>iDb</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>iDb</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbHasProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>DB_SchemaLoaded</name></expr></argument>)</argument_list></call>
           <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name>
           <operator>||</operator> <operator>(</operator><name>CORRUPT_DB</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_NoSchemaError</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SchemaClear</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DBFLAG_SchemaKnownOk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3InitOne</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_SchemaChange</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <name>LEGACY_SCHEMA_TABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>pzErrMsg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>mInitFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>mxPage</name></name> <operator>=</operator> <call><name>sqlite3BtreeLastPage</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
       <argument><expr><literal type="string">"SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid"</literal></expr></argument>,
       <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>nInitRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>sqlite3InitCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>initData</name><operator>.</operator><name>rc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>initData</name><operator>.</operator><name>nInitRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* The OP_ParseSchema opcode with a non-NULL P4 argument should parse
        ** at least one SQL statement. Any less than that indicates that
        ** the sqlite_schema table is corrupt. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>  
</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_ANALYZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: LoadAnalysis P1 * * * *
**
** Read the sqlite_stat1 table for database P1 and load the content
** of that table into the internal index hash table.  This will cause
** the analysis to be used when preparing all subsequent queries.
*/</comment>
<case>case <expr><name>OP_LoadAnalysis</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3AnalysisLoad</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>  
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_ANALYZE) */</comment>

<comment type="block">/* Opcode: DropTable P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the table named P4 in database P1.  This is called after a table
** is dropped from disk (using the Destroy opcode) in order to keep 
** the internal representation of the
** schema consistent with what is on disk.
*/</comment>
<case>case <expr><name>OP_DropTable</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DropIndex P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the index named P4 in database P1.  This is called after an index
** is dropped from disk (using the Destroy opcode)
** in order to keep the internal representation of the
** schema consistent with what is on disk.
*/</comment>
<case>case <expr><name>OP_DropIndex</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DropTrigger P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the trigger named P4 in database P1.  This is called after a trigger
** is dropped from disk (using the Destroy opcode) in order to keep 
** the internal representation of the
** schema consistent with what is on disk.
*/</comment>
<case>case <expr><name>OP_DropTrigger</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/* Opcode: IntegrityCk P1 P2 P3 P4 P5
**
** Do an analysis of the currently open database.  Store in
** register P1 the text of an error message describing any problems.
** If no problems are found, store a NULL in register P1.
**
** The register P3 contains one less than the maximum number of allowed errors.
** At most reg(P3) errors will be reported.
** In other words, the analysis stops as soon as reg(P1) errors are 
** seen.  Reg(P1) is updated with the number of errors remaining.
**
** The root page numbers of all tables in the database are integers
** stored in P4_INTARRAY argument.
**
** If P5 is not zero, the check is done on the auxiliary database
** file, not the main database file.
**
** This opcode is used to implement the integrity_check pragma.
*/</comment>
<case>case <expr><name>OP_IntegrityCk</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name></decl>;</decl_stmt>      <comment type="block">/* Number of tables to check.  (Number of root pages.) */</comment>
  <decl_stmt><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>aRoot</name></decl>;</decl_stmt>    <comment type="block">/* Array of rootpage numbers for tables to be checked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>       <comment type="block">/* Number of errors reported */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>        <comment type="block">/* Text of the error report */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pnErr</name></decl>;</decl_stmt>     <comment type="block">/* Register keeping track of errors remaining */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nRoot</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aRoot</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRoot</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aRoot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><operator>(</operator><name>Pgno</name><operator>)</operator><name>nRoot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pnErr</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pnErr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pnErr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3BtreeIntegrityCheck</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRoot</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pnErr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nErr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pnErr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>-=</operator> <name>nErr</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<comment type="block">/* Opcode: RowSetAdd P1 P2 * * *
** Synopsis: rowset(P1)=r[P2]
**
** Insert the integer value held by register P2 into a RowSet object
** held in register P1.
**
** An assertion fails if P2 is not an integer.
*/</comment>
<case>case <expr><name>OP_RowSetAdd</name></expr>:</case> <block>{<block_content>       <comment type="block">/* in1, in2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemSetRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RowSetInsert</name><argument_list>(<argument><expr><operator>(</operator><name>RowSet</name><operator>*</operator><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: RowSetRead P1 P2 P3 * *
** Synopsis: r[P3]=rowset(P1)
**
** Extract the smallest value from the RowSet object in P1
** and put that value into register P3.
** Or, if RowSet object P1 is initially empty, leave P3
** unchanged and jump to instruction P2.
*/</comment>
<case>case <expr><name>OP_RowSetRead</name></expr>:</case> <block>{<block_content>       <comment type="block">/* jump, in1, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>val</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
   <operator>||</operator> <call><name>sqlite3RowSetNext</name><argument_list>(<argument><expr><operator>(</operator><name>RowSet</name><operator>*</operator><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* The boolean index is empty */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* A value was pulled from the index */</comment>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: RowSetTest P1 P2 P3 P4
** Synopsis: if r[P3] in rowset(P1) goto P2
**
** Register P3 is assumed to hold a 64-bit integer value. If register P1
** contains a RowSet object and that RowSet object contains
** the value held in P3, jump to register P2. Otherwise, insert the
** integer in P3 into the RowSet and continue on to the
** next opcode.
**
** The RowSet object is optimized for the case where sets of integers
** are inserted in distinct phases, which each set contains no duplicates.
** Each set is identified by a unique P4 value. The first set
** must have P4==0, the final set must have P4==-1, and for all other sets
** must have P4&gt;0.
**
** This allows optimizations: (a) when P4==0 there is no need to test
** the RowSet object for P3, as it is guaranteed not to contain it,
** (b) when P4==-1 there is no need to insert the value, as it will
** never be tested for, and (c) when a value that is part of set X is
** inserted, there is no need to search to see if the same value was
** previously inserted as part of set X (only if it was previously
** inserted as part of some other set).
*/</comment>
<case>case <expr><name>OP_RowSetTest</name></expr>:</case> <block>{<block_content>                     <comment type="block">/* jump, in1, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSet</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is anything other than a rowset object in memory cell P1,
  ** delete it now and initialize P1 with an empty rowset
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemSetRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSet</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>iSet</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>exists</name> <operator>=</operator> <call><name>sqlite3RowSetTest</name><argument_list>(<argument><expr><operator>(</operator><name>RowSet</name><operator>*</operator><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>iSet</name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>exists</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>exists</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSet</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RowSetInsert</name><argument_list>(<argument><expr><operator>(</operator><name>RowSet</name><operator>*</operator><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>

<comment type="block">/* Opcode: Program P1 P2 P3 P4 P5
**
** Execute the trigger program passed as P4 (type P4_SUBPROGRAM). 
**
** P1 contains the address of the memory cell that contains the first memory 
** cell in an array of values used as arguments to the sub-program. P2 
** contains the address to jump to if the sub-program throws an IGNORE 
** exception using the RAISE() function. Register P3 contains the address 
** of a memory cell in this (the parent) VM that is used to allocate the 
** memory required by the sub-vdbe at runtime.
**
** P4 is a pointer to the VM containing the trigger program.
**
** If P5 is non-zero, then recursive program invocation is enabled.
*/</comment>
<case>case <expr><name>OP_Program</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMem</name></decl>;</decl_stmt>               <comment type="block">/* Number of memory registers for sub-program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>              <comment type="block">/* Bytes of runtime space required for sub-program */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRt</name></decl>;</decl_stmt>               <comment type="block">/* Register to allocate runtime space */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>              <comment type="block">/* Used to iterate through memory cells */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>              <comment type="block">/* Last memory cell in new array */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>      <comment type="block">/* New vdbe frame to execute in */</comment>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier></type><name>pProgram</name></decl>;</decl_stmt>   <comment type="block">/* Sub-program to execute */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>                <comment type="block">/* Token identifying trigger */</comment>

  <expr_stmt><expr><name>pProgram</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRt</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the p5 flag is clear, then recursive invocation of triggers is 
  ** disabled for backwards compatibility (p5 is set if this sub-program
  ** is really a trigger, not a foreign key action, and the flag set
  ** and cleared by the "PRAGMA recursive_triggers" command is clear).
  ** 
  ** It is recursive invocation of triggers, at the SQL level, that is 
  ** disabled. In some cases a single trigger may generate more than one 
  ** SubProgram (if the trigger may be executed with more than one different 
  ** ON CONFLICT algorithm). SubProgram structures associated with a
  ** single trigger all have the same value for the SubProgram.token 
  ** variable.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>token</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name>pFrame</name> <operator>&amp;&amp;</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>token</name></name><operator>!=</operator><name>t</name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <if_stmt><if>if<condition>( <expr><name>pFrame</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_TRIGGER_DEPTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"too many levels of trigger recursion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register pRt is used to store the memory required to save the state
  ** of the current program, and the memory required at runtime to execute
  ** the trigger program. If this trigger has been fired before, then pRt 
  ** is already allocated. Otherwise, it must be initialized.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRt</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* SubProgram.nMem is set to the number of memory cells used by the 
    ** program stored in SubProgram.aOp. As well as these, one memory
    ** cell is required for each cursor used by the program. Set local
    ** variable nMem (and later, VdbeFrame.nChildMem) to this value.
    */</comment>
    <expr_stmt><expr><name>nMem</name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMem</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMem</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
              <operator>+</operator> <name>nMem</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof>
              <operator>+</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name><operator>*</operator></expr></argument>)</argument_list></sizeof>
              <operator>+</operator> <operator>(</operator><name><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pFrame</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pRt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRt</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name><operator>|</operator><name>MEM_Dyn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRt</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pFrame</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRt</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRt</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>sqlite3VdbeFrameMemDel</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name> <operator>=</operator> <name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChildCsr</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nOp</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>token</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>token</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>iFrameMagic</name></name> <operator>=</operator> <name>SQLITE_FRAME_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <operator>&amp;</operator><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call><index>[<expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name></expr>]</index></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pMem</name><operator>=</operator><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pMem</name><operator>!=</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pMem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <operator>(</operator><name>VdbeFrame</name><operator>*</operator><operator>)</operator><name><name>pRt</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRt</name><operator>-&gt;</operator><name>xDel</name></name><operator>==</operator><name>sqlite3VdbeFrameMemDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pProgram</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name> 
        <operator>||</operator> <operator>(</operator><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildCsr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nDbChange</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pAuxData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pAuxData</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>=</operator> <name>pFrame</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <name>aMem</name> <operator>=</operator> <call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildCsr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <operator>(</operator><name>VdbeCursor</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aOnce</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aOnce</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name>aOp</name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Verify that second and subsequent executions of the same trigger do not
  ** try to reuse register values from the first use. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pScopyFrom</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Prevent false-positive AboutToChange() errs */</comment>
      <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MEM_Undefined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Fault if this reg is reused */</comment>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Param P1 P2 * * *
**
** This opcode is only ever present in sub-programs called via the 
** OP_Program instruction. Copy a value currently stored in a memory 
** cell of the calling (parent) frame to cell P2 in the current frames 
** address space. This is used by trigger programs to access the new.* 
** and old.* values.
**
** The address of the cell in the parent frame is determined by adding
** the value of the P1 argument to the value of the P1 argument to the
** calling OP_Program instruction.
*/</comment>
<case>case <expr><name>OP_Param</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn</name> <operator>=</operator> <operator>&amp;</operator><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>+</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name></expr>]</index></name><operator>.</operator><name>p1</name></expr>]</index></name></expr>;</expr_stmt>   
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_TRIGGER */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
<comment type="block">/* Opcode: FkCounter P1 P2 * * *
** Synopsis: fkctr[P1]+=P2
**
** Increment a "constraint counter" by P2 (P2 may be negative or positive).
** If P1 is non-zero, the database constraint counter is incremented 
** (deferred foreign key constraints). Otherwise, if P1 is zero, the 
** statement counter is incremented (immediate foreign key constraints).
*/</comment>
<case>case <expr><name>OP_FkCounter</name></expr>:</case> <block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: FkIfZero P1 P2 * * *
** Synopsis: if fkctr[P1]==0 goto P2
**
** This opcode tests if a foreign key constraint-counter is currently zero.
** If so, jump to instruction P2. Otherwise, fall through to the next 
** instruction.
**
** If P1 is non-zero, then the jump is taken if the database constraint-counter
** is zero (the one that counts deferred constraint violations). If P1 is
** zero, the jump is taken if the statement constraint-counter is zero
** (immediate foreign key constraint violations).
*/</comment>
<case>case <expr><name>OP_FkIfZero</name></expr>:</case> <block>{<block_content>         <comment type="block">/* jump */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_FOREIGN_KEY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
<comment type="block">/* Opcode: MemMax P1 P2 * * *
** Synopsis: r[P1]=max(r[P1],r[P2])
**
** P1 is a register in the root frame of this VM (the root frame is
** different from the current frame if this instruction is being executed
** within a sub-program). Set the value of register P1 to the maximum of 
** its current value and the value in register P2.
**
** This instruction throws an error if the memory cell is not initially
** an integer.
*/</comment>
<case>case <expr><name>OP_MemMax</name></expr>:</case> <block>{<block_content>        <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOINCREMENT */</comment>

<comment type="block">/* Opcode: IfPos P1 P2 P3 * *
** Synopsis: if r[P1]&gt;0 then r[P1]-=P3, goto P2
**
** Register P1 must contain an integer.
** If the value of register P1 is 1 or greater, subtract P3 from the
** value in P1 and jump to P2.
**
** If the initial value of register P1 is less than 1, then the
** value is unchanged and control passes through to the next instruction.
*/</comment>
<case>case <expr><name>OP_IfPos</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>-=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OffsetLimit P1 P2 P3 * *
** Synopsis: if r[P1]&gt;0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)
**
** This opcode performs a commonly used computation associated with
** LIMIT and OFFSET processing.  r[P1] holds the limit counter.  r[P3]
** holds the offset counter.  The opcode computes the combined value
** of the LIMIT and OFFSET and stores that value in r[P2].  The r[P2]
** value computed is the total number of rows that will need to be
** visited in order to complete the query.
**
** If r[P3] is zero or negative, that means there is no OFFSET
** and r[P2] is set to be the value of the LIMIT, r[P1].
**
** if r[P1] is zero or negative, that means there is no LIMIT
** and r[P2] is set to -1. 
**
** Otherwise, r[P2] is set to the sum of r[P1] and r[P3].
*/</comment>
<case>case <expr><name>OP_OffsetLimit</name></expr>:</case> <block>{<block_content>    <comment type="block">/* in1, out2, in3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>?</condition><then><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the LIMIT is less than or equal to zero, loop forever.  This
    ** is documented.  But also, if the LIMIT+OFFSET exceeds 2^63 then
    ** also loop forever.  This is undocumented.  In fact, one could argue
    ** that the loop should terminate.  But assuming 1 billion iterations
    ** per second (far exceeding the capabilities of any current hardware)
    ** it would take nearly 300 years to actually reach the limit.  So
    ** looping forever is a reasonable approximation. */</comment>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IfNotZero P1 P2 * * *
** Synopsis: if r[P1]!=0 then r[P1]--, goto P2
**
** Register P1 must contain an integer.  If the content of register P1 is
** initially greater than zero, then decrement the value in register P1.
** If it is non-zero (negative or positive) and then also jump to P2.  
** If register P1 is initially zero, leave it unchanged and fall through.
*/</comment>
<case>case <expr><name>OP_IfNotZero</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block>{<block_content>
     <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
     <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DecrJumpZero P1 P2 * * *
** Synopsis: if (--r[P1])==0 goto P2
**
** Register P1 must hold an integer.  Decrement the value in P1
** and jump to P2 if the new value is exactly zero.
*/</comment>
<case>case <expr><name>OP_DecrJumpZero</name></expr>:</case> <block>{<block_content>      <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><name>SMALLEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: AggStep * P2 P3 P4 P5
** Synopsis: accum=r[P3] step(r[P2@P5])
**
** Execute the xStep function for an aggregate.
** The function has P5 arguments.  P4 is a pointer to the 
** FuncDef structure that specifies the function.  Register P3 is the
** accumulator.
**
** The P5 arguments are taken from register P2 and its
** successors.
*/</comment>
<comment type="block">/* Opcode: AggInverse * P2 P3 P4 P5
** Synopsis: accum=r[P3] inverse(r[P2@P5])
**
** Execute the xInverse function for an aggregate.
** The function has P5 arguments.  P4 is a pointer to the 
** FuncDef structure that specifies the function.  Register P3 is the
** accumulator.
**
** The P5 arguments are taken from register P2 and its
** successors.
*/</comment>
<comment type="block">/* Opcode: AggStep1 P1 P2 P3 P4 P5
** Synopsis: accum=r[P3] step(r[P2@P5])
**
** Execute the xStep (if P1==0) or xInverse (if P1!=0) function for an
** aggregate.  The function has P5 arguments.  P4 is a pointer to the 
** FuncDef structure that specifies the function.  Register P3 is the
** accumulator.
**
** The P5 arguments are taken from register P2 and its
** successors.
**
** This opcode is initially coded as OP_AggStep0.  On first evaluation,
** the FuncDef stored in P4 is converted into an sqlite3_context and
** the opcode is changed.  In this way, the initialization of the
** sqlite3_context only happens once, instead of on each call to the
** step function.
*/</comment>
<case>case <expr><name>OP_AggInverse</name></expr>:</case>
<case>case <expr><name>OP_AggStep</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCDEF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator>
               <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pMem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>n</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_FUNCCTX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>

  <comment type="block">/* OP_AggInverse must have P1==1 and OP_AggStep must have P1==0 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_AggInverse</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_AggStep1</name></expr>;</expr_stmt>
  <comment type="block">/* Fall through into OP_AggStep */</comment>
  <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
</block_content>}</block>
<case>case <expr><name>OP_AggStep1</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCCTX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is an OP_AggInverse call.  Verify that xStep has always
    ** been called at least once prior to any xInverse call. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>uTemp</name></name><operator>==</operator><literal type="number">0x1122e0e3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This is an OP_AggStep call.  Mark it as such. */</comment>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <literal type="number">0x1122e0e3</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If this function is inside of a trigger, the register array in aMem[]
  ** might change from one evaluation to the next.  The next block of code
  ** checks to see if the register array has changed, and if so it
  ** reinitializes the relavant parts of the sqlite3_context object */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pMem</name></name> <operator>!=</operator> <name>pMem</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pMem</name></name> <operator>=</operator> <name>pMem</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xInverse</name></name><operator>)</operator><operator>(</operator><name>pCtx</name><operator>,</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>,</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>(</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xSFunc</name></name><operator>)</operator><operator>(</operator><name>pCtx</name><operator>,</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>,</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* IMP: R-24505-23230 */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_CollSeq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AggFinal P1 P2 * P4 *
** Synopsis: accum=r[P1] N=P2
**
** P1 is the memory location that is the accumulator for an aggregate
** or window function.  Execute the finalizer function 
** for an aggregate and store the result in P1.
**
** P2 is the number of arguments that the step function takes and
** P4 is a pointer to the FuncDef for this function.  The P2
** argument is not used by this opcode.  It is only there to disambiguate
** functions that can take varying numbers of arguments.  The
** P4 argument is only needed for the case where
** the step function was not previously called.
*/</comment>
<comment type="block">/* Opcode: AggValue * P2 P3 P4 *
** Synopsis: r[P3]=value N=P2
**
** Invoke the xValue() function and store the result in register P3.
**
** P2 is the number of arguments that the step function takes and
** P4 is a pointer to the FuncDef for this function.  The P2
** argument is not used by this opcode.  It is only there to disambiguate
** functions that can take varying numbers of arguments.  The
** P4 argument is only needed for the case where
** the step function was not previously called.
*/</comment>
<case>case <expr><name>OP_AggValue</name></expr>:</case>
<case>case <expr><name>OP_AggFinal</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_AggValue</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Agg</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemAggValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFinalize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/* Opcode: Checkpoint P1 P2 P3 * *
**
** Checkpoint database P1. This is a no-op if P1 is not currently in
** WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL,
** RESTART, or TRUNCATE.  Write 1 or 0 into mem[P3] if the checkpoint returns
** SQLITE_BUSY or not, respectively.  Write the number of pages in the
** WAL after the checkpoint into mem[P3+1] and the number of pages
** in the WAL that have been checkpointed after the checkpoint
** completes into mem[P3+2].  However on an error, mem[P3+1] and
** mem[P3+2] are initialized to -1.
*/</comment>
<case>case <expr><name>OP_Checkpoint</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aRes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>                    <comment type="block">/* Results */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>                      <comment type="block">/* Write results here */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aRes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_PASSIVE</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_FULL</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_RESTART</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_TRUNCATE</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pMem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>aRes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>    
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PRAGMA</name></cpp:ifndef>
<comment type="block">/* Opcode: JournalMode P1 P2 P3 * *
**
** Change the journal mode of database P1 to P3. P3 must be one of the
** PAGER_JOURNALMODE_XXX values. If changing between the various rollback
** modes (delete, truncate, persist, off and memory), this is a simple
** operation. No IO is required.
**
** If changing into or out of WAL mode the procedure is more complicated.
**
** Write a string containing the final journal-mode to register P2.
*/</comment>
<case>case <expr><name>OP_JournalMode</name></expr>:</case> <block>{<block_content>    <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>                     <comment type="block">/* Btree to change journal mode of */</comment>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>                  <comment type="block">/* Pager associated with pBt */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eNew</name></decl>;</decl_stmt>                       <comment type="block">/* New journal mode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eOld</name></decl>;</decl_stmt>                       <comment type="block">/* The old journal mode */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>          <comment type="block">/* Name of database file for pPager */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_DELETE</name> 
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_TRUNCATE</name> 
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_PERSIST</name> 
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name>
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name>
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name>
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_QUERY</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name> <operator>=</operator> <call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eOld</name> <operator>=</operator> <call><name>sqlite3PagerGetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_QUERY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3PagerOkToChangeJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do not allow a transition to journal_mode=WAL for a database
  ** in temporary storage or if the VFS does not support shared memory 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>           <comment type="block">/* Temp file */</comment>
       <operator>||</operator> <operator>!</operator><call><name>sqlite3PagerWalSupported</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr>   <comment type="block">/* No shared-memory support */</comment>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eNew</name><operator>!=</operator><name>eOld</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name> <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
          <argument><expr><literal type="string">"cannot change %s wal mode from within a transaction"</literal></expr></argument>,
          <argument><expr><operator>(</operator><ternary><condition><expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> ?</condition><then> <expr><literal type="string">"into"</literal></expr> </then><else>: <expr><literal type="string">"out of"</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if><else>else<block>{<block_content>
 
      <if_stmt><if>if<condition>( <expr><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If leaving WAL mode, close the log file. If successful, the call
        ** to PagerCloseWal() checkpoints and deletes the write-ahead-log 
        ** file. An EXCLUSIVE lock may still be held on the database file 
        ** after a successful return. 
        */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerCloseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3PagerSetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>eNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Cannot transition directly from MEMORY to WAL.  Use mode OFF
        ** as an intermediate */</comment>
        <expr_stmt><expr><call><name>sqlite3PagerSetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>PAGER_JOURNALMODE_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  
      <comment type="block">/* Open a transaction on the database file. Regardless of the journal
      ** mode, this transaction always uses a rollback journal.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_TXN_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeSetVersion</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_WAL */</comment>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>eNew</name> <operator>=</operator> <call><name>sqlite3PagerSetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>eNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3JournalModename</name><argument_list>(<argument><expr><name>eNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_PRAGMA */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VACUUM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_ATTACH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: Vacuum P1 P2 * * *
**
** Vacuum the entire database P1.  P1 is 0 for "main", and 2 or more
** for an attached database.  The "temp" database may not be vacuumed.
**
** If P2 is not zero, then it is a register holding a string which is
** the file into which the result of vacuum should be written.  When
** P2 is zero, the vacuum overwrites the original database.
*/</comment>
<case>case <expr><name>OP_Vacuum</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3RunVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUTOVACUUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: IncrVacuum P1 P2 * * *
**
** Perform a single step of the incremental vacuum procedure on
** the P1 database. If the vacuum has finished, jump to instruction
** P2. Otherwise, fall through to the next instruction.
*/</comment>
<case>case <expr><name>OP_IncrVacuum</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIncrVacuum</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: Expire P1 P2 * * *
**
** Cause precompiled statements to expire.  When an expired statement
** is executed using sqlite3_step() it will either automatically
** reprepare itself (if it was originally created using sqlite3_prepare_v2())
** or it will fail with SQLITE_SCHEMA.
** 
** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,
** then only the currently executing statement is expired.
**
** If P2 is 0, then SQL statements are expired immediately.  If P2 is 1,
** then running SQL statements are allowed to continue to run to completion.
** The P2==1 case occurs when a CREATE INDEX or similar schema change happens
** that might help the statement run faster but which does not affect the
** correctness of operation.
*/</comment>
<case>case <expr><name>OP_Expire</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: CursorLock P1 * * * *
**
** Lock the btree to which cursor P1 is pointing so that the btree cannot be
** written by an other cursor.
*/</comment>
<case>case <expr><name>OP_CursorLock</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeCursorPin</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: CursorUnlock P1 * * * *
**
** Unlock the btree to which cursor P1 is pointing so that it can be
** written by other cursors.
*/</comment>
<case>case <expr><name>OP_CursorUnlock</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeCursorUnpin</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/* Opcode: TableLock P1 P2 P3 P4 *
** Synopsis: iDb=P1 root=P2 write=P3
**
** Obtain a lock on a particular table. This instruction is only used when
** the shared-cache feature is enabled. 
**
** P1 is the index of the database in sqlite3.aDb[] of the database
** on which the lock is acquired.  A readlock is obtained if P3==0 or
** a write lock if P3==1.
**
** P2 contains the root-page of the table to lock.
**
** P4 contains a pointer to the name of the table being locked. This is only
** used to generate an error message if the lock cannot be obtained.
*/</comment>
<case>case <expr><name>OP_TableLock</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>isWriteLock</name> <init>= <expr><operator>(</operator><name>u8</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>isWriteLock</name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ReadUncommit</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>p1</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></init></decl>;</decl_stmt> 
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isWriteLock</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isWriteLock</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLockTable</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>p1</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>isWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator><operator>==</operator><name>SQLITE_LOCKED</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"database table is locked: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VBegin * * * P4 *
**
** P4 may be a pointer to an sqlite3_vtab structure. If so, call the 
** xBegin method for that table.
**
** Also, whether or not P4 is set, check that this is not being called from
** within a callback to a virtual table xSync() method. If it is, the error
** code will be set to SQLITE_LOCKED.
*/</comment>
<case>case <expr><name>OP_VBegin</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVTab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabBegin</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VCreate P1 P2 * * *
**
** P2 is a register that holds the name of a virtual table in database 
** P1. Call the xCreate method for that table.
*/</comment>
<case>case <expr><name>OP_VCreate</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name></type> <name>sMem</name></decl>;</decl_stmt>          <comment type="block">/* For storing the record being decoded */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>  <comment type="block">/* Name of the virtual table */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sMem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sMem</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <comment type="block">/* Because P2 is always a static string, it is impossible for the
  ** sqlite3VdbeMemCopy() to fail */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Static</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTab</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTab</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabCallCreate</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VDestroy P1 * * P4 *
**
** P4 is the name of a virtual table in database P1.  Call the xDestroy method
** of that table.
*/</comment>
<case>case <expr><name>OP_VDestroy</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVDestroy</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabCallDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVDestroy</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Abort</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VOpen P1 * * P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** P1 is a cursor number.  This opcode opens a cursor to the virtual
** table and stores that cursor in P1.
*/</comment>
<case>case <expr><name>OP_VOpen</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVCur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVtab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Initialize sqlite3_vtab_cursor base class */</comment>
  <expr_stmt><expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>=</operator> <name>pVtab</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize vdbe cursor object */</comment>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>CURTYPE_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name> <operator>=</operator> <name>pVCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VInitIn P1 P2 P3 * *
** Synopsis: r[P2]=ValueList(P1,P3)
**
** Set register P2 to be a pointer to a ValueList object for cursor P1
** with cache register P3 and output register P3+1.  This ValueList object
** can be used as the first argument to sqlite3_vtab_in_first() and
** sqlite3_vtab_in_next() to extract all of the values stored in the P1
** cursor.  Register P3 is used to hold the values returned by
** sqlite3_vtab_in_first() and sqlite3_vtab_in_next().
*/</comment>
<case>case <expr><name>OP_VInitIn</name></expr>:</case> <block>{<block_content>        <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>         <comment type="block">/* The cursor containing the RHS values */</comment>
  <decl_stmt><decl><type><name>ValueList</name> <modifier>*</modifier></type><name>pRhs</name></decl>;</decl_stmt>        <comment type="block">/* New ValueList object to put in reg[P2] */</comment>

  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRhs</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRhs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetPointer</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>, <argument><expr><literal type="string">"ValueList"</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VFilter P1 P2 P3 P4 *
** Synopsis: iplan=r[P3] zplan='P4'
**
** P1 is a cursor opened using VOpen.  P2 is an address to jump to if
** the filtered result set is empty.
**
** P4 is either NULL or a string that was generated by the xBestIndex
** method of the module.  The interpretation of the P4 string is left
** to the module implementation.
**
** This opcode invokes the xFilter method on the virtual table specified
** by P1.  The integer query plan parameter to xFilter is stored in register
** P3. Register P3+1 stores the argc parameter to be passed to the
** xFilter method. Registers P3+2..P3+1+argc are the argc
** additional parameters which are passed to
** xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.
**
** A jump is made to P2 if the result set after filtering would be empty.
*/</comment>
<case>case <expr><name>OP_VFilter</name></expr>:</case> <block>{<block_content>   <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pArgc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pQuery</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pArgc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pQuery</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVCur</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>

  <comment type="block">/* Grab the index number and argc parameters */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pQuery</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pArgc</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pArgc</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iQuery</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pQuery</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the xFilter method */</comment>
  <expr_stmt><expr><name>apArg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apArg</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pArgc</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xFilter</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>, <argument><expr><name>iQuery</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xEof</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VColumn P1 P2 P3 * P5
** Synopsis: r[P3]=vcolumn(P2)
**
** Store in register P3 the value of the P2-th column of
** the current row of the virtual-table of cursor P1.
**
** If the VColumn opcode is being used to fetch the value of
** an unchanging column during an UPDATE operation, then the P5
** value is OPFLAG_NOCHNG.  This will cause the sqlite3_vtab_nochange()
** function to return true inside the xColumn method of the virtual
** table implementation.  The P5 column might also contain other
** bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are
** unused by OP_VColumn.
*/</comment>
<case>case <expr><name>OP_VColumn</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pDest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>sContext</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sContext</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <name>pDest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sContext</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OPFLAG_NOCHNG</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_NOCHNG</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name><operator>|</operator><name>MEM_Zero</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xColumn</name></name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sContext</name><operator>.</operator><name>isError</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>sContext</name><operator>.</operator><name>isError</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VNext P1 P2 * * *
**
** Advance virtual table P1 to the next row in its result set and
** jump to instruction P2.  Or, if the virtual table has reached
** the end of its result set, then fall through to the next instruction.
*/</comment>
<case>case <expr><name>OP_VNext</name></expr>:</case> <block>{<block_content>   <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invoke the xNext() method of the module. There is no way for the
  ** underlying implementation to return an error if one occurs during
  ** xNext(). Instead, if an error occurs, true is returned (indicating that 
  ** data is available) and the error code returned when xColumn or
  ** some other method is next invoked on the save virtual table cursor.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xEof</name></name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><operator>!</operator><name>res</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>res</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is data, jump to P2 */</comment>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VRename P1 * * P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** This opcode invokes the corresponding xRename method. The value
** in register P1 is passed as the zName argument to the xRename method.
*/</comment>
<case>case <expr><name>OP_VRename</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isLegacy</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>isLegacy</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_LegacyAlter</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_LegacyAlter</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pName</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xRename</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xRename</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>u64</name><operator>)</operator><name>SQLITE_LegacyAlter</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VUpdate P1 P2 P3 P4 P5
** Synopsis: data=r[P3@P2]
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** This opcode invokes the corresponding xUpdate method. P2 values
** are contiguous memory cells starting at P3 to pass to the xUpdate 
** invocation. The value in register (P3+P2-1) corresponds to the 
** p2th element of the argv array passed to xUpdate.
**
** The xUpdate method will do a DELETE or an INSERT or both.
** The argv[0] element (which corresponds to memory cell P3)
** is the rowid of a row to delete.  If argv[0] is NULL then no 
** deletion occurs.  The argv[1] element is the rowid of the new 
** row.  This can be NULL to have the virtual table select the new 
** rowid for itself.  The subsequent elements in the array are 
** the values of columns in the new row.
**
** If P2==1 then no insert is performed.  argv[0] is the rowid of
** a row to delete.
**
** P1 is a boolean flag. If it is set to true and the xUpdate call
** is successful, then the value returned by sqlite3_last_insert_rowid() 
** is set to the value of the rowid for the row just inserted.
**
** P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to
** apply in the case of a constraint failure on an insert or update.
*/</comment>
<case>case <expr><name>OP_VUpdate</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>rowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">1</literal>        <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Fail</name>   <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Rollback</name> 
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Abort</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Replace</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIncrWriteCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVtab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xUpdate</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>vtabOnConflict</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>apArg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apArg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pX</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pX</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xUpdate</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name> <operator>=</operator> <name>vtabOnConflict</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>flags</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>bConstraint</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Replace</name><operator>)</operator></expr> ?</condition><then> <expr><name>OE_Abort</name></expr> </then><else>: <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<comment type="block">/* Opcode: Pagecount P1 P2 * * *
**
** Write the current number of pages in database P1 to memory cell P2.
*/</comment>
<case>case <expr><name>OP_Pagecount</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>sqlite3BtreeLastPage</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<comment type="block">/* Opcode: MaxPgcnt P1 P2 P3 * *
**
** Try to set the maximum page count for database P1 to the value in P3.
** Do not let the maximum page count fall below the current page count and
** do not change the maximum page count value if P3==0.
**
** Store the maximum page count after the change in register P2.
*/</comment>
<case>case <expr><name>OP_MaxPgcnt</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>newMax</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>newMax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>newMax</name> <operator>=</operator> <call><name>sqlite3BtreeLastPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>newMax</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newMax</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>sqlite3BtreeMaxPageCount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>newMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: Function P1 P2 P3 P4 *
** Synopsis: r[P3]=func(r[P2@NP])
**
** Invoke a user function (P4 is a pointer to an sqlite3_context object that
** contains a pointer to the function to be run) with arguments taken
** from register P2 and successors.  The number of arguments is in
** the sqlite3_context object that P4 points to.
** The result of the function is stored
** in register P3.  Register P3 must not be one of the function inputs.
**
** P1 is a 32-bit bitmask indicating whether or not each argument to the 
** function was determined to be constant at compile time. If the first
** argument was constant then bit 0 of P1 is set. This is used to determine
** whether meta data associated with a user function argument using the
** sqlite3_set_auxdata() API may be safely retained until the next
** invocation of this opcode.
**
** See also: AggStep, AggFinal, PureFunc
*/</comment>
<comment type="block">/* Opcode: PureFunc P1 P2 P3 P4 *
** Synopsis: r[P3]=func(r[P2@NP])
**
** Invoke a user function (P4 is a pointer to an sqlite3_context object that
** contains a pointer to the function to be run) with arguments taken
** from register P2 and successors.  The number of arguments is in
** the sqlite3_context object that P4 points to.
** The result of the function is stored
** in register P3.  Register P3 must not be one of the function inputs.
**
** P1 is a 32-bit bitmask indicating whether or not each argument to the 
** function was determined to be constant at compile time. If the first
** argument was constant then bit 0 of P1 is set. This is used to determine
** whether meta data associated with a user function argument using the
** sqlite3_set_auxdata() API may be safely retained until the next
** invocation of this opcode.
**
** This opcode works exactly like OP_Function.  The only difference is in
** its name.  This opcode is used in places where the function must be
** purely non-deterministic.  Some built-in date/time functions can be
** either determinitic of non-deterministic, depending on their arguments.
** When those function are used in a non-deterministic way, they will check
** to see if they were called using OP_PureFunc instead of OP_Function, and
** if they were, they throw an error.
**
** See also: AggStep, AggFinal, Function
*/</comment>
<case>case <expr><name>OP_PureFunc</name></expr>:</case>              <comment type="block">/* group */</comment>
<case>case <expr><name>OP_Function</name></expr>:</case> <block>{<block_content>            <comment type="block">/* group */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCCTX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name></expr>;</expr_stmt>

  <comment type="block">/* If this function is inside of a trigger, the register array in aMem[]
  ** might change from one evaluation to the next.  The next block of code
  ** checks to see if the register array has changed, and if so it
  ** reinitializes the relavant parts of the sqlite3_context object */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>!=</operator> <name>pOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call>(<modifier>*</modifier><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xSFunc</name></name>)<argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="block">/* IMP: R-24505-23230 */</comment>

  <comment type="block">/* If the function returned an error, throw an exception */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>encoding</name>
       <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ClrSubtype P1 * * * *
** Synopsis:  r[P1].subtype = 0
**
** Clear the subtype from register P1.
*/</comment>
<case>case <expr><name>OP_ClrSubtype</name></expr>:</case> <block>{<block_content>   <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Subtype</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: FilterAdd P1 * P3 P4 *
** Synopsis: filter(P1) += key(P3@P4)
**
** Compute a hash on the P4 registers starting with r[P3] and
** add that hash to the bloom filter contained in r[P1].
*/</comment>
<case>case <expr><name>OP_FilterAdd</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>h</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>filterHash</name><argument_list>(<argument><expr><name>aMem</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"hash: %llu modulo %d -&gt; %u\n"</literal></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>h</name><operator>%</operator><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>h</name> <operator>%=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>h</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>h</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Filter P1 P2 P3 P4 *
** Synopsis: if key(P3@P4) not in filter(P1) goto P2
**
** Compute a hash on the key contained in the P4 registers starting
** with r[P3].  Check to see if that hash is found in the
** bloom filter hosted by register P1.  If it is not present then
** maybe jump to P2.  Otherwise fall through.
**
** False negatives are harmless.  It is always safe to fall through,
** even if the value is in the bloom filter.  A false negative causes
** more CPU cycles to be used, but it should still yield the correct
** answer.  However, an incorrect answer may well arise from a
** false positive - if the jump is taken when it should fall through.
*/</comment>
<case>case <expr><name>OP_Filter</name></expr>:</case> <block>{<block_content>          <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>h</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>filterHash</name><argument_list>(<argument><expr><name>aMem</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"hash: %llu modulo %d -&gt; %u\n"</literal></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>h</name><operator>%</operator><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>h</name> <operator>%=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>h</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>h</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_FILTER_HIT</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_FILTER_MISS</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Trace P1 P2 * P4 *
**
** Write P4 on the statement trace output if statement tracing is
** enabled.
**
** Operand P1 must be 0x7fffffff and P2 must positive.
*/</comment>
<comment type="block">/* Opcode: Init P1 P2 P3 P4 *
** Synopsis: Start at P2
**
** Programs contain a single instance of this opcode as the very first
** opcode.
**
** If tracing is enabled (by the sqlite3_trace()) interface, then
** the UTF-8 string contained in P4 is emitted on the trace callback.
** Or if P4 is blank, use the string returned by sqlite3_sql().
**
** If P2 is not zero, jump to instruction P2.
**
** Increment the value of P1 so that OP_Once opcodes will jump the
** first time they are evaluated for this run.
**
** If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT
** error is encountered.
*/</comment>
<case>case <expr><name>OP_Trace</name></expr>:</case>
<case>case <expr><name>OP_Init</name></expr>:</case> <block>{<block_content>          <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTrace</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the P4 argument is not NULL, then it must be an SQL comment string.
  ** The "--" string is broken up to prevent false-positives with srcck1.c.
  **
  ** This assert() provides evidence for:
  ** EVIDENCE-OF: R-50676-09860 The callback can compute the same text that
  ** would have been returned by the legacy sqlite3_trace() interface by
  ** using the X argument when X begins with "--" and invoking
  ** sqlite3_expanded_sql(P) otherwise.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal> <literal type="string">"- "</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* OP_Init is always instruction 0 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Trace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_TRACE_STMT</name><operator>|</operator><name>SQLITE_TRACE_LEGACY</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name><operator>!=</operator><literal type="number">254</literal>  <comment type="block">/* tag-20220401a */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>zTrace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> ?</condition><then> <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></else></ternary><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <name>SQLITE_TRACE_LEGACY</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3VdbeExpandSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xLegacy</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeExec</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"-- %s"</literal></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xV2</name></name><argument_list>(<argument><expr><name>SQLITE_TRACE_STMT</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xV2</name></name><argument_list>(<argument><expr><name>SQLITE_TRACE_STMT</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_USE_FCNTL_TRACE</name></cpp:ifdef>
  <expr_stmt><expr><name>zTrace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> ?</condition><then> <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTrace</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_TRACE</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_USE_FCNTL_TRACE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_SqlTrace</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>zTrace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> ?</condition><then> <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></else></ternary><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"SQL-trace: %s\n"</literal></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>iOnceResetThreshold</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Trace</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Once</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_RUN</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
  <goto>goto <name>jump_to_p2</name>;</goto>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/* Opcode: CursorHint P1 * * P4 *
**
** Provide a hint to cursor P1 that it only needs to return rows that
** satisfy the Expr in P4.  TK_REGISTER terms in the P4 expression refer
** to values currently held in registers.  TK_COLUMN terms in the P4
** expression refer to columns in the b-tree to which cursor P1 is pointing.
*/</comment>
<case>case <expr><name>OP_CursorHint</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pC</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeCursorHint</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>BTREE_HINT_RANGE</name></expr></argument>,
                           <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>aMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_CURSOR_HINTS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/* Opcode:  Abortable   * * * * *
**
** Verify that an Abort can happen.  Assert if an Abort at this point
** might cause database corruption.  This opcode only appears in debugging
** builds.
**
** An Abort is safe if either there have been no writes, or if there is
** an active statement journal.
*/</comment>
<case>case <expr><name>OP_Abortable</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeAssertAbortable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/* Opcode:  ReleaseReg   P1 P2 P3 * P5
** Synopsis: release r[P1@P2] mask P3
**
** Release registers from service.  Any content that was in the
** the registers is unreliable after this opcode completes.
**
** The registers released will be the P2 registers starting at P1,
** except if bit ii of P3 set, then do not release register P1+ii.
** In other words, P3 is a mask of registers to preserve.
**
** Releasing a register clears the Mem.pScopyFrom pointer.  That means
** that if the content of the released register was set using OP_SCopy,
** a change to the value of the source register for the OP_SCopy will no longer
** generate an assertion fault in sqlite3VdbeMemAboutToChange().
**
** If P5 is set, then all released registers have their type set
** to MEM_Undefined so that any subsequent attempt to read the released
** register (before it is reinitialized) will generate an assertion fault.
**
** P5 ought to be set on every call to this opcode.
** However, there are places in the code generator will release registers
** before their are used, under the (valid) assumption that the registers
** will not be reallocated for some other purpose before they are used and
** hence are safe to release.
**
** This opcode is only available in testing and debugging builds.  It is
** not generated for release builds.  The purpose of this opcode is to help
** validate the generated bytecode.  This opcode does not actually contribute
** to computing an answer.
*/</comment>
<case>case <expr><name>OP_ReleaseReg</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>constMask</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>constMask</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pMem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">32</literal> <operator>||</operator> <operator>(</operator><name>constMask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">32</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Undefined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: Noop * * * * *
**
** Do nothing.  This instruction is often useful as a jump
** destination.
*/</comment>
<comment type="block">/*
** The magic Explain opcode are only inserted when explain==2 (which
** is to say when the EXPLAIN QUERY PLAN syntax is used.)
** This opcode records information from the optimizer.  It is the
** the same as a no-op.  This opcodesnever appears in a real VM program.
*/</comment>
<default>default:</default> <block>{<block_content>          <comment type="block">/* This is really OP_Noop, OP_Explain */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Noop</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Explain</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <break>break;</break>
</block_content>}</block>

<comment type="block" format="doxygen">/*****************************************************************************
** The cases of the switch statement above this line should all be indented
** by 6 spaces.  But the left-most 6 spaces have been removed to improve the
** readability.  From this point on down, the normal indentation rules are
** restored.
*****************************************************************************/</comment>
    </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>u64</name></type> <name>endTime</name> <init>= <expr><ternary><condition><expr><name>sqlite3NProfileCnt</name></expr> ?</condition><then> <expr><name>sqlite3NProfileCnt</name></expr> </then><else>: <expr><call><name>sqlite3Hwtime</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>endTime</name><operator>&gt;</operator><name>start</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>cycles</name></name> <operator>+=</operator> <name>endTime</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The following code adds nothing to the actual functionality
    ** of the program.  It is only here for testing and debugging.
    ** On the other hand, it does burn CPU cycles every time through
    ** the evaluator loop.  So we can leave it out when NDEBUG is defined.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>pOp</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>opProperty</name> <init>= <expr><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"rc=%d\n"</literal></expr></argument>,<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>opProperty</name> <operator>&amp;</operator> <operator>(</operator><name>OPFLG_OUT2</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>opProperty</name> <operator>&amp;</operator> <name>OPFLG_OUT3</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>opProperty</name><operator>==</operator><literal type="number">0xff</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Never happens.  This code exists to avoid a harmless linkage
        ** warning aboud sqlite3VdbeRegisterDump() being defined but not
        ** used. */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeRegisterDump</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_DEBUG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NDEBUG */</comment>
  </block_content>}</block></for>  <comment type="block">/* The end of the for(;;) loop the loops through opcodes */</comment>

  <comment type="block">/* If we reach this point, it means that execution is finished with
  ** an error of some kind.
  */</comment>
<label><name>abort_due_to_error</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_CORRUPTFS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTrace</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Trace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zTrace</name> <operator>=</operator> <name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zTrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zTrace</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ABORT-due-to-error (rc=%d): %s\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SystemError</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"statement aborts at %d: [%s] %s"</literal></expr></argument>, 
                   <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_RUN_STATE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CORRUPT</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_CorruptRdOnly</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>resetSchemaOnFault</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ResetOneSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>resetSchemaOnFault</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This is the only way out of this procedure.  We have to
  ** release the mutexes on btrees that were acquired at the
  ** top. */</comment>
<label><name>vdbe_return</name>:</label>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <while>while<condition>( <expr><name>nVmStep</name><operator>&gt;=</operator><name>nProgressLimit</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nProgressLimit</name> <operator>+=</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nProgressLimit</name> <operator>=</operator> <name>LARGEST_UINT64</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_VM_STEP</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nVmStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>nExtraDelete</name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"DELETE%"</literal></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

  <comment type="block">/* Jump to here if a string or blob larger than SQLITE_MAX_LENGTH
  ** is encountered.
  */</comment>
<label><name>too_big</name>:</label>
  <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"string or blob too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
  <goto>goto <name>abort_due_to_error</name>;</goto>

  <comment type="block">/* Jump to here if a malloc() fails.
  */</comment>
<label><name>no_mem</name>:</label>
  <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  <goto>goto <name>abort_due_to_error</name>;</goto>

  <comment type="block">/* Jump to here if the sqlite3_interrupt() API sets the interrupt
  ** flag.
  */</comment>
<label><name>abort_due_to_interrupt</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
  <goto>goto <name>abort_due_to_error</name>;</goto>
</block_content>}</block></function>
</unit>
