<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/select.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle SELECT statements in SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** An instance of the following object is used to record information about
** how to process the DISTINCT keyword, to simplify passing that information
** into the selectInnerLoop() routine.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>DistinctCtx</name></name></type> <name>DistinctCtx</name>;</typedef>
<struct>struct <name>DistinctCtx</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>isTnct</name></decl>;</decl_stmt>      <comment type="block">/* 0: Not distinct. 1: DISTICT  2: DISTINCT and ORDER BY */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eTnctType</name></decl>;</decl_stmt>   <comment type="block">/* One of the WHERE_DISTINCT_* operators */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tabTnct</name></decl>;</decl_stmt>    <comment type="block">/* Ephemeral table used for DISTINCT processing */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTnct</name></decl>;</decl_stmt>   <comment type="block">/* Address of OP_OpenEphemeral opcode for tabTnct */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the following object is used to record information about
** the ORDER BY (or GROUP BY) clause of query is being coded.
**
** The aDefer[] array is used by the sorter-references optimization. For
** example, assuming there is no index that can be used for the ORDER BY,
** for the query:
**
**     SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10;
**
** it may be more efficient to add just the "a" values to the sorter, and
** retrieve the associated "bigblob" values directly from table t1 as the
** 10 smallest "a" values are extracted from the sorter.
**
** When the sorter-reference optimization is used, there is one entry in the
** aDefer[] array for each database table that may be read as values are
** extracted from the sorter.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SortCtx</name></name></type> <name>SortCtx</name>;</typedef>
<struct>struct <name>SortCtx</name> <block>{
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl>;</decl_stmt>   <comment type="block">/* The ORDER BY (or GROUP BY clause) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOBSat</name></decl>;</decl_stmt>           <comment type="block">/* Number of ORDER BY terms satisfied by indices */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iECursor</name></decl>;</decl_stmt>         <comment type="block">/* Cursor number for the sorter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regReturn</name></decl>;</decl_stmt>        <comment type="block">/* Register holding block-output return address */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelBkOut</name></decl>;</decl_stmt>       <comment type="block">/* Start label for the block-output subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrSortIndex</name></decl>;</decl_stmt>    <comment type="block">/* Address of the OP_SorterOpen or OP_OpenEphemeral */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelDone</name></decl>;</decl_stmt>        <comment type="block">/* Jump here when done, ex: LIMIT reached */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelOBLopt</name></decl>;</decl_stmt>      <comment type="block">/* Jump here when sorter is full */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>sortFlags</name></decl>;</decl_stmt>         <comment type="block">/* Zero or more SORTFLAG_* bits */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u8</name></type> <name>nDefer</name></decl>;</decl_stmt>            <comment type="block">/* Number of valid entries in aDefer[] */</comment>
  <struct>struct <name>DeferredCsr</name> <block>{
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>        <comment type="block">/* Table definition */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCsr</name></decl>;</decl_stmt>           <comment type="block">/* Cursor number for table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>           <comment type="block">/* Number of PK columns for table pTab (&gt;=1) */</comment>
  }</block> <decl><name><name>aDefer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowLoadInfo</name></name> <modifier>*</modifier></type><name>pDeferredRowLoad</name></decl>;</decl_stmt>  <comment type="block">/* Deferred row loading info or NULL */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORTFLAG_UseSorter</name></cpp:macro>  <cpp:value>0x01</cpp:value></cpp:define>   <comment type="block">/* Use SorterOpen instead of OpenEphemeral */</comment>

<comment type="block">/*
** Delete all the content of a Select structure.  Deallocate the structure
** itself depending on the value of bFree
**
** If bFree==1, call sqlite3DbFree() on the p object.
** If bFree==0, Leave the first Select object unfreed
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearSelect</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bFree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pPrior</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>OK_IF_ALWAYS_TRUE</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3WithDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>OK_IF_ALWAYS_TRUE</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWinDefn</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WindowListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWinDefn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>ppThis</name></name><operator>==</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WindowUnlinkFromSelect</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>bFree</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bFree</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a SelectDest structure.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectDestInit</name><parameter_list>(<parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eDest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iParm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eDest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name> <operator>=</operator> <name>iParm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>nSdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Allocate a new Select structure and return a pointer to that
** structure.
*/</comment>
<function><type><name>Select</name> <modifier>*</modifier></type><name>sqlite3SelectNew</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,     <comment type="block">/* which columns to include in the result */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,        <comment type="block">/* the FROM clause -- which tables to scan */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,         <comment type="block">/* the WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name></decl></parameter>,   <comment type="block">/* the GROUP BY clause */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pHaving</name></decl></parameter>,        <comment type="block">/* the HAVING clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* the ORDER BY clause */</comment>
  <parameter><decl><type><name>u32</name></type> <name>selFlags</name></decl></parameter>,         <comment type="block">/* Flag parameters, such as SF_Distinct */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl></parameter>          <comment type="block">/* LIMIT value.  NULL means not used */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pNew</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pAllocated</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name></type> <name>standin</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pAllocated</name> <operator>=</operator> <name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>&amp;</operator><name>standin</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pEList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                   <argument><expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>TK_ASTERISK</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <name>pEList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_SELECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>=</operator> <name>selFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>selId</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nSelect</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSrc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pSrc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <name>pWhere</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <name>pGroupBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <name>pHaving</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name>pLimit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWinDefn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>clearSelect</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pNew</name><operator>!=</operator><operator>&amp;</operator><name>standin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAllocated</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSrc</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pAllocated</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Delete the given Select structure and all of its substructures.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>OK_IF_ALWAYS_TRUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clearSelect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the right-most SELECT statement in a compound.
*/</comment>
<function><type><specifier>static</specifier> <name>Select</name> <modifier>*</modifier></type><name>findRightmost</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given 1 to 3 identifiers preceding the JOIN keyword, determine the
** type of join.  Return an integer constant that expresses that type
** in terms of the following bit values:
**
**     JT_INNER
**     JT_CROSS
**     JT_OUTER
**     JT_NATURAL
**     JT_LEFT
**     JT_RIGHT
**
** A full outer join is the combination of JT_LEFT and JT_RIGHT.
**
** If an illegal or unsupported join type is seen, then still return
** a join type, but put an error in the pParse structure.
**
** These are the valid join types:
**
**
**      pA       pB       pC               Return Value
**     -------  -----    -----             ------------
**     CROSS      -        -                 JT_CROSS
**     INNER      -        -                 JT_INNER
**     LEFT       -        -                 JT_LEFT|JT_OUTER
**     LEFT     OUTER      -                 JT_LEFT|JT_OUTER
**     RIGHT      -        -                 JT_RIGHT|JT_OUTER
**     RIGHT    OUTER      -                 JT_RIGHT|JT_OUTER
**     FULL       -        -                 JT_LEFT|JT_RIGHT|JT_OUTER
**     FULL     OUTER      -                 JT_LEFT|JT_RIGHT|JT_OUTER
**     NATURAL  INNER      -                 JT_NATURAL|JT_INNER
**     NATURAL  LEFT       -                 JT_NATURAL|JT_LEFT|JT_OUTER
**     NATURAL  LEFT     OUTER               JT_NATURAL|JT_LEFT|JT_OUTER
**     NATURAL  RIGHT      -                 JT_NATURAL|JT_RIGHT|JT_OUTER
**     NATURAL  RIGHT    OUTER               JT_NATURAL|JT_RIGHT|JT_OUTER
**     NATURAL  FULL       -                 JT_NATURAL|JT_LEFT|JT_RIGHT
**     NATURAL  FULL     OUTER               JT_NATRUAL|JT_LEFT|JT_RIGHT
**
** To preserve historical compatibly, SQLite also accepts a variety 
** of other non-standard and in many cases non-sensical join types.
** This routine makes as much sense at it can from the nonsense join
** type and returns a result.  Examples of accepted nonsense join types
** include but are not limited to:
**
**          INNER CROSS JOIN        -&gt;   same as JOIN
**          NATURAL CROSS JOIN      -&gt;   same as NATURAL JOIN
**          OUTER LEFT JOIN         -&gt;   same as LEFT JOIN
**          LEFT NATURAL JOIN       -&gt;   same as NATURAL LEFT JOIN
**          LEFT RIGHT JOIN         -&gt;   same as FULL JOIN
**          RIGHT OUTER FULL JOIN   -&gt;   same as FULL JOIN
**          CROSS CROSS CROSS JOIN  -&gt;   same as JOIN
**
** The only restrictions on the join type name are:
**
**    *   "INNER" cannot appear together with "OUTER", "LEFT", "RIGHT",
**        or "FULL".
**
**    *   "CROSS" cannot appear together with "OUTER", "LEFT", "RIGHT,
**        or "FULL".
**
**    *   If "OUTER" is present then there must also be one of
**        "LEFT", "RIGHT", or "FULL"
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JoinType</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>jointype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name><name>apAll</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
                             <comment type="block">/*   0123456789 123456789 123456789 123 */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zKeyText</name><index>[]</index></name> <init>= <expr><literal type="string">"naturaleftouterightfullinnercross"</literal></expr></init></decl>;</decl_stmt>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
    <decl_stmt><decl><type><name>u8</name></type> <name>i</name></decl>;</decl_stmt>        <comment type="block">/* Beginning of keyword text in zKeyText[] */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>nChar</name></decl>;</decl_stmt>    <comment type="block">/* Length of the keyword in characters */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>code</name></decl>;</decl_stmt>     <comment type="block">/* Join type mask */</comment>
  }</block> <decl><name><name>aKeyword</name><index>[]</index></name> <init>= <expr><block>{
    <comment type="block">/* (0) natural */</comment> <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">7</literal></expr>, <expr><name>JT_NATURAL</name></expr>                }</block></expr>,
    <comment type="block">/* (1) left    */</comment> <expr><block>{ <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">4</literal></expr>, <expr><name>JT_LEFT</name><operator>|</operator><name>JT_OUTER</name></expr>          }</block></expr>,
    <comment type="block">/* (2) outer   */</comment> <expr><block>{ <expr><literal type="number">10</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>JT_OUTER</name></expr>                  }</block></expr>,
    <comment type="block">/* (3) right   */</comment> <expr><block>{ <expr><literal type="number">14</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>JT_RIGHT</name><operator>|</operator><name>JT_OUTER</name></expr>         }</block></expr>,
    <comment type="block">/* (4) full    */</comment> <expr><block>{ <expr><literal type="number">19</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>JT_LEFT</name><operator>|</operator><name>JT_RIGHT</name><operator>|</operator><name>JT_OUTER</name></expr> }</block></expr>,
    <comment type="block">/* (5) inner   */</comment> <expr><block>{ <expr><literal type="number">23</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>JT_INNER</name></expr>                  }</block></expr>,
    <comment type="block">/* (6) cross   */</comment> <expr><block>{ <expr><literal type="number">28</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>JT_INNER</name><operator>|</operator><name>JT_CROSS</name></expr>         }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>apAll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>apAll</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>apAll</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>pC</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>apAll</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>apAll</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aKeyword</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><name><name>aKeyword</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nChar</name> 
          <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zKeyText</name><index>[<expr><name><name>aKeyword</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>jointype</name> <operator>|=</operator> <name><name>aKeyword</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>code</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">2</literal> <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">4</literal> <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">5</literal> <operator>||</operator> <name>j</name><operator>==</operator><literal type="number">6</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aKeyword</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>jointype</name> <operator>|=</operator> <name>JT_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>(
     <expr><operator>(</operator><name>jointype</name> <operator>&amp;</operator> <operator>(</operator><name>JT_INNER</name><operator>|</operator><name>JT_OUTER</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>JT_INNER</name><operator>|</operator><name>JT_OUTER</name><operator>)</operator> <operator>||</operator>
     <operator>(</operator><name>jointype</name> <operator>&amp;</operator> <name>JT_ERROR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator>
     <operator>(</operator><name>jointype</name> <operator>&amp;</operator> <operator>(</operator><name>JT_OUTER</name><operator>|</operator><name>JT_LEFT</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>==</operator><name>JT_OUTER</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSp1</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSp2</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zSp1</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pC</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zSp2</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unknown join type: "</literal>
       <literal type="string">"%T%s%T%s%T"</literal></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>zSp1</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>zSp2</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JT_INNER</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>jointype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the index of a column in a table.  Return -1 if the column
** is not contained in the table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ColumnIndex</name><parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>h</name> <init>= <expr><call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>pCol</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name><operator>==</operator><name>h</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Mark a subquery result column as having been used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcItemColumnUsed</name><parameter_list>(<parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name> <operator>==</operator> <call><name>IsNestedFrom</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pResults</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pResults</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pResults</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pResults</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pResults</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bUsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Search the tables iStart..iEnd (inclusive) in pSrc, looking for a
** table that has a column named zCol.  The search is left-to-right.
** The first match found is returned.
**
** When found, set *piTab and *piCol to the table index and column index
** of the matching column and return TRUE.
**
** If not found, return FALSE.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tableAndColumnIndex</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,       <comment type="block">/* Array of tables to search */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>,          <comment type="block">/* First member of pSrc-&gt;a[] to check */</comment>
  <parameter><decl><type><name>int</name></type> <name>iEnd</name></decl></parameter>,            <comment type="block">/* Last member of pSrc-&gt;a[] to check */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>,    <comment type="block">/* Name of the column we are looking for */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piTab</name></decl></parameter>,          <comment type="block">/* Write index of pSrc-&gt;a[] here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piCol</name></decl></parameter>,          <comment type="block">/* Write index of pSrc-&gt;a[*piTab].pTab-&gt;aCol[] here */</comment>
  <parameter><decl><type><name>int</name></type> <name>bIgnoreHidden</name></decl></parameter>    <comment type="block">/* Ignore hidden columns */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>               <comment type="block">/* For looping over tables in pSrc */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>            <comment type="block">/* Index of column matching zCol */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEnd</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStart</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>piTab</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>piCol</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Both or neither are NULL */</comment>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iStart</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>sqlite3ColumnIndex</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>bIgnoreHidden</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>IsHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>piTab</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3SrcItemColumnUsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>piTab</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>piCol</name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the EP_OuterON property on all terms of the given expression.
** And set the Expr.w.iJoin to iTable for every term in the
** expression.
**
** The EP_OuterON property is used on terms of an expression to tell
** the OUTER JOIN processing logic that this term is part of the
** join restriction specified in the ON or USING clause and not a part
** of the more general WHERE clause.  These terms are moved over to the
** WHERE clause during join processing but we need to remember that they
** originated in the ON or USING clause.
**
** The Expr.w.iJoin tells the WHERE clause processing that the
** expression depends on table w.iJoin even if that table is not
** explicitly mentioned in the expression.  That information is needed
** for cases like this:
**
**    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5
**
** The where clause needs to defer the handling of the t1.x=5
** term until after the t2 loop of the join.  In that way, a
** NULL t2 row will be inserted whenever t1.x!=5.  If we do not
** defer the handling of t1.x=5, it will be processed immediately
** after the t1 loop and rows with t1.x!=5 will never appear in
** the output, which is incorrect.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SetJoinExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>joinFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>joinFlag</name><operator>==</operator><name>EP_OuterON</name> <operator>||</operator> <name>joinFlag</name><operator>==</operator><name>EP_InnerON</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>joinFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name> <operator>=</operator> <name>iTable</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3SetJoinExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>joinFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3SetJoinExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>joinFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></while> 
</block_content>}</block></function>

<comment type="block">/* Undo the work of sqlite3SetJoinExpr().  This is used when a LEFT JOIN
** is simplified into an ordinary JOIN, and when an ON expression is
** "pushed down" into the WHERE clause of a subquery.
**
** Convert every term that is marked with EP_OuterON and w.iJoin==iTable into
** an ordinary term that omits the EP_OuterON mark.  Or if iTable&lt;0, then
** just clear every EP_OuterON and EP_InnerON mark from the expression tree.
**
** If nullable is true, that means that Expr p might evaluate to NULL even
** if it is a reference to a NOT NULL column.  This can happen, for example,
** if the table that p references is on the left side of a RIGHT JOIN.
** If nullable is true, then take care to not remove the EP_CanBeNull bit.
** See forum thread https://sqlite.org/forum/forumpost/b40696f50145d21c
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unsetJoinExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nullable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name><operator>==</operator><name>iTable</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTable</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>nullable</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>unsetJoinExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>nullable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unsetJoinExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>nullable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></while> 
</block_content>}</block></function>

<comment type="block">/*
** This routine processes the join information for a SELECT statement.
**
**   *  A NATURAL join is converted into a USING join.  After that, we
**      do not need to be concerned with NATURAL joins and we only have
**      think about USING joins.
**
**   *  ON and USING clauses result in extra terms being added to the
**      WHERE clause to enforce the specified constraints.  The extra
**      WHERE clause terms will be tagged with EP_OuterON or
**      EP_InnerON so that we know that they originated in ON/USING.
**
** The terms of a FROM clause are contained in the Select.pSrc structure.
** The left most table is the first entry in Select.pSrc.  The right-most
** table is the last entry.  The join operator is held in the entry to
** the right.  Thus entry 1 contains the join operator for the join between
** entries 0 and 1.  Any ON or USING clauses associated with the join are
** also attached to the right entry.
**
** This routine returns the number of errors encountered.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3ProcessJoin</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>                  <comment type="block">/* All tables in the FROM clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                       <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>                 <comment type="block">/* Left table being joined */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>                <comment type="block">/* Right table being joined */</comment>

  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRight</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLeft</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pRight</name><operator>++</operator></expr><operator>,</operator> <expr><name>pLeft</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pRightTab</name> <init>= <expr><name><name>pRight</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>joinType</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pRightTab</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>joinType</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_OUTER</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>EP_OuterON</name></expr> </then><else>: <expr><name>EP_InnerON</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* If this is a NATURAL join, synthesize an approprate USING clause
    ** to specify which columns should be joined.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_NATURAL</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pUsing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"a NATURAL join may not have "</literal>
           <literal type="string">"an ON or USING clause"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pRightTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>   <comment type="block">/* Name of column in the right table */</comment>

        <if_stmt><if>if<condition>( <expr><call><name>IsHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRightTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pRightTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>tableAndColumnIndex</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pUsing</name> <operator>=</operator> <call><name>sqlite3IdListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pUsing</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pUsing</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUsing</name><operator>-&gt;</operator><name>nId</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUsing</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pUsing</name><operator>-&gt;</operator><name>nId</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zName</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pUsing</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pUsing</name><operator>-&gt;</operator><name>nId</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pUsing</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isSynthUsing</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name> <operator>=</operator> <name>pUsing</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create extra terms on the WHERE clause for each column named
    ** in the USING clause.  Example: If the two tables to be joined are 
    ** A and B and the USING clause names X, Y, and Z, then add this
    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z
    ** Report an error if any column mentioned in the USING clause is
    ** not contained in both tables to be joined.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>     <comment type="block">/* Name of the term in the USING clause */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iLeft</name></decl>;</decl_stmt>       <comment type="block">/* Table on the left with matching column name */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iLeftCol</name></decl>;</decl_stmt>    <comment type="block">/* Column number of matching column on the left */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iRightCol</name></decl>;</decl_stmt>   <comment type="block">/* Column number of matching column on the right */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE1</name></decl>;</decl_stmt>       <comment type="block">/* Reference to the column on the LEFT of the join */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name></decl>;</decl_stmt>       <comment type="block">/* Reference to the column on the RIGHT of the join */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pEq</name></decl>;</decl_stmt>       <comment type="block">/* Equality constraint.  pE1 == pE2 */</comment>

        <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iRightCol</name> <operator>=</operator> <call><name>sqlite3ColumnIndex</name><argument_list>(<argument><expr><name>pRightTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iRightCol</name><operator>&lt;</operator><literal type="number">0</literal>
         <operator>||</operator> <call><name>tableAndColumnIndex</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeftCol</name></expr></argument>,
                                <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isSynthUsing</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot join using column %s - column "</literal>
            <literal type="string">"not present in both tables"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pE1</name> <operator>=</operator> <call><name>sqlite3CreateColumnExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>iLeft</name></expr></argument>, <argument><expr><name>iLeftCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SrcItemColumnUsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr></argument>, <argument><expr><name>iLeftCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* This branch runs if the query contains one or more RIGHT or FULL
          ** JOINs.  If only a single table on the left side of this join
          ** contains the zName column, then this branch is a no-op.
          ** But if there are two or more tables on the left side
          ** of the join, construct a coalesce() function that gathers all
          ** such tables.  Raise an error if more than one of those references
          ** to zName is not also within a prior USING clause.
          **
          ** We really ought to raise an error if there are two or more
          ** non-USING references to zName on the left of an INNER or LEFT
          ** JOIN.  But older versions of SQLite do not do that, so we avoid
          ** adding a new error so as to not break legacy applications.
          */</comment>
          <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pFuncArgs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Arguments to the coalesce() */</comment>
          <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Token</name></type> <name>tkCoalesce</name> <init>= <expr><block>{ <expr><literal type="string">"coalesce"</literal></expr>, <expr><literal type="number">8</literal></expr> }</block></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><call><name>tableAndColumnIndex</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>iLeft</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeftCol</name></expr></argument>,
                                     <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isSynthUsing</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal>
             <operator>||</operator> <call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>.</operator><name><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ambiguous reference to %s in USING()"</literal></expr></argument>,
                              <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pFuncArgs</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFuncArgs</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pE1</name> <operator>=</operator> <call><name>sqlite3CreateColumnExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>iLeft</name></expr></argument>, <argument><expr><name>iLeftCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3SrcItemColumnUsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr></argument>, <argument><expr><name>iLeftCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><name>pFuncArgs</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pFuncArgs</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFuncArgs</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pE1</name> <operator>=</operator> <call><name>sqlite3ExprFunction</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFuncArgs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tkCoalesce</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pE2</name> <operator>=</operator> <call><name>sqlite3CreateColumnExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRightCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SrcItemColumnUsed</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>iRightCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pEq</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pE2</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pEq</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pEq</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pEq</name></expr></argument>, <argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pEq</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pEq</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pEq</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name> <operator>=</operator> <name><name>pE2</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if>

    <comment type="block">/* Add the ON clause to the end of the WHERE clause, connected by
    ** an AND operator.
    */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SetJoinExpr</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isOn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of this object holds information (beyond pParse and pSelect)
** needed to load the next result row that is to be added to the sorter.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RowLoadInfo</name></name></type> <name>RowLoadInfo</name>;</typedef>
<struct>struct <name>RowLoadInfo</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>regResult</name></decl>;</decl_stmt>               <comment type="block">/* Store results in array of registers here */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>ecelFlags</name></decl>;</decl_stmt>                <comment type="block">/* Flag argument to ExprCodeExprList() */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pExtra</name></decl>;</decl_stmt>            <comment type="block">/* Extra columns needed by sorter refs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regExtraResult</name></decl>;</decl_stmt>          <comment type="block">/* Where to load the extra columns */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** This routine does the work of loading query data into an array of
** registers so that it can be added to the sorter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>innerLoopLoadRow</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,             <comment type="block">/* Statement under construction */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,           <comment type="block">/* The query being coded */</comment>
  <parameter><decl><type><name>RowLoadInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>         <comment type="block">/* Info needed to complete the row load */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>ecelFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>pExtra</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pExtra</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>regExtraResult</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Code the OP_MakeRecord instruction that generates the entry to be
** added into the sorter.
**
** Return the register in which the result is stored.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>makeSorterRecord</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><name>SortCtx</name> <modifier>*</modifier></type><name>pSort</name></decl></parameter>,
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>regBase</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nBase</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOBSat</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regOut</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>pDeferredRowLoad</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>innerLoopLoadRow</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>pDeferredRowLoad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nOBSat</name></expr></argument>, <argument><expr><name>nBase</name><operator>-</operator><name>nOBSat</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>regOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will push the record in registers regData
** through regData+nData-1 onto the sorter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pushOntoSorter</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>SortCtx</name> <modifier>*</modifier></type><name>pSort</name></decl></parameter>,        <comment type="block">/* Information about the ORDER BY clause */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,       <comment type="block">/* The whole SELECT statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>regData</name></decl></parameter>,           <comment type="block">/* First register holding data to be sorted */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOrigData</name></decl></parameter>,       <comment type="block">/* First register holding data before packing */</comment>
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,             <comment type="block">/* Number of elements in the regData data array */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPrefixReg</name></decl></parameter>         <comment type="block">/* No. of reg prior to regData available for use */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>                         <comment type="block">/* Stmt under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSeq</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>pSort</name><operator>-&gt;</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>SORTFLAG_UseSorter</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* No. of ORDER BY terms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBase</name> <init>= <expr><name>nExpr</name> <operator>+</operator> <name>bSeq</name> <operator>+</operator> <name>nData</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Fields in sorter record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                                     <comment type="block">/* Regs for sorter record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                               <comment type="block">/* Assembled sorter record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOBSat</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></init></decl>;</decl_stmt>                      <comment type="block">/* ORDER BY terms to skip */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                            <comment type="block">/* Opcode to add sorter record to sorter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name></decl>;</decl_stmt>                        <comment type="block">/* LIMIT counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSkip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* End of the sorter insert loop */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeq</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bSeq</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Three cases:
  **   (1) The data to be sorted has already been packed into a Record
  **       by a prior OP_MakeRecord.  In this case nData==1 and regData
  **       will be completely unrelated to regOrigData.
  **   (2) All output columns are included in the sort record.  In that
  **       case regData==regOrigData.
  **   (3) Some output columns are omitted from the sort record due to
  **       the SQLITE_ENABLE_SORTER_REFERENCE optimization, or due to the
  **       SQLITE_ECEL_OMITREF optimization, or due to the 
  **       SortCtx.pDeferredRowLoad optimiation.  In any of these cases
  **       regOrigData is 0 to prevent this routine from trying to copy
  **       values that might not yet exist.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>regData</name><operator>==</operator><name>regOrigData</name> <operator>||</operator> <name>regOrigData</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nPrefixReg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefixReg</name><operator>==</operator><name>nExpr</name><operator>+</operator><name>bSeq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regBase</name> <operator>=</operator> <name>regData</name> <operator>-</operator> <name>nPrefixReg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>regBase</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nBase</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>iOffset</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>iLimit</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <ternary><condition><expr><name><name>pSelect</name><operator>-&gt;</operator><name>iOffset</name></name></expr> ?</condition><then> <expr><name><name>pSelect</name><operator>-&gt;</operator><name>iOffset</name></name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>pSelect</name><operator>-&gt;</operator><name>iLimit</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelDone</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>regOrigData</name></expr></argument>,
                          <argument><expr><name>SQLITE_ECEL_DUP</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>regOrigData</name></expr>?</condition><then> <expr><name>SQLITE_ECEL_REF</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bSeq</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sequence</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>iECursor</name></name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPrefixReg</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nExpr</name><operator>+</operator><name>bSeq</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOBSat</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regPrevKey</name></decl>;</decl_stmt>   <comment type="block">/* The first nOBSat columns of the previous row */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrFirst</name></decl>;</decl_stmt>    <comment type="block">/* Address of the OP_IfNot opcode */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrJmp</name></decl>;</decl_stmt>      <comment type="block">/* Address of the OP_Jump opcode */</comment>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>      <comment type="block">/* Opcode that opens the sorter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>         <comment type="block">/* Number of sorting key columns, including OP_Sequence */</comment>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKI</name></decl>;</decl_stmt>     <comment type="block">/* Original KeyInfo on the sorter table */</comment>

    <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <call><name>makeSorterRecord</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regPrevKey</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>nExpr</name> <operator>-</operator> <name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>+</operator> <name>bSeq</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bSeq</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrFirst</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>addrFirst</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SequenceTest</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>iECursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>regPrevKey</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>addrSortIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>nKey</name> <operator>+</operator> <name>nData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKI</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pKI</name><operator>-&gt;</operator><name>aSortFlags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pKI</name><operator>-&gt;</operator><name>nKeyField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Makes OP_Jump testable */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKI</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pKI</name><operator>-&gt;</operator><name>nAllField</name></name> <operator>&gt;</operator> <name><name>pKI</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>,<argument><expr><name>nOBSat</name></expr></argument>,
                                           <argument><expr><name><name>pKI</name><operator>-&gt;</operator><name>nAllField</name></name><operator>-</operator><name><name>pKI</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Ensure pOp not used after sqltie3VdbeAddOp3() */</comment>
    <expr_stmt><expr><name>addrJmp</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addrJmp</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrJmp</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelBkOut</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>regReturn</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelBkOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetSorter</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>iECursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iLimit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>regPrevKey</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrJmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iLimit</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* At this point the values for the new sorter entry are stored
    ** in an array of registers. They need to be composed into a record
    ** and inserted into the sorter if either (a) there are currently
    ** less than LIMIT+OFFSET items or (b) the new record is smaller than 
    ** the largest record currently in the sorter. If (b) is true and there
    ** are already LIMIT+OFFSET items in the sorter, delete the largest
    ** entry before inserting the new one. This way there are never more 
    ** than LIMIT+OFFSET items in the sorter.
    **
    ** If the new record does not need to be inserted into the sorter,
    ** jump to the next iteration of the loop. If the pSort-&gt;labelOBLopt
    ** value is not zero, then it is a label of where to jump.  Otherwise,
    ** just bypass the row insert logic.  See the header comment on the
    ** sqlite3WhereOrderByLimitOptLabel() function for additional info.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCsr</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>iECursor</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNotZero</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Last</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSkip</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxLE</name></expr></argument>,
                                 <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nOBSat</name></expr></argument>, <argument><expr><name>nExpr</name><operator>-</operator><name>nOBSat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>regRecord</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <call><name>makeSorterRecord</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>SORTFLAG_UseSorter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_SorterInsert</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_IdxInsert</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>iECursor</name></name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>,
                       <argument><expr><name>regBase</name><operator>+</operator><name>nOBSat</name></expr></argument>, <argument><expr><name>nBase</name><operator>-</operator><name>nOBSat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSkip</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iSkip</name></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelOBLopt</name></name></expr> ?</condition><then> <expr><name><name>pSort</name><operator>-&gt;</operator><name>labelOBLopt</name></name></expr> </then><else>: <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add code to implement the OFFSET
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeOffset</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,          <comment type="block">/* Generate code into this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>iOffset</name></decl></parameter>,      <comment type="block">/* Register holding the offset counter */</comment>
  <parameter><decl><type><name>int</name></type> <name>iContinue</name></decl></parameter>     <comment type="block">/* Jump here to skip the current record */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iOffset</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"OFFSET"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add code that will check to make sure the array of registers starting at
** iMem form a distinct entry. This is used by both "SELECT DISTINCT ..." and
** distinct aggregates ("SELECT count(DISTINCT &lt;expr&gt;) ..."). Three strategies
** are available. Which is used depends on the value of parameter eTnctType,
** as follows:
**
**   WHERE_DISTINCT_UNORDERED/WHERE_DISTINCT_NOOP:
**     Build an ephemeral table that contains all entries seen before and
**     skip entries which have been seen before.
**
**     Parameter iTab is the cursor number of an ephemeral table that must
**     be opened before the VM code generated by this routine is executed.
**     The ephemeral cursor table is queried for a record identical to the
**     record formed by the current array of registers. If one is found,
**     jump to VM address addrRepeat. Otherwise, insert a new record into
**     the ephemeral cursor and proceed.
**
**     The returned value in this case is a copy of parameter iTab.
**
**   WHERE_DISTINCT_ORDERED:
**     In this case rows are being delivered sorted order. The ephermal
**     table is not required. Instead, the current set of values
**     is compared against previous row. If they match, the new row
**     is not distinct and control jumps to VM address addrRepeat. Otherwise,
**     the VM program proceeds with processing the new row.
**
**     The returned value in this case is the register number of the first
**     in an array of registers used to store the previous result row so that
**     it can be compared to the next. The caller must ensure that this
**     register is initialized to NULL.  (The fixDistinctOpenEph() routine
**     will take care of this initialization.)
**
**   WHERE_DISTINCT_UNIQUE:
**     In this case it has already been determined that the rows are distinct.
**     No special action is required. The return value is zero.
**
** Parameter pEList is the list of expressions used to generated the 
** contents of each row. It is used by this routine to determine (a) 
** how many elements there are in the array of registers and (b) the 
** collation sequences that should be used for the comparisons if 
** eTnctType is WHERE_DISTINCT_ORDERED.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeDistinct</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>int</name></type> <name>eTnctType</name></decl></parameter>,     <comment type="block">/* WHERE_DISTINCT_* value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>,          <comment type="block">/* A sorting index used to test for distinctness */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrRepeat</name></decl></parameter>,    <comment type="block">/* Jump to here if not distinct */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,  <comment type="block">/* Expression for each element */</comment>
  <parameter><decl><type><name>int</name></type> <name>regElem</name></decl></parameter>        <comment type="block">/* First element */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nResultCol</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name>eTnctType</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>WHERE_DISTINCT_ORDERED</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iJump</name></decl>;</decl_stmt>              <comment type="block">/* Jump destination */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regPrev</name></decl>;</decl_stmt>            <comment type="block">/* Previous row content */</comment>

      <comment type="block">/* Allocate space for the previous row */</comment>
      <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>regPrev</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nResultCol</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>iJump</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nResultCol</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nResultCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nResultCol</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ne</name></expr></argument>, <argument><expr><name>regElem</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>iJump</name></expr></argument>, <argument><expr><name>regPrev</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regElem</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>addrRepeat</name></expr></argument>, <argument><expr><name>regPrev</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>==</operator><name>iJump</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regElem</name></expr></argument>, <argument><expr><name>regPrev</name></expr></argument>, <argument><expr><name>nResultCol</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>WHERE_DISTINCT_UNIQUE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* nothing to do */</comment>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addrRepeat</name></expr></argument>, <argument><expr><name>regElem</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regElem</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regElem</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine runs after codeDistinct().  It makes necessary
** adjustments to the OP_OpenEphemeral opcode that the codeDistinct()
** routine made use of.  This processing must be done separately since
** sometimes codeDistinct is called before the OP_OpenEphemeral is actually
** laid down.
**
** WHERE_DISTINCT_NOOP:
** WHERE_DISTINCT_UNORDERED:
**
**     No adjustments necessary.  This function is a no-op.
**
** WHERE_DISTINCT_UNIQUE:
**
**     The ephemeral table is not needed.  So change the
**     OP_OpenEphemeral opcode into an OP_Noop.
**
** WHERE_DISTINCT_ORDERED:
**
**     The ephemeral table is not needed.  But we do need register
**     iVal to be initialized to NULL.  So change the OP_OpenEphemeral
**     into an OP_Null on the iVal register.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fixDistinctOpenEph</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>int</name></type> <name>eTnctType</name></decl></parameter>,     <comment type="block">/* WHERE_DISTINCT_* value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>,          <comment type="block">/* Value returned by codeDistinct() */</comment>
  <parameter><decl><type><name>int</name></type> <name>iOpenEphAddr</name></decl></parameter>   <comment type="block">/* Address of OP_OpenEphemeral instruction for iTab */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>eTnctType</name><operator>==</operator><name>WHERE_DISTINCT_UNIQUE</name> <operator>||</operator> <name>eTnctType</name><operator>==</operator><name>WHERE_DISTINCT_ORDERED</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOpenEphAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOpenEphAddr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_Explain</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOpenEphAddr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eTnctType</name><operator>==</operator><name>WHERE_DISTINCT_ORDERED</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Change the OP_OpenEphemeral to an OP_Null that sets the MEM_Cleared 
      ** bit on the first register of the previous value.  This will cause the
      ** OP_Ne added in codeDistinct() to always fail on the first iteration of
      ** the loop even if the first row is all NULLs.  */</comment>
      <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOpenEphAddr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Null</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
<comment type="block">/*
** This function is called as part of inner-loop generation for a SELECT
** statement with an ORDER BY that is not optimized by an index. It 
** determines the expressions, if any, that the sorter-reference 
** optimization should be used for. The sorter-reference optimization
** is used for SELECT queries like:
**
**   SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10
**
** If the optimization is used for expression "bigblob", then instead of
** storing values read from that column in the sorter records, the PK of
** the row from table t1 is stored instead. Then, as records are extracted from
** the sorter to return to the user, the required value of bigblob is
** retrieved directly from table t1. If the values are very large, this 
** can be more efficient than storing them directly in the sorter records.
**
** The ExprList_item.fg.bSorterRef flag is set for each expression in pEList 
** for which the sorter-reference optimization should be enabled. 
** Additionally, the pSort-&gt;aDefer[] array is populated with entries
** for all cursors required to evaluate all selected expressions. Finally.
** output variable (*ppExtra) is set to an expression list containing
** expressions for all extra PK values that should be stored in the
** sorter records.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>selectExprDefer</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Leave any error here */</comment>
  <parameter><decl><type><name>SortCtx</name> <modifier>*</modifier></type><name>pSort</name></decl></parameter>,                 <comment type="block">/* Sorter context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,               <comment type="block">/* Expressions destined for sorter */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExtra</name></decl></parameter>              <comment type="block">/* Expressions to append to sorter record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDefer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
       <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>pTab</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_SORTERREF</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nDefer</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iCsr</name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nDefer</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nDefer</name><operator>==</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <continue>continue;</continue>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>nKey</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <ternary><condition><expr><name>pPk</name></expr> ?</condition><then> <expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>k</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>pExtra</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExtra</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>nDefer</name></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>nDefer</name></expr>]</index></name><operator>.</operator><name>iCsr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>nDefer</name></expr>]</index></name><operator>.</operator><name>nKey</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nDefer</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bSorterRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>nDefer</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nDefer</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppExtra</name> <operator>=</operator> <name>pExtra</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine generates the code for the inside of the inner loop
** of a SELECT.
**
** If srcTab is negative, then the p-&gt;pEList expressions
** are evaluated in order to get the data for this row.  If srcTab is
** zero or more, then data is pulled from srcTab and p-&gt;pEList is used only 
** to get the number of columns and the collation sequence for each column.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>selectInnerLoop</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,              <comment type="block">/* The complete select statement being coded */</comment>
  <parameter><decl><type><name>int</name></type> <name>srcTab</name></decl></parameter>,             <comment type="block">/* Pull data from this table if non-negative */</comment>
  <parameter><decl><type><name>SortCtx</name> <modifier>*</modifier></type><name>pSort</name></decl></parameter>,         <comment type="block">/* If not NULL, info on how to process ORDER BY */</comment>
  <parameter><decl><type><name>DistinctCtx</name> <modifier>*</modifier></type><name>pDistinct</name></decl></parameter>, <comment type="block">/* If not NULL, info on how to process DISTINCT */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,      <comment type="block">/* How to dispose of the results */</comment>
  <parameter><decl><type><name>int</name></type> <name>iContinue</name></decl></parameter>,          <comment type="block">/* Jump here to continue with next row */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBreak</name></decl></parameter>              <comment type="block">/* Jump here to break out of the inner loop */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasDistinct</name></decl>;</decl_stmt>            <comment type="block">/* True if the DISTINCT keyword is present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* How to dispose of results */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iParm</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* First argument to disposal method */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nResultCol</name></decl>;</decl_stmt>             <comment type="block">/* Number of result columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefixReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Number of extra registers before regResult */</comment>
  <decl_stmt><decl><type><name>RowLoadInfo</name></type> <name>sRowLoadInfo</name></decl>;</decl_stmt>   <comment type="block">/* Info for deferred row loading */</comment>

  <comment type="block">/* Usually, regResult is the first cell in an array of memory cells
  ** containing the current result row. In this case regOrig is set to the
  ** same value. However, if the results are being sent to the sorter, the
  ** values for any expressions that are also part of the sort-key are omitted
  ** from this array. In this case regOrig is set to zero.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regResult</name></decl>;</decl_stmt>              <comment type="block">/* Start of memory holding current results */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOrig</name></decl>;</decl_stmt>                <comment type="block">/* Start of memory holding full result (or 0) */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hasDistinct</name> <operator>=</operator> <ternary><condition><expr><name>pDistinct</name></expr> ?</condition><then> <expr><name><name>pDistinct</name><operator>-&gt;</operator><name>eTnctType</name></name></expr> </then><else>: <expr><name>WHERE_DISTINCT_NOOP</name></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSort</name> <operator>&amp;&amp;</operator> <name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pSort</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSort</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasDistinct</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iContinue</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Pull the requested columns.
  */</comment>
  <expr_stmt><expr><name>nResultCol</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pSort</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nPrefixReg</name> <operator>=</operator> <name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pSort</name><operator>-&gt;</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>SORTFLAG_UseSorter</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nPrefixReg</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPrefixReg</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nResultCol</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name><operator>+</operator><name>nResultCol</name> <operator>&gt;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is an error condition that can result, for example, when a SELECT
    ** on the right-hand side of an INSERT contains more result columns than
    ** there are columns in the table on the left.  The error will be caught
    ** and reported later.  But we need to make sure enough memory is allocated
    ** to avoid other spurious errors in the meantime. */</comment>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nResultCol</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>nSdst</name></name> <operator>=</operator> <name>nResultCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regOrig</name> <operator>=</operator> <name>regResult</name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>srcTab</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nResultCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regResult</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eDest</name><operator>!=</operator><name>SRT_Exists</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* If the destination is an EXISTS(...) expression, the actual
    ** values returned by the SELECT are not required.
    */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>ecelFlags</name></decl>;</decl_stmt>    <comment type="block">/* "ecel" is an abbreviation of "ExprCodeExprList" */</comment>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_Mem</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Output</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Coroutine</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ecelFlags</name> <operator>=</operator> <name>SQLITE_ECEL_DUP</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>ecelFlags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSort</name> <operator>&amp;&amp;</operator> <name>hasDistinct</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eDest</name><operator>!=</operator><name>SRT_EphemTab</name> <operator>&amp;&amp;</operator> <name>eDest</name><operator>!=</operator><name>SRT_Table</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For each expression in p-&gt;pEList that is a copy of an expression in
      ** the ORDER BY clause (pSort-&gt;pOrderBy), set the associated 
      ** iOrderByCol value to one more than the index of the ORDER BY 
      ** expression within the sort-key that pushOntoSorter() will generate.
      ** This allows the p-&gt;pEList field to be omitted from the sorted record,
      ** saving space and CPU cycles.  */</comment>
      <expr_stmt><expr><name>ecelFlags</name> <operator>|=</operator> <operator>(</operator><name>SQLITE_ECEL_OMITREF</name><operator>|</operator><name>SQLITE_ECEL_REF</name><operator>)</operator></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>j</name> <operator>=</operator> <name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
      <expr_stmt><expr><call><name>selectExprDefer</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pExtra</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If there are any extra PK columns to add to the sorter records,
        ** allocate extra memory cells and adjust the OpenEphemeral 
        ** instruction to account for the larger records. This is only
        ** required if there are one or more WITHOUT ROWID tables with
        ** composite primary keys in the SortCtx.aDefer[] array.  */</comment>
        <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>addrSortIndex</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>+=</operator> <operator>(</operator><name><name>pExtra</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>-</operator> <name><name>pSort</name><operator>-&gt;</operator><name>nDefer</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name> <operator>+=</operator> <operator>(</operator><name><name>pExtra</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>-</operator> <name><name>pSort</name><operator>-&gt;</operator><name>nDefer</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pExtra</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* Adjust nResultCol to account for columns that are omitted
      ** from the sorter by the optimizations in this branch */</comment>
      <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>&gt;</operator><literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
         <operator>||</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bSorterRef</name></name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>nResultCol</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>regOrig</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regOrig</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Set</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Mem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Coroutine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Output</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Set</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Mem</name> 
           <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Coroutine</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Output</name>
           <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Upfrom</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sRowLoadInfo</name><operator>.</operator><name>regResult</name></name> <operator>=</operator> <name>regResult</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sRowLoadInfo</name><operator>.</operator><name>ecelFlags</name></name> <operator>=</operator> <name>ecelFlags</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <expr_stmt><expr><name><name>sRowLoadInfo</name><operator>.</operator><name>pExtra</name></name> <operator>=</operator> <name>pExtra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sRowLoadInfo</name><operator>.</operator><name>regExtraResult</name></name> <operator>=</operator> <name>regResult</name> <operator>+</operator> <name>nResultCol</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pExtra</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nResultCol</name> <operator>+=</operator> <name><name>pExtra</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>ecelFlags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_OMITREF</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name>nPrefixReg</name><operator>&gt;</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSort</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>hasDistinct</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>pDeferredRowLoad</name></name> <operator>=</operator> <operator>&amp;</operator><name>sRowLoadInfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regOrig</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>innerLoopLoadRow</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sRowLoadInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the DISTINCT keyword was present on the SELECT statement
  ** and this row has been seen before, then do not make this row
  ** part of the result.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>hasDistinct</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name><name>pDistinct</name><operator>-&gt;</operator><name>eTnctType</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><name><name>pDistinct</name><operator>-&gt;</operator><name>tabTnct</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nResultCol</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iTab</name> <operator>=</operator> <call><name>codeDistinct</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fixDistinctOpenEph</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name><name>pDistinct</name><operator>-&gt;</operator><name>addrTnct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSort</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name>eDest</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* In this mode, write each query result to the key of the temporary
    ** table iParm.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
    <case>case <expr><name>SRT_Union</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* Construct a record from the query result, but instead of
    ** saving that record, use it as a key to delete elements from
    ** the temporary table iParm.
    */</comment>
    <case>case <expr><name>SRT_Except</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxDelete</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPOUND_SELECT */</comment>

    <comment type="block">/* Store the result as data using a unique key.
    */</comment>
    <case>case <expr><name>SRT_Fifo</name></expr>:</case>
    <case>case <expr><name>SRT_DistFifo</name></expr>:</case>
    <case>case <expr><name>SRT_Table</name></expr>:</case>
    <case>case <expr><name>SRT_EphemTab</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPrefixReg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Table</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_EphemTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Fifo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_DistFifo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>r1</name><operator>+</operator><name>nPrefixReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_DistFifo</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If the destination is DistFifo, then cursor (iParm+1) is open
        ** on an ephemeral index. If the current row is already present
        ** in the index, do not write it to the output. If not, add the
        ** current row to the index and proceed with writing it to the
        ** output table as well.  */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iParm</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>,<argument><expr><name>regResult</name></expr></argument>,<argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSort</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>pSort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regResult</name><operator>==</operator><name>regOrig</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>r1</name><operator>+</operator><name>nPrefixReg</name></expr></argument>, <argument><expr><name>regOrig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nPrefixReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>r2</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nPrefixReg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SRT_Upfrom</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pSort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(
            <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>regOrig</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>nPrefixReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm2</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If the UPDATE FROM join is an aggregate that matches no rows, it
        ** might still be trying to return one row, because that is what
        ** aggregates do.  Don't record that empty row in the output table. */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>,
                          <argument><expr><name>regResult</name><operator>+</operator><operator>(</operator><name>i2</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>nResultCol</name><operator>-</operator><operator>(</operator><name>i2</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <comment type="block">/* If we are creating a set for an "expr IN (SELECT ...)" construct,
    ** then there should be a single item on the stack.  Write this
    ** item into the set table with bogus data.
    */</comment>
    <case>case <expr><name>SRT_Set</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pSort</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* At first glance you would think we could optimize out the
        ** ORDER BY in this case since the order of entries in the set
        ** does not matter.  But there might be a LIMIT clause, in which
        ** case the order does matter */</comment>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(
            <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>regOrig</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>nPrefixReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>nResultCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, 
            <argument><expr><name>r1</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>


    <comment type="block">/* If any row exist in the result set, record that fact and abort.
    */</comment>
    <case>case <expr><name>SRT_Exists</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The LIMIT clause will terminate the loop for us */</comment>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* If this is a scalar select that is part of an expression, then
    ** store the results in the appropriate memory cell or array of 
    ** memory cells and break out of the scan loop.
    */</comment>
    <case>case <expr><name>SRT_Mem</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pSort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nResultCol</name><operator>&lt;=</operator><name><name>pDest</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(
            <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>regOrig</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>nPrefixReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nResultCol</name><operator>==</operator><name><name>pDest</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regResult</name><operator>==</operator><name>iParm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The LIMIT clause will jump out of the loop for us */</comment>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_SUBQUERY */</comment>

    <case>case <expr><name>SRT_Coroutine</name></expr>:</case>       <comment type="block">/* Send data to a co-routine */</comment>
    <case>case <expr><name>SRT_Output</name></expr>:</case> <block>{<block_content>        <comment type="block">/* Return the results */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Coroutine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Output</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>regOrig</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>,
                       <argument><expr><name>nPrefixReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_Coroutine</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
    <comment type="block">/* Write the results into a priority queue that is order according to
    ** pDest-&gt;pOrderBy (in pSO).  pDest-&gt;iSDParm (in iParm) is the cursor for an
    ** index with pSO-&gt;nExpr+2 columns.  Build a key using pSO for the first
    ** pSO-&gt;nExpr columns, then make sure all keys are unique by adding a
    ** final OP_Sequence column.  The last column is the record as a blob.
    */</comment>
    <case>case <expr><name>SRT_DistQueue</name></expr>:</case>
    <case>case <expr><name>SRT_Queue</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>r3</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>addrTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pSO</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pSO</name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pSO</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r3</name> <operator>=</operator> <name>r2</name><operator>+</operator><name>nKey</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_DistQueue</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If the destination is DistQueue, then cursor (iParm+1) is open
        ** on a second ephemeral index that holds all values every previously
        ** added to the queue. */</comment>
        <expr_stmt><expr><name>addrTest</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iParm</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
                                        <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nResultCol</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_DistQueue</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nKey</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>,
                          <argument><expr><name>regResult</name> <operator>+</operator> <name><name>pSO</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                          <argument><expr><name>r2</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sequence</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r2</name><operator>+</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>addrTest</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CTE */</comment>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Discard the results.  This is used for SELECT statements inside
    ** the body of a TRIGGER.  The purpose of such selects is to call
    ** user-defined functions that have side effects.  We do not care
    ** about the actual results of the select.
    */</comment>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Discard</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>

  <comment type="block">/* Jump to the end of the loop if the LIMIT is reached.  Except, if
  ** there is a sorter, in which case the sorter has already limited
  ** the output for us.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSort</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DecrJumpZero</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a KeyInfo object sufficient for an index of N key columns and
** X extra columns.
*/</comment>
<function><type><name>KeyInfo</name> <modifier>*</modifier></type><name>sqlite3KeyInfoAlloc</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>X</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><operator>(</operator><name>N</name><operator>+</operator><name>X</name><operator>)</operator><operator>*</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>CollSeq</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CollSeq</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>KeyInfo</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nExtra</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSortFlags</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>N</name><operator>+</operator><name>X</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nKeyField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAllField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>N</name><operator>+</operator><name>X</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>(</operator><name>KeyInfo</name><operator>*</operator><operator>)</operator><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate a KeyInfo object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3KeyInfoUnref</name><parameter_list>(<parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make a new pointer to a KeyInfo object
*/</comment>
<function><type><name>KeyInfo</name> <modifier>*</modifier></type><name>sqlite3KeyInfoRef</name><parameter_list>(<parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Return TRUE if a KeyInfo object can be change.  The KeyInfo object
** can only be changed if this is just a single reference to the object.
**
** This routine is used only inside of assert() statements.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3KeyInfoIsWriteable</name><parameter_list>(<parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block">/*
** Given an expression list, generate a KeyInfo structure that records
** the collating sequence for each expression in that expression list.
**
** If the ExprList is an ORDER BY or GROUP BY clause then the resulting
** KeyInfo structure is appropriate for initializing a virtual index to
** implement that clause.  If the ExprList is the result set of a SELECT
** then the KeyInfo structure is appropriate for initializing a virtual
** index to implement a DISTINCT test.
**
** Space to hold the KeyInfo structure is obtained from malloc.  The calling
** function is responsible for seeing that this structure is eventually
** freed.
*/</comment>
<function><type><name>KeyInfo</name> <modifier>*</modifier></type><name>sqlite3KeyInfoFromExprList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,     <comment type="block">/* Form the KeyInfo object from this ExprList */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>,          <comment type="block">/* Begin with this column of pList */</comment>
  <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>           <comment type="block">/* Add this many extra columns to the end */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nExpr</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nExpr</name><operator>-</operator><name>iStart</name></expr></argument>, <argument><expr><name>nExtra</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pInfo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iStart</name></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name>iStart</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExpr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name><operator>-</operator><name>iStart</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name><operator>-</operator><name>iStart</name></expr>]</index></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>sortFlags</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Name of the connection operator, used for error messages.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3SelectOpName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>id</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_ALL</name></expr>:</case>       <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"UNION ALL"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_INTERSECT</name></expr>:</case> <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"INTERSECT"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_EXCEPT</name></expr>:</case>    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"EXCEPT"</literal></expr>;</expr_stmt>      <break>break;</break>
    <default>default:</default>           <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"UNION"</literal></expr>;</expr_stmt>       <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<comment type="block">/*
** Unless an "EXPLAIN QUERY PLAN" command is being processed, this function
** is a no-op. Otherwise, it adds a single row of output to the EQP result,
** where the caption is of the form:
**
**   "USE TEMP B-TREE FOR xxx"
**
** where xxx is one of "DISTINCT", "ORDER BY" or "GROUP BY". Exactly which
** is determined by the zUsage argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explainTempTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUsage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="string">"USE TEMP B-TREE FOR %s"</literal><operator>,</operator> <name>zUsage</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Assign expression b to lvalue a. A second, no-op, version of this macro
** is provided when SQLITE_OMIT_EXPLAIN is defined. This allows the code
** in sqlite3Select() to assign values to structure member variables that
** only exist if SQLITE_OMIT_EXPLAIN is not defined without polluting the
** code with #ifndef directives.
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>explainSetInteger</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = b</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* No-op versions of the explainXXX() functions and macros. */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>explainTempTable</name><parameter_list>(<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>explainSetInteger</name><parameter_list>(<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** If the inner loop was generated using a non-null pOrderBy argument,
** then the results were placed in a sorter.  After the loop is terminated
** we need to run the sorter and output the results.  The following
** routine generates the code needed to do that.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>generateSortTail</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,        <comment type="block">/* The SELECT statement */</comment>
  <parameter><decl><type><name>SortCtx</name> <modifier>*</modifier></type><name>pSort</name></decl></parameter>,   <comment type="block">/* Information on the ORDER BY clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>nColumn</name></decl></parameter>,      <comment type="block">/* Number of columns of data */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter> <comment type="block">/* Write the sorted results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>                     <comment type="block">/* The prepared statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrBreak</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>labelDone</name></name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Jump here to exit loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrContinue</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><comment type="block">/* Jump here for next cycle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>                       <comment type="block">/* Top of output loop. Jump for Next. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOnce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iParm</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>                       <comment type="block">/* Number of key columns in sorter record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSortTab</name></decl>;</decl_stmt>                   <comment type="block">/* Sorter cursor to read from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSeq</name></decl>;</decl_stmt>                       <comment type="block">/* True if sorter record includes seq. no. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRefKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>aOutEx</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>addrBreak</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>labelBkOut</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelBkOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>labelBkOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
  <comment type="block">/* Open any cursors needed for sorter-reference expressions */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSort</name><operator>-&gt;</operator><name>nDefer</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTab</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCsr</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRefKey</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>nRefKey</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name><name>pSort</name><operator>-&gt;</operator><name>iECursor</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_Output</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Coroutine</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Mem</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_Mem</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>regRow</name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_EphemTab</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Table</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>regRow</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>regRow</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>-</operator> <name><name>pSort</name><operator>-&gt;</operator><name>nOBSat</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>SORTFLAG_UseSorter</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regSortOut</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>iSortTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>labelBkOut</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>iSortTab</name></expr></argument>, <argument><expr><name>regSortOut</name></expr></argument>, 
        <argument><expr><name>nKey</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>nColumn</name><operator>+</operator><name>nRefKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>addrOnce</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterSort</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterData</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>regSortOut</name></expr></argument>, <argument><expr><name>iSortTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bSeq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sort</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name>addrContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSortTab</name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bSeq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>iCol</name><operator>=</operator><name>nKey</name><operator>+</operator><name>bSeq</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bSorterRef</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>nDefer</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name> <init>= <expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regKey</name> <init>= <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nRefKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSort</name><operator>-&gt;</operator><name>nDefer</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCsr</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCsr</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTab</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>aDefer</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nKey</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iSortTab</name></expr></argument>, <argument><expr><name>iKey</name><operator>++</operator></expr></argument>, <argument><expr><name>regKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekRowid</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, 
            <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iJmp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nKeyCol</name><operator>==</operator><name>nKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>nKey</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iSortTab</name></expr></argument>, <argument><expr><name>iKey</name><operator>++</operator></expr></argument>, <argument><expr><name>regKey</name><operator>+</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>iJmp</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekGE</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>iJmp</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>regKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxLE</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>iJmp</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>regKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regKey</name></expr></argument>, <argument><expr><name>nRefKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bSorterRef</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regRow</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iRead</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iRead</name> <operator>=</operator> <name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iRead</name> <operator>=</operator> <name>iCol</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iSortTab</name></expr></argument>, <argument><expr><name>iRead</name></expr></argument>, <argument><expr><name>regRow</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>aOutEx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <switch>switch<condition>( <expr><name>eDest</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SRT_Table</name></expr>:</case>
    <case>case <expr><name>SRT_EphemTab</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iSortTab</name></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><name>bSeq</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>SRT_Set</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name><operator>==</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>,
                        <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SRT_Mem</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* The LIMIT clause will terminate the loop for us */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>SRT_Upfrom</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm2</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>,<argument><expr><name>regRow</name><operator>+</operator><operator>(</operator><name>i2</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument>,<argument><expr><name>nColumn</name><operator>-</operator><operator>(</operator><name>i2</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument>,<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Output</name> <operator>||</operator> <name>eDest</name><operator>==</operator><name>SRT_Coroutine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Output</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name><operator>==</operator><name>SRT_Coroutine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_Output</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <if_stmt><if>if<condition>( <expr><name>regRowid</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>eDest</name><operator>==</operator><name>SRT_Set</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* The bottom of the loop
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>SORTFLAG_UseSorter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterNext</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSort</name><operator>-&gt;</operator><name>regReturn</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to a string containing the 'declaration type' of the
** expression pExpr. The string may be treated as static by the caller.
**
** The declaration type is the exact datatype definition extracted from the
** original CREATE TABLE statement if the expression is a column. The
** declaration type for a ROWID field is INTEGER. Exactly when an expression
** is considered a column can be complex in the presence of subqueries. The
** result-set expression in all of the following SELECT statements is 
** considered a column by this function.
**
**   SELECT col FROM tbl;
**   SELECT (SELECT col FROM tbl;
**   SELECT (SELECT col FROM tbl);
**   SELECT abc FROM (SELECT col AS abc FROM tbl);
** 
** The declaration type for any expression other than a column is NULL.
**
** This routine has either 3 or 6 parameters depending on whether or not
** the SQLITE_ENABLE_COLUMN_METADATA compile-time option is used.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>columnType</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>,<parameter><type><name>D</name></type></parameter>,<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>columnTypeImpl(A,B,C,D,E)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if !defined(SQLITE_ENABLE_COLUMN_METADATA) */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>columnType</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>,<parameter><type><name>D</name></type></parameter>,<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>columnTypeImpl(A,B)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>columnTypeImpl</name><parameter_list>(
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>, 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifndef>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier><name>pExpr</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOrigDb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOrigTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOrigCol</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zOrigDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zOrigTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zOrigCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* The expression is a column. Locate the table the column is being
      ** extracted from in NameContext.pSrcList. This table may be real
      ** database table or a subquery.
      */</comment>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Table structure column is extracted from */</comment>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Select the column is extracted from */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Index of column in pTab */</comment>
      <while>while<condition>( <expr><name>pNC</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>j</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>&amp;&amp;</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iCursor</name><operator>!=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pS</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pSelect</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>pNC</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>

      <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* At one time, code such as "SELECT new.x" within a trigger would
        ** cause this condition to run.  Since then, we have restructured how
        ** trigger code is generated and so this condition is no longer 
        ** possible. However, it can still be true for statements like
        ** the following:
        **
        **   CREATE TABLE t1(col INTEGER);
        **   SELECT (SELECT t1.col) FROM FROM t1;
        **
        ** when columnType() is called on the expression "t1.col" in the 
        ** sub-select. In this case, set the column type to NULL, even
        ** though it should really be "INTEGER".
        **
        ** This is not a problem, as the column type of "t1.col" is never
        ** used. When columnType() is called on the expression 
        ** "(SELECT t1.col)", the correct type is returned (see the TK_SELECT
        ** branch below.  */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name> <operator>&amp;&amp;</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pS</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The "table" is actually a sub-select or a view in the FROM clause
        ** of the SELECT statement. Return the declaration type and origin
        ** data for the result-set column of the sub-select.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><name><name>pS</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifdef>
         <operator>&amp;&amp;</operator> <name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
         <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><block>{<block_content> 
          <comment type="block">/* If iCol is less than zero, then the expression requests the
          ** rowid of the sub-select or view. This expression is legal (see 
          ** test case misc2.2.2) - it always evaluates to NULL.
          */</comment>
          <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pS</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>pS</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>columnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zOrigDb</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zOrigTab</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zOrigCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* A real table or a CTE table */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>XN_ROWID</name> <operator>||</operator> <operator>(</operator><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"INTEGER"</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>zOrigCol</name> <operator>=</operator> <literal type="string">"rowid"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zOrigCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>sqlite3ColumnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>zOrigTab</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>zOrigDb</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>XN_ROWID</name> <operator>||</operator> <operator>(</operator><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"INTEGER"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>sqlite3ColumnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_SELECT</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* The expression is a sub-select. Return the declaration type and
      ** origin info for the single column in the result set of the SELECT
      ** statement.
      */</comment>
      <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pS</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pS</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pS</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>pS</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>columnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOrigDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOrigTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOrigCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>  
  <if_stmt><if>if<condition>( <expr><name>pzOrigDb</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pzOrigTab</name> <operator>&amp;&amp;</operator> <name>pzOrigCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzOrigDb</name> <operator>=</operator> <name>zOrigDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzOrigTab</name> <operator>=</operator> <name>zOrigTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzOrigCol</name> <operator>=</operator> <name>zOrigCol</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>zType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will tell the VDBE the declaration types of columns
** in the result set.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>generateColumnTypes</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,  <comment type="block">/* List of tables */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>    <comment type="block">/* Expressions defining the result set */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DECLTYPE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOrigDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOrigTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOrigCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>columnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOrigDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOrigTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOrigCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The vdbe must make its own copy of the column-type and other 
    ** column specific strings, in case the schema is reset before this
    ** virtual machine is deleted.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_DATABASE</name></expr></argument>, <argument><expr><name>zOrigDb</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_TABLE</name></expr></argument>, <argument><expr><name>zOrigTab</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_COLUMN</name></expr></argument>, <argument><expr><name>zOrigCol</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>columnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_DECLTYPE</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_DECLTYPE) */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Compute the column names for a SELECT statement.
**
** The only guarantee that SQLite makes about column names is that if the
** column has an AS clause assigning it a name, that will be the name used.
** That is the only documented guarantee.  However, countless applications
** developed over the years have made baseless assumptions about column names
** and will break if those assumptions changes.  Hence, use extreme caution
** when modifying this routine to avoid breaking legacy.
**
** See Also: sqlite3ColumnsFromExprList()
**
** The PRAGMA short_column_names and PRAGMA full_column_names settings are
** deprecated.  The default setting is short=ON, full=OFF.  99.9% of all
** applications should operate this way.  Nevertheless, we need to support the
** other modes for legacy:
**
**    short=OFF, full=OFF:      Column name is the text of the expression has it
**                              originally appears in the SELECT statement.  In
**                              other words, the zSpan of the result expression.
**
**    short=ON, full=OFF:       (This is the default setting).  If the result
**                              refers directly to a table column, then the
**                              result column name is just the table column
**                              name: COLUMN.  Otherwise use zSpan.
**
**    full=ON, short=ANY:       If the result refers directly to a table column,
**                              then the result column name with the table name
**                              prefix, ex: TABLE.COLUMN.  Otherwise use zSpan.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateColumnNames</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>     <comment type="block">/* Generate column names for this SELECT statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fullName</name></decl>;</decl_stmt>    <comment type="block">/* TABLE.COLUMN if no AS clause and is a direct table ref */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>srcName</name></decl>;</decl_stmt>     <comment type="block">/* COLUMN or TABLE.COLUMN if no AS clause and is direct */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
  <comment type="block">/* If this is an EXPLAIN, skip this step */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>colNamesSet</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Column names are determined by the left-most term of a compound select */</comment>
  <while>while<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x80</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pSelect</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"generating column names\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>colNamesSet</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>fullName</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_FullColNames</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>srcName</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ShortColNames</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>fullName</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Agg processing has not run yet */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name>
        <operator>||</operator> <operator>(</operator><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Covering idx not yet coded */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* An AS clause always takes first priority */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>srcName</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zCol</name> <operator>=</operator> <literal type="string">"rowid"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>fullName</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <ternary><condition><expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"column%d"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>generateColumnTypes</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given an expression list (which is really the list of expressions
** that form the result set of a SELECT statement) compute appropriate
** column names for a table that would hold the expression list.
**
** All column names will be unique.
**
** Only the column names are computed.  Column.zType, Column.zColl,
** and other fields of Column are zeroed.
**
** Return SQLITE_OK on success.  If a memory allocation error occurs,
** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.
**
** The only guarantee that SQLite makes about column names is that if the
** column has an AS clause assigning it a name, that will be the name used.
** That is the only documented guarantee.  However, countless applications
** developed over the years have made baseless assumptions about column names
** and will break if those assumptions changes.  Hence, use extreme caution
** when modifying this routine to avoid breaking legacy.
**
** See Also: sqlite3GenerateColumnNames()
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ColumnsFromExprList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,       <comment type="block">/* Expr list from which to derive column names */</comment>
  <parameter><decl><type><name>i16</name> <modifier>*</modifier></type><name>pnCol</name></decl></parameter>,             <comment type="block">/* Write the number of columns here */</comment>
  <parameter><decl><type><name>Column</name> <modifier>*</modifier><modifier>*</modifier></type><name>paCol</name></decl></parameter>          <comment type="block">/* Write the new column list here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cnt</name></decl>;</decl_stmt>                    <comment type="block">/* Index added to make the name unique */</comment>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>aCol</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>        <comment type="block">/* For looping over result columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the result set */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                <comment type="block">/* Column name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                  <comment type="block">/* Size of name in zName[] */</comment>
  <decl_stmt><decl><type><name>Hash</name></type> <name>ht</name></decl>;</decl_stmt>                    <comment type="block">/* Hash table of column names */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEList</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aCol</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>aCol</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>nCol</name><operator>&gt;</operator><literal type="number">32767</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">32767</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCol</name><operator>==</operator><operator>(</operator><name>i16</name><operator>)</operator><name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>paCol</name> <operator>=</operator> <name>aCol</name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pCol</name><operator>=</operator><name>aCol</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><operator>&amp;</operator><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pCollide</name></decl>;</decl_stmt>
    <comment type="block">/* Get an appropriate name for the column
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zName</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the column contains an "AS &lt;name&gt;" phrase, use &lt;name&gt; as the name */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pColExpr</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pColExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pColExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_DOT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pColExpr</name> <operator>=</operator> <name><name>pColExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pColExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>pColExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pColExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>( <argument><expr><name><name>pColExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* For columns use the column name name */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pColExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pColExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr> </then><else>: <expr><literal type="string">"rowid"</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pColExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pColExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pColExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Use the original text of the column expression as its name */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pointer comparison intended */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zName</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3IsTrueOrFalse</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="string">"column%d"</literal></expr></argument>,<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Make sure the column name is unique.  If the name is not unique,
    ** append an integer to the name so that it becomes unique.
    */</comment>
    <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>zName</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pCollide</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCollide</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bUsingTerm</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_NOEXPAND</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nName</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>nName</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zName</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
        <if_stmt><if>if<condition>( <expr><name><name>zName</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="char">':'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nName</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%.*z:%u"</literal></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>++</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name> <operator>=</operator> <call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bNoExpand</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_NOEXPAND</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ColumnPropertiesFromName</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zName</name> <operator>&amp;&amp;</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call><operator>==</operator><name>pX</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>paCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add type and collation information to a column list based on
** a SELECT statement.
** 
** The column list presumably came from selectColumnNamesFromExprList().
** The column list has only names, not types or collations.  This
** routine goes through and adds the types and collations.
**
** This routine requires that all identifiers in the SELECT
** statement be resolved.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectAddColumnTypeAndCollation</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing contexts */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,          <comment type="block">/* Add column type information to this table */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* SELECT used to determine types and collations */</comment>
  <parameter><decl><type><name>char</name></type> <name>aff</name></decl></parameter>              <comment type="block">/* Default affinity for columns */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSelect</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_NOINSERT</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <call><name>columnType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* pCol-&gt;szEst = ... // Column size est for SELECT tables never used */</comment>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zType</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><name>m</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>m</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_HASTYPE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_HASTYPE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>COLFLAG_HASTYPE</name><operator>|</operator><name>COLFLAG_HASCOLL</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>&lt;=</operator><name>SQLITE_AFF_NONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <name>aff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColl</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ColumnSetColl</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Any non-zero value works */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Given a SELECT statement, generate a Table structure that describes
** the result set of that SELECT.
*/</comment>
<function><type><name>Table</name> <modifier>*</modifier></type><name>sqlite3ResultSetOfSelect</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>aff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>savedFlags</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>savedFlags</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>u64</name><operator>)</operator><name>SQLITE_FullColNames</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_ShortColNames</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>savedFlags</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">200</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1048576</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ColumnsFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectAddColumnTypeAndCollation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pTab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Get a VDBE for the given parser context.  Create a new one if necessary.
** If an error occurs, return NULL and leave a message in pParse.
*/</comment>
<function><type><name>Vdbe</name> <modifier>*</modifier></type><name>sqlite3GetVdbe</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pToplevel</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>SQLITE_FactorOutConst</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3VdbeCreate</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Compute the iLimit and iOffset fields of the SELECT based on the
** pLimit expressions.  pLimit-&gt;pLeft and pLimit-&gt;pRight hold the expressions
** that appear in the original SQL statement after the LIMIT and OFFSET
** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset 
** are the integer memory register numbers for counters used to compute 
** the limit and offset.  If there is no limit and/or offset, then 
** iLimit and iOffset are negative.
**
** This routine changes the values of iLimit and iOffset only if
** a limit or offset is defined by pLimit-&gt;pLeft and pLimit-&gt;pRight.  iLimit
** and iOffset should have been preset to appropriate default values (zero)
** prior to calling this routine.
**
** The iOffset register (if it exists) is initialized to the value
** of the OFFSET.  The iLimit register is initialized to LIMIT.  Register
** iOffset+1 is initialized to LIMIT+OFFSET.
**
** Only if pLimit-&gt;pLeft!=0 do the limit registers get
** redefined.  The UNION ALL operator uses this property to force
** the reuse of the same limit and offset registers across multiple
** SELECT statements.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>computeLimitRegisters</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBreak</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* 
  ** "LIMIT -1" always shows all rows.  There is some
  ** controversy about what the correct behavior should be.
  ** The current implementation interprets "LIMIT 0" to mean
  ** no rows.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pLimit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLimit</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LIMIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name>iLimit</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"LIMIT counter"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name><operator>&gt;</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_FixedLimit</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"LIMIT counter"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLimit</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name>iOffset</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* Allocate an extra register for limit+offset */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pLimit</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"OFFSET counter"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OffsetLimit</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>iOffset</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"LIMIT+OFFSET"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
<comment type="block">/*
** Return the appropriate collating sequence for the iCol-th column of
** the result set for the compound-select statement "p".  Return NULL if
** the column has no default collating sequence.
**
** The collating sequence for the compound select is taken from the
** left-most term of the select that has a collating sequence.
*/</comment>
<function><type><specifier>static</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>multiSelectCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* iCol must be less than p-&gt;pEList-&gt;nExpr.  Otherwise an error would
  ** have been thrown during name resolution and we would not have gotten
  ** this far */</comment>
  <if_stmt><if>if<condition>( <expr><name>pRet</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>iCol</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The select statement passed as the second parameter is a compound SELECT
** with an ORDER BY clause. This function allocates and returns a KeyInfo
** structure suitable for implementing the ORDER BY.
**
** Space to hold the KeyInfo structure is obtained from malloc. The calling
** function is responsible for ensuring that this structure is eventually
** freed.
*/</comment>
<function><type><specifier>static</specifier> <name>KeyInfo</name> <modifier>*</modifier></type><name>multiSelectOrderByKeyInfo</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name> <init>= <expr><ternary><condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pOrderBy</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nOrderBy</name><operator>+</operator><name>nExtra</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator>
          <call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pColl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
<comment type="block">/*
** This routine generates VDBE code to compute the content of a WITH RECURSIVE
** query of the form:
**
**   &lt;recursive-table&gt; AS (&lt;setup-query&gt; UNION [ALL] &lt;recursive-query&gt;)
**                         \___________/             \_______________/
**                           p-&gt;pPrior                      p
**
**
** There is exactly one reference to the recursive-table in the FROM clause
** of recursive-query, marked with the SrcList-&gt;a[].fg.isRecursive flag.
**
** The setup-query runs once to generate an initial set of rows that go
** into a Queue table.  Rows are extracted from the Queue table one by
** one.  Each row extracted from Queue is output to pDest.  Then the single
** extracted row (now in the iCurrent table) becomes the content of the
** recursive-table for a recursive-query run.  The output of the recursive-query
** is added back into the Queue table.  Then another row is extracted from Queue
** and the iteration continues until the Queue table is empty.
**
** If the compound query operator is UNION then no duplicate rows are ever
** inserted into the Queue table.  The iDistinct table keeps a copy of all rows
** that have ever been inserted into Queue and causes duplicates to be
** discarded.  If the operator is UNION ALL, then duplicates are allowed.
** 
** If the query has an ORDER BY, then entries in the Queue table are kept in
** ORDER BY order and the first entry is extracted for each cycle.  Without
** an ORDER BY, the Queue table is just a FIFO.
**
** If a LIMIT clause is provided, then the iteration stops after LIMIT rows
** have been output to pDest.  A LIMIT of zero means to output no rows and a
** negative LIMIT means to output all rows.  If there is also an OFFSET clause
** with a positive value, then the first OFFSET outputs are discarded rather
** than being sent to pDest.  The LIMIT count does not begin until after OFFSET
** rows have been skipped.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>generateWithRecursiveQuery</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The recursive SELECT to be coded */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The FROM clause of the recursive query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of columns in the recursive table */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The prepared statement under construction */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSetup</name></decl>;</decl_stmt>               <comment type="block">/* The setup query */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pFirstRec</name></decl>;</decl_stmt>            <comment type="block">/* Left-most recursive term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>                  <comment type="block">/* Top of the loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name></decl>, <decl><type ref="prev"/><name>addrBreak</name></decl>;</decl_stmt>      <comment type="block">/* CONTINUE and BREAK addresses */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* The Current table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regCurrent</name></decl>;</decl_stmt>               <comment type="block">/* Register holding Current table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iQueue</name></decl>;</decl_stmt>                   <comment type="block">/* The Queue table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDistinct</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* To ensure unique results if UNION */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name> <init>= <expr><name>SRT_Fifo</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* How to write to Queue */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>destQueue</name></decl>;</decl_stmt>         <comment type="block">/* SelectDest targetting the Queue table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                       <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl>;</decl_stmt>           <comment type="block">/* The ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl>;</decl_stmt>                 <comment type="block">/* Saved LIMIT and OFFSET */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regLimit</name></decl>, <decl><type ref="prev"/><name>regOffset</name></decl>;</decl_stmt>      <comment type="block">/* Registers used by LIMIT and OFFSET */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot use window functions in recursive queries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Obtain authorization to do a recursive query */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_RECURSIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Process the LIMIT and OFFSET clauses, if they exist */</comment>
  <expr_stmt><expr><name>addrBreak</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <literal type="number">320</literal></expr>;</expr_stmt>  <comment type="block">/* 4 billion rows */</comment>
  <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regLimit</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regOffset</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>

  <comment type="block">/* Locate the cursor number of the Current table */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isRecursive</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCurrent</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Allocate cursors numbers for Queue and Distinct.  The cursor number for
  ** the Distinct table must be exactly one greater than Queue in order
  ** for the SRT_DistFifo and SRT_DistQueue destinations to work. */</comment>
  <expr_stmt><expr><name>iQueue</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UNION</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eDest</name> <operator>=</operator> <ternary><condition><expr><name>pOrderBy</name></expr> ?</condition><then> <expr><name>SRT_DistQueue</name></expr> </then><else>: <expr><name>SRT_DistFifo</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDistinct</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>eDest</name> <operator>=</operator> <ternary><condition><expr><name>pOrderBy</name></expr> ?</condition><then> <expr><name>SRT_Queue</name></expr> </then><else>: <expr><name>SRT_Fifo</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>destQueue</name></expr></argument>, <argument><expr><name>eDest</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate cursors for Current, Queue, and Distinct. */</comment>
  <expr_stmt><expr><name>regCurrent</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>iCurrent</name></expr></argument>, <argument><expr><name>regCurrent</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><call><name>multiSelectOrderByKeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                      <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destQueue</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Queue table"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDistinct</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>iDistinct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_UsesEphemeral</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Detach the ORDER BY clause from the compound SELECT */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Figure out how many elements of the compound SELECT are part of the
  ** recursive query.  Make sure no recursive elements use aggregate
  ** functions.  Mark the recursive elements as UNION ALL even if they
  ** are really UNION because the distinctness will be enforced by the
  ** iDistinct table.  pFirstRec is left pointing to the left-most
  ** recursive term of the CTE.
  */</comment>
  <for>for<control>(<init><expr><name>pFirstRec</name><operator>=</operator><name>p</name></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pFirstRec</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pFirstRec</name><operator>=</operator><name><name>pFirstRec</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFirstRec</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"recursive aggregate queries not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>end_of_recursive_query</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFirstRec</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ALL</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFirstRec</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Store the results of the setup-query in Queue. */</comment>
  <expr_stmt><expr><name>pSetup</name> <operator>=</operator> <name><name>pFirstRec</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSetup</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"SETUP"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSetup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSetup</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_of_recursive_query</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Find the next row in the Queue and output that row */</comment>
  <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Transfer the next row in Queue over to Current */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>iCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* To reset column cache */</comment>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>, <argument><expr><name>regCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Output the single row in Current */</comment>
  <expr_stmt><expr><name>addrCont</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regOffset</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iCurrent</name></expr></argument>,
      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>regLimit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DecrJumpZero</name></expr></argument>, <argument><expr><name>regLimit</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Execute the recursive SELECT taking the single row in Current as
  ** the value for the recursive-table. Store the results in the Queue.
  */</comment>
  <expr_stmt><expr><name><name>pFirstRec</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"RECURSIVE STEP"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFirstRec</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFirstRec</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pSetup</name></expr>;</expr_stmt>

  <comment type="block">/* Keep running the loop until the Queue is empty */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end_of_recursive_query</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name>pLimit</name></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CTE */</comment>

<comment type="block">/* Forward references */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>multiSelectOrderBy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list>;</function_decl>

<comment type="block">/*
** Handle the special case of a compound-select that originates from a
** VALUES clause.  By handling this as a special case, we avoid deep
** recursion, and thus do not need to enforce the SQLITE_LIMIT_COMPOUND_SELECT
** on a VALUES clause.
**
** Because the Select object originates from a VALUES clause:
**   (1) There is no LIMIT or OFFSET or else there is a LIMIT of exactly 1
**   (2) All terms are UNION ALL
**   (3) There is no ORDER BY clause
**
** The "LIMIT of exactly 1" case of condition (1) comes about when a VALUES
** clause occurs within scalar expression (ex: "SELECT (VALUES(1),(2),(3))").
** The sqlite3CodeSubselect will have added the LIMIT 1 clause in tht case.
** Since the limit is exactly 1, we only need to evaluate the left-most VALUES.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiSelectValues</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bShowAll</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_MultiValue</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Values</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRow</name> <operator>+=</operator> <name>bShowAll</name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="string">"SCAN %d CONSTANT ROW%s"</literal><operator>,</operator> <name>nRow</name><operator>,</operator>
                    <ternary><condition><expr><name>nRow</name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"S"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bShowAll</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name>nRow</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the SELECT statement which is known to be the recursive
** part of a recursive CTE still has its anchor terms attached.  If the
** anchor terms have already been removed, then return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasAnchor</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called to process a compound query form from
** two or more separate queries using UNION, UNION ALL, EXCEPT, or
** INTERSECT
**
** "p" points to the right-most of the two queries.  the query on the
** left is p-&gt;pPrior.  The left query could also be a compound query
** in which case this routine will be called recursively. 
**
** The results of the total query are to be written into a destination
** of type eDest with parameter iParm.
**
** Example 1:  Consider a three-way compound SQL statement.
**
**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3
**
** This statement is parsed up as follows:
**
**     SELECT c FROM t3
**      |
**      `-----&gt;  SELECT b FROM t2
**                |
**                `------&gt;  SELECT a FROM t1
**
** The arrows in the diagram above represent the Select.pPrior pointer.
** So if this routine is called with p equal to the t3 query, then
** pPrior will be the t2 query.  p-&gt;op will be TK_UNION in this case.
**
** Notice that because of the way SQLite parses compound SELECTs, the
** individual selects always group from left to right.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiSelect</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Success code from a subroutine */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>       <comment type="block">/* Another SELECT immediately to our left */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Generate code to this VDBE */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>      <comment type="block">/* Alternative data destination */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pDelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Chain of simple selects to delete */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection */</comment>

  <comment type="block">/* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only
  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Calling function guarantees this much */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UNION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Compound</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>*</operator><name>pDest</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pLimit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The VDBE already created by calling function */</comment>

  <comment type="block">/* Create the destination temporary table if necessary
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>dest</name><operator>.</operator><name>eDest</name></name><operator>==</operator><name>SRT_EphemTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>eDest</name></name> <operator>=</operator> <name>SRT_Table</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Special handling for a compound-select that originates as a VALUES clause.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_MultiValue</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiSelectValues</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>multi_select_end</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure all SELECTs in the statement have the same number of elements
  ** in their result sets.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name> <operator>&amp;&amp;</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name><name>pPrior</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>hasAnchor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>generateWithRecursiveQuery</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Compound SELECTs that have an ORDER BY clause are handled separately.
  */</comment>
  if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>multiSelectOrderBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pPrior</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"COMPOUND QUERY"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"LEFT-MOST SUBQUERY"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Generate code for the left and right SELECT statements.
    */</comment>
    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>TK_ALL</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Initialize to suppress harmless compiler warning */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPrior</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"multiSelect UNION ALL left...\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>multi_select_end</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>iLimit</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Jump ahead if LIMIT reached"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OffsetLimit</name></expr></argument>,
                              <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"UNION ALL"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"multiSelect UNION ALL right...\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDelete</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name>
         <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLimit</name></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <name>nLimit</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>&gt;</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>nLimit</name></expr></argument>)</argument_list></call></expr> 
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>nLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>addr</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TK_EXCEPT</name></expr>:</case>
      <case>case <expr><name>TK_UNION</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>unionTab</name></decl>;</decl_stmt>    <comment type="block">/* Cursor number of the temp table holding result */</comment>
        <decl_stmt><decl><type><name>u8</name></type> <name>op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* One of the SRT_ operations to apply to self */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>priorOp</name></decl>;</decl_stmt>     <comment type="block">/* The SRT_ operation to apply to prior selects */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl>;</decl_stmt>    <comment type="block">/* Saved values of p-&gt;nLimit  */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SelectDest</name></type> <name>uniondest</name></decl>;</decl_stmt>
  
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXCEPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UNION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>priorOp</name> <operator>=</operator> <name>SRT_Union</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>dest</name><operator>.</operator><name>eDest</name></name><operator>==</operator><name>priorOp</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* We can reuse a temporary table generated by a SELECT to our
          ** right.
          */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Not allowed on leftward elements */</comment>
          <expr_stmt><expr><name>unionTab</name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* We will need to create our own temporary table to hold the
          ** intermediate results.
          */</comment>
          <expr_stmt><expr><name>unionTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>findRightmost</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>selFlags</name> <operator>|=</operator> <name>SF_UsesEphemeral</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
          
  
        <comment type="block">/* Code the SELECT statements to our left
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uniondest</name></expr></argument>, <argument><expr><name>priorOp</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"multiSelect EXCEPT/UNION left...\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uniondest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>multi_select_end</name>;</goto>
        </block_content>}</block></if></if_stmt>
  
        <comment type="block">/* Code the current SELECT statement
        */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXCEPT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>op</name> <operator>=</operator> <name>SRT_Except</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UNION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>op</name> <operator>=</operator> <name>SRT_Union</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uniondest</name><operator>.</operator><name>eDest</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"%s USING TEMP B-TREE"</literal><operator>,</operator>
                          <call><name>sqlite3SelectOpName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"multiSelect EXCEPT/UNION right...\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uniondest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDelete</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UNION</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name>pLimit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  
        <comment type="block">/* Convert the data in the temporary table into whatever form
        ** it is that we currently need.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>unionTab</name><operator>==</operator><name><name>dest</name><operator>.</operator><name>iSDParm</name></name> <operator>||</operator> <name><name>dest</name><operator>.</operator><name>eDest</name></name><operator>!=</operator><name>priorOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>dest</name><operator>.</operator><name>eDest</name></name><operator>!=</operator><name>priorOp</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iCont</name></decl>, <decl><type ref="prev"/><name>iBreak</name></decl>, <decl><type ref="prev"/><name>iStart</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>iBreak</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iCont</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_INTERSECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tab1</name></decl>, <decl><type ref="prev"/><name>tab2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iCont</name></decl>, <decl><type ref="prev"/><name>iBreak</name></decl>, <decl><type ref="prev"/><name>iStart</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SelectDest</name></type> <name>intersectdest</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
  
        <comment type="block">/* INTERSECT is different from the others since it requires
        ** two temporary tables.  Hence it has its own case.  Begin
        ** by allocating the tables we will need.
        */</comment>
        <expr_stmt><expr><name>tab1</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tab2</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
        <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>findRightmost</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>selFlags</name> <operator>|=</operator> <name>SF_UsesEphemeral</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
        <comment type="block">/* Code the SELECTs to our left into temporary table "tab1".
        */</comment>
        <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intersectdest</name></expr></argument>, <argument><expr><name>SRT_Union</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x400</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"multiSelect INTERSECT left...\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intersectdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>multi_select_end</name>;</goto>
        </block_content>}</block></if></if_stmt>
  
        <comment type="block">/* Code the current SELECT into temporary table "tab2"
        */</comment>
        <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>tab2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>intersectdest</name><operator>.</operator><name>iSDParm</name></name> <operator>=</operator> <name>tab2</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"%s USING TEMP B-TREE"</literal><operator>,</operator>
                          <call><name>sqlite3SelectOpName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x400</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"multiSelect INTERSECT right...\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intersectdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDelete</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name><operator>&gt;</operator><name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name>pLimit</name></expr>;</expr_stmt>
  
        <comment type="block">/* Generate code to take the intersection of the two temporary
        ** tables.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iBreak</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iCont</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>tab2</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>,
                        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>tab2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>multi_select_end</name>;</goto></block_content></block></if></if_stmt>
  
  <comment type="block">/* Compute collating sequences used by 
  ** temporary tables needed to implement the compound select.
  ** Attach the KeyInfo structure to all temporary tables.
  **
  ** This section is run by the right-most SELECT statement only.
  ** SELECT statements to the left always skip this part.  The right-most
  ** SELECT might also skip this part if it has no ORDER BY clause and
  ** no temp tables are required.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_UsesEphemeral</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>            <comment type="block">/* Collating sequence for the result set */</comment>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>                <comment type="block">/* For looping through SELECT statements */</comment>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier><modifier>*</modifier></type><name>apColl</name></decl>;</decl_stmt>             <comment type="block">/* For looping through pKeyInfo-&gt;aColl[] */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                     <comment type="block">/* Number of columns in result set */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>multi_select_end</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>apColl</name><operator>=</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>apColl</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>apColl</name> <operator>=</operator> <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>*</operator><name>apColl</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>apColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for<control>(<init><expr><name>pLoop</name><operator>=</operator><name>p</name></expr>;</init> <condition><expr><name>pLoop</name></expr>;</condition> <incr><expr><name>pLoop</name><operator>=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>addr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* If [0] is unused then [1] is also unused.  So we can
          ** always safely abort as soon as the first unused slot is found */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3KeyInfoRef</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>multi_select_end</name>:</label>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSdst</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>nSdst</name></name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>nSdst</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDelete</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3SelectDelete</name></expr></argument>,
        <argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPOUND_SELECT */</comment>

<comment type="block">/*
** Error message for when two or more terms of a compound select have different
** size result sets.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectWrongNumTermsError</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Values</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"all VALUES must have the same number of terms"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"SELECTs to the left and right of %s"</literal>
      <literal type="string">" do not have the same number of result columns"</literal></expr></argument>,
      <argument><expr><call><name>sqlite3SelectOpName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Code an output subroutine for a coroutine implementation of a
** SELECT statment.
**
** The data to be output is contained in pIn-&gt;iSdst.  There are
** pIn-&gt;nSdst columns to be output.  pDest is where the output should
** be sent.
**
** regReturn is the number of the register holding the subroutine
** return address.
**
** If regPrev&gt;0 then it is the first register in a vector that
** records the previous output.  mem[regPrev] is a flag that is false
** if there has been no previous output.  If regPrev&gt;0 then code is
** generated to suppress duplicates.  pKeyInfo is used for comparing
** keys.
**
** If the LIMIT found in p-&gt;iLimit is reached, jump immediately to
** iBreak.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>generateOutputSubroutine</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,              <comment type="block">/* The SELECT statement */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,        <comment type="block">/* Coroutine supplying data */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,      <comment type="block">/* Where to send the data */</comment>
  <parameter><decl><type><name>int</name></type> <name>regReturn</name></decl></parameter>,          <comment type="block">/* The return address register */</comment>
  <parameter><decl><type><name>int</name></type> <name>regPrev</name></decl></parameter>,            <comment type="block">/* Previous result register.  No uniqueness if 0 */</comment>
  <parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,      <comment type="block">/* For comparing with previous entry */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBreak</name></decl></parameter>              <comment type="block">/* Jump here if we hit the LIMIT */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iContinue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iContinue</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Suppress duplicates for UNION, EXCEPT, and INTERSECT 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>regPrev</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>, <decl><type ref="prev"/><name>addr2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>regPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr2</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name>regPrev</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>,
                              <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3KeyInfoRef</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addr2</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><name>addr2</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name>regPrev</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>regPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Suppress the first OFFSET entries if there is an OFFSET clause
  */</comment>
  <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>!=</operator><name>SRT_Exists</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>!=</operator><name>SRT_Table</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Store the result as data using a unique key.
    */</comment>
    <case>case <expr><name>SRT_EphemTab</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r2</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <comment type="block">/* If we are creating a set for an "expr IN (SELECT ...)".
    */</comment>
    <case>case <expr><name>SRT_Set</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>, 
          <argument><expr><name>r1</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zAffSdst</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name>r1</name></expr></argument>,
                           <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* If this is a scalar select that is part of an expression, then
    ** store the results in the appropriate memory cell and break out
    ** of the scan loop.  Note that the select might return multiple columns
    ** if it is the RHS of a row-value IN operator.
    */</comment>
    <case>case <expr><name>SRT_Mem</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The LIMIT clause will jump out of the loop for us */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_SUBQUERY */</comment>

    <comment type="block">/* The results are stored in a sequence of registers
    ** starting at pDest-&gt;iSdst.  Then the co-routine yields.
    */</comment>
    <case>case <expr><name>SRT_Coroutine</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>nSdst</name></name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* If none of the above, then the result destination must be
    ** SRT_Output.  This routine is never called with any other
    ** destination other than the ones handled above or SRT_Output.
    **
    ** For SRT_Output, results are stored in a sequence of registers.  
    ** Then the OP_ResultRow opcode is used to cause sqlite3_step() to
    ** return the next row of result.
    */</comment>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_Output</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <comment type="block">/* Jump to the end of the loop if the LIMIT is reached.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DecrJumpZero</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate the subroutine return
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Alternative compound select code generator for cases when there
** is an ORDER BY clause.
**
** We assume a query of the following form:
**
**      &lt;selectA&gt;  &lt;operator&gt;  &lt;selectB&gt;  ORDER BY &lt;orderbylist&gt;
**
** &lt;operator&gt; is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea
** is to code both &lt;selectA&gt; and &lt;selectB&gt; with the ORDER BY clause as
** co-routines.  Then run the co-routines in parallel and merge the results
** into the output.  In addition to the two coroutines (called selectA and
** selectB) there are 7 subroutines:
**
**    outA:    Move the output of the selectA coroutine into the output
**             of the compound query.
**
**    outB:    Move the output of the selectB coroutine into the output
**             of the compound query.  (Only generated for UNION and
**             UNION ALL.  EXCEPT and INSERTSECT never output a row that
**             appears only in B.)
**
**    AltB:    Called when there is data from both coroutines and A&lt;B.
**
**    AeqB:    Called when there is data from both coroutines and A==B.
**
**    AgtB:    Called when there is data from both coroutines and A&gt;B.
**
**    EofA:    Called when data is exhausted from selectA.
**
**    EofB:    Called when data is exhausted from selectB.
**
** The implementation of the latter five subroutines depend on which 
** &lt;operator&gt; is used:
**
**
**             UNION ALL         UNION            EXCEPT          INTERSECT
**          -------------  -----------------  --------------  -----------------
**   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA
**
**   AeqB:   outA, nextA         nextA             nextA         outA, nextA
**
**   AgtB:   outB, nextB      outB, nextB          nextB            nextB
**
**   EofA:   outB, nextB      outB, nextB          halt             halt
**
**   EofB:   outA, nextA      outA, nextA       outA, nextA         halt
**
** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA
** causes an immediate jump to EofA and an EOF on B following nextB causes
** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or
** following nextX causes a jump to the end of the select processing.
**
** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled
** within the output subroutine.  The regPrev register set holds the previously
** output value.  A comparison is made against this value and the output
** is skipped if the next results would be the same as the previous.
**
** The implementation plan is to implement the two coroutines and seven
** subroutines first, then put the control logic at the bottom.  Like this:
**
**          goto Init
**     coA: coroutine for left query (A)
**     coB: coroutine for right query (B)
**    outA: output one row of A
**    outB: output one row of B (UNION and UNION ALL only)
**    EofA: ...
**    EofB: ...
**    AltB: ...
**    AeqB: ...
**    AgtB: ...
**    Init: initialize coroutine registers
**          yield coA
**          if eof(A) goto EofA
**          yield coB
**          if eof(B) goto EofB
**    Cmpr: Compare A, B
**          Jump AltB, AeqB, AgtB
**     End: ...
**
** We call AltB, AeqB, AgtB, EofA, and EofB "subroutines" but they are not
** actually called using Gosub and they do not Return.  EofA and EofB loop
** until all data is exhausted then jump to the "end" labe.  AltB, AeqB,
** and AgtB jump to either L2 or to one of EofA or EofB.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiSelectOrderBy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>             <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>       <comment type="block">/* Another SELECT immediately to our left */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSplit</name></decl>;</decl_stmt>       <comment type="block">/* Left-most SELECT in the right-hand group */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSelect</name></decl>;</decl_stmt>          <comment type="block">/* Number of SELECT statements in the compound */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Generate code to this VDBE */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>destA</name></decl>;</decl_stmt>     <comment type="block">/* Destination for coroutine A */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>destB</name></decl>;</decl_stmt>     <comment type="block">/* Destination for coroutine B */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAddrA</name></decl>;</decl_stmt>         <comment type="block">/* Address register for select-A coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAddrB</name></decl>;</decl_stmt>         <comment type="block">/* Address register for select-B coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrSelectA</name></decl>;</decl_stmt>      <comment type="block">/* Address of the select-A coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrSelectB</name></decl>;</decl_stmt>      <comment type="block">/* Address of the select-B coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOutA</name></decl>;</decl_stmt>          <comment type="block">/* Address register for the output-A subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOutB</name></decl>;</decl_stmt>          <comment type="block">/* Address register for the output-B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOutA</name></decl>;</decl_stmt>         <comment type="block">/* Address of the output-A subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOutB</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Address of the output-B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEofA</name></decl>;</decl_stmt>         <comment type="block">/* Address of the select-A-exhausted subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEofA_noB</name></decl>;</decl_stmt>     <comment type="block">/* Alternate addrEofA if B is uninitialized */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEofB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the select-B-exhausted subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrAltB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the A&lt;B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrAeqB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the A==B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrAgtB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the A&gt;B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regLimitA</name></decl>;</decl_stmt>        <comment type="block">/* Limit register for select-A */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regLimitB</name></decl>;</decl_stmt>        <comment type="block">/* Limit register for select-A */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regPrev</name></decl>;</decl_stmt>          <comment type="block">/* A range of registers to hold previous output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>savedLimit</name></decl>;</decl_stmt>       <comment type="block">/* Saved value of p-&gt;iLimit */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>savedOffset</name></decl>;</decl_stmt>      <comment type="block">/* Saved value of p-&gt;iOffset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelCmpr</name></decl>;</decl_stmt>        <comment type="block">/* Label for the start of the merge algorithm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelEnd</name></decl>;</decl_stmt>         <comment type="block">/* Label for the end of the overall SELECT stmt */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>            <comment type="block">/* Jump instructions that get retargetted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>               <comment type="block">/* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyDup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Comparison information for duplicate removal */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyMerge</name></decl>;</decl_stmt>   <comment type="block">/* Comparison information for merging rows */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl>;</decl_stmt>   <comment type="block">/* The ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>         <comment type="block">/* Number of terms in the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aPermute</name></decl>;</decl_stmt>        <comment type="block">/* Mapping from ORDER BY terms to result set columns */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyDup</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* "Managed" code needs this.  Ticket #3382. */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* Already thrown the error if VDBE alloc failed */</comment>
  <expr_stmt><expr><name>labelEnd</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>labelCmpr</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Patch up the ORDER BY clause
  */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>

  <comment type="block">/* For operators other than UNION ALL we have to make sure that
  ** the ORDER BY clause covers every term of the result set.  Add
  ** terms to the ORDER BY clause as necessary.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_ALL</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nOrderBy</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_IntValue</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>nOrderBy</name><operator>++</operator></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute the comparison permutation and keyinfo that is used with
  ** the permutation used to determine if the next
  ** row of results comes from selectA or selectB.  Also add explicit
  ** collations to the ORDER BY clause terms so that when the subqueries
  ** to the right and the left are evaluated, they use the correct
  ** collation.
  */</comment>
  <expr_stmt><expr><name>aPermute</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nOrderBy</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aPermute</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>aPermute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nOrderBy</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aPermute</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pKeyMerge</name> <operator>=</operator> <call><name>multiSelectOrderByKeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pKeyMerge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Allocate a range of temporary registers and the KeyInfo needed
  ** for the logic that removes duplicate result rows when the
  ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_ALL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regPrev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOrderBy</name><operator>&gt;=</operator><name>nExpr</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regPrev</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nExpr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyDup</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pKeyDup</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pKeyDup</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExpr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pKeyDup</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pKeyDup</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
 
  <comment type="block">/* Separate the left and the right query from one another
  */</comment>
  <expr_stmt><expr><name>nSelect</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UNION</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BalancedMerge</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pSplit</name><operator>=</operator><name>p</name></expr>;</init> <condition><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSplit</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>op</name></expr>;</condition> <incr><expr><name>pSplit</name><operator>=</operator><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>nSelect</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name>pSplit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSelect</name><operator>&lt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pSplit</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pSplit</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSelect</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><name>pSplit</name> <operator>=</operator> <name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt> </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>==</operator> <name>pOrderBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ResolveOrderGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="string">"ORDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ResolveOrderGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="string">"ORDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compute the limit registers */</comment>
  <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>TK_ALL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regLimitA</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regLimitB</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></else></ternary></expr></argument>,
                                  <argument><expr><name>regLimitA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regLimitA</name></expr></argument>, <argument><expr><name>regLimitB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>regLimitA</name> <operator>=</operator> <name>regLimitB</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>regAddrA</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regAddrB</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regOutA</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regOutB</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>destA</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>destB</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"MERGE (%s)"</literal><operator>,</operator> <call><name>sqlite3SelectOpName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a coroutine to evaluate the SELECT statement to the
  ** left of the compound operator - the "A" select.
  */</comment>
  <expr_stmt><expr><name>addrSelectA</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrSelectA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"left SELECT"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name>regLimitA</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"LEFT"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeEndCoroutine</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a coroutine to evaluate the SELECT statement on 
  ** the right - the "B" select
  */</comment>
  <expr_stmt><expr><name>addrSelectB</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrSelectB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"right SELECT"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedLimit</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedOffset</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name>regLimitB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"RIGHT"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name>savedLimit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name>savedOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeEndCoroutine</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a subroutine that outputs the current row of the A
  ** select as the next output row of the compound select.
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Output routine for A"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrOutA</name> <operator>=</operator> <call><name>generateOutputSubroutine</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                 <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destA</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>regOutA</name></expr></argument>,
                 <argument><expr><name>regPrev</name></expr></argument>, <argument><expr><name>pKeyDup</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Generate a subroutine that outputs the current row of the B
  ** select as the next output row of the compound select.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UNION</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Output routine for B"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrOutB</name> <operator>=</operator> <call><name>generateOutputSubroutine</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                 <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destB</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>regOutB</name></expr></argument>,
                 <argument><expr><name>regPrev</name></expr></argument>, <argument><expr><name>pKeyDup</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><name>pKeyDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a subroutine to run when the results from select A
  ** are exhausted and only data in select B remains.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_EXCEPT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_INTERSECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrEofA_noB</name> <operator>=</operator> <name>addrEofA</name> <operator>=</operator> <name>labelEnd</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>  
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"eof-A subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrEofA</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutB</name></expr></argument>, <argument><expr><name>addrOutB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrEofA_noB</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                     <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Generate a subroutine to run when the results from select B
  ** are exhausted and only data in select A remains.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_INTERSECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrEofB</name> <operator>=</operator> <name>addrEofA</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>&gt;</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>  
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"eof-B subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrEofB</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutA</name></expr></argument>, <argument><expr><name>addrOutA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Generate code to handle the case of A&lt;B
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"A-lt-B subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrAltB</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutA</name></expr></argument>, <argument><expr><name>addrOutA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code to handle the case of A==B
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_ALL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrAeqB</name> <operator>=</operator> <name>addrAltB</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_INTERSECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrAeqB</name> <operator>=</operator> <name>addrAltB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrAltB</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"A-eq-B subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrAeqB</name> <operator>=</operator>
    <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Generate code to handle the case of A&gt;B
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"A-gt-B subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrAgtB</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UNION</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutB</name></expr></argument>, <argument><expr><name>addrOutB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>, <argument><expr><name>addrEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This code runs once to initialize everything.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>, <argument><expr><name>addrEofA_noB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>, <argument><expr><name>addrEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Implement the main merge loop
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Permutation</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>aPermute</name></expr></argument>, <argument><expr><name>P4_INTARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name><name>destA</name><operator>.</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name><name>destB</name><operator>.</operator><name>iSdst</name></name></expr></argument>, <argument><expr><name>nOrderBy</name></expr></argument>,
                         <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKeyMerge</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_PERMUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addrAltB</name></expr></argument>, <argument><expr><name>addrAeqB</name></expr></argument>, <argument><expr><name>addrAgtB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Jump to the this point in order to terminate the query.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make arrangements to free the 2nd and subsequent arms of the compound
  ** after the parse has finished */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
       <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3SelectDelete</name></expr></argument>, <argument><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pSplit</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/*** TBD:  Insert subroutine calls to close cursors on incomplete
  **** subqueries ****/</comment>
  <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* An instance of the SubstContext object describes an substitution edit
** to be performed on a parse tree.
**
** All references to columns in table iTable are to be replaced by corresponding
** expressions in pEList.
**
** ## About "isOuterJoin":
**
** The isOuterJoin column indicates that the replacement will occur into a
** position in the parent that NULL-able due to an OUTER JOIN.  Either the
** target slot in the parent is the right operand of a LEFT JOIN, or one of
** the left operands of a RIGHT JOIN.  In either case, we need to potentially
** bypass the substituted expression with OP_IfNullRow.
**
** Suppose the original expression is an integer constant. Even though the table
** has the nullRow flag set, because the expression is an integer constant,
** it will not be NULLed out.  So instead, we insert an OP_IfNullRow opcode
** that checks to see if the nullRow flag is set on the table.  If the nullRow
** flag is set, then the value in the register is set to NULL and the original
** expression is bypassed.  If the nullRow flag is not set, then the original
** expression runs to populate the register.
**
** Example where this is needed:
**
**      CREATE TABLE t1(a INTEGER PRIMARY KEY, b INT);
**      CREATE TABLE t2(x INT UNIQUE);
**
**      SELECT a,b,m,x FROM t1 LEFT JOIN (SELECT 59 AS m,x FROM t2) ON b=x;
**
** When the subquery on the right side of the LEFT JOIN is flattened, we
** have to add OP_IfNullRow in front of the OP_Integer that implements the
** "m" value of the subquery so that a NULL will be loaded instead of 59
** when processing a non-matched row of the left.
*/</comment>
<typedef>typedef <type><struct>struct <name>SubstContext</name> <block>{
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>            <comment type="block">/* The parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTable</name></decl>;</decl_stmt>               <comment type="block">/* Replace references to this table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNewTable</name></decl>;</decl_stmt>            <comment type="block">/* New table number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isOuterJoin</name></decl>;</decl_stmt>          <comment type="block">/* Add TK_IF_NULL_ROW opcodes on each replacement */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>         <comment type="block">/* Replacement expressions */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pCList</name></decl>;</decl_stmt>         <comment type="block">/* Collation sequences for replacement expr */</comment>
}</block></struct></type> <name>SubstContext</name>;</typedef>

<comment type="block">/* Forward Declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>substExprList</name><parameter_list>(<parameter><decl><type><name>SubstContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ExprList</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>substSelect</name><parameter_list>(<parameter><decl><type><name>SubstContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Select</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Scan through the expression pExpr.  Replace every reference to
** a column in table number iTable with a copy of the iColumn-th
** entry in pEList.  (But leave references to the ROWID column 
** unchanged.)
**
** This routine is part of the flattening procedure.  A subquery
** whose result set is defined by pEList appears as entry in the
** FROM clause of a SELECT such that the VDBE cursor assigned to that
** FORM clause entry is iTable.  This routine makes the necessary 
** changes to pExpr so that it refers directly to the source table
** of the subquery rather the result set of the subquery.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>substExpr</name><parameter_list>(
  <parameter><decl><type><name>SubstContext</name> <modifier>*</modifier></type><name>pSubst</name></decl></parameter>,  <comment type="block">/* Description of the substitution */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>            <comment type="block">/* Expr in which substitution occurs */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name><operator>==</operator><name><name>pSubst</name><operator>-&gt;</operator><name>iTable</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name> <operator>=</operator> <name><name>pSubst</name><operator>-&gt;</operator><name>iNewTable</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSubst</name><operator>-&gt;</operator><name>iTable</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><name><name>pSubst</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>ifNullRow</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubst</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iColumn</name><operator>&lt;</operator><name><name>pSubst</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name>pCopy</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VectorErrorMsg</name><argument_list>(<argument><expr><name><name>pSubst</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pSubst</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pSubst</name><operator>-&gt;</operator><name>isOuterJoin</name></name> <operator>&amp;&amp;</operator> <name><name>pCopy</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifNullRow</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ifNullRow</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ifNullRow</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_IF_NULL_ROW</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ifNullRow</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <name>pCopy</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ifNullRow</name><operator>.</operator><name>iTable</name></name> <operator>=</operator> <name><name>pSubst</name><operator>-&gt;</operator><name>iNewTable</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ifNullRow</name><operator>.</operator><name>iColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">99</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ifNullRow</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>EP_IfNullRow</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <operator>&amp;</operator><name>ifNullRow</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>EP_Subquery</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>pExpr</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pSubst</name><operator>-&gt;</operator><name>isOuterJoin</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3SetJoinExpr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name></expr></argument>,
                             <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRUEFALSE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <call><name>sqlite3ExprTruthValue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_INTEGER</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Ensure that the expression now has an implicit collation sequence,
        ** just as it did when it was a column of a view or sub-query. */</comment>
        <block>{<block_content>
          <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pNat</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name><name>pSubst</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name><name>pSubst</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>,
                <argument><expr><name><name>pSubst</name><operator>-&gt;</operator><name>pCList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>
          )</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>pNat</name><operator>!=</operator><name>pColl</name> <operator>||</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLLATE</name><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name><name>pSubst</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>,
                <argument><expr><operator>(</operator><ternary><condition><expr><name>pColl</name></expr> ?</condition><then> <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><literal type="string">"BINARY"</literal></expr></else></ternary><operator>)</operator></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Collate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSubst</name><operator>-&gt;</operator><name>iTable</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pSubst</name><operator>-&gt;</operator><name>iNewTable</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>substSelect</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>substExprList</name><parameter_list>(
  <parameter><decl><type><name>SubstContext</name> <modifier>*</modifier></type><name>pSubst</name></decl></parameter>, <comment type="block">/* Description of the substitution */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>       <comment type="block">/* List to scan and in which to make substitutes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>substSelect</name><parameter_list>(
  <parameter><decl><type><name>SubstContext</name> <modifier>*</modifier></type><name>pSubst</name></decl></parameter>, <comment type="block">/* Description of the substitution */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* SELECT statement in which to make substitutions */</comment>
  <parameter><decl><type><name>int</name></type> <name>doPrior</name></decl></parameter>           <comment type="block">/* Do substitutes on p-&gt;pPrior too */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>substSelect</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>pSubst</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><name>doPrior</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** pSelect is a SELECT statement and pSrcItem is one item in the FROM
** clause of that SELECT.
**
** This routine scans the entire SELECT statement and recomputes the
** pSrcItem-&gt;colUsed mask.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recomputeColumnsUsedExpr</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pSrcItem</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>!=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>|=</operator> <call><name>sqlite3ExprColUsed</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recomputeColumnsUsed</name><parameter_list>(
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,                 <comment type="block">/* The complete SELECT statement */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrcItem</name></decl></parameter>                <comment type="block">/* Which FROM clause item to recompute */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pSrcItem</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>recomputeColumnsUsedExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pSrcItem</name></name> <operator>=</operator> <name>pSrcItem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSrcItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Assign new cursor numbers to each of the items in pSrc. For each
** new cursor number assigned, set an entry in the aCsrMap[] array 
** to map the old cursor number to the new:
**
**     aCsrMap[iOld+1] = iNew;
**
** The array is guaranteed by the caller to be large enough for all
** existing cursor numbers in pSrc.  aCsrMap[0] is the array size.
**
** If pSrc contains any sub-selects, call this routine recursively
** on the FROM clause of each such sub-select, with iExcept set to -1.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>srclistRenumberCursors</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aCsrMap</name></decl></parameter>,                   <comment type="block">/* Array to store cursor mappings in */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                  <comment type="block">/* FROM clause to renumber */</comment>
  <parameter><decl><type><name>int</name></type> <name>iExcept</name></decl></parameter>                     <comment type="block">/* FROM clause item to skip */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>iExcept</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>&lt;</operator> <name><name>aCsrMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name> <operator>||</operator> <name><name>aCsrMap</name><index>[<expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aCsrMap</name><index>[<expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name><name>aCsrMap</name><index>[<expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>srclistRenumberCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>aCsrMap</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** *piCursor is a cursor number.  Change it if it needs to be mapped.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renumberCursorDoMapping</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aCsrMap</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aiCol</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCsr</name> <init>= <expr><operator>*</operator><name>piCursor</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>iCsr</name> <argument_list type="generic">&lt; <argument><expr><name><name>aCsrMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>aCsrMap</name><index>[<expr><name>iCsr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piCursor</name> <operator>=</operator> <name><name>aCsrMap</name><index>[<expr><name>iCsr</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expression walker callback used by renumberCursors() to update
** Expr objects to match newly assigned cursor numbers.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renumberCursorsCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_IF_NULL_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>renumberCursorDoMapping</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>renumberCursorDoMapping</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Assign a new cursor number to each cursor in the FROM clause (Select.pSrc)
** of the SELECT statement passed as the second argument, and to each 
** cursor in the FROM clause of any FROM clause sub-selects, recursively.
** Except, do not assign a new cursor number to the iExcept'th element in
** the FROM clause of (*p). Update all expressions and other references 
** to refer to the new cursor numbers.
**
** Argument aCsrMap is an array that may be used for temporary working
** space. Two guarantees are made by the caller:
**
**   * the array is larger than the largest cursor number used within the
**     select statement passed as an argument, and
**
**   * the array entries for all cursor numbers that do *not* appear in 
**     FROM clauses of the select statement as described above are 
**     initialized to zero.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renumberCursors</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                      <comment type="block">/* Select to renumber cursors within */</comment>
  <parameter><decl><type><name>int</name></type> <name>iExcept</name></decl></parameter>,                    <comment type="block">/* FROM clause item to skip */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aCsrMap</name></decl></parameter>                    <comment type="block">/* Working space */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>srclistRenumberCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>aCsrMap</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>, <argument><expr><name>iExcept</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>aiCol</name></name> <operator>=</operator> <name>aCsrMap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>renumberCursorsCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<comment type="block">/*
** If pSel is not part of a compound SELECT, return a pointer to its
** expression list. Otherwise, return a pointer to the expression list
** of the leftmost SELECT in the compound.
*/</comment>
<function><type><specifier>static</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>findLeftmostExprlist</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pSel</name> <operator>=</operator> <name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if any of the result-set columns in the compound query
** have incompatible affinities on one or more arms of the compound.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>compoundHasDifferentAffinities</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub1</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pSub1</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</init> <condition><expr><name>pSub1</name></expr>;</condition> <incr><expr><name>pSub1</name><operator>=</operator><name><name>pSub1</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub1</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub1</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name>ii</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub1</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pSub1</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call><operator>!=</operator><name>aff</name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This routine attempts to flatten subqueries as a performance optimization.
** This routine returns 1 if it makes changes and 0 if no flattening occurs.
**
** To understand the concept of flattening, consider the following
** query:
**
**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z&lt;100) WHERE a&gt;5
**
** The default way of implementing this query is to execute the
** subquery first and store the results in a temporary table, then
** run the outer query on that temporary table.  This requires two
** passes over the data.  Furthermore, because the temporary table
** has no indices, the WHERE clause on the outer query cannot be
** optimized.
**
** This routine attempts to rewrite queries such as the above into
** a single flat select, like this:
**
**     SELECT x+y AS a FROM t1 WHERE z&lt;100 AND a&gt;5
**
** The code generated for this simplification gives the same result
** but only has to scan the data once.  And because indices might 
** exist on the table t1, a complete scan of the data might be
** avoided.
**
** Flattening is subject to the following constraints:
**
**  (**)  We no longer attempt to flatten aggregate subqueries. Was:
**        The subquery and the outer query cannot both be aggregates.
**
**  (**)  We no longer attempt to flatten aggregate subqueries. Was:
**        (2) If the subquery is an aggregate then
**        (2a) the outer query must not be a join and
**        (2b) the outer query must not use subqueries
**             other than the one FROM-clause subquery that is a candidate
**             for flattening.  (This is due to ticket [2f7170d73bf9abf80]
**             from 2015-02-09.)
**
**   (3)  If the subquery is the right operand of a LEFT JOIN then
**        (3a) the subquery may not be a join and
**        (3b) the FROM clause of the subquery may not contain a virtual
**             table and
**        (**) Was: "The outer query may not have a GROUP BY." This case
**             is now managed correctly
**        (3d) the outer query may not be DISTINCT.
**        See also (26) for restrictions on RIGHT JOIN.
**
**   (4)  The subquery can not be DISTINCT.
**
**  (**)  At one point restrictions (4) and (5) defined a subset of DISTINCT
**        sub-queries that were excluded from this optimization. Restriction 
**        (4) has since been expanded to exclude all DISTINCT subqueries.
**
**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:
**        If the subquery is aggregate, the outer query may not be DISTINCT.
**
**   (7)  The subquery must have a FROM clause.  TODO:  For subqueries without
**        A FROM clause, consider adding a FROM clause with the special
**        table sqlite_once that consists of a single row containing a
**        single NULL.
**
**   (8)  If the subquery uses LIMIT then the outer query may not be a join.
**
**   (9)  If the subquery uses LIMIT then the outer query may not be aggregate.
**
**  (**)  Restriction (10) was removed from the code on 2005-02-05 but we
**        accidently carried the comment forward until 2014-09-15.  Original
**        constraint: "If the subquery is aggregate then the outer query 
**        may not use LIMIT."
**
**  (11)  The subquery and the outer query may not both have ORDER BY clauses.
**
**  (**)  Not implemented.  Subsumed into restriction (3).  Was previously
**        a separate restriction deriving from ticket #350.
**
**  (13)  The subquery and outer query may not both use LIMIT.
**
**  (14)  The subquery may not use OFFSET.
**
**  (15)  If the outer query is part of a compound select, then the
**        subquery may not use LIMIT.
**        (See ticket #2339 and ticket [02a8e81d44]).
**
**  (16)  If the outer query is aggregate, then the subquery may not
**        use ORDER BY.  (Ticket #2942)  This used to not matter
**        until we introduced the group_concat() function.  
**
**  (17)  If the subquery is a compound select, then
**        (17a) all compound operators must be a UNION ALL, and
**        (17b) no terms within the subquery compound may be aggregate
**              or DISTINCT, and
**        (17c) every term within the subquery compound must have a FROM clause
**        (17d) the outer query may not be
**              (17d1) aggregate, or
**              (17d2) DISTINCT
**        (17e) the subquery may not contain window functions, and
**        (17f) the subquery must not be the RHS of a LEFT JOIN.
**        (17g) either the subquery is the first element of the outer
**              query or there are no RIGHT or FULL JOINs in any arm
**              of the subquery.  (This is a duplicate of condition (27b).)
**        (17h) The corresponding result set expressions in all arms of the
**              compound must have the same affinity. (See restriction (9)
**              on the push-down optimization.)
**
**        The parent and sub-query may contain WHERE clauses. Subject to
**        rules (11), (13) and (14), they may also contain ORDER BY,
**        LIMIT and OFFSET clauses.  The subquery cannot use any compound
**        operator other than UNION ALL because all the other compound
**        operators have an implied DISTINCT which is disallowed by
**        restriction (4).
**
**        Also, each component of the sub-query must return the same number
**        of result columns. This is actually a requirement for any compound
**        SELECT statement, but all the code here does is make sure that no
**        such (illegal) sub-query is flattened. The caller will detect the
**        syntax error and return a detailed message.
**
**  (18)  If the sub-query is a compound select, then all terms of the
**        ORDER BY clause of the parent must be copies of a term returned
**        by the parent query.
**
**  (19)  If the subquery uses LIMIT then the outer query may not
**        have a WHERE clause.
**
**  (20)  If the sub-query is a compound select, then it must not use
**        an ORDER BY clause.  Ticket #3773.  We could relax this constraint
**        somewhat by saying that the terms of the ORDER BY clause must
**        appear as unmodified result columns in the outer query.  But we
**        have other optimizations in mind to deal with that case.
**
**  (21)  If the subquery uses LIMIT then the outer query may not be
**        DISTINCT.  (See ticket [752e1646fc]).
**
**  (22)  The subquery may not be a recursive CTE.
**
**  (23)  If the outer query is a recursive CTE, then the sub-query may not be
**        a compound query.  This restriction is because transforming the
**        parent to a compound query confuses the code that handles
**        recursive queries in multiSelect().
**
**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:
**        The subquery may not be an aggregate that uses the built-in min() or 
**        or max() functions.  (Without this restriction, a query like:
**        "SELECT x FROM (SELECT max(y), x FROM t1)" would not necessarily
**        return the value X for which Y was maximal.)
**
**  (25)  If either the subquery or the parent query contains a window
**        function in the select list or ORDER BY clause, flattening
**        is not attempted.
**
**  (26)  The subquery may not be the right operand of a RIGHT JOIN.
**        See also (3) for restrictions on LEFT JOIN.
**
**  (27)  The subquery may not contain a FULL or RIGHT JOIN unless it
**        is the first element of the parent query.  Two subcases:
**        (27a) the subquery is not a compound query.
**        (27b) the subquery is a compound query and the RIGHT JOIN occurs
**              in any arm of the compound query.  (See also (17g).)
**
**  (28)  The subquery is not a MATERIALIZED CTE.
**
**
** In this routine, the "p" parameter is a pointer to the outer query.
** The subquery is p-&gt;pSrc-&gt;a[iFrom].  isAgg is true if the outer query
** uses aggregates.
**
** If flattening is not attempted, this routine is a no-op and returns 0.
** If flattening is attempted this routine returns 1.
**
** All of the expression analysis must occur on both the outer query and
** the subquery before this routine runs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>flattenSubquery</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,           <comment type="block">/* The parent or outer SELECT statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>,           <comment type="block">/* Index in p-&gt;pSrc-&gt;a[] of the inner subquery */</comment>
  <parameter><decl><type><name>int</name></type> <name>isAgg</name></decl></parameter>            <comment type="block">/* True if outer SELECT uses aggregate functions */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSavedAuthContext</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pParent</name></decl>;</decl_stmt>    <comment type="block">/* Current UNION ALL term of the other query */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name></decl>;</decl_stmt>       <comment type="block">/* The inner query or "subquery" */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub1</name></decl>;</decl_stmt>      <comment type="block">/* Pointer to the rightmost select in sub-query */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>      <comment type="block">/* The FROM clause of the outer query */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSubSrc</name></decl>;</decl_stmt>   <comment type="block">/* The FROM clause of the subquery */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iParent</name></decl>;</decl_stmt>        <comment type="block">/* VDBE cursor number of the pSub result set temp table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNewParent</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt><comment type="block">/* Replacement table for iParent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isOuterJoin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True if pSub is the right side of a LEFT JOIN */</comment>    
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>              <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl>;</decl_stmt>                    <comment type="block">/* The WHERE clause */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSubitem</name></decl>;</decl_stmt>               <comment type="block">/* The subquery */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>                        <comment type="block">/* Walker to persist agginfo data */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aCsrMap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check to see if flattening is permitted.  Return 0 if not.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_QueryFlattener</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name> <operator>&amp;&amp;</operator> <name>iFrom</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iFrom</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubitem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iFrom</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iParent</name> <operator>=</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSub</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name> <operator>||</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                  <comment type="block">/* Restriction (25) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>pSubSrc</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSubSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,
  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET
  ** because they could be computed at compile-time.  But when LIMIT and OFFSET
  ** became arbitrary expressions, we were forced to add restrictions (13)
  ** and (14). */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Restriction (13) */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Restriction (14) */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Compound</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                                            <comment type="block">/* Restriction (15) */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSubSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                       <comment type="block">/* Restriction (7)  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>           <comment type="block">/* Restriction (4)  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>isAgg</name><operator>)</operator></expr> )</condition><block>{<block_content>
     <return>return <expr><literal type="number">0</literal></expr>;</return>         <comment type="block">/* Restrictions (8)(9) */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
     <return>return <expr><literal type="number">0</literal></expr>;</return>                                           <comment type="block">/* Restriction (11) */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isAgg</name> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* Restriction (16) */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Restriction (19) */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
     <return>return <expr><literal type="number">0</literal></expr>;</return>         <comment type="block">/* Restriction (21) */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Recursive</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Restrictions (22) */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** If the subquery is the right operand of a LEFT JOIN, then the
  ** subquery may not be a join itself (3a). Example of why this is not
  ** allowed:
  **
  **         t1 LEFT OUTER JOIN (t2 JOIN t3)
  **
  ** If we flatten the above, we would get
  **
  **         (t1 LEFT OUTER JOIN t2) JOIN t3
  **
  ** which is not at all the same thing.
  **
  ** See also tickets #306, #350, and #3300.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSubitem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_OUTER</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSubSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal>                        <comment type="block">/* (3a) */</comment>
     <operator>||</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pSubSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>)</argument_list></call>          <comment type="block">/* (3b) */</comment>
     <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>         <comment type="block">/* (3d) */</comment>
     <operator>||</operator> <operator>(</operator><name><name>pSubitem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>  <comment type="block">/* (26) */</comment>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>isOuterJoin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* True by restriction (7) */</comment>
  <if_stmt><if>if<condition>( <expr><name>iFrom</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSubSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Restriction (27a) */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSubitem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name> <operator>&amp;&amp;</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>eM10d</name></name><operator>==</operator><name>M10d_Yes</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>       <comment type="block">/* (28) */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Restriction (17): If the sub-query is a compound SELECT, then it must
  ** use only the UNION ALL operator. And none of the simple select queries
  ** that make up the compound SELECT are allowed to be aggregate or distinct
  ** queries.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Restriction (20) */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>isAgg</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>isOuterJoin</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* (17d1), (17d2), or (17f) */</comment>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pSub1</name><operator>=</operator><name>pSub</name></expr>;</init> <condition><expr><name>pSub1</name></expr>;</condition> <incr><expr><name>pSub1</name><operator>=</operator><name><name>pSub1</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSub1</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Distinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSub1</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Aggregate</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pSrc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name><name>pSub1</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSub1</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>    <comment type="block">/* (17b) */</comment>
       <operator>||</operator> <operator>(</operator><name><name>pSub1</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>&amp;&amp;</operator> <name><name>pSub1</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ALL</name><operator>)</operator>                 <comment type="block">/* (17a) */</comment>
       <operator>||</operator> <name><name>pSub1</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&lt;</operator><literal type="number">1</literal>                                  <comment type="block">/* (17c) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
       <operator>||</operator> <name><name>pSub1</name><operator>-&gt;</operator><name>pWin</name></name></expr>                                          <comment type="block">/* (17e) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iFrom</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSub1</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Without this restriction, the JT_LTORJ flag would end up being
        ** omitted on left-hand tables of the right join that is being
        ** flattened. */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Restrictions (17g), (27b) */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pSub1</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Restriction (18). */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Restriction (23) */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Restriction (17h) */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>compoundHasDifferentAffinities</name><argument_list>(<argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nSelect</name></name><operator>&gt;</operator><literal type="number">500</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_FlttnUnionAll</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>aCsrMap</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aCsrMap</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aCsrMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block" format="doxygen">/***** If we reach this point, flattening is permitted. *****/</comment>
  <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x4</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"flatten %u.%p from term %d\n"</literal><operator>,</operator>
                   <name><name>pSub</name><operator>-&gt;</operator><name>selId</name></name><operator>,</operator> <name>pSub</name><operator>,</operator> <name>iFrom</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Authorize the subquery */</comment>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>(<argument>i =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_SELECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>SQLITE_DENY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name>zSavedAuthContext</name></expr>;</expr_stmt>

  <comment type="block">/* Delete the transient structures associated with thesubquery */</comment>
  <expr_stmt><expr><name>pSub1</name> <operator>=</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>zDatabase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>zAlias</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the sub-query is a compound SELECT statement, then (by restrictions
  ** 17 and 18 above) it must be a UNION ALL and the parent query must 
  ** be of the form:
  **
  **     SELECT &lt;expr-list&gt; FROM (&lt;sub-query&gt;) &lt;where-clause&gt; 
  **
  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block
  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or 
  ** OFFSET clauses and joins them to the left-hand-side of the original
  ** using UNION ALL operators. In this case N is the number of simple
  ** select statements in the compound sub-query.
  **
  ** Example:
  **
  **     SELECT a+1 FROM (
  **        SELECT x FROM tab
  **        UNION ALL
  **        SELECT y FROM tab
  **        UNION ALL
  **        SELECT abs(z*2) FROM tab2
  **     ) WHERE a!=5 ORDER BY 1
  **
  ** Transformed into:
  **
  **     SELECT x+1 FROM tab WHERE x+1!=5
  **     UNION ALL
  **     SELECT y+1 FROM tab WHERE y+1!=5
  **     UNION ALL
  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5
  **     ORDER BY 1
  **
  ** We call this the "compound-subquery flattening".
  */</comment>
  <for>for<control>(<init><expr><name>pSub</name><operator>=</operator><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</init> <condition><expr><name>pSub</name></expr>;</condition> <incr><expr><name>pSub</name><operator>=</operator><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pPrior</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pItemTab</name> <init>= <expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name>pLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ALL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pItemTab</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>selId</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nSelect</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aCsrMap</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>renumberCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><name>aCsrMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPrior</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x4</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"compound-subquery flattener"</literal>
                              <literal type="string">" creates %u as peer\n"</literal><operator>,</operator><name><name>pNew</name><operator>-&gt;</operator><name>selId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aCsrMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <name>pSub1</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Defer deleting the Table object associated with the
  ** subquery until code generation is
  ** complete, since there may still exist Expr.pTab entries that
  ** refer to the subquery even after flattening.  Ticket #3346.
  **
  ** pSubitem-&gt;pTab is always non-NULL by test restrictions and tests above.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTabToDel</name> <init>= <expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTabToDel</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pToplevel</name></expr></argument>, 
         <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3DeleteTable</name></expr></argument>,
         <argument><expr><name>pTabToDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>earlyCleanup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTabToDel</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pSubitem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The following loop runs once for each term in a compound-subquery
  ** flattening (as described above).  If we are doing a different kind
  ** of flattening - a flattening other than a compound-subquery flattening -
  ** then this loop only runs once.
  **
  ** This loop moves all of the FROM elements of the subquery into the
  ** the FROM clause of the outer query.  Before doing this, remember
  ** the cursor number for the original outer query FROM element in
  ** iParent.  The iParent cursor will never be used.  Subsequent code
  ** will scan expressions looking for iParent references and replace
  ** those references with expressions that resolve to the subquery FROM
  ** elements we are now copying in.
  */</comment>
  <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name>pSub1</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pParent</name><operator>=</operator><name>p</name></expr>;</init> <condition><expr><name>pParent</name></expr>;</condition> <incr><expr><name>pParent</name><operator>=</operator><name><name>pParent</name><operator>-&gt;</operator><name>pPrior</name></name></expr><operator>,</operator> <expr><name>pSub</name><operator>=</operator><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSubSrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>jointype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>ltorj</name> <init>= <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iFrom</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSub</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSubSrc</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>     <comment type="block">/* FROM clause of subquery */</comment>
    <expr_stmt><expr><name>nSubSrc</name> <operator>=</operator> <name><name>pSubSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</expr_stmt>  <comment type="block">/* Number of terms in subquery FROM clause */</comment>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>     <comment type="block">/* FROM clause of the outer query */</comment>

    <if_stmt><if>if<condition>( <expr><name>pParent</name><operator>==</operator><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>jointype</name> <operator>=</operator> <name><name>pSubitem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>     <comment type="block">/* First time through the loop */</comment>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* The subquery uses a single slot of the FROM clause of the outer
    ** query.  If the subquery has more than one element in its FROM clause,
    ** then expand the outer query to make space for it to hold all elements
    ** of the subquery.
    **
    ** Example:
    **
    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;
    **
    ** The outer query has 3 slots in its FROM clause.  One slot of the
    ** outer query (the middle slot) is used by the subquery.  The next
    ** block of code will expand the outer query FROM clause to 4 slots.
    ** The middle slot is expanded to two slots in order to make space
    ** for the two elements in the FROM clause of the subquery.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nSubSrc</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3SrcListEnlarge</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>nSubSrc</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>iFrom</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSrc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Transfer the FROM clause terms from the subquery into the
    ** outer query.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSubSrc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>+</operator><name>iFrom</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pItem</name> <operator>=</operator> <name><name>pSubSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>|=</operator> <name>ltorj</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNewParent</name> <operator>=</operator> <name><name>pSubSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSubSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pSubSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iFrom</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;=</operator> <name>JT_LTORJ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iFrom</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>|=</operator> <name>jointype</name> <operator>|</operator> <name>ltorj</name></expr>;</expr_stmt>
  
    <comment type="block">/* Now begin substituting subquery result set expressions for 
    ** references to the iParent in the outer query.
    ** 
    ** Example:
    **
    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a&gt;b;
    **   \                     \_____________ subquery __________/          /
    **    \_____________________ outer query ______________________________/
    **
    ** We look at every expression in the outer query and every place we see
    ** "a" we substitute "x*3" and every place we see "b" we substitute "y+10".
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pParent</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_NoopOrderBy</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* At this point, any non-zero iOrderByCol values indicate that the
      ** ORDER BY column expression is identical to the iOrderByCol'th
      ** expression returned by SELECT statement pSub. Since these values
      ** do not necessarily correspond to columns in SELECT statement pParent,
      ** zero them before transfering the ORDER BY clause.
      **
      ** Not doing this may cause an error if a subsequent call to this
      ** function attempts to flatten a compound sub-query into pParent
      ** (the only way this can happen is if the compound sub-query is
      ** currently part of pSub-&gt;pSrc). See ticket [d11a6e908f].  */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pWhere</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isOuterJoin</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SetJoinExpr</name><argument_list>(<argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>iNewParent</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pWhere</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pParent</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <name>pWhere</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SubstContext</name></type> <name>x</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iTable</name></name> <operator>=</operator> <name>iParent</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iNewTable</name></name> <operator>=</operator> <name>iNewParent</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>isOuterJoin</name></name> <operator>=</operator> <name>isOuterJoin</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pCList</name></name> <operator>=</operator> <call><name>findLeftmostExprlist</name><argument_list>(<argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>substSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* The flattened query is a compound if either the inner or the
    ** outer query is a compound. */</comment>
    <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Compound</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* restriction (17b) */</comment>
  
    <comment type="block">/*
    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;
    **
    ** One is tempted to try to add a and b to combine the limits.  But this
    ** does not work if either limit is negative.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Recompute the SrcItem.colUsed masks for the flattened
    ** tables. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSubSrc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>recomputeColumnsUsed</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>+</operator><name>iFrom</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Finially, delete what is left of the subquery and return
  ** success.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3AggInfoPersistWalkerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>,<argument><expr><name>pSub1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x4</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"After flattening:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<comment type="block">/*
** A structure to keep track of all of the column values that are fixed to
** a known value due to WHERE clause constraints of the form COLUMN=VALUE.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>WhereConst</name></name></type> <name>WhereConst</name>;</typedef>
<struct>struct <name>WhereConst</name> <block>{
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>   <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOomFault</name></decl>;</decl_stmt>   <comment type="block">/* Pointer to pParse-&gt;db-&gt;mallocFailed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nConst</name></decl>;</decl_stmt>      <comment type="block">/* Number for COLUMN=CONSTANT terms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChng</name></decl>;</decl_stmt>       <comment type="block">/* Number of times a constant is propagated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHasAffBlob</name></decl>;</decl_stmt> <comment type="block">/* At least one column in apExpr[] as affinity BLOB */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mExcludeOn</name></decl>;</decl_stmt>  <comment type="block">/* Which ON expressions to exclude from considertion.
                   ** Either EP_OuterON or EP_InnerON|EP_OuterON */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>apExpr</name></decl>;</decl_stmt>   <comment type="block">/* [i*2] is COLUMN and [i*2+1] is VALUE */</comment>
}</block>;</struct>

<comment type="block">/*
** Add a new entry to the pConst object.  Except, do not add duplicate
** pColumn entires.  Also, do not add if doing so would not be appropriate.
**
** The caller guarantees the pColumn is a column and pValue is a constant.
** This routine has to do some additional checks before completing the
** insert.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>constInsert</name><parameter_list>(
  <parameter><decl><type><name>WhereConst</name> <modifier>*</modifier></type><name>pConst</name></decl></parameter>,  <comment type="block">/* The WhereConst into which we are inserting */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pColumn</name></decl></parameter>,       <comment type="block">/* The COLUMN part of the constraint */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,        <comment type="block">/* The VALUE part of the constraint */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>          <comment type="block">/* Overall expression: COLUMN=VALUE or VALUE=COLUMN */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pColumn</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IsBinary</name><argument_list>(<argument><expr><call><name>sqlite3ExprCompareCollSeq</name><argument_list>(<argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 2018-10-25 ticket [cf5ed20f]
  ** Make sure the same pColumn is not inserted more than once */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pE2</name> <init>= <expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pColumn</name><operator>-&gt;</operator><name>iTable</name></name>
     <operator>&amp;&amp;</operator> <name><name>pE2</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pColumn</name><operator>-&gt;</operator><name>iColumn</name></name></expr>
    )</condition><block>{<block_content>
      <return>return;</return>  <comment type="block">/* Already present.  Return without doing anything. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pColumn</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>bHasAffBlob</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name></name></expr></argument>,
                         <argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name><index>[<expr><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name><operator>*</operator><literal type="number">2</literal><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>pColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name><index>[<expr><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name><operator>*</operator><literal type="number">2</literal><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pValue</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find all terms of COLUMN=VALUE or VALUE=COLUMN in pExpr where VALUE
** is a constant expression and where the term must be true because it
** is part of the AND-connected terms of the expression.  For each term
** found, add it to the pConst structure.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>findConstInWhere</name><parameter_list>(<parameter><decl><type><name>WhereConst</name> <modifier>*</modifier></type><name>pConst</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>mExcludeOn</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>findConstInWhere</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>findConstInWhere</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_EQ</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRight</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>constInsert</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>,<argument><expr><name>pRight</name></expr></argument>,<argument><expr><name>pLeft</name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>constInsert</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>,<argument><expr><name>pLeft</name></expr></argument>,<argument><expr><name>pRight</name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is a helper function for Walker callback propagateConstantExprRewrite().
**
** Argument pExpr is a candidate expression to be replaced by a value. If 
** pExpr is equivalent to one of the columns named in pWalker-&gt;u.pConst, 
** then overwrite it with the corresponding value. Except, do not do so
** if argument bIgnoreAffBlob is non-zero and the affinity of pExpr
** is SQLITE_AFF_BLOB.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>propagateConstantExprRewriteOne</name><parameter_list>(
  <parameter><decl><type><name>WhereConst</name> <modifier>*</modifier></type><name>pConst</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bIgnoreAffBlob</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pConst</name><operator>-&gt;</operator><name>pOomFault</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Prune</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FixedCol</name><operator>|</operator><name><name>pConst</name><operator>-&gt;</operator><name>mExcludeOn</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Continue</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pConst</name><operator>-&gt;</operator><name>nConst</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pColumn</name> <init>= <expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><name>pExpr</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pColumn</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pColumn</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bIgnoreAffBlob</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pColumn</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* A match is found.  Add the EP_FixedCol property */</comment>
    <expr_stmt><expr><name><name>pConst</name><operator>-&gt;</operator><name>nChng</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>apExpr</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConst</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Prune</name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></for>
  <return>return <expr><name>WRC_Prune</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a Walker expression callback. pExpr is a node from the WHERE
** clause of a SELECT statement. This function examines pExpr to see if
** any substitutions based on the contents of pWalker-&gt;u.pConst should
** be made to pExpr or its immediate children.
**
** A substitution is made if:
**
**   + pExpr is a column with an affinity other than BLOB that matches
**     one of the columns in pWalker-&gt;u.pConst, or
**
**   + pExpr is a binary comparison operator (=, &lt;=, &gt;=, &lt;, &gt;) that
**     uses an affinity other than TEXT and one of its immediate
**     children is a column that matches one of the columns in 
**     pWalker-&gt;u.pConst.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>propagateConstantExprRewrite</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereConst</name> <modifier>*</modifier></type><name>pConst</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pConst</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name><operator>==</operator><name>TK_EQ</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name><operator>==</operator><name>TK_EQ</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name><operator>==</operator><name>TK_EQ</name><operator>+</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name><operator>==</operator><name>TK_EQ</name><operator>+</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pConst</name><operator>-&gt;</operator><name>bHasAffBlob</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>&gt;=</operator><name>TK_EQ</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>&lt;=</operator><name>TK_GE</name><operator>)</operator>
     <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>propagateConstantExprRewriteOne</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pConst</name><operator>-&gt;</operator><name>pOomFault</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Prune</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>propagateConstantExprRewriteOne</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>propagateConstantExprRewriteOne</name><argument_list>(<argument><expr><name>pConst</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pConst</name><operator>-&gt;</operator><name>bHasAffBlob</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The WHERE-clause constant propagation optimization.
**
** If the WHERE clause contains terms of the form COLUMN=CONSTANT or
** CONSTANT=COLUMN that are top-level AND-connected terms that are not
** part of a ON clause from a LEFT JOIN, then throughout the query
** replace all other occurrences of COLUMN with CONSTANT.
**
** For example, the query:
**
**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=t1.a AND t3.c=t2.b
**
** Is transformed into
**
**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=39 AND t3.c=39
**
** Return true if any transformations where made and false if not.
**
** Implementation note:  Constant propagation is tricky due to affinity
** and collating sequence interactions.  Consider this example:
**
**    CREATE TABLE t1(a INT,b TEXT);
**    INSERT INTO t1 VALUES(123,'0123');
**    SELECT * FROM t1 WHERE a=123 AND b=a;
**    SELECT * FROM t1 WHERE a=123 AND b=123;
**
** The two SELECT statements above should return different answers.  b=a
** is alway true because the comparison uses numeric affinity, but b=123
** is false because it uses text affinity and '0123' is not the same as '123'.
** To work around this, the expression tree is not actually changed from
** "b=a" to "b=123" but rather the "a" in "b=a" is tagged with EP_FixedCol
** and the "123" value is hung off of the pLeft pointer.  Code generator
** routines know to generate the constant "123" instead of looking up the
** column value.  Also, to avoid collation problems, this optimization is
** only attempted if the "a=123" term uses the default BINARY collation.
**
** 2021-05-25 forum post 6a06202608: Another troublesome case is...
**
**    CREATE TABLE t1(x);
**    INSERT INTO t1 VALUES(10.0);
**    SELECT 1 FROM t1 WHERE x=10 AND x LIKE 10;
**
** The query should return no rows, because the t1.x value is '10.0' not '10'
** and '10.0' is not LIKE '10'.  But if we are not careful, the first WHERE
** term "x=10" will cause the second WHERE term to become "10 LIKE 10",
** resulting in a false positive.  To avoid this, constant propagation for
** columns with BLOB affinity is only allowed if the constant is used with
** operators ==, &lt;=, &lt;, &gt;=, &gt;, or IS in a way that will cause the correct
** type conversions to occur.  See logic associated with the bHasAffBlob flag
** for details.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>propagateConstants</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>        <comment type="block">/* The query in which to propagate constants */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereConst</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nChng</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pOomFault</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nConst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nChng</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>apExpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>bHasAffBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* Do not propagate constants on any ON clause if there is a
      ** RIGHT JOIN anywhere in the query */</comment>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>mExcludeOn</name></name> <operator>=</operator> <name>EP_InnerON</name> <operator>|</operator> <name>EP_OuterON</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Do not propagate constants through the ON clause of a LEFT JOIN */</comment>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>mExcludeOn</name></name> <operator>=</operator> <name>EP_OuterON</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>findConstInWhere</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nConst</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>propagateConstantExprRewrite</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>walkerDepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pConst</name></name> <operator>=</operator> <operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>apExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nChng</name> <operator>+=</operator> <name><name>x</name><operator>.</operator><name>nChng</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><name><name>x</name><operator>.</operator><name>nChng</name></name></expr> )</condition>;</do>  
  <return>return <expr><name>nChng</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WINDOWFUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This function is called to determine whether or not it is safe to
** push WHERE clause expression pExpr down to FROM clause sub-query
** pSubq, which contains at least one window function. Return 1
** if it is safe and the expression should be pushed down, or 0 
** otherwise.
**
** It is only safe to push the expression down if it consists only 
** of constants and copies of expressions that appear in the PARTITION
** BY clause of all window function used by the sub-query. It is safe
** to filter out entire partitions, but not rows within partitions, as
** this may change the results of the window functions.
**
** At the time this function is called it is guaranteed that 
**
**   * the sub-query uses only one distinct window frame, and 
**   * that the window frame has a PARTITION BY clase.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pushDownWindowCheck</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSubq</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSubq</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_MultiPart</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ExprIsConstantOrGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Make copies of relevant WHERE clause terms of the outer query into
** the WHERE clause of subquery.  Example:
**
**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1) WHERE x=5 AND y=10;
**
** Transformed into:
**
**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1 WHERE a=5 AND c-d=10)
**     WHERE x=5 AND y=10;
**
** The hope is that the terms added to the inner query will make it more
** efficient.
**
** Do not attempt this optimization if:
**
**   (1) (** This restriction was removed on 2017-09-29.  We used to
**           disallow this optimization for aggregate subqueries, but now
**           it is allowed by putting the extra terms on the HAVING clause.
**           The added HAVING clause is pointless if the subquery lacks
**           a GROUP BY clause.  But such a HAVING clause is also harmless
**           so there does not appear to be any reason to add extra logic
**           to suppress it. **)
**
**   (2) The inner query is the recursive part of a common table expression.
**
**   (3) The inner query has a LIMIT clause (since the changes to the WHERE
**       clause would change the meaning of the LIMIT).
**
**   (4) The inner query is the right operand of a LEFT JOIN and the
**       expression to be pushed down does not come from the ON clause
**       on that LEFT JOIN.
**
**   (5) The WHERE clause expression originates in the ON or USING clause
**       of a LEFT JOIN where iCursor is not the right-hand table of that
**       left join.  An example:
**
**           SELECT *
**           FROM (SELECT 1 AS a1 UNION ALL SELECT 2) AS aa
**           JOIN (SELECT 1 AS b2 UNION ALL SELECT 2) AS bb ON (a1=b2)
**           LEFT JOIN (SELECT 8 AS c3 UNION ALL SELECT 9) AS cc ON (b2=2);
**
**       The correct answer is three rows:  (1,1,NULL),(2,2,8),(2,2,9).
**       But if the (b2=2) term were to be pushed down into the bb subquery,
**       then the (1,1,NULL) row would be suppressed.
**
**   (6) Window functions make things tricky as changes to the WHERE clause 
**       of the inner query could change the window over which window 
**       functions are calculated. Therefore, do not attempt the optimization
**       if:
**
**     (6a) The inner query uses multiple incompatible window partitions.
**
**     (6b) The inner query is a compound and uses window-functions. 
**
**     (6c) The WHERE clause does not consist entirely of constants and
**          copies of expressions found in the PARTITION BY clause of
**          all window-functions used by the sub-query. It is safe to
**          filter out entire partitions, as this does not change the 
**          window over which any window-function is calculated.
**
**   (7) The inner query is a Common Table Expression (CTE) that should
**       be materialized.  (This restriction is implemented in the calling
**       routine.)
**
**   (8) If the subquery is a compound that uses UNION, INTERSECT,
**       or EXCEPT, then all of the result set columns for all arms of
**       the compound must use the BINARY collating sequence.
**
**   (9) If the subquery is a compound, then all arms of the compound must
**       have the same affinity.  (This is the same as restriction (17h)
**       for query flattening.)
**       
**
** Return 0 if no changes are made and non-zero if one or more WHERE clause
** terms are duplicated into the subquery.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pushDownWhereTerms</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parse context (for malloc() and error reporting) */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSubq</name></decl></parameter>,        <comment type="block">/* The subquery whose WHERE clause is to be augmented */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,         <comment type="block">/* The WHERE clause of the outer query */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>         <comment type="block">/* The subquery term of the outer FROM clause */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nChng</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWhere</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSubq</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Recursive</name><operator>|</operator><name>SF_MultiPart</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSubq</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>notUnionAll</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pSel</name><operator>=</operator><name>pSubq</name></expr>;</init> <condition><expr><name>pSel</name></expr>;</condition> <incr><expr><name>pSel</name><operator>=</operator><name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>op</name> <init>= <expr><name><name>pSel</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_SELECT</name> 
           <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UNION</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_INTERSECT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_EXCEPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_ALL</name> <operator>&amp;&amp;</operator> <name>op</name><operator>!=</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>notUnionAll</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* restriction (6b) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><call><name>compoundHasDifferentAffinities</name><argument_list>(<argument><expr><name>pSubq</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* restriction (9) */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>notUnionAll</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If any of the compound arms are connected using UNION, INTERSECT,
      ** or EXCEPT, then we must ensure that none of the columns use a
      ** non-BINARY collating sequence. */</comment>
      <for>for<control>(<init><expr><name>pSel</name><operator>=</operator><name>pSubq</name></expr>;</init> <condition><expr><name>pSel</name></expr>;</condition> <incr><expr><name>pSel</name><operator>=</operator><name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IsBinary</name><argument_list>(<argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Restriction (8) */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pSubq</name><operator>-&gt;</operator><name>pWin</name></name> <operator>&amp;&amp;</operator> <name><name>pSubq</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Only the first term of a compound can have a WITH clause.  But make
  ** sure no other terms are marked SF_Recursive in case something changes
  ** in the future.
  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>  
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name>pSubq</name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Recursive</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>pSubq</name><operator>-&gt;</operator><name>pLimit</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* restriction (3) */</comment>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name><name>pWhere</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nChng</name> <operator>+=</operator> <call><name>pushDownWhereTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSubq</name></expr></argument>, <argument><expr><name><name>pWhere</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <name><name>pWhere</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* Legacy code. Checks now done by sqlite3ExprIsTableConstraint() */</comment>
  if( isLeftJoin
   &amp;&amp; (ExprHasProperty(pWhere,EP_OuterON)==0
         || pWhere-&gt;w.iJoin!=iCursor)
  ){
    return 0; <comment type="block">/* restriction (4) */</comment>
  }
  if( ExprHasProperty(pWhere,EP_OuterON)
   &amp;&amp; pWhere-&gt;w.iJoin!=iCursor 
  ){
    return 0; <comment type="block">/* restriction (5) */</comment>
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsTableConstraint</name><argument_list>(<argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nChng</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSubq</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_PushDown</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pSubq</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SubstContext</name></type> <name>x</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unsetJoinExpr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iTable</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iNewTable</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>isOuterJoin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name><name>pSubq</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pCList</name></name> <operator>=</operator> <call><name>findLeftmostExprlist</name><argument_list>(<argument><expr><name>pSubq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>substExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pSubq</name><operator>-&gt;</operator><name>pWin</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>pushDownWindowCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSubq</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* Restriction 6c has prevented push-down in this case */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nChng</name><operator>--</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name><name>pSubq</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSubq</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>pSubq</name> <operator>=</operator> <name><name>pSubq</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nChng</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<comment type="block">/*
** The pFunc is the only aggregate function in the query.  Check to see
** if the query is a candidate for the min/max optimization. 
**
** If the query is a candidate for the min/max optimization, then set
** *ppMinMax to be an ORDER BY clause to be used for the optimization
** and return either WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX depending on
** whether pFunc is a min() or max() function.
**
** If the query is not a candidate for the min/max optimization, return
** WHERE_ORDERBY_NORMAL (which must be zero).
**
** This routine must be called after aggregate functions have been
** located but before their arguments have been subjected to aggregate
** analysis.
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name></type> <name>minMaxQuery</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pFunc</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppMinMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eRet</name> <init>= <expr><name>WHERE_ORDERBY_NORMAL</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>                     <comment type="block">/* Arguments to agg function */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl>;</decl_stmt>                    <comment type="block">/* Name of aggregate function pFunc */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>sortFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppMinMax</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsWindowFunc</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEList</name><operator>==</operator><literal type="number">0</literal> 
   <operator>||</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal>
   <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_MinMaxOpt</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>eRet</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFunc</name> <operator>=</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zFunc</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eRet</name> <operator>=</operator> <name>WHERE_ORDERBY_MIN</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sortFlags</name> <operator>=</operator> <name>KEYINFO_ORDER_BIGNULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zFunc</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eRet</name> <operator>=</operator> <name>WHERE_ORDERBY_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortFlags</name> <operator>=</operator> <name>KEYINFO_ORDER_DESC</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>eRet</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppMinMax</name> <operator>=</operator> <name>pOrderBy</name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>=</operator> <name>sortFlags</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>eRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The select statement passed as the first argument is an aggregate query.
** The second argument is the associated aggregate-info object. This 
** function tests if the SELECT is of the form:
**
**   SELECT count(*) FROM &lt;tbl&gt;
**
** where table is a database table, not a sub-select or view. If the query
** does match this pattern, then a pointer to the Table object representing
** &lt;tbl&gt; is returned. Otherwise, NULL is returned.
**
** This routine checks to see if it is safe to use the count optimization.
** A correct answer is still obtained (though perhaps more slowly) if
** this routine returns NULL when it could have returned a table pointer.
** But returning the pointer when NULL should have been returned can
** result in incorrect answers and/or crashes.  So, when in doubt, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>Table</name> <modifier>*</modifier></type><name>isSimpleCount</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name> 
   <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal> 
   <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal>
   <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name>
   <operator>||</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name><operator>!=</operator><literal type="number">1</literal>
   <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>!=</operator><name>pAggInfo</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name><operator>&amp;</operator><name>SQLITE_FUNC_COUNT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFExpr</name><operator>==</operator><name>pExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Distinct</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Distinct</name><operator>|</operator><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>pTab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the source-list item passed as an argument was augmented with an
** INDEXED BY clause, then try to locate the specified index. If there
** was such a clause and the named index cannot be found, return 
** SQLITE_ERROR and leave an error in pParse. Otherwise, populate 
** pFrom-&gt;pIndex and return SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IndexedByLookup</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIndexedBy</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> 
      <condition><expr><name>pIdx</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zIndexedBy</name></expr></argument>)</argument_list></call></expr>;</condition> 
      <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>
  )</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pIdx</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such index: %s"</literal></expr></argument>, <argument><expr><name>zIndexedBy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pIBIndex</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Detect compound SELECT statements that use an ORDER BY clause with 
** an alternative collating sequence.
**
**    SELECT ... FROM t1 EXCEPT SELECT ... FROM t2 ORDER BY .. COLLATE ...
**
** These are rewritten as a subquery:
**
**    SELECT * FROM (SELECT ... FROM t1 EXCEPT SELECT ... FROM t2)
**     ORDER BY ... COLLATE ...
**
** This transformation is necessary because the multiSelectOrderBy() routine
** above that generates the code for a compound SELECT with an ORDER BY clause
** uses a merge algorithm that requires the same collating sequence on the
** result columns as on the ORDER BY clause.  See ticket
** http://www.sqlite.org/src/info/6709574d2a
**
** This transformation is only needed for EXCEPT, INTERSECT, and UNION.
** The UNION ALL operator works fine with multiSelectOrderBy() even when
** there are COLLATE terms in the ORDER BY.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>convertCompoundSelectToSubquery</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pNewSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>dummy</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name>p</name></expr>;</init> <condition><expr><name>pX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name><operator>)</operator></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <comment type="block">/* If iOrderByCol is already non-zero, then it has already been matched
  ** to a result column of the SELECT statement. This occurs when the
  ** SELECT is rewritten for window-functions processing and then passed
  ** to sqlite3SelectPrep() and similar a second time. The rewriting done
  ** by this function is not required in this case. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* If we reach this point, that means the transformation is required. */</comment>

  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNewSrc</name> <operator>=</operator> <call><name>sqlite3SrcListAppendFromTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>,<argument><expr><name>pNew</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNewSrc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pNew</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <name>pNewSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ASTERISK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_SELECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWinDefn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_Compound</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Converted</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Converted</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the FROM clause term pFrom has table-valued function
** arguments.  If it does, leave an error message in pParse and return
** non-zero, since pFrom is not allowed to be a table-valued function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cannotBeFunction</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"'%s' is not a function"</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
<comment type="block">/*
** Argument pWith (which may be NULL) points to a linked list of nested 
** WITH contexts, from inner to outermost. If the table identified by 
** FROM clause element pItem is really a common-table-expression (CTE) 
** then return a pointer to the CTE definition for that table. Otherwise
** return NULL.
**
** If a non-NULL value is returned, set *ppContext to point to the With
** object that the returned CTE belongs to.
*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>Cte</name></name> <modifier>*</modifier></type><name>searchWith</name><parameter_list>(
  <parameter><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name></decl></parameter>,                    <comment type="block">/* Current innermost WITH clause */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl></parameter>,                 <comment type="block">/* FROM clause element to resolve */</comment>
  <parameter><decl><type><name>With</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppContext</name></decl></parameter>                <comment type="block">/* OUT: WITH clause return value belongs to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pWith</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pOuter</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppContext</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <return>return <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bView</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The code generator maintains a stack of active WITH clauses
** with the inner-most WITH clause being at the top of the stack.
**
** This routine pushes the WITH clause passed as the second argument
** onto the top of the stack. If argument bFree is true, then this
** WITH clause will never be popped from the stack but should instead
** be freed along with the Parse object. In other cases, when
** bFree==0, the With object will be freed along with the SELECT 
** statement with which it is associated.
**
** This routine returns a copy of pWith.  Or, if bFree is true and
** the pWith object is destroyed immediately due to an OOM condition,
** then this routine return NULL.
**
** If bFree is true, do not continue to use the pWith pointer after
** calling this routine,  Instead, use only the return value.
*/</comment>
<function><type><name>With</name> <modifier>*</modifier></type><name>sqlite3WithPush</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>bFree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pWith</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bFree</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pWith</name> <operator>=</operator> <operator>(</operator><name>With</name><operator>*</operator><operator>)</operator><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
                      <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3WithDelete</name></expr></argument>,
                      <argument><expr><name>pWith</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pWith</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name><operator>!=</operator><name>pWith</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWith</name><operator>-&gt;</operator><name>pOuter</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pWith</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pWith</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function checks if argument pFrom refers to a CTE declared by 
** a WITH clause on the stack currently maintained by the parser (on the
** pParse-&gt;pWith linked list).  And if currently processing a CTE
** CTE expression, through routine checks to see if the reference is
** a recursive reference to the CTE.
**
** If pFrom matches a CTE according to either of these two above, pFrom-&gt;pTab
** and other fields are populated accordingly.
**
** Return 0 if no match is found. 
** Return 1 if a match is found.
** Return 2 if an error condition is detected.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveFromTermToCte</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>,                <comment type="block">/* Current tree walker */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>                  <comment type="block">/* The FROM clause term to check */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Cte</name> <modifier>*</modifier></type><name>pCte</name></decl>;</decl_stmt>               <comment type="block">/* Matched CTE (or NULL if no match) */</comment>
  <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name></decl>;</decl_stmt>             <comment type="block">/* The matching WITH */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* There are no WITH clauses in the stack.  No match is possible */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Prior errors might have left pParse-&gt;pWith in a goofy state, so
    ** go no further. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>zDatabase</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The FROM term contains a schema qualifier (ex: main.t1) and so
    ** it cannot possibly be a CTE reference. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notCte</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The FROM term is specifically excluded from matching a CTE.
    **   (1)  It is part of a trigger that used to have zDatabase but had
    **        zDatabase removed by sqlite3FixTriggerStep().
    **   (2)  This is the first term in the FROM clause of an UPDATE.
    */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pCte</name> <operator>=</operator> <call><name>searchWith</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pWith</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCte</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>                <comment type="block">/* Left-most SELECT statement */</comment>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pRecTerm</name></decl>;</decl_stmt>             <comment type="block">/* Left-most recursive term */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bMayRecursive</name></decl>;</decl_stmt>            <comment type="block">/* True if compound joined by UNION [ALL] */</comment>
    <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pSavedWith</name></decl>;</decl_stmt>             <comment type="block">/* Initial value of pParse-&gt;pWith */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iRecTab</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Cursor for recursive table */</comment>
    <decl_stmt><decl><type><name>CteUse</name> <modifier>*</modifier></type><name>pCteUse</name></decl>;</decl_stmt>

    <comment type="block">/* If pCte-&gt;zCteErr is non-NULL at this point, then this is an illegal
    ** recursive reference to CTE pCte. Leave an error in pParse and return
    ** early. If pCte-&gt;zCteErr is NULL, then this is not a recursive reference.
    ** In this case, proceed.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pCte</name><operator>-&gt;</operator><name>zCteErr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zCteErr</name></name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cannotBeFunction</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pCteUse</name> <operator>=</operator> <name><name>pCte</name><operator>-&gt;</operator><name>pUse</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCteUse</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCte</name><operator>-&gt;</operator><name>pUse</name></name> <operator>=</operator> <name>pCteUse</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCteUse</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pCteUse</name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>sqlite3DbFree</name></expr></argument>,<argument><expr><name>pCteUse</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>eM10d</name></name> <operator>=</operator> <name><name>pCte</name><operator>-&gt;</operator><name>eM10d</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">200</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1048576</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Ephemeral</name> <operator>|</operator> <name>TF_NoVisibleRowid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_CopyCte</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such index: \"%s\""</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name></name> <operator>=</operator> <name>pCteUse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>nUse</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCteUse</name><operator>-&gt;</operator><name>nUse</name></name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pCteUse</name><operator>-&gt;</operator><name>eM10d</name></name><operator>==</operator><name>M10d_Any</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>eM10d</name></name> <operator>=</operator> <name>M10d_Yes</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if this is a recursive CTE. */</comment>
    <expr_stmt><expr><name>pRecTerm</name> <operator>=</operator> <name>pSel</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bMayRecursive</name> <operator>=</operator> <operator>(</operator> <name><name>pSel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ALL</name> <operator>||</operator> <name><name>pSel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UNION</name> <operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>bMayRecursive</name> <operator>&amp;&amp;</operator> <name><name>pRecTerm</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name><name>pSel</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>pPrior</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name><operator>==</operator><literal type="number">0</literal> 
         <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal> 
         <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
               <argument><expr><literal type="string">"multiple references to recursive table: %s"</literal></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">2</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Recursive</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iRecTab</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iRecTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name>iRecTab</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRecTerm</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pRecTerm</name> <operator>=</operator> <name><name>pRecTerm</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>pCte</name><operator>-&gt;</operator><name>zCteErr</name></name> <operator>=</operator> <literal type="string">"circular reference: %s"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSavedWith</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pWith</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRecTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRecTerm</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>pNext</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRecTerm</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>pWith</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name><name>pSel</name><operator>-&gt;</operator><name>pWith</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pRecTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRecTerm</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pSavedWith</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pSavedWith</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pWith</name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>pLeft</name><operator>=</operator><name>pSel</name></expr>;</init> <condition><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</condition> <incr><expr><name>pLeft</name><operator>=</operator><name><name>pLeft</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCte</name><operator>-&gt;</operator><name>pCols</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>pCte</name><operator>-&gt;</operator><name>pCols</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %s has %d values for %d columns"</literal></expr></argument>,
            <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><name><name>pCte</name><operator>-&gt;</operator><name>pCols</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pSavedWith</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pCte</name><operator>-&gt;</operator><name>pCols</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3ColumnsFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bMayRecursive</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Recursive</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCte</name><operator>-&gt;</operator><name>zCteErr</name></name> <operator>=</operator> <literal type="string">"multiple recursive references: %s"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pCte</name><operator>-&gt;</operator><name>zCteErr</name></name> <operator>=</operator> <literal type="string">"recursive reference in a subquery: %s"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCte</name><operator>-&gt;</operator><name>zCteErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name>pSavedWith</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Success */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No match */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
<comment type="block">/*
** If the SELECT passed as the second argument has an associated WITH 
** clause, pop it from the stack stored as part of the Parse object.
**
** This function is used as the xSelectCallback2() callback by
** sqlite3SelectExpand() when walking a SELECT tree to resolve table
** names and other FROM clause elements. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectPopWith</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>OK_IF_ALWAYS_TRUE</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name> <init>= <expr><call><name>findRightmost</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pWith</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pWith</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name><operator>==</operator><name>pWith</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name><name>pWith</name><operator>-&gt;</operator><name>pOuter</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The SrcItem structure passed as the second argument represents a
** sub-query in the FROM clause of a SELECT statement. This function
** allocates and populates the SrcItem.pTab object. If successful,
** SQLITE_OK is returned. Otherwise, if an OOM error is encountered,
** SQLITE_NOMEM.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExpandSubquery</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>zAlias</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"%!S"</literal></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <while>while<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pSel</name> <operator>=</operator> <name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt> </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3ColumnsFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">200</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1048576</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifndef>
  <comment type="block">/* The usual case - do not allow ROWID on a subquery */</comment>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Ephemeral</name> <operator>|</operator> <name>TF_NoVisibleRowid</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Ephemeral</name></expr>;</expr_stmt>  <comment type="block">/* Legacy compatibility mode */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check the N SrcItem objects to the right of pBase.  (N might be zero!)
** If any of those SrcItem objects have a USING clause containing zName
** then return true.
**
** If N is zero, or none of the N SrcItem objects to the right of pBase
** contains a USING clause, or if none of the USING clauses contain zName,
** then return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>inAnyUsingClause</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <comment type="block">/* Name we are looking for */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pBase</name></decl></parameter>,    <comment type="block">/* The base SrcItem.  Looking at pBase[1] and following */</comment>
  <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>              <comment type="block">/* How many SrcItems to check */</comment>
)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>N</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBase</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBase</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pBase</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pBase</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This routine is a Walker callback for "expanding" a SELECT statement.
** "Expanding" means to do the following:
**
**    (1)  Make sure VDBE cursor numbers have been assigned to every
**         element of the FROM clause.
**
**    (2)  Fill in the pTabList-&gt;a[].pTab fields in the SrcList that 
**         defines FROM clause.  When views appear in the FROM clause,
**         fill pTabList-&gt;a[].pSelect with a copy of the SELECT statement
**         that implements the view.  A copy is made of the view's SELECT
**         statement so that we can freely modify or delete that statement
**         without worrying about messing up the persistent representation
**         of the view.
**
**    (3)  Add terms to the WHERE clause to accommodate the NATURAL keyword
**         on joins and the ON and USING clause of joins.
**
**    (4)  Scan the list of columns in the result set (pEList) looking
**         for instances of the "*" operator or the TABLE.* operator.
**         If found, expand each "*" to be every column in every table
**         and TABLE.* to be every column in TABLE.
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>selectExpander</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pFrom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pRight</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>selFlags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>elistFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Expanded</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr>  )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <name>SF_Expanded</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Renumber selId because it has been copied from a view */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selId</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nSelect</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_View</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <operator>(</operator><name>With</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>With</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name><operator>-&gt;</operator><name>bView</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3WithPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure cursor numbers have been assigned to all entries in
  ** the FROM clause of the SELECT statement.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Look up every table named in the FROM clause of the select.  If
  ** an entry of the FROM clause is a subquery instead of a table or view,
  ** then create a transient table structure to describe the subquery.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* A sub-query in the FROM clause of a SELECT */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSel</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExpandSubquery</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>resolveFromTermToCte</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* An ordinary table or view name in the FROM clause */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>&gt;=</operator><literal type="number">0xffff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many references to \"%s\": max 65535"</literal></expr></argument>,
           <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cannotBeFunction</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i16</name></type> <name>nCol</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name></type> <name>eCodeOrig</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_EnableView</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"access to view \"%s\" prohibited"</literal></expr></argument>,
              <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
        <if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>fromDDL</name></name>
         <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>p</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>eVtabRisk</name></name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_TrustedSchema</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unsafe use of virtual table \"%s\""</literal></expr></argument>,
                                  <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_VTABRISK_Normal</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>SQLITE_VTABRISK_High</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Turn on Select.selId renumbering */</comment>
        <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <name>eCodeOrig</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Locate the index named by the INDEXED BY clause, if any. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3IndexedByLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Process NATURAL keywords, and ON and USING clauses of joins.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <call><name>sqlite3ProcessJoin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* For every "*" that occurs in the column list, insert the names of
  ** all columns in all tables.  And for every TABLE.* insert the names
  ** of all columns in TABLE.  The parser inserted a special expression
  ** with the TK_ASTERISK operator for each "*" that it found in the column
  ** list.  The following code just has to locate the TK_ASTERISK
  ** expressions and expand each one to the list of all columns in
  ** all tables.
  **
  ** The first loop just checks to see if there are any "*" operators
  ** that need expanding.
  */</comment>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pE</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ASTERISK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_DOT</name> <operator>||</operator> <name><name>pE</name><operator>-&gt;</operator><name>pRight</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_DOT</name> <operator>||</operator> <operator>(</operator><name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pE</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_DOT</name> <operator>&amp;&amp;</operator> <name><name>pE</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ASTERISK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>elistFlags</name> <operator>|=</operator> <name><name>pE</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/*
    ** If we get here it means the result set contains one or more "*"
    ** operators that need to be expanded.  Loop through each expression
    ** in the result set and expand them one by one.
    */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>longNames</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_FullColNames</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
                      <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ShortColNames</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pE</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>elistFlags</name> <operator>|=</operator> <name><name>pE</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pE</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_DOT</name> <operator>||</operator> <name>pRight</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ASTERISK</name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_DOT</name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ASTERISK</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* This particular expression does not need to be expanded.
        */</comment>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zEName</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>zEName</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* This expression is a "*" or a "TABLE.*" and needs to be
        ** expanded. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>tableSeen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Set to 1 when TABLE matches */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* text of name of TABLE */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_DOT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zTName</name> <operator>=</operator> <name><name>pE</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Table for this data source */</comment>
          <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pNestedFrom</name></decl>;</decl_stmt>       <comment type="block">/* Result-set of a nested FROM clause */</comment>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTabName</name></decl>;</decl_stmt>              <comment type="block">/* AS name for this data source */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchemaName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Schema name for this data source */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                     <comment type="block">/* Schema index for this data src */</comment>
          <decl_stmt><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pUsing</name></decl>;</decl_stmt>              <comment type="block">/* USING clause for pFrom[1] */</comment>

          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zTabName</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>zAlias</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>zTabName</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name> <operator>==</operator> <call><name>IsNestedFrom</name><argument_list>(<argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isNestedFrom</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pNestedFrom</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNestedFrom</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNestedFrom</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>zTName</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zTName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pNestedFrom</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zSchemaName</name> <operator>=</operator> <ternary><condition><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr> </then><else>: <expr><literal type="string">"*"</literal></expr></else></ternary></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name>
           <operator>&amp;&amp;</operator> <name><name>pFrom</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isUsing</name></name>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <name>SF_NestedFrom</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>pUsing</name> <operator>=</operator> <name><name>pFrom</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u3</name><operator>.</operator><name>pUsing</name></name></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pUsing</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUName</name> <init>= <expr><name><name>pUsing</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zUName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="string">"..%s"</literal></expr></argument>, <argument><expr><name>zUName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name> <operator>=</operator> <name>ENAME_TAB</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bUsingTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>pUsing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt> <comment type="block">/* Newly added ExprList term */</comment>

            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>zTName</name>
             <operator>&amp;&amp;</operator> <name>pNestedFrom</name>
             <operator>&amp;&amp;</operator> <call><name>sqlite3MatchEName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNestedFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zTName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
            )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* If a column is marked as 'hidden', omit it from the expanded
            ** result-set list unless the SELECT has the SF_IncludeHidden
            ** bit set.
            */</comment>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_IncludeHidden</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <call><name>IsHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> 
            )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_NOEXPAND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <name>zTName</name><operator>==</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <operator>(</operator><name>SF_NestedFrom</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
            )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>tableSeen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zTName</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <name>SF_NestedFrom</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name>
               <operator>&amp;&amp;</operator> <call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr>
              )</condition><block>{<block_content>
                <comment type="block">/* In a join with a USING clause, omit columns in the
                ** using clause from the table on the right. */</comment>
                <continue>continue;</continue>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal>
                 <operator>&amp;&amp;</operator> <operator>(</operator>  <operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
                     <operator>||</operator> <operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <name>SF_NestedFrom</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
                     <operator>||</operator> <operator>!</operator><call><name>inAnyUsingClause</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><name>pFrom</name></expr></argument>,<argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call>
                    <operator>)</operator>
                <operator>)</operator>
             <operator>||</operator> <name>IN_RENAME_OBJECT</name></expr>
            )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name>zSchemaName</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zSchemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <break>break;</break>  <comment type="block">/* OOM */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pX</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <name>SF_NestedFrom</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>pNestedFrom</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNestedFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s.%s.%s"</literal></expr></argument>,
                                           <argument><expr><name>zSchemaName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
              <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name> <operator>=</operator> <name>ENAME_TAB</name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name>
                   <operator>&amp;&amp;</operator> <call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator>
               <operator>||</operator> <operator>(</operator><name>pUsing</name> <operator>&amp;&amp;</operator> <call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name>pUsing</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator>
               <operator>||</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_NOEXPAND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
              )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bNoExpand</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>longNames</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name> <operator>=</operator> <name>ENAME_NAME</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name> <operator>=</operator> <name>ENAME_NAME</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>tableSeen</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>zTName</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such table: %s"</literal></expr></argument>, <argument><expr><name>zTName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no tables specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many columns in result set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>elistFlags</name> <operator>&amp;</operator> <operator>(</operator><name>EP_HasFunc</name><operator>|</operator><name>EP_Subquery</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_ComplexResult</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x8</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"After result-set wildcard expansion:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
<comment type="block">/*
** Always assert.  This xSelectCallback2 implementation proves that the
** xSelectCallback2 is never invoked.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectWalkAssert2</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** This routine "expands" a SELECT statement and all of its subqueries.
** For additional information on what it means to "expand" a SELECT
** statement, see the comment on the selectExpand worker callback above.
**
** Expanding a SELECT statement is the first step in processing a
** SELECT statement.  The SELECT statement must be expanded before
** name resolution is performed.
**
** If anything goes wrong, an error message is written into pParse.
** The calling function can detect the problem by looking at pParse-&gt;nErr
** and/or pParse-&gt;db-&gt;mallocFailed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3SelectExpand</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>sqlite3ExprWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>OK_IF_ALWAYS_TRUE</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>hasCompound</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>convertCompoundSelectToSubquery</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>selectExpander</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>sqlite3SelectPopWith</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()
** interface.
**
** For each FROM-clause subquery, add Column.zType and Column.zColl
** information to the Table structure that represents the result set
** of that subquery.
**
** The Table structure that represents the result set was constructed
** by selectExpander() but the type and collation information was omitted
** at that point because identifiers had not yet been resolved.  This
** routine is called after identifier resolution.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>selectAddSubqueryTypeInfo</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pFrom</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_HasTypeInfo</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_HasTypeInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* A sub-query in the FROM clause of a SELECT */</comment>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSel</name></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pSel</name> <operator>=</operator> <name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>sqlite3SelectAddColumnTypeAndCollation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>,
                                               <argument><expr><name>SQLITE_AFF_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This routine adds datatype and collating sequence information to
** the Table structures of all FROM-clause subqueries in a
** SELECT statement.
**
** Use this routine after name resolution.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3SelectAddTypeInfo</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>selectAddSubqueryTypeInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>sqlite3ExprWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
** This routine sets up a SELECT statement for processing.  The
** following is accomplished:
**
**     *  VDBE Cursor numbers are assigned to all FROM-clause terms.
**     *  Ephemeral Table objects are created for all FROM-clause subqueries.
**     *  ON and USING clauses are shifted into WHERE statements
**     *  Wildcards "*" and "TABLE.*" in result sets are expanded.
**     *  Identifiers in expression are matched to tables.
**
** This routine acts recursively on all subqueries within the SELECT.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectPrep</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* The SELECT statement being coded. */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pOuterNC</name></decl></parameter>  <comment type="block">/* Name context for container */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_HasTypeInfo</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectExpand</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ResolveSelectNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOuterNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectAddTypeInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
<comment type="block">/*
** Display all information about an AggInfo object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printAggInfo</name><parameter_list>(<parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
       <argument><expr><literal type="string">"agg-column[%d] pTab=%s iTable=%d iColumn=%d iMem=%d"</literal>
       <literal type="string">" iSorterColumn=%d %s\n"</literal></expr></argument>,
       <argument><expr><name>ii</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pCol</name><operator>-&gt;</operator><name>pTab</name></name></expr> ?</condition><then> <expr><name><name>pCol</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary></expr></argument>, 
       <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>+</operator><name>ii</name></expr></argument>,
       <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name></expr></argument>, 
       <argument><expr><ternary><condition><expr><name>ii</name><operator>&gt;=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" Accumulator"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pCExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"agg-func[%d]: iMem=%d\n"</literal></expr></argument>,
        <argument><expr><name>ii</name></expr></argument>, <argument><expr><call><name>AggInfoFuncReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TREETRACE_ENABLED */</comment>

<comment type="block">/*
** Analyze the arguments to aggregate functions.  Create new pAggInfo-&gt;aCol[]
** entries for columns that are arguments to aggregate functions but which
** are not otherwise used.
**
** The aCol[] entries in AggInfo prior to nAccumulator are columns that
** are referenced outside of aggregate functions.  These might be columns
** that are part of the GROUP by clause, for example.  Other database engines
** would throw an error if there is a column reference that is not in the
** GROUP BY clause and that is not part of an aggregate function argument.
** But SQLite allows this.
**
** The aCol[] entries beginning with the aCol[nAccumulator] and following
** are column references that are used exclusively as arguments to
** aggregate functions.  This routine is responsible for computing
** (or recomputing) those aCol[] entries.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>analyzeAggFuncArgs</name><parameter_list>(
  <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>,
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pAggInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_InAggFunc</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggList</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsWindowFunc</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggregates</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_InAggFunc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** An index on expressions is being used in the inner loop of an
** aggregate query with a GROUP BY clause.  This routine attempts
** to adjust the AggInfo object to take advantage of index and to
** perhaps use the index as a covering index.
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>optimizeAggregateUseOfIndexedExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,        <comment type="block">/* The SELECT statement being processed */</comment>
  <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>,      <comment type="block">/* The aggregate info */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>        <comment type="block">/* Name context used to resolve agg-func args */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name> <operator>=</operator>
        <name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iSorterColumn</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>analyzeAggFuncArgs</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x20</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IndexedExpr</name> <modifier>*</modifier></type><name>pIEpr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>,
        <argument><expr><operator>(</operator><literal type="string">"AggInfo (possibly) adjusted for Indexed Exprs\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pIEpr</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr>;</init> <condition><expr><name>pIEpr</name></expr>;</condition> <incr><expr><name>pIEpr</name><operator>=</operator><name><name>pIEpr</name><operator>-&gt;</operator><name>pIENext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"data-cursor=%d index={%d,%d}\n"</literal></expr></argument>,
          <argument><expr><name><name>pIEpr</name><operator>-&gt;</operator><name>iDataCur</name></name></expr></argument>, <argument><expr><name><name>pIEpr</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name><name>pIEpr</name><operator>-&gt;</operator><name>iIdxCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIEpr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printAggInfo</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Walker callback for aggregateConvertIndexedExprRefToColumn().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>aggregateIdxEprRefToColCallback</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pAggInfo</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_AGG_COLUMN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Prune</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert every pAggInfo-&gt;aFunc[].pExpr such that any node within
** those expressions that has pAppInfo set is changed into a TK_AGG_COLUMN
** opcode.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>aggregateConvertIndexedExprRefToColumn</name><parameter_list>(<parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>aggregateIdxEprRefToColCallback</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Allocate a block of registers so that there is one register for each
** pAggInfo-&gt;aCol[] and pAggInfo-&gt;aFunc[] entry in pAggInfo.  The first
** register in this block is stored in pAggInfo-&gt;iFirstReg.
**
** This routine may only be called once for each AggInfo object.  Prior
** to calling this routine:
**
**     *  The aCol[] and aFunc[] arrays may be modified
**     *  The AggInfoColumnReg() and AggInfoFuncReg() macros may not be used
**
** After clling this routine:
**
**     *  The aCol[] and aFunc[] arrays are fixed
**     *  The AggInfoColumnReg() and AggInfoFuncReg() macros may be used
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assignAggregateRegisters</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pAggInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>+</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Reset the aggregate accumulator.
**
** The aggregate accumulator is a set of memory cells that hold
** intermediate results while calculating an aggregate.  This
** routine generates code that stores NULLs in all of those memory
** cells.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resetAccumulator</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pFunc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nReg</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name> <operator>+</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name></expr></argument>,
                    <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>+</operator><name>nReg</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pFunc</name><operator>=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pFunc</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>iDistinct</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name> <init>= <expr><name><name>pFunc</name><operator>-&gt;</operator><name>pFExpr</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pE</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"DISTINCT aggregates must have exactly one "</literal>
           <literal type="string">"argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFunc</name><operator>-&gt;</operator><name>iDistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pFunc</name><operator>-&gt;</operator><name>iDistAddr</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, 
            <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>iDistinct</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="string">"USE TEMP B-TREE FOR %s(DISTINCT)"</literal><operator>,</operator>
                          <name><name>pFunc</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the OP_AggFinalize opcode for every aggregate function
** in the AggInfo structure.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>finalizeAggFunctions</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pF</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pF</name><operator>=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pF</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AggFinal</name></expr></argument>, <argument><expr><call><name>AggInfoFuncReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><ternary><condition><expr><name>pList</name></expr> ?</condition><then> <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>pFunc</name></name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Generate code that will update the accumulator memory cells for an
** aggregate based on the current cursor position.
**
** If regAcc is non-zero and there are no min() or max() aggregates
** in pAggInfo, then only populate the pAggInfo-&gt;nAccumulator accumulator
** registers if register regAcc contains 0. The caller will take care
** of setting and clearing regAcc.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateAccumulator</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>regAcc</name></decl></parameter>, 
  <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eDistinctType</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regHit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addrHitTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pF</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pF</name><operator>=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pF</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regAgg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsWindowFunc</name><argument_list>(<argument><expr><name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name></name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pFilter</name> <init>= <expr><name><name>pF</name><operator>-&gt;</operator><name>pFExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name> 
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pF</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name><operator>)</operator> 
       <operator>&amp;&amp;</operator> <name>regAcc</name></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* If regAcc==0, there there exists some min() or max() function
        ** without a FILTER clause that will ensure the magnet registers
        ** are populated. */</comment>
        <if_stmt><if>if<condition>( <expr><name>regHit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>regHit</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* If this is the first row of the group (regAcc contains 0), clear the
        ** "magnet" register regHit so that the accumulator registers
        ** are populated if the FILTER clause jumps over the the 
        ** invocation of min() or max() altogether. Or, if this is not
        ** the first row (regAcc contains 1), set the magnet register so that
        ** the accumulators are not populated unless the min()/max() is invoked
        ** and indicates that they should be.  */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regAcc</name></expr></argument>, <argument><expr><name>regHit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>addrNext</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFilter</name></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nArg</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regAgg</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_ECEL_DUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nArg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>regAgg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pF</name><operator>-&gt;</operator><name>iDistinct</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pList</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>addrNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
        <expr_stmt><expr><name>addrNext</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pF</name><operator>-&gt;</operator><name>iDistinct</name></name> <operator>=</operator> <call><name>codeDistinct</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eDistinctType</name></expr></argument>, 
          <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>iDistinct</name></name></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pF</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pList!=0 if pF-&gt;pFunc has NEEDCOLL */</comment>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><operator>!</operator><name>pColl</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>regHit</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>regHit</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CollSeq</name></expr></argument>, <argument><expr><name>regHit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AggStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr><call><name>AggInfoFuncReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>pFunc</name></name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>addrNext</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>regHit</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regHit</name> <operator>=</operator> <name>regAcc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>regHit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrHitTest</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regHit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pC</name><operator>=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pC</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>pCExpr</name></name></expr></argument>, <argument><expr><call><name>AggInfoColumnReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>addrHitTest</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHereOrPopInst</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrHitTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a single OP_Explain instruction to the VDBE to explain a simple
** count(*) query ("SELECT count(*) FROM pTab").
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explainSimpleCount</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Table being queried */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>                     <comment type="block">/* Index used to optimize scan, or NULL */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bCover</name> <init>= <expr><operator>(</operator><name>pIdx</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeExplain</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"SCAN %s%s%s"</literal></expr></argument>,
        <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
        <argument><expr><ternary><condition><expr><name>bCover</name></expr> ?</condition><then> <expr><literal type="string">" USING COVERING INDEX "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><name>bCover</name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>explainSimpleCount</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** sqlite3WalkExpr() callback used by havingToWhere().
**
** If the node passed to the callback is a TK_AND node, return 
** WRC_Continue to tell sqlite3WalkExpr() to iterate through child nodes.
**
** Otherwise, return WRC_Prune. In this case, also check if the 
** sub-expression matches the criteria for being moved to the WHERE
** clause. If so, add it to the WHERE clause and replace the sub-expression
** within the HAVING expression with a constant "1".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>havingToWhereExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pS</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* This routine is called before the HAVING clause of the current
    ** SELECT is analyzed for aggregates. So if pExpr-&gt;pAggInfo is set
    ** here, it indicates that the expression is a correlated reference to a
    ** column from an outer aggregate query, or an aggregate function that
    ** belongs to an outer query. Do not move the expression to the WHERE
    ** clause in this obscure case, as doing so may corrupt the outer Select
    ** statements AggInfo structure.  */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsConstantOrGroupBy</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pS</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name> <init>= <expr><name><name>pS</name><operator>-&gt;</operator><name>pWhere</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>Expr</name></expr></argument>, <argument><expr><operator>*</operator><name>pNew</name></expr></argument>, <argument><expr><operator>*</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pS</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Transfer eligible terms from the HAVING clause of a query, which is
** processed after grouping, to the WHERE clause, which is processed before
** grouping. For example, the query:
**
**   SELECT * FROM &lt;tables&gt; WHERE a=? GROUP BY b HAVING b=? AND c=?
**
** can be rewritten as:
**
**   SELECT * FROM &lt;tables&gt; WHERE a=? AND b=? GROUP BY b HAVING c=?
**
** A term of the HAVING expression is eligible for transfer if it consists
** entirely of constants and expressions that are also GROUP BY terms that
** use the "BINARY" collation sequence.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>havingToWhere</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sWalker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>havingToWhereExprCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x100</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x100</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Move HAVING terms into WHERE:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the pThis entry of pTabList is a self-join of a prior view.
** If it is, then return the SrcItem for the prior view.  If it is not,
** then return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>isSelfJoinView</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,           <comment type="block">/* Search for self-joins in this FROM clause */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pThis</name></decl></parameter>               <comment type="block">/* Search for prior reference to this subquery */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_PushDown</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pItem</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pItem</name><operator>&lt;</operator><name>pThis</name></expr>;</condition> <incr><expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pS1</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>!=</operator><name><name>pThis</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pS1</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pThis</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selId</name></name><operator>!=</operator><name><name>pS1</name><operator>-&gt;</operator><name>selId</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The query flattener left two different CTE tables with identical
      ** names in the same FROM clause. */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_PushDown</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The view was modified by some other optimization such as
      ** pushDownWhereTerms() */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>pItem</name></expr>;</return>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate a single AggInfo object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>agginfoFree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_COUNTOFVIEW_OPTIMIZATION</name></cpp:ifdef>
<comment type="block">/*
** Attempt to transform a query of the form
**
**    SELECT count(*) FROM (SELECT x FROM t1 UNION ALL SELECT y FROM t2)
**
** Into this:
**
**    SELECT (SELECT count(*) FROM t1)+(SELECT count(*) FROM t2)
**
** The transformation only works if all of the following are true:
**
**   *  The subquery is a UNION ALL of two or more terms
**   *  The subquery does not have a LIMIT clause
**   *  There is no WHERE or GROUP BY or HAVING clauses on the subqueries
**   *  The outer query is a simple count(*) with no WHERE clause or other
**      extraneous syntax.
**
** Return TRUE if the optimization is undertaken.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>countOfViewOptimization</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* This is an aggregate */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>               <comment type="block">/* Single result column */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* Result is an aggregate */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseUToken</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Is count() */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                 <comment type="block">/* Must be count(*) */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                  <comment type="block">/* One table in FROM  */</comment>
  <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSub</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                           <comment type="block">/* The FROM is a subquery */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                   <comment type="block">/* Must be a compound ry */</comment>
  <do>do<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ALL</name> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Must be UNION ALL */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                      <comment type="block">/* No WHERE clause */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                      <comment type="block">/* No LIMIT clause */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>     <comment type="block">/* Not an aggregate */</comment>
    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>                              <comment type="block">/* Repeat over compound */</comment>
  </block_content>}</block>while<condition>( <expr><name>pSub</name></expr> )</condition>;</do>

  <comment type="block">/* If we reach this point then it is OK to perform the transformation */</comment>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCount</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pSub</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Aggregate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_Compound</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <ternary><condition><expr><name>pPrior</name></expr> ?</condition><then> <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCount</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>pCount</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_SELECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PExprAddSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_PLUS</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name>pPrior</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_Aggregate</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x200</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"After count-of-view optimization:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_COUNTOFVIEW_OPTIMIZATION */</comment>

<comment type="block">/*
** If any term of pSrc, or any SF_NestedFrom sub-query, is not the same
** as pSrcItem but has the same alias as p0, then return true.
** Otherwise return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sameSrcAlias</name><parameter_list>(<parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>p0</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>p0</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p0</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p0</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>pSelect</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_NestedFrom</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>sameSrcAlias</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for the SELECT statement given in the p argument.  
**
** The results are returned according to the SelectDest structure.
** See comments in sqliteInt.h for further information.
**
** This routine returns the number of errors.  If any errors are
** encountered, then an appropriate error message is left in
** pParse-&gt;zErrMsg.
**
** This routine does NOT free the Select structure passed in.  The
** calling function needs to do that.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Select</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* The SELECT statement being coded. */</comment>
  <parameter><decl><type><name>SelectDest</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>      <comment type="block">/* What to do with the query results */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>              <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>     <comment type="block">/* Return from sqlite3WhereBegin() */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>               <comment type="block">/* The virtual machine under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isAgg</name></decl>;</decl_stmt>             <comment type="block">/* True for select lists like "count(*)" */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* List of columns to extract. */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl>;</decl_stmt>     <comment type="block">/* List of tables to select from */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl>;</decl_stmt>          <comment type="block">/* The WHERE clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name></decl>;</decl_stmt>    <comment type="block">/* The GROUP BY clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pHaving</name></decl>;</decl_stmt>         <comment type="block">/* The HAVING clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Aggregate information */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Value to return from this function */</comment>
  <decl_stmt><decl><type><name>DistinctCtx</name></type> <name>sDistinct</name></decl>;</decl_stmt> <comment type="block">/* Info on how to code the DISTINCT keyword */</comment>
  <decl_stmt><decl><type><name>SortCtx</name></type> <name>sSort</name></decl>;</decl_stmt>         <comment type="block">/* Info on how to code the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name></decl>;</decl_stmt>              <comment type="block">/* Address of the end of the query */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pMinMaxOrderBy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Added ORDER BY for min/max queries */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>minMaxFlag</name></decl>;</decl_stmt>                 <comment type="block">/* Flag for min/max queries */</comment>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_SELECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x1</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"begin processing:\n"</literal><operator>,</operator> <name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x10001</literal><operator>)</operator><operator>==</operator><literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TreeViewLine</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"In sqlite3Select() at %s:%d"</literal></expr></argument>,
                           <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ShowSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>!=</operator><name>SRT_DistFifo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>!=</operator><name>SRT_Fifo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>!=</operator><name>SRT_DistQueue</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>!=</operator><name>SRT_Queue</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IgnorableDistinct</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_Exists</name>     <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_Union</name> <operator>||</operator> 
           <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_Except</name>     <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_Discard</name> <operator>||</operator>
           <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_DistQueue</name>  <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_DistFifo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* All of these destinations are also able to ignore the ORDER BY clause */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"dropping superfluous ORDER BY:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x800</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3TreeViewExprList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ORDERBY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
      <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3ExprListDelete</name></expr></argument>,
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>earlyCleanup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_Distinct</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_NoopOrderBy</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>select_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x10</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x10</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"after name resolution:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the SF_UFSrcCheck flag is set, then this function is being called
  ** as part of populating the temp table for an UPDATE...FROM statement.
  ** In this case, it is an error if the target object (pSrc-&gt;a[0]) name 
  ** or alias is duplicated within FROM clause (pSrc-&gt;a[1..n]).  
  **
  ** Postgres disallows this case too. The reason is that some other 
  ** systems handle this case differently, and not all the same way, 
  ** which is just confusing. To avoid this, we follow PG's lead and
  ** disallow it altogether.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_UFSrcCheck</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>p0</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sameSrcAlias</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><literal type="string">"target object/alias may not appear in FROM clause: %s"</literal></expr></argument>, 
          <argument><expr><ternary><condition><expr><name><name>p0</name><operator>-&gt;</operator><name>zAlias</name></name></expr> ?</condition><then> <expr><name><name>p0</name><operator>-&gt;</operator><name>zAlias</name></name></expr> </then><else>: <expr><name><name>p0</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></else></ternary></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>select_end</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear the SF_UFSrcCheck flag. The check has already been performed,
    ** and leaving this flag set can cause errors if a compound sub-query
    ** in p-&gt;pSrc is flattened into this query and this function called
    ** again as part of compound SELECT processing.  */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_UFSrcCheck</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_Output</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3GenerateColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3WindowRewrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>select_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x40</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x40</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"after window rewrite:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>
  <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>isAgg</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sSort</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>

  <comment type="block">/* Try to do various optimizations (flattening subqueries, and strength
  ** reduction of join operators) in the FROM clause up into the main query
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* The expander should have already created transient Table objects
    ** even for FROM clause elements such as subqueries that do not correspond
    ** to a real table */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert LEFT JOIN into JOIN if there are terms of the right table
    ** of the LEFT JOIN used in the WHERE clause.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>==</operator><name>JT_LEFT</name>
     <operator>&amp;&amp;</operator> <call><name>sqlite3ExprImpliesNonNullRow</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_SimplifyJoin</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x1000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,
                <argument><expr><operator>(</operator><literal type="string">"LEFT-JOIN simplifies to JOIN on term %d\n"</literal><operator>,</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_OUTER</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unsetJoinExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>,
                    <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No futher action if this term of the FROM clause is no a subquery */</comment>
    <if_stmt><if>if<condition>( <expr><name>pSub</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Catch mismatch in the declared columns of a view and the number of
    ** columns in the SELECT on the RHS */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><name><name>pSub</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"expected %d columns for '%s' but got %d"</literal></expr></argument>,
                      <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>select_end</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Do not try to flatten an aggregate subquery.
    **
    ** Flattening an aggregate subquery is only possible if the outer query
    ** is not a join.  But if the outer query is not a join, then the subquery
    ** will be implemented as a co-routine and there is no advantage to
    ** flattening in that case.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pGroupBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If a FROM-clause subquery has an ORDER BY clause that is not
    ** really doing anything, then delete it now so that it does not
    ** interfere with query flattening.  See the discussion at
    ** https://sqlite.org/forum/forumpost/2d76f2bcf65d256a
    **
    ** Beware of these cases where the ORDER BY clause may not be safely
    ** omitted:
    **
    **    (1)   There is also a LIMIT clause
    **    (2)   The subquery was added to help with window-function
    **          processing
    **    (3)   The subquery is in the FROM clause of an UPDATE
    **    (4)   The outer query uses an aggregate function other than
    **          the built-in count(), min(), or max().
    **    (5)   The ORDER BY isn't going to accomplish anything because
    **          one of:
    **            (a)  The outer query has a different ORDER BY clause
    **            (b)  The subquery is part of a join
    **          See forum post 062d576715d277c8
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator>      <comment type="block">/* Condition (5) */</comment>
     <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pLimit</name></name><operator>==</operator><literal type="number">0</literal>                           <comment type="block">/* Condition (1) */</comment>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_OrderByReqd</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>      <comment type="block">/* Condition (2) */</comment>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_OrderByReqd</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>         <comment type="block">/* Condition (3) and (4) */</comment>
     <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OmitOrderBy</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,
                <argument><expr><operator>(</operator><literal type="string">"omit superfluous ORDER BY on %r FROM-clause subquery\n"</literal><operator>,</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
         <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3ExprListDelete</name></expr></argument>,
         <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the outer query contains a "complex" result set (that is,
    ** if the result set of the outer query uses functions or subqueries)
    ** and if the subquery contains an ORDER BY clause and if
    ** it will be implemented as a co-routine, then do not flatten.  This
    ** restriction allows SQL constructs like this:
    **
    **  SELECT expensive_function(x)
    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);
    **
    ** The expensive_function() is only computed on the 10 rows that
    ** are output, rather than every row of the table.
    **
    ** The requirement that the outer query have a complex result set
    ** means that flattening does occur on simpler SQL constraints without
    ** the expensive_function() like:
    **
    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_ComplexResult</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal>
         <operator>||</operator> <operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name><operator>&amp;</operator><operator>(</operator><name>JT_OUTER</name><operator>|</operator><name>JT_CROSS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>flattenSubquery</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>isAgg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>select_end</name>;</goto></block_content></block></if></if_stmt>
      <comment type="block">/* This subquery can be absorbed into its parent. */</comment>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>select_end</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IgnorableOrderby</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
  <comment type="block">/* Handle compound SELECT statements using the separate multiSelect()
  ** procedure.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x400</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"end compound-select processing\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x400</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExplainQueryPlanParent</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do the WHERE-clause constant propagation optimization if this is
  ** a join.  No need to speed time on this operation for non-join queries
  ** as the equivalent optimization will be handled by query planner in
  ** sqlite3WhereBegin().
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pWhere</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_PropagateConst</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <call><name>propagateConstants</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x2000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"After constant propagation:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Constant propagation not helpful\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_COUNTOFVIEW_OPTIMIZATION</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_QueryFlattener</name><operator>|</operator><name>SQLITE_CountOfView</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <call><name>countOfViewOptimization</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>select_end</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* For each term in the FROM clause, do two things:
  ** (1) Authorized unreferenced tables
  ** (2) Generate code for all sub-queries
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSavedAuthContext</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Issue SQLITE_READ authorizations with a fake column name for any
    ** tables that are referenced but from which no values are extracted.
    ** Examples of where these kinds of null SQLITE_READ authorizations
    ** would occur:
    **
    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.""
    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.""
    **
    ** The fake column name is an empty string.  It is possible for a table to
    ** have a column named by the empty string, in which case there is no way to
    ** distinguish between an unreferenced table and an actual reference to the
    ** "" column. The original design was for the fake column name to be a NULL,
    ** which would be unambiguous.  But legacy authorization callbacks might
    ** assume the column name is non-NULL and segfault.  The use of an empty
    ** string for the fake column name seems safer.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_READ</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Generate code for all sub-queries in the FROM clause
    */</comment>
    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSub</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* The code for a subquery should only be generated once. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>addrFillSub</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Increment Parse.nHeight by the height of the largest expression
    ** tree referred to by this, the parent select. The child select
    ** may contain expression trees of at most
    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit
    ** more conservative than necessary, but much easier than enforcing
    ** an exact limit.
    */</comment>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>+=</operator> <call><name>sqlite3SelectExprHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make copies of constant WHERE-clause terms in the outer query down
    ** inside the subquery.  This can help the subquery to run more efficiently.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_PushDown</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name><operator>==</operator><literal type="number">0</literal> 
         <operator>||</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>eM10d</name></name><operator>!=</operator><name>M10d_Yes</name> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>nUse</name></name><operator>&lt;</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator>
     <operator>&amp;&amp;</operator> <call><name>pushDownWhereTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
      <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x4000</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x4000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,
            <argument><expr><operator>(</operator><literal type="string">"After WHERE-clause push-down into subquery %d:\n"</literal><operator>,</operator> <name><name>pSub</name><operator>-&gt;</operator><name>selId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_PushDown</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x4000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Push-down not possible\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>zSavedAuthContext</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>

    <comment type="block">/* Generate code to implement the subquery
    **
    ** The subquery is implemented as a co-routine if all of the following are
    ** true:
    **
    **    (1)  the subquery is guaranteed to be the outer loop (so that
    **         it does not need to be computed more than once), and
    **    (2)  the subquery is not a CTE that should be materialized
    **    (3)  the subquery is not part of a left operand for a RIGHT JOIN
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal>
            <operator>||</operator> <operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name><operator>&amp;</operator><operator>(</operator><name>JT_OUTER</name><operator>|</operator><name>JT_CROSS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator>  <comment type="block">/* (1) */</comment>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>eM10d</name></name><operator>!=</operator><name>M10d_Yes</name><operator>)</operator>   <comment type="block">/* (2) */</comment>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>                   <comment type="block">/* (3) */</comment>
    )</condition><block>{<block_content>
      <comment type="block">/* Implement a co-routine that will return a single row of the result
      ** set on each invocation.
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
     
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>addrFillSub</name></name> <operator>=</operator> <name>addrTop</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"CO-ROUTINE %!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>regResult</name></name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSdst</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeEndCoroutine</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ClearTempRegCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>addrM9e</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This is a CTE for which materialization code has already been
      ** generated.  Invoke the subroutine to compute the materialization,
      ** the make the pItem-&gt;iCursor be a copy of the ephemerial table that
      ** holds the result of the materialization. */</comment>
      <decl_stmt><decl><type><name>CteUse</name> <modifier>*</modifier></type><name>pCteUse</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>regRtn</name></name></expr></argument>, <argument><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>addrM9e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>!=</operator><name><name>pCteUse</name><operator>-&gt;</operator><name>iCur</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>iCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name><name>pCteUse</name><operator>-&gt;</operator><name>nRowEst</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>pPrior</name> <operator>=</operator> <call><name>isSelfJoinView</name><argument_list>(<argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This view has already been materialized by a prior entry in
      ** this same FROM clause.  Reuse it. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pPrior</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name><name>pPrior</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Materialize the view.  If the view is not correlated, generate a
      ** subroutine to do the materialization so that subsequent uses of
      ** the same view can reuse the materialization. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>topAddr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>onceAddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>topAddr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>addrFillSub</name></name> <operator>=</operator> <name>topAddr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isMaterialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If the subquery is not correlated and if we are not inside of
        ** a trigger, then we only need to compute the value of the subquery
        ** once. */</comment>
        <expr_stmt><expr><name>onceAddr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"materialize %!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"materialize %!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_EphemTab</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"MATERIALIZE %!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>zAffSdst</name></name> <operator>=</operator> <call><name>sqlite3TableAffinityStr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>zAffSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>zAffSdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>onceAddr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>onceAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name>topAddr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"end %!S"</literal><operator>,</operator> <name>pItem</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>topAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ClearTempRegCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>CteUse</name> <modifier>*</modifier></type><name>pCteUse</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>addrM9e</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>regRtn</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>iCur</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCteUse</name><operator>-&gt;</operator><name>nRowEst</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>select_end</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>-=</operator> <call><name>sqlite3SelectExprHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name>zSavedAuthContext</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>

  <comment type="block">/* Various elements of the SELECT copied into local variables for
  ** convenience */</comment>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGroupBy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHaving</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x8000</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x8000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"After all FROM-clause analysis:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the query is DISTINCT with an ORDER BY but is not an aggregate, and 
  ** if the select-list is the same as the ORDER BY list, then this query
  ** can be rewritten as a GROUP BY. In other words, this:
  **
  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz
  **
  ** is transformed to:
  **
  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz
  **
  ** The second form is preferred as a single index (or temp-table) may be 
  ** used for both the ORDER BY and DISTINCT processing. As originally 
  ** written the query must use a temp-table for at least one of the ORDER 
  ** BY and DISTINCT, and an index or separate temp-table for the other.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Distinct</name> 
   <operator>&amp;&amp;</operator> <call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pWin</name></name><operator>==</operator><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_Distinct</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroupBy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Aggregate</name></expr>;</expr_stmt>
    <comment type="block">/* Notice that even thought SF_Distinct has been cleared from p-&gt;selFlags,
    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the
    ** original setting of the SF_Distinct flag, not the current setting */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x20000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x20000</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Transform DISTINCT into GROUP BY:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there is an ORDER BY clause, then create an ephemeral index to
  ** do the sorting.  But this sorting ephemeral index might end up
  ** being unused if the data can be extracted in pre-sorted order.
  ** If that is the case, then the OP_OpenEphemeral instruction will be
  ** changed to an OP_Noop once we figure out that the sorting index is
  ** not needed.  The sSort.addrSortIndex variable is used to facilitate
  ** that change.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoFromExprList</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>iECursor</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name> <operator>=</operator>
      <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>,
          <argument><expr><name><name>sSort</name><operator>.</operator><name>iECursor</name></name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
          <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If the output is destined for a temporary table, open that table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>eDest</name></name><operator>==</operator><name>SRT_EphemTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_NestedFrom</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Delete or NULL-out result columns that will never be used */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bUsed</name></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ii</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>bUsed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the limiter.
  */</comment>
  <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_FixedLimit</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <literal type="number">320</literal></expr>;</expr_stmt>  <comment type="block">/* 4 billion rows */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeOpcode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name></expr></argument>, <argument><expr><name>OP_SorterOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>sortFlags</name></name> <operator>|=</operator> <name>SORTFLAG_UseSorter</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open an ephemeral index to use for the distinct set.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>tabTnct</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>addrTnct</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>,
                       <argument><expr><name><name>sDistinct</name><operator>.</operator><name>tabTnct</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                       <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BTREE_UNORDERED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>eTnctType</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNORDERED</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>eTnctType</name></name> <operator>=</operator> <name>WHERE_DISTINCT_NOOP</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isAgg</name> <operator>&amp;&amp;</operator> <name>pGroupBy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* No aggregate functions and no GROUP BY clause */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>wctrlFlags</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name></expr> ?</condition><then> <expr><name>WHERE_WANT_DISTINCT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
                   <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_FixedLimit</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Main window object (or NULL) */</comment>
    <if_stmt><if>if<condition>( <expr><name>pWin</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WindowCodeInit</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WHERE_USE_LIMIT</name><operator>==</operator><name>SF_FixedLimit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Begin the database scan. */</comment>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereBegin\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr></argument>,
                               <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>wctrlFlags</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pWInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>select_end</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3WhereOutputRowCount</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <call><name>sqlite3WhereOutputRowCount</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3WhereIsDistinct</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sDistinct</name><operator>.</operator><name>eTnctType</name></name> <operator>=</operator> <call><name>sqlite3WhereIsDistinct</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>nOBSat</name></name> <operator>=</operator> <call><name>sqlite3WhereIsOrdered</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>labelOBLopt</name></name> <operator>=</operator> <call><name>sqlite3WhereOrderByLimitOptLabel</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sSort</name><operator>.</operator><name>nOBSat</name></name><operator>==</operator><name><name>sSort</name><operator>.</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereBegin returns\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If sorting index that was created by a prior OP_OpenEphemeral 
    ** instruction ended up not being needed, then change the OP_OpenEphemeral
    ** into an OP_Noop.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>==</operator><name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>pWin</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addrGosub</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCont</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iBreak</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>regGosub</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>sqlite3WindowCodeStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>regGosub</name></expr></argument>, <argument><expr><name>addrGosub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrGosub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"inner-loop subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>labelOBLopt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sDistinct</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regGosub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"end inner-loop subroutine"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>
    <block>{<block_content>
      <comment type="block">/* Use the standard inner loop. */</comment>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sDistinct</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>,
          <argument><expr><call><name>sqlite3WhereContinueLabel</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><call><name>sqlite3WhereBreakLabel</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* End the database scan loop.
      */</comment>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereEnd\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This case when there exist aggregate functions or a GROUP BY clause
    ** or both */</comment>
    <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>    <comment type="block">/* Name context for processing aggregate information */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iAMem</name></decl>;</decl_stmt>          <comment type="block">/* First Mem address for storing current GROUP BY */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iBMem</name></decl>;</decl_stmt>          <comment type="block">/* First Mem address for previous GROUP BY */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iUseFlag</name></decl>;</decl_stmt>       <comment type="block">/* Mem address holding flag indicating that at least
                        ** one row of the input to the aggregator has been
                        ** processed */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iAbortFlag</name></decl>;</decl_stmt>     <comment type="block">/* Mem address which causes query abort if positive */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>groupBySort</name></decl>;</decl_stmt>    <comment type="block">/* Rows come from source in GROUP BY order */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrEnd</name></decl>;</decl_stmt>        <comment type="block">/* End of processing for this SELECT */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>sortPTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pseudotable used to decode sorting results */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>sortOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Output register from the sorter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>orderByGrp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True if the GROUP BY and ORDER BY are the same */</comment>

    <comment type="block">/* Remove any and all aliases between the result set and the
    ** GROUP BY clause.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>  <comment type="block">/* For looping over expression in a list */</comment>

      <for>for<control>(<init><expr><name>k</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>k</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iAlias</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>k</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iAlias</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">66</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name><operator>&gt;</operator><literal type="number">66</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <literal type="number">66</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* If there is both a GROUP BY and an ORDER BY clause and they are
      ** identical, then it may be possible to disable the ORDER BY clause 
      ** on the grounds that the GROUP BY will cause elements to come out 
      ** in the correct order. It also may not - the GROUP BY might use a
      ** database index that causes rows to be grouped together as required
      ** but not actually sorted. Either way, record the fact that the
      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp
      ** variable.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name> <operator>&amp;&amp;</operator> <name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name><name>sSort</name><operator>.</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
        <comment type="block">/* The GROUP BY processing doesn't care whether rows are delivered in
        ** ASC or DESC order - only that each group is returned contiguously.
        ** So set the ASC/DESC flags in the GROUP BY to match those in the 
        ** ORDER BY to maximize the chances of rows being delivered in an 
        ** order that makes the ORDER BY redundant.  */</comment>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name></type> <name>sortFlags</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>sortFlags</name> <operator>=</operator> <name><name>sSort</name><operator>.</operator><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pGroupBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>=</operator> <name>sortFlags</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>orderByGrp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Create a label to jump to when we want to abort the query */</comment>
    <expr_stmt><expr><name>addrEnd</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in
    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the
    ** SELECT statement.
    */</comment>
    <expr_stmt><expr><name>pAggInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pAggInfo</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pAggInfo</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
          <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>agginfoFree</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>earlyCleanup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <goto>goto <name>select_end</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>selId</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>selId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>uNC</name><operator>.</operator><name>pAggInfo</name></name> <operator>=</operator> <name>pAggInfo</name></expr>;</expr_stmt>
    <macro><name>VVA_ONLY</name><argument_list>( <argument>sNC.ncFlags = NC_UAggInfo;</argument> )</argument_list></macro>
    <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name> <operator>=</operator> <ternary><condition><expr><name>pGroupBy</name></expr> ?</condition><then> <expr><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <name>pGroupBy</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pHaving</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWhere</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pHaving</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pGroupBy</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>havingToWhere</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggregates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>minMaxFlag</name> <operator>=</operator> <call><name>minMaxQuery</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMinMaxOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>minMaxFlag</name> <operator>=</operator> <name>WHERE_ORDERBY_NORMAL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>analyzeAggFuncArgs</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>select_end</name>;</goto></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x20</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"After aggregate analysis %p:\n"</literal><operator>,</operator> <name>pAggInfo</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>minMaxFlag</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"MIN/MAX Optimization (0x%02x) adds:\n"</literal></expr></argument>, <argument><expr><name>minMaxFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3TreeViewExprList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pMinMaxOrderBy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ORDERBY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>printAggInfo</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/* Processing for aggregates with GROUP BY is very different and
    ** much more complex than aggregates without a GROUP BY.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>  <comment type="block">/* Keying information for the group by clause */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>          <comment type="block">/* A-vs-B comparision jump */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrOutputRow</name></decl>;</decl_stmt>  <comment type="block">/* Start of subroutine that outputs a result row */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regOutputRow</name></decl>;</decl_stmt>   <comment type="block">/* Return address register for output subroutine */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrSetAbort</name></decl>;</decl_stmt>   <comment type="block">/* Set the abort flag and return */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrTopOfLoop</name></decl>;</decl_stmt>  <comment type="block">/* Top of the input loop */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrSortingIdx</name></decl>;</decl_stmt> <comment type="block">/* The OP_OpenEphemeral for the sorting index */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrReset</name></decl>;</decl_stmt>      <comment type="block">/* Subroutine for resetting the accumulator */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regReset</name></decl>;</decl_stmt>       <comment type="block">/* Return address register for reset subroutine */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pDistinct</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u16</name></type> <name>distFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eDist</name> <init>= <expr><name>WHERE_DISTINCT_NOOP</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name><operator>==</operator><literal type="number">1</literal> 
       <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iDistinct</name><operator>&gt;=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pFExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pFExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDistinct</name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDistinct</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDistinct</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>distFlag</name> <operator>=</operator> <ternary><condition><expr><name>pDistinct</name></expr> ?</condition><then> <expr><operator>(</operator><name>WHERE_WANT_DISTINCT</name><operator>|</operator><name>WHERE_AGG_DISTINCT</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If there is a GROUP BY clause we might need a sorting index to
      ** implement it.  Allocate that sorting index now.  If it turns out
      ** that we do not need it after all, the OP_SorterOpen instruction
      ** will be converted into a Noop.  
      */</comment>
      <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdx</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>,
                                            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrSortingIdx</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterOpen</name></expr></argument>, 
          <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdx</name></name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name></expr></argument>, 
          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Initialize memory locations used by GROUP BY aggregate processing
      */</comment>
      <expr_stmt><expr><name>iUseFlag</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iAbortFlag</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regOutputRow</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrOutputRow</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regReset</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrReset</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iAMem</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBMem</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iAbortFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"clear abort flag"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iAMem</name></expr></argument>, <argument><expr><name>iAMem</name><operator>+</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Begin a loop that will extract all source rows in GROUP BY order.
      ** This might involve two separate loops with an OP_Sort in between, or
      ** it might be a single loop that uses an index to extract information
      ** in the right order to begin with.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regReset</name></expr></argument>, <argument><expr><name>addrReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereBegin\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><name>pDistinct</name></expr></argument>,
          <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name>WHERE_DISTINCTBY</name></expr> </then><else>: <expr><name>WHERE_GROUPBY</name></expr></else></ternary><operator>)</operator> 
          <operator>|</operator>  <operator>(</operator><ternary><condition><expr><name>orderByGrp</name></expr> ?</condition><then> <expr><name>WHERE_SORTBYGROUP</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <name>distFlag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pWInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>select_end</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>optimizeAggregateUseOfIndexedExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assignAggregateRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>eDist</name> <operator>=</operator> <call><name>sqlite3WhereIsDistinct</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereBegin returns\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3WhereIsOrdered</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The optimizer is able to deliver rows in group by order so
        ** we do not have to sort.  The OP_OpenEphemeral table will be
        ** cancelled later because we still need to use the pKeyInfo
        */</comment>
        <expr_stmt><expr><name>groupBySort</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Rows are coming out in undetermined order.  We have to push
        ** each row into a sorting index, terminate the first loop,
        ** then loop over the sorting index in order to get the output
        ** in sorted order
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nGroupBy</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>explainTempTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>sDistinct</name><operator>.</operator><name>isTnct</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name><operator>&amp;</operator><name>SF_Distinct</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
                    <expr><literal type="string">"DISTINCT"</literal></expr> </then><else>: <expr><literal type="string">"GROUP BY"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>groupBySort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nGroupBy</name> <operator>=</operator> <name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name>nGroupBy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nGroupBy</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iSorterColumn</name><operator>&gt;=</operator><name>j</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>regBase</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nGroupBy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name><operator>&gt;=</operator><name>j</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCExpr</name></name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <name>regBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterInsert</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdx</name></name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereEnd\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdxPTab</name></name> <operator>=</operator> <name>sortPTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>sortOut</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>sortPTab</name></expr></argument>, <argument><expr><name>sortOut</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterSort</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdx</name></name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"GROUP BY sort"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>useSortingIdx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* If there entries in pAgggInfo-&gt;aFunc[] that contain subexpressions
      ** that are indexed (and that were previously identified and tagged
      ** in optimizeAggregateUseOfIndexedExpr()) then those subexpressions
      ** must now be converted into a TK_AGG_COLUMN node so that the value
      ** is correctly pulled from the index rather than being recomputed. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>aggregateConvertIndexedExprRefToColumn</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
        <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x20</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
             <argument><expr><operator>(</operator><literal type="string">"AggInfo function expressions converted to reference index\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printAggInfo</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If the index or temporary table used by the GROUP BY sort
      ** will naturally deliver rows in the order required by the ORDER BY
      ** clause, cancel the ephemeral table open coded earlier.
      **
      ** This is an optimization - the correct answer should result regardless.
      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to 
      ** disable this optimization for testing purposes.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>orderByGrp</name> <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_GroupByOrder</name></expr></argument>)</argument_list></call> 
       <operator>&amp;&amp;</operator> <operator>(</operator><name>groupBySort</name> <operator>||</operator> <call><name>sqlite3WhereIsSorted</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>sSort</name><operator>.</operator><name>addrSortIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Evaluate the current GROUP BY terms and store in b0, b1, b2...
      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)
      ** Then compare the current GROUP BY terms against the GROUP BY terms
      ** from the previous row currently stored in a0, a1, a2...
      */</comment>
      <expr_stmt><expr><name>addrTopOfLoop</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>groupBySort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterData</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdx</name></name></expr></argument>,
                          <argument><expr><name>sortOut</name></expr></argument>, <argument><expr><name>sortPTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>groupBySort</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>sortPTab</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>iBMem</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pGroupBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iBMem</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>iAMem</name></expr></argument>, <argument><expr><name>iBMem</name></expr></argument>, <argument><expr><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>,
                          <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3KeyInfoRef</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate code that runs whenever the GROUP BY changes.
      ** Changes in the GROUP BY are detected by the previous code
      ** block.  If there were no changes, this block is skipped.
      **
      ** This code copies current group by terms in b0,b1,b2,...
      ** over to a0,a1,a2.  It then calls the output subroutine
      ** and resets the aggregate accumulator registers in preparation
      ** for the next GROUP BY batch.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iBMem</name></expr></argument>, <argument><expr><name>iAMem</name></expr></argument>, <argument><expr><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>, <argument><expr><name>addrOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"output one row"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iAbortFlag</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"check abort flag"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regReset</name></expr></argument>, <argument><expr><name>addrReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"reset accumulator"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Update the aggregate accumulators based on the content of
      ** the current row
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>updateAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><name>eDist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"indicate data in accumulator"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* End of the loop
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>groupBySort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SorterNext</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdx</name></name></expr></argument>,<argument><expr><name>addrTopOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereEnd\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrSortingIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Output the final row of result
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>, <argument><expr><name>addrOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"output final row"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Jump over the subroutines
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate a subroutine that outputs a single row of the result
      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag
      ** is less than or equal to zero, the subroutine is a no-op.  If
      ** the processing calls for the query to abort, this subroutine
      ** increments the iAbortFlag memory location before returning in
      ** order to signal the caller to abort.
      */</comment>
      <expr_stmt><expr><name>addrSetAbort</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbortFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"set abort flag"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrOutputRow</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>, <argument><expr><name>addrOutputRow</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Groupby result generator entry point"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>finalizeAggFunctions</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>, <argument><expr><name>addrOutputRow</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSort</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>sDistinct</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>,
                      <argument><expr><name>addrOutputRow</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>addrSetAbort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"end groupby result generator"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate a subroutine that will reset the group-by accumulator
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>resetAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"indicate accumulator empty"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>distFlag</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eDist</name><operator>!=</operator><name>WHERE_DISTINCT_NOOP</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pF</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fixDistinctOpenEph</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eDist</name></expr></argument>, <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>iDistinct</name></name></expr></argument>, <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>iDistAddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <comment type="block">/* endif pGroupBy.  Begin aggregate queries without GROUP BY: */</comment>
    <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pTab</name> <operator>=</operator> <call><name>isSimpleCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If isSimpleCount() returns a pointer to a Table structure, then
        ** the SQL statement is of the form:
        **
        **   SELECT count(*) FROM &lt;tbl&gt;
        **
        ** where the Table structure returned represents table &lt;tbl&gt;.
        **
        ** This statement is so common that it is optimized specially. The
        ** OP_Count instruction is executed either on the intkey table that
        ** contains the data for table &lt;tbl&gt; or on one of its indexes. It
        ** is better to execute the op on an index, as indexes are almost
        ** always spread across less pages than their corresponding tables.
        */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iCsr</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>     <comment type="block">/* Cursor to scan b-tree */</comment>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                         <comment type="block">/* Iterator variable */</comment>
        <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Keyinfo for scanned index */</comment>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pBest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Best index found so far */</comment>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iRoot</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Root page of scanned b-tree */</comment>

        <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Search for the index that has the lowest scan cost.
        **
        ** (2011-04-15) Do not do a full scan of an unordered index.
        **
        ** (2013-10-03) Do not count the entries in a partial index.
        **
        ** In practice the KeyInfo structure will not be used. It is only 
        ** passed to keep OP_OpenRead happy.
        */</comment>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pBest</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>notIndexed</name></name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>bUnordered</name></name><operator>==</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name>
             <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>==</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>pBest</name> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>&lt;</operator><name><name>pBest</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>)</operator></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pBest</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iRoot</name> <operator>=</operator> <name><name>pBest</name><operator>-&gt;</operator><name>tnum</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoOfIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Open a read-only cursor, execute the OP_Count, close the cursor. */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iRoot</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assignAggregateRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Count</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><call><name>AggInfoFuncReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>explainSimpleCount</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pBest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>regAcc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* "populate accumulators" flag */</comment>
        <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pDistinct</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u16</name></type> <name>distFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eDist</name></decl>;</decl_stmt>

        <comment type="block">/* If there are accumulator registers but no min() or max() functions
        ** without FILTER clauses, allocate register regAcc. Register regAcc
        ** will contain 0 the first time the inner loop runs, and 1 thereafter.
        ** The code generated by updateAccumulator() uses this to ensure
        ** that the accumulator registers are (a) updated only once if
        ** there are no min() or max functions or (b) always updated for the
        ** first row visited by the aggregate, so that they are updated at
        ** least once even if the FILTER clause means the min() or max() 
        ** function visits zero rows.  */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nAccumulator</name></name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name><operator>&amp;</operator><name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><block>{<block_content>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>regAcc</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regAcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iDistinct</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pDistinct</name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pFExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>distFlag</name> <operator>=</operator> <ternary><condition><expr><name>pDistinct</name></expr> ?</condition><then> <expr><operator>(</operator><name>WHERE_WANT_DISTINCT</name><operator>|</operator><name>WHERE_AGG_DISTINCT</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assignAggregateRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* This case runs if the aggregate has no GROUP BY clause.  The
        ** processing is much simpler since there is only a single row
        ** of output.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resetAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If this query is a candidate for the min/max optimization, then
        ** minMaxFlag will have been previously set to either
        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will
        ** be an appropriate ORDER BY expression for the optimization.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>minMaxFlag</name><operator>==</operator><name>WHERE_ORDERBY_NORMAL</name> <operator>||</operator> <name>pMinMaxOrderBy</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMinMaxOrderBy</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMinMaxOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereBegin\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pMinMaxOrderBy</name></expr></argument>,
                                   <argument><expr><name>pDistinct</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>minMaxFlag</name><operator>|</operator><name>distFlag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pWInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <goto>goto <name>select_end</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereBegin returns\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eDist</name> <operator>=</operator> <call><name>sqlite3WhereIsDistinct</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAcc</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><name>eDist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eDist</name><operator>!=</operator><name>WHERE_DISTINCT_NOOP</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pF</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>pF</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fixDistinctOpenEph</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eDist</name></expr></argument>, <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>iDistinct</name></name></expr></argument>, <argument><expr><name><name>pF</name><operator>-&gt;</operator><name>iDistAddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>regAcc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>regAcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>minMaxFlag</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3WhereMinMaxOptEarlyOut</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"WhereEnd\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>finalizeAggFunctions</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
                      <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  </block_content>}</block></else></if_stmt> <comment type="block">/* endif aggregate query */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>sDistinct</name><operator>.</operator><name>eTnctType</name></name><operator>==</operator><name>WHERE_DISTINCT_UNORDERED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>explainTempTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"DISTINCT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there is an ORDER BY clause, then we need to sort the results
  ** and send them to the callback one by one.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sSort</name><operator>.</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>explainTempTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                     <argument><expr><ternary><condition><expr><name><name>sSort</name><operator>.</operator><name>nOBSat</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"RIGHT PART OF ORDER BY"</literal></expr></then><else>:<expr><literal type="string">"ORDER BY"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>==</operator><name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>generateSortTail</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSort</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Jump here to skip this query
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The SELECT has been coded. If there is an error in the Parse structure,
  ** set the return code to 1. Otherwise 0. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Control jumps to here if an error is encountered above, or upon
  ** successful coding of the SELECT.
  */</comment>
<label><name>select_end</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMinMaxOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pAggInfo</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCExpr</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>==</operator><name>pAggInfo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pFExpr</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>==</operator><name>pAggInfo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x1</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"end processing\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x40000</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExplainQueryPlanParent</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
