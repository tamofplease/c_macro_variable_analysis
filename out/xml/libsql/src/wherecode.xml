<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/wherecode.c"><comment type="block">/*
** 2015-06-06
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.
**
** This file was split off from where.c on 2015-06-06 in order to reduce the
** size of where.c and make it easier to edit.  This file contains the routines
** that actually generate the bulk of the WHERE loop code.  The original where.c
** file retains the code that does query planning and analysis.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"whereInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>

<comment type="block">/*
** Return the name of the i-th column of the pIdx index.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>explainIndexColumnName</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"&lt;expr&gt;"</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>XN_ROWID</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"rowid"</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is a helper for explainIndexRange() below
**
** pStr holds the text of an expression that we are building up one term
** at a time.  This routine adds a new term to the end of the expression.
** Terms are separated by AND so add the "AND" text for second and subsequent
** terms only.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explainAppendTerm</name><parameter_list>(
  <parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,             <comment type="block">/* The text expression being built */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                <comment type="block">/* Index to read column names from */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                  <comment type="block">/* Number of terms */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTerm</name></decl></parameter>,                  <comment type="block">/* Zero-based index of first term. */</comment>
  <parameter><decl><type><name>int</name></type> <name>bAnd</name></decl></parameter>,                   <comment type="block">/* Non-zero to append " AND " */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name></decl></parameter>             <comment type="block">/* Name of the operator */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bAnd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iTerm</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>zOp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Argument pLevel describes a strategy for scanning table pTab. This 
** function appends text to pStr that describes the subset of table
** rows scanned by the strategy in the form of an SQL expression.
**
** For example, if the query:
**
**   SELECT * FROM t1 WHERE a=1 AND b&gt;2;
**
** is run and there is an index on (a, b), then this function returns a
** string similar to:
**
**   "a=? AND b&gt;?"
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explainIndexRange</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nSkip</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><operator>(</operator><name>WHERE_BTM_LIMIT</name><operator>|</operator><name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nEq</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>&gt;=</operator><name>nSkip</name></expr> ?</condition><then> <expr><literal type="string">"%s=?"</literal></expr> </then><else>: <expr><literal type="string">"ANY(%s)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>explainAppendTerm</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_TOP_LIMIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>explainAppendTerm</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op unless currently processing an EXPLAIN QUERY PLAN
** command, or if either SQLITE_DEBUG or SQLITE_ENABLE_STMT_SCANSTATUS was
** defined at compile-time. If it is not a no-op, a single OP_Explain opcode 
** is added to the output to describe the table scan strategy in pLevel.
**
** If an OP_Explain opcode is added to the VM, its address is returned.
** Otherwise, if no OP_Explain is coded, zero is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereExplainOneScan</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,              <comment type="block">/* Table list this loop refers to */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,             <comment type="block">/* Scan to write OP_Explain opcode for */</comment>
  <parameter><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl></parameter>                  <comment type="block">/* Flags passed to sqlite3WhereBegin() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_STMT_SCANSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>explain</name><operator>==</operator><literal type="number">2</literal></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* VM being constructed */</comment>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Database handle */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isSearch</name></decl>;</decl_stmt>                 <comment type="block">/* True for a SEARCH. False for SCAN. */</comment>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>             <comment type="block">/* The controlling WhereLoop object */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>flags</name></decl>;</decl_stmt>                    <comment type="block">/* Flags that describe this loop */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>                   <comment type="block">/* Text to add to EQP output */</comment>
    <decl_stmt><decl><type><name>StrAccum</name></type> <name>str</name></decl>;</decl_stmt>                 <comment type="block">/* EQP output string */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Initial space for EQP output string */</comment>

    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_MULTI_OR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><name>WHERE_OR_SUBCLAUSE</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>isSearch</name> <operator>=</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_BTM_LIMIT</name><operator>|</operator><name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
            <operator>||</operator> <operator>(</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>
            <operator>||</operator> <operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_ORDERBY_MIN</name><operator>|</operator><name>WHERE_ORDERBY_MAX</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>printfFlags</name></name> <operator>=</operator> <name>SQLITE_PRINTF_INTERNAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s %S"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>isSearch</name></expr> ?</condition><then> <expr><literal type="string">"SEARCH"</literal></expr> </then><else>: <expr><literal type="string">"SCAN"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_AUTO_INDEX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_IDX_ONLY</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>isSearch</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"PRIMARY KEY"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>WHERE_PARTIALIDX</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"AUTOMATIC PARTIAL COVERING INDEX"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"AUTOMATIC COVERING INDEX"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"COVERING INDEX %s"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"INDEX %s"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zFmt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>explainIndexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WHERE_IPK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WHERE_CONSTRAINT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>cRangeOp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* Better output, but breaks many tests */</comment>
      const Table *pTab = pItem-&gt;pTab;
      const char *zRowid = pTab-&gt;iPKey&gt;=0 ? pTab-&gt;aCol[pTab-&gt;iPKey].zCnName:
                              "rowid";
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRowid</name> <init>= <expr><literal type="string">"rowid"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" USING INTEGER PRIMARY KEY (%s"</literal></expr></argument>, <argument><expr><name>zRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_COLUMN_EQ</name><operator>|</operator><name>WHERE_COLUMN_IN</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>cRangeOp</name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_BOTH_LIMIT</name><operator>)</operator><operator>==</operator><name>WHERE_BOTH_LIMIT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;? AND %s"</literal></expr></argument>, <argument><expr><name>zRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cRangeOp</name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>cRangeOp</name> <operator>=</operator> <literal type="char">'&gt;'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>&amp;</operator><name>WHERE_TOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cRangeOp</name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%c?)"</literal></expr></argument>, <argument><expr><name>cRangeOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" VIRTUAL TABLE INDEX %d:%s"</literal></expr></argument>,
                  <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" LEFT-JOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXPLAIN_ESTIMATED_ROWS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" (~%llu rows)"</literal></expr></argument>,
             <argument><expr><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" (~1 row)"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExplainBreakpoint</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Explain</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>,<argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a single OP_Explain opcode that describes a Bloom filter.
**
** Or if not processing EXPLAIN QUERY PLAN and not in a SQLITE_DEBUG and/or
** SQLITE_ENABLE_STMT_SCANSTATUS build, then OP_Explain opcodes are not
** required and this routine is a no-op.
**
** If an OP_Explain opcode is added to the VM, its address is returned.
** Otherwise, if no OP_Explain is coded, zero is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereExplainBloomFilter</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,               <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,           <comment type="block">/* WHERE clause */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>           <comment type="block">/* Bloom filter on this level */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* VM being constructed */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>                   <comment type="block">/* Text to add to EQP output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>             <comment type="block">/* The where loop */</comment>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>str</name></decl>;</decl_stmt>                 <comment type="block">/* EQP output string */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Initial space for EQP output string */</comment>

  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><operator>.</operator><name>printfFlags</name></name> <operator>=</operator> <name>SQLITE_PRINTF_INTERNAL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"BLOOM FILTER ON %S ("</literal></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s=?"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"rowid=?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s=?"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Explain</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>,<argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
<comment type="block">/*
** Configure the VM passed as the first argument with an
** sqlite3_stmt_scanstatus() entry corresponding to the scan used to 
** implement level pLvl. Argument pSrclist is a pointer to the FROM 
** clause that the scan reads data from.
**
** If argument addrExplain is not 0, it must be the address of an 
** OP_Explain instruction that describes the same loop.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereAddScanStatus</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,                        <comment type="block">/* Vdbe to add scanstatus entry to */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrclist</name></decl></parameter>,              <comment type="block">/* FROM clause pLvl reads data from */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>,               <comment type="block">/* Level to add scanstatus() entry for */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrExplain</name></decl></parameter>                 <comment type="block">/* Address of OP_Explain (or 0) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zObj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>  <operator>&amp;&amp;</operator>  <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zObj</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zObj</name> <operator>=</operator> <name><name>pSrclist</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLvl</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeScanStatus</name><argument_list>(
      <argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrExplain</name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>addrBody</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>addrVisit</name></name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>, <argument><expr><name>zObj</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Disable a term in the WHERE clause.  Except, do not disable the term
** if it controls a LEFT OUTER JOIN and it did not originate in the ON
** or USING clause of that join.
**
** Consider the term t2.z='ok' in the following queries:
**
**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'
**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'
**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'
**
** The t2.z='ok' is disabled in the in (2) because it originates
** in the ON clause.  The term is disabled in (3) because it is not part
** of a LEFT OUTER JOIN.  In (1), the term is not disabled.
**
** Disabling a term causes that term to not be tested in the inner loop
** of the join.  Disabling is an optimization.  When terms are satisfied
** by indices, we disable them to prevent redundant tests in the inner
** loop.  We would get the correct results if nothing were ever disabled,
** but joins might run a little slower.  The trick is to disable as much
** as we can without disabling too much.  If we disabled in (1), we'd get
** the wrong answer.  See ticket #813.
**
** If all the children of a term are disabled, then that term is also
** automatically disabled.  In this way, terms get disabled if derived
** virtual terms are tested first.  For example:
**
**      x GLOB 'abc*' AND x&gt;='abc' AND x&lt;'acd'
**      \___________/     \______/     \_____/
**         parent          child1       child2
**
** Only the parent term was in the original WHERE clause.  The child1
** and child2 terms were added by the LIKE optimization.  If both of
** the virtual child terms are valid, then testing of the parent can be 
** skipped.
**
** Usually the parent term is marked as TERM_CODED.  But if the parent
** term was originally TERM_LIKE, then the parent gets TERM_LIKECOND instead.
** The TERM_LIKECOND marking indicates that the term should be coded inside
** a conditional such that is only evaluated on the second pass of a
** LIKE-optimization loop, when scanning BLOBs instead of strings.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>disableTerm</name><parameter_list>(<parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>, <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nLoop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name> <operator>&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nLoop</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_LIKECOND</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4001</literal><operator>)</operator><operator>==</operator><literal type="number">0x4001</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"DISABLE-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereTermPrint</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pTerm</name> <operator>-</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>nChild</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>nChild</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nLoop</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Code an OP_Affinity opcode to apply the column affinity string zAff
** to the n registers starting at base. 
**
** As an optimization, SQLITE_AFF_BLOB and SQLITE_AFF_NONE entries (which
** are no-ops) at the beginning and end of zAff are ignored.  If all entries
** in zAff are SQLITE_AFF_BLOB or SQLITE_AFF_NONE, then no code gets generated.
**
** This routine makes its own copy of zAff so that the caller is free
** to modify zAff after this routine returns.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeApplyAffinity</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zAff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zAff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Adjust base and n to skip over SQLITE_AFF_BLOB and SQLITE_AFF_NONE
  ** entries at the beginning and end of the affinity string.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_AFF_NONE</name><operator>&lt;</operator><name>SQLITE_AFF_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zAff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zAff</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zAff</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;=</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Code the OP_Affinity opcode if there is anything left to do. */</comment>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zAff</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expression pRight, which is the RHS of a comparison operation, is 
** either a vector of n elements or, if n==1, a scalar expression.
** Before the comparison operation, affinity zAff is to be applied
** to the pRight values. This function modifies characters within the
** affinity string to SQLITE_AFF_BLOB if either:
**
**   * the comparison will be performed with no affinity, or
**   * the affinity change in zAff is guaranteed not to change the value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateRangeAffinityStr</name><parameter_list>(
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,                   <comment type="block">/* RHS of comparison */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                          <comment type="block">/* Number of vector elements in comparison */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zAff</name></decl></parameter>                      <comment type="block">/* Affinity string to modify */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_AFF_BLOB</name>
     <operator>||</operator> <call><name>sqlite3ExprNeedsNoAffinityChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zAff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** pX is an expression of the form:  (vector) IN (SELECT ...)
** In other words, it is a vector IN operator with a SELECT clause on the
** LHS.  But not all terms in the vector are indexable and the terms might
** not be in the correct order for indexing.
**
** This routine makes a copy of the input pX expression and then adjusts
** the vector on the LHS with corresponding changes to the SELECT so that
** the vector contains only index terms and those terms are in the correct
** order.  The modified IN expression is returned.  The caller is responsible
** for deleting the returned expression.
**
** Example:
**
**    CREATE TABLE t1(a,b,c,d,e,f);
**    CREATE INDEX t1x1 ON t1(e,c);
**    SELECT * FROM t1 WHERE (a,b,c,d,e) IN (SELECT v,w,x,y,z FROM t2)
**                           \_______________________________________/
**                                     The pX expression
**
** Since only columns e and c can be used with the index, in that order,
** the modified IN expression that is returned will be:
**
**        (e,c) IN (SELECT z,x FROM t2)
**
** The reduced pX is different from the original (obviously) and thus is
** only used for indexing, to improve performance.  The original unaltered
** IN expression must also be run on each output row for correctness.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>removeUnindexableInClauseTerms</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iEq</name></decl></parameter>,              <comment type="block">/* Look at loop terms starting here */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>,     <comment type="block">/* The current loop */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>              <comment type="block">/* The IN expression to be reduced */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrigRhs</name></decl>;</decl_stmt>         <comment type="block">/* Original unmodified RHS */</comment>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrigLhs</name></decl>;</decl_stmt>         <comment type="block">/* Original unmodified LHS */</comment>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pRhs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* New RHS after modifications */</comment>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pLhs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* New LHS after mods */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to the SELECT on the RHS */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrigRhs</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrigLhs</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iEq</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name><operator>==</operator><name>pX</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iField</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>eOperator</name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iField</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOrigRhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Duplicate PK column */</comment>
        <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>, <argument><expr><name><name>pOrigRhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOrigRhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrigLhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLhs</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLhs</name></expr></argument>, <argument><expr><name><name>pOrigLhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOrigLhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrigRhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrigLhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pLhs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <name>pRhs</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pLhs</name> <operator>&amp;&amp;</operator> <name><name>pLhs</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Take care here not to generate a TK_VECTOR containing only a
      ** single value. Since the parser never creates such a vector, some
      ** of the subroutines do not handle this case.  */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pLhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pLhs</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the SELECT statement has an ORDER BY clause, zero the 
      ** iOrderByCol variables. These are set to non-zero when an 
      ** ORDER BY term exactly matches one of the terms of the 
      ** result-set. Since the result-set of the SELECT statement may
      ** have been modified or reordered, these variables are no longer 
      ** set correctly.  Since setting them is just an optimization, 
      ** it's easiest just to zero them here.  */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    printf("For indexing, change the IN expr:\n");
    sqlite3TreeViewExpr(0, pX, 0);
    printf("Into:\n");
    sqlite3TreeViewExpr(0, pNew, 0);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Generate code for a single equality term of the WHERE clause.  An equality
** term can be either X=expr or X IN (...).   pTerm is the term to be 
** coded.
**
** The current value for the constraint is left in a register, the index
** of which is returned.  An attempt is made store the result in iTarget but
** this is only guaranteed for TK_ISNULL and TK_IN constraints.  If the
** constraint is a TK_EQ or TK_IS, then the current value might be left in
** some other register and it is the caller's responsibility to compensate.
**
** For a constraint of the form X=expr, the expression is evaluated in
** straight-line code.  For constraints of the form X IN (...)
** this routine sets up a loop that will iterate over all values of X.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeEqualityTerm</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>,   <comment type="block">/* The term of the WHERE clause to be coded */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>, <comment type="block">/* The level of the FROM clause we are working on */</comment>
  <parameter><decl><type><name>int</name></type> <name>iEq</name></decl></parameter>,            <comment type="block">/* Index of the equality term within this level */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRev</name></decl></parameter>,           <comment type="block">/* True for reverse-order IN operations */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTarget</name></decl></parameter>         <comment type="block">/* Attempt to leave results in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>                  <comment type="block">/* Register holding results */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>iEq</name></expr>]</index></name><operator>==</operator><name>pTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTarget</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <name>iTarget</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name>IN_INDEX_NOOP</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>InLoop</name></name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiMap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>iEq</name></expr>]</index></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iEq</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bRev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>!</operator><name>bRev</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <name>iTarget</name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iEq</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name><operator>==</operator><name>pX</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>iTarget</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iEq</name></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name><operator>==</operator><name>pX</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nEq</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>iTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>IN_INDEX_LOOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subrtn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>removeUnindexableInClauseTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iEq</name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>aiMap</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>IN_INDEX_LOOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aiMap</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>aiMap</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>MAX</name><argument_list>(<argument><expr><name>nEq</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>IN_INDEX_LOOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aiMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_INDEX_DESC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bRev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>!</operator><name>bRev</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Last</name></expr> </then><else>: <expr><name>OP_Rewind</name></expr></else></ternary></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>!</operator><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_IN_ABLE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iEq</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_SEEKSCAN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_IN_EARLYOUT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name> <operator>+=</operator> <name>nEq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name> <operator>=</operator>
       <call><name>sqlite3WhereRealloc</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></argument>,
                           <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iMap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Index in aiMap[] */</comment>
      <expr_stmt><expr><name>pIn</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iEq</name></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name><operator>==</operator><name>pX</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><name>iReg</name> <operator>+</operator> <name>i</name> <operator>-</operator> <name>iEq</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_ROWID</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><ternary><condition><expr><name>aiMap</name></expr> ?</condition><then> <expr><name><name>aiMap</name><index>[<expr><name>iMap</name><operator>++</operator></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>OP_Column</name></expr></argument>,<argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>iOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>iEq</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iCur</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Prev</name></expr> </then><else>: <expr><name>OP_Next</name></expr></else></ternary></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>iEq</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iBase</name></name> <operator>=</operator> <name>iReg</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>nPrefix</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>nPrefix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iEq</name><operator>&gt;</operator><literal type="number">0</literal>
                <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_SEEKSCAN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
                <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iEq</name><operator>&gt;</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IN_SEEKSCAN</name><operator>|</operator><name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekHit</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>aiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* As an optimization, try to disable the WHERE clause term that is
  ** driving the index as it will always be true.  The correct answer is
  ** obtained regardless, but we might get the answer with fewer CPU cycles
  ** by omitting the term.
  **
  ** But do not disable the term unless we are certain that the term is
  ** not a transitive constraint.  For an example of where that does not
  ** work, see https://sqlite.org/forum/forumpost/eb8613976a (2021-05-04)
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TRANSCONS</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>iReg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate all == and IN constraints for an
** index scan.
**
** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).
** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c&gt;5 AND c&lt;10
** The index has as many as three equality constraints, but in this
** example, the third "c" value is an inequality.  So only two 
** constraints are coded.  This routine will generate code to evaluate
** a==5 and b IN (1,2,3).  The current values for a and b will be stored
** in consecutive registers and the index of the first register is returned.
**
** In the example above nEq==2.  But this subroutine works for any value
** of nEq including 0.  If nEq==0, this routine is nearly a no-op.
** The only thing it does is allocate the pLevel-&gt;iMem memory cell and
** compute the affinity string.
**
** The nExtraReg parameter is 0 or 1.  It is 0 if all WHERE clause constraints
** are == or IN and are covered by the nEq.  nExtraReg is 1 if there is
** an inequality constraint (such as the "c&gt;=5 AND c&lt;10" in the example) that
** occurs after the nEq quality constraints.
**
** This routine allocates a range of nEq+nExtraReg memory cells and returns
** the index of the first memory cell in that range. The code that
** calls this routine will use that memory range to store keys for
** start and termination conditions of the loop.
** key value of the loop.  If one or more IN operators appear, then
** this routine allocates an additional nEq memory cells for internal
** use.
**
** Before returning, *pzAff is set to point to a buffer containing a
** copy of the column affinity string of the index allocated using
** sqlite3DbMalloc(). Except, entries in the copy of the string associated
** with equality constraints that use BLOB or NONE affinity are set to
** SQLITE_AFF_BLOB. This is to deal with SQL such as the following:
**
**   CREATE TABLE t1(a TEXT PRIMARY KEY, b);
**   SELECT ... FROM t1 AS t2, t1 WHERE t1.a = t2.b;
**
** In the example above, the index on t1(a) has TEXT affinity. But since
** the right hand side of the equality constraint (t2.b) has BLOB/NONE affinity,
** no conversion should be attempted before using a t2.b value as part of
** a key to search the index. Hence the first byte in the returned affinity
** string in this example would be set to SQLITE_AFF_BLOB.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeAllEqualityTerms</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,   <comment type="block">/* Which nested loop of the FROM we are coding */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRev</name></decl></parameter>,             <comment type="block">/* Reverse the order of IN operators */</comment>
  <parameter><decl><type><name>int</name></type> <name>nExtraReg</name></decl></parameter>,        <comment type="block">/* Number of extra registers to allocate */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzAff</name></decl></parameter>          <comment type="block">/* OUT: Set to point to affinity string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name></decl>;</decl_stmt>                      <comment type="block">/* The number of == or IN constraints to code */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nSkip</name></decl>;</decl_stmt>                    <comment type="block">/* Number of left-most columns to skip */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The vm under construction */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                  <comment type="block">/* The index being used for this loop */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>             <comment type="block">/* A single constraint term */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>             <comment type="block">/* The WhereLoop object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                  <comment type="block">/* Base register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReg</name></decl>;</decl_stmt>                     <comment type="block">/* Number of registers to allocate */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAff</name></decl>;</decl_stmt>                   <comment type="block">/* Affinity string to return */</comment>

  <comment type="block">/* This module is only called on query plans that use an index. */</comment>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nEq</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSkip</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out how many memory cells we will need then allocate them.
  */</comment>
  <expr_stmt><expr><name>regBase</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nReg</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>+</operator> <name>nExtraReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>zAff</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAff</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nSkip</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nSkip</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bRev</name></expr>?</condition><then><expr><name>OP_Last</name></expr></then><else>:<expr><name>OP_Rewind</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"begin skip-scan on %s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bRev</name></expr>?</condition><then><expr><name>OP_SeekLT</name></expr></then><else>:<expr><name>OP_SeekGT</name></expr></else></ternary><operator>)</operator></expr></argument>,
                            <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nSkip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nSkip</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name>XN_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>    

  <comment type="block">/* Evaluate the equality constraints
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAff</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zAff</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>nSkip</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nEq</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The following testcase is true for indices with redundant columns. 
    ** Ex: CREATE INDEX i1 ON t1(a,b,a); SELECT * FROM t1 WHERE a=0 AND b=0; */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>r1</name><operator>!=</operator><name>regBase</name><operator>+</operator><name>j</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>regBase</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>nSkip</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nEq</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_xIsSelect</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* No affinity ever needs to be (or should be) applied to a value
        ** from the RHS of an "? IN (SELECT ...)" expression. The 
        ** sqlite3FindInIndex() routine has already ensured that the 
        ** affinity of the comparison has been applied to the value.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>zAff</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_IS</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprNeedsNoAffinityChange</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pzAff</name> <operator>=</operator> <name>zAff</name></expr>;</expr_stmt>
  <return>return <expr><name>regBase</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
<comment type="block">/*
** If the most recently coded instruction is a constant range constraint
** (a string literal) that originated from the LIKE optimization, then 
** set P3 and P5 on the OP_String opcode so that the string will be cast
** to a BLOB at appropriate times.
**
** The LIKE optimization trys to evaluate "x LIKE 'abc%'" as a range
** expression: "x&gt;='ABC' AND x&lt;'abd'".  But this requires that the range
** scan loop run twice, once for strings and a second time for BLOBs.
** The OP_String opcodes on the second pass convert the upper and lower
** bound string constants to blobs.  This routine makes the necessary changes
** to the OP_String opcodes for that to happen.
**
** Except, of course, if SQLITE_LIKE_DOESNT_MATCH_BLOBS is defined, then
** only the one pass through the string space is required, so this routine
** becomes a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLikeOptimizationStringFixup</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,                <comment type="block">/* prepared statement under construction */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,     <comment type="block">/* The loop that contains the LIKE operator */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>        <comment type="block">/* The upper or lower bound just coded */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetLastOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_String8</name> 
            <operator>||</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Register holding counter */</comment>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* ASC or DESC */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>whereLikeOptimizationStringFixup</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/*
** Information is passed from codeCursorHint() down to individual nodes of
** the expression tree (by sqlite3WalkExpr()) using an instance of this
** structure.
*/</comment>
<struct>struct <name>CCurHint</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iTabCur</name></decl>;</decl_stmt>    <comment type="block">/* Cursor for the main table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>    <comment type="block">/* Cursor for the index, if pIdx!=0.  Unused otherwise */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>    <comment type="block">/* The index used to access the table */</comment>
}</block>;</struct>

<comment type="block">/*
** This function is called for every node of an expression that is a candidate
** for a cursor hint on an index cursor.  For TK_COLUMN nodes that reference
** the table CCurHint.iTabCur, verify that the same column can be
** accessed through the index.  If it cannot, then set pWalker-&gt;eCode to 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCursorHintCheckExpr</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CCurHint</name></name> <modifier>*</modifier></type><name>pHint</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCCurHint</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pHint</name><operator>-&gt;</operator><name>iTabCur</name></name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Test whether or not expression pExpr, which was part of a WHERE clause,
** should be included in the cursor-hint for a table that is on the rhs
** of a LEFT JOIN. Set Walker.eCode to non-zero before returning if the 
** expression is not suitable.
**
** An expression is unsuitable if it might evaluate to non NULL even if
** a TK_COLUMN node that does affect the value of the expression is set
** to NULL. For example:
**
**   col IS NULL
**   col IS NOT NULL
**   coalesce(col, 1)
**   CASE WHEN col THEN 0 ELSE 1 END
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCursorHintIsOrFunction</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name> 
   <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNULL</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name> 
   <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_CASE</name></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>d1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>d2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3IsLikeFunction</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called on every node of an expression tree used as an
** argument to the OP_CursorHint instruction. If the node is a TK_COLUMN
** that accesses any table other than the one identified by
** CCurHint.iTabCur, then do the following:
**
**   1) allocate a register and code an OP_Column instruction to read 
**      the specified column into the new register, and
**
**   2) transform the expression node to a TK_REGISTER node that reads 
**      from the newly populated register.
**
** Also, if the node is a TK_COLUMN that does access the table idenified
** by pCCurHint.iTabCur, and an index is being used (which we will
** know because CCurHint.pIdx!=0) then transform the TK_COLUMN into
** an access of the index rather than the original table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCursorHintFixExpr</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>WRC_Continue</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>CCurHint</name></name> <modifier>*</modifier></type><name>pHint</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCCurHint</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pHint</name><operator>-&gt;</operator><name>iTabCur</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>reg</name> <init>= <expr><operator>++</operator><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Register for column value */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_REGISTER</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pHint</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An aggregate function in the WHERE clause of a query means this must
    ** be a correlated sub-query, and expression pExpr is an aggregate from
    ** the parent context. Do not walk the function arguments in this case.
    **
    ** todo: It should be possible to replace this node with a TK_REGISTER
    ** expression, as the result of the expression must be stored in a 
    ** register at this point. The same holds for TK_AGG_COLUMN nodes. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WRC_Prune</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert an OP_CursorHint instruction if it is appropriate to do so.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeCursorHint</name><parameter_list>(
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name></decl></parameter>,  <comment type="block">/* FROM clause item */</comment>
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,    <comment type="block">/* The where clause */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,   <comment type="block">/* Which loop to provide hints for */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pEndRange</name></decl></parameter>  <comment type="block">/* Hint this end-of-scan boundary term if not NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>CCurHint</name></name></type> <name>sHint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_CursorHints</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sHint</name><operator>.</operator><name>iTabCur</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sHint</name><operator>.</operator><name>iIdxCur</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sHint</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sWalker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pCCurHint</name></name> <operator>=</operator> <operator>&amp;</operator><name>sHint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Any terms specified as part of the ON(...) clause for any LEFT 
    ** JOIN for which the current table is not the rhs are omitted
    ** from the cursor-hint. 
    **
    ** If this table is the rhs of a LEFT JOIN, "IS" or "IS NULL" terms 
    ** that were specified as part of the WHERE clause must be excluded.
    ** This is to address the following:
    **
    **   SELECT ... t1 LEFT JOIN t2 ON (t1.a=t2.b) WHERE t2.c IS NULL;
    **
    ** Say there is a single row in t2 that matches (t1.a=t2.b), but its
    ** t2.c values is not NULL. If the (t2.c IS NULL) constraint is 
    ** pushed down to the cursor, this row is filtered out, causing
    ** SQLite to synthesize a row of NULL values. Which does match the
    ** WHERE clause, and so the query returns a row. Which is incorrect.
    **
    ** For the same reason, WHERE terms such as:
    **
    **   WHERE 1 = (t2.c IS NULL)
    **
    ** are also excluded. See codeCursorHintIsOrFunction() for details.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name><operator>!=</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>codeCursorHintIsOrFunction</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* All terms in pWLoop-&gt;aLTerm[] except pEndRange are used to initialize
    ** the cursor.  These terms are not needed as hints for a pure range
    ** scan (that has no == terms) so omit them. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>!=</operator><name>pEndRange</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><name>pTerm</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No subqueries or non-deterministic functions allowed */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprContainsSubquery</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* For an index scan, make sure referenced columns are actually in
    ** the index. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sHint</name><operator>.</operator><name>pIdx</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>codeCursorHintCheckExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we survive all prior tests, that means this term is worth hinting */</comment>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>codeCursorHintFixExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CursorHint</name></expr></argument>, 
                      <argument><expr><operator>(</operator><ternary><condition><expr><name><name>sHint</name><operator>.</operator><name>pIdx</name></name></expr> ?</condition><then> <expr><name><name>sHint</name><operator>.</operator><name>iIdxCur</name></name></expr> </then><else>: <expr><name><name>sHint</name><operator>.</operator><name>iTabCur</name></name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                      <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>, <argument><expr><name>P4_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>codeCursorHint</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>,<parameter><type><name>D</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* No-op */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_CURSOR_HINTS */</comment>

<comment type="block">/*
** Cursor iCur is open on an intkey b-tree (a table). Register iRowid contains
** a rowid value just read from cursor iIdxCur, open on index pIdx. This
** function generates code to do a deferred seek of cursor iCur to the 
** rowid stored in register iRowid.
**
** Normally, this is just:
**
**   OP_DeferredSeek $iCur $iRowid
**
** Which causes a seek on $iCur to the row with rowid $iRowid.
**
** However, if the scan currently being coded is a branch of an OR-loop and
** the statement currently being coded is a SELECT, then additional information
** is added that might allow OP_Column to omit the seek and instead do its
** lookup on the index, thus avoiding an expensive seek operation.  To
** enable this optimization, the P3 of OP_DeferredSeek is set to iIdxCur
** and P4 is set to an array of integers containing one entry for each column
** in the table.  For each table column, if the column is the i'th
** column of the index, then the corresponding array entry is set to (i+1).
** If the column does not appear in the index at all, the array entry is set
** to 0.  The OP_Column opcode can check this array to see if the column it
** wants is in the index and if it is, it will substitute the index cursor
** and column number and continue with those new values, rather than seeking
** the table cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeDeferredSeek</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,              <comment type="block">/* Where clause context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                    <comment type="block">/* Index scan is using */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,                       <comment type="block">/* Cursor for IPK b-tree */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>                     <comment type="block">/* Index cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Parse context */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Vdbe to generate code within */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCur</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>bDeferredSeek</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DeferredSeek</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_OR_SUBCLAUSE</name><operator>|</operator><name>WHERE_RIGHT_JOIN</name><operator>)</operator><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>DbMaskAllZero</name><argument_list>(<argument><expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>writeMask</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>ai</name> <init>= <expr><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>ai</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>ai</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>x1</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>x2</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x1</name><operator>!=</operator><name>x2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>x1</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ai</name><index>[<expr><name>x2</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ai</name></expr></argument>, <argument><expr><name>P4_INTARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the expression passed as the second argument is a vector, generate
** code to write the first nReg elements of the vector into an array
** of registers starting with iReg.
**
** If the expression is not a vector, then nReg must be passed 1. In
** this case, generate code to evaluate the expression and leave the
** result in register iReg.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeExprOrVector</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReg</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iSelect</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iSelect</name> <operator>=</operator> <call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>iSelect</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>nReg</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReg</name><operator>&lt;=</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nReg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iReg</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReg</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The pTruth expression is always true because it is the WHERE clause
** a partial index that is driving a query loop.  Look through all of the
** WHERE clause terms on the query, and if any of those terms must be
** true because pTruth is true, then mark those WHERE clause terms as
** coded.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereApplyPartialIndexConstraints</name><parameter_list>(
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTruth</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>pTruth</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>whereApplyPartialIndexConstraints</name><argument_list>(<argument><expr><name><name>pTruth</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTruth</name> <operator>=</operator> <name><name>pTruth</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pTruth</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called right after An OP_Filter has been generated and
** before the corresponding index search has been performed.  This routine
** checks to see if there are additional Bloom filters in inner loops that
** can be checked prior to doing the index lookup.  If there are available
** inner-loop Bloom filters, then evaluate those filters now, before the
** index lookup.  The idea is that a Bloom filter check is way faster than
** an index lookup, and the Bloom filter might return false, meaning that
** the index lookup can be skipped.
**
** We know that an inner loop uses a Bloom filter because it has the
** WhereLevel.regFilter set.  If an inner-loop Bloom filter is checked,
** then clear the WhereLevel.regFilter value to prevent the Bloom filter
** from being checked a second time when the inner loop is evaluated.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>filterPullDown</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,   <comment type="block">/* Complete information about the WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,          <comment type="block">/* Which level of pWInfo-&gt;a[] should be coded */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrNxt</name></decl></parameter>,         <comment type="block">/* Jump here to bypass inner loops */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>     <comment type="block">/* Loops that are not ready */</comment>
)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><operator>++</operator><name>iLevel</name> <operator>&lt;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <comment type="block">/*         ,--- Because sqlite3ConstructBloomFilter() has will not have set
    **  vvvvv--'    pLevel-&gt;regFilter if this were true. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name>notReady</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name> <operator>=</operator> <name>addrNxt</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_Filter</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>,
                           <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStartAff</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_IN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>codeAllEqualityTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pLevel</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_Filter</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>,
                           <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for the start of the iLevel-th loop in the WHERE clause
** implementation described by pWInfo.
*/</comment>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereCodeOneLoopStart</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,             <comment type="block">/* Prepared statement under construction */</comment>
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,   <comment type="block">/* Complete information about the WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,          <comment type="block">/* Which level of pWInfo-&gt;a[] should be coded */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,  <comment type="block">/* The current level pointer */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>     <comment type="block">/* Which tables are currently available */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>            <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>            <comment type="block">/* The VDBE cursor for the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrNxt</name></decl>;</decl_stmt>         <comment type="block">/* Where to jump to continue with the next IN case */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRev</name></decl>;</decl_stmt>            <comment type="block">/* True if we need to scan in reverse order */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>    <comment type="block">/* The WhereLoop object being coded */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>    <comment type="block">/* Decomposition of the entire WHERE clause */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>               <comment type="block">/* A WHERE clause term */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>              <comment type="block">/* FROM clause term being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrBrk</name></decl>;</decl_stmt>                    <comment type="block">/* Jump here to break out of the loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrHalt</name></decl>;</decl_stmt>                   <comment type="block">/* addrBrk for the outermost loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name></decl>;</decl_stmt>                   <comment type="block">/* Jump here to continue with next cycle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Rowid is stored in this register, if not zero */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iReleaseReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Temp register to free before returning */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Index used by loop (if any) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLoop</name></decl>;</decl_stmt>                <comment type="block">/* Iteration of constraint generator loop */</comment>

  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name> <operator>=</operator> <name>notReady</name> <operator>&amp;</operator> <operator>~</operator><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name><operator>&gt;&gt;</operator><name>iLevel</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Begin WHERE-loop%d: %s"</literal><operator>,</operator><name>iLevel</name><operator>,</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x4001 */</comment>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"Coding level %d of %d:  notReady=%llx  iFrom=%d\n"</literal></expr></argument>,
       <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>notReady</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x1000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>pLoop</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4001</literal><operator>)</operator><operator>==</operator><literal type="number">0x4001</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"WHERE clause being coded:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"All WHERE-clause terms before coding:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereClausePrint</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Create labels for the "break" and "continue" instructions
  ** for the current loop.  Jump to addrBrk to break out of a loop.
  ** Jump to cont to go immediately to the next iteration of the
  ** loop.
  **
  ** When there is an IN operator, we also have a "addrNxt" label that
  ** means to continue with the next IN value combination.  When
  ** there are no IN operators in the constraints, the "addrNxt" label
  ** is the same as "addrBrk".
  */</comment>
  <expr_stmt><expr><name>addrBrk</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrCont</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is the right table of a LEFT OUTER JOIN, allocate and
  ** initialize a memory cell that records if this table matches any
  ** row of the left table of the join.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_OR_SUBCLAUSE</name><operator>|</operator><name>WHERE_RIGHT_JOIN</name><operator>)</operator><operator>)</operator>
       <operator>||</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pTabItem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTabItem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"init LEFT JOIN no-match flag"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute a safe address to jump to if we discover that the table for
  ** this loop is empty and can never contribute content. */</comment>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>iLevel</name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iLeftJoin</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pRJ</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>addrHalt</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addrBrk</name></expr>;</expr_stmt>

  <comment type="block">/* Special case of a FROM clause subquery implemented as a co-routine */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regYield</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator>  <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"next row of %s"</literal><operator>,</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Goto</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  if<condition>(  <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 1:  The table is a virtual-table.  Use the VFilter and VNext
    **          to access the data.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>   <comment type="block">/* P3 Value for OP_VFilter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrNotFound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nConstraint</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrNotFound</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTarget</name> <init>= <expr><name>iReg</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>SMASKBIT32</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>mHandleIn</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iCache</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3CodeRhsOfIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VInitIn</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>, <argument><expr><name>iCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>addrNotFound</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>codeExprOrVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_OFFSET</name>
         <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>bOmitOffset</name></name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_AUX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator><literal type="string">"Zero OFFSET counter"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>, <argument><expr><name>iReg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VFilter</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrNotFound</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>,
                      <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>,
                      <argument><expr><ternary><condition><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name></expr> ?</condition><then> <expr><name>P4_DYNAMIC</name></expr> </then><else>: <expr><name>P4_STATIC</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* An OOM inside of AddOp4(OP_VFilter) instruction above might have freed
    ** the u.vtab.idxStr.  NULL it out to prevent a use-after-free */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name></expr> ?</condition><then> <expr><name>OP_Noop</name></expr> </then><else>: <expr><name>OP_VNext</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">16</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name><operator>&gt;&gt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SMASKBIT32</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>mHandleIn</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCompare</name></decl>;</decl_stmt>  <comment type="block">/* The comparison operator */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>    <comment type="block">/* RHS of the comparison */</comment>
        <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>     <comment type="block">/* Opcode to access the value of the IN constraint */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>         <comment type="block">/* IN loop corresponding to the j-th constraint */</comment>

        <comment type="block">/* Reload the constraint value into reg[iReg+j+2].  The same value
        ** was loaded into the same register prior to the OP_VFilter, but
        ** the xFilter implementation might have changed the datatype or
        ** encoding of the value in the register, so it *must* be reloaded.
        */</comment>
        <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>iIn</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>.</operator><name>addrInTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>iReg</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">2</literal><operator>)</operator>
           <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Rowid</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>iReg</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Rowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Generate code that will continue to the next row if 
        ** the IN constraint is not satisfied
        */</comment>
        <expr_stmt><expr><name>pCompare</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iFld</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iFld</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFld</name><operator>&lt;=</operator><name><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCompare</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iFld</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>pCompare</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name><name>pCompare</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pRight</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_REGISTER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pRight</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iReg</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(
                <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCompare</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pCompare</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* These registers need to be preserved in case there is an IN operator
    ** loop.  So we could deallocate the registers here (and potentially
    ** reuse them later) if (pLoop-&gt;wsFlags &amp; WHERE_IN_ABLE)==0.  But it seems
    ** simpler and safer to simply not reuse the registers.
    **
    **    sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2);
    */</comment>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

  if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_COLUMN_IN</name><operator>|</operator><name>WHERE_COLUMN_EQ</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Case 2:  We can directly reference a single row using an
    **          equality comparison against the ROWID field.  Or
    **          we reference multiple rows using a "rowid IN (...)"
    **          construct.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iReleaseReg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bRev</name></expr></argument>, <argument><expr><name>iReleaseReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iRowidReg</name><operator>!=</operator><name>iReleaseReg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReleaseReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>addrNxt</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Filter</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>,
                           <argument><expr><name>iRowidReg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>filterPullDown</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekRowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_RANGE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Case 3:  We have an inequality comparison against the ROWID field.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>testOp</name> <init>= <expr><name>OP_Noop</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>memEndValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pStart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name>pEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStart</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pEnd</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRev</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name>pStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>codeCursorHint</name><argument_list>(<argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>             <comment type="block">/* The expression that defines the start bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>rTemp</name></decl>;</decl_stmt>        <comment type="block">/* Registers for holding the start boundary */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>               <comment type="block">/* Cursor seek operation */</comment>

      <comment type="block">/* The following constant maps TK_xx codes into corresponding 
      ** seek opcodes.  It depends on a particular ordering of TK_xx
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name></type> <name><name>aMoveOp</name><index>[]</index></name> <init>= <expr><block>{
           <comment type="block">/* TK_GT */</comment>  <expr><name>OP_SeekGT</name></expr>,
           <comment type="block">/* TK_LE */</comment>  <expr><name>OP_SeekLE</name></expr>,
           <comment type="block">/* TK_LT */</comment>  <expr><name>OP_SeekLT</name></expr>,
           <comment type="block">/* TK_GE */</comment>  <expr><name>OP_SeekGE</name></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Make sure the ordering.. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/*  ... of the TK_xx values... */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/*  ... is correcct. */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pStart</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pStart</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* transitive constraints */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <name>rTemp</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codeExprOrVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aMoveOp</name><index>[<expr><operator>(</operator><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>op</name></name> <operator>-</operator> <name>TK_GT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_GT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_GE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_LT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_LE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aMoveOp</name><index>[<expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>op</name></name> <operator>-</operator> <name>TK_GT</name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"pk"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Last</name></expr> </then><else>: <expr><name>OP_Rewind</name></expr></else></ternary></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrHalt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pEnd</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pEnd</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Transitive constraints */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>memEndValue</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeExprOrVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>memEndValue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call> 
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>testOp</name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Le</name></expr> </then><else>: <expr><name>OP_Ge</name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>testOp</name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Lt</name></expr> </then><else>: <expr><name>OP_Gt</name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Prev</name></expr> </then><else>: <expr><name>OP_Next</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>testOp</name><operator>!=</operator><name>OP_Noop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name></expr></argument>, <argument><expr><name>memEndValue</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name> <operator>|</operator> <name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 4: A scan using an index.
    **
    **         The WHERE clause may contain zero or more equality 
    **         terms ("==" or "IN" operators) that refer to the N
    **         left-most columns of the index. It may also contain
    **         inequality constraints (&gt;, &lt;, &gt;= or &lt;=) on the indexed
    **         column that immediately follows the N equalities. Only 
    **         the right-most column can be an inequality - the rest must
    **         use the "==" and "IN" operators. For example, if the 
    **         index is on (x,y,z), then the following clauses are all 
    **         optimized:
    **
    **            x=5
    **            x=5 AND y=10
    **            x=5 AND y&lt;10
    **            x=5 AND y&gt;5 AND y&lt;10
    **            x=5 AND y=5 AND z&lt;=10
    **
    **         The z&lt;10 term of the following cannot be used, only
    **         the x=5 term:
    **
    **            x=5 AND z&lt;10
    **
    **         N may be zero if there are inequality constraints.
    **         If there are no inequality constraints, then N is at
    **         least one.
    **
    **         This case is also used when there are no WHERE clause
    **         constraints but an index is selected anyway, in order
    **         to force the output order to conform to an ORDER BY.
    */</comment>  
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aStartOp</name><index>[]</index></name> <init>= <expr><block>{
      <expr><literal type="number">0</literal></expr>,
      <expr><literal type="number">0</literal></expr>,
      <expr><name>OP_Rewind</name></expr>,           <comment type="block">/* 2: (!start_constraints &amp;&amp; startEq &amp;&amp;  !bRev) */</comment>
      <expr><name>OP_Last</name></expr>,             <comment type="block">/* 3: (!start_constraints &amp;&amp; startEq &amp;&amp;   bRev) */</comment>
      <expr><name>OP_SeekGT</name></expr>,           <comment type="block">/* 4: (start_constraints  &amp;&amp; !startEq &amp;&amp; !bRev) */</comment>
      <expr><name>OP_SeekLT</name></expr>,           <comment type="block">/* 5: (start_constraints  &amp;&amp; !startEq &amp;&amp;  bRev) */</comment>
      <expr><name>OP_SeekGE</name></expr>,           <comment type="block">/* 6: (start_constraints  &amp;&amp;  startEq &amp;&amp; !bRev) */</comment>
      <expr><name>OP_SeekLE</name></expr>            <comment type="block">/* 7: (start_constraints  &amp;&amp;  startEq &amp;&amp;  bRev) */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aEndOp</name><index>[]</index></name> <init>= <expr><block>{
      <expr><name>OP_IdxGE</name></expr>,            <comment type="block">/* 0: (end_constraints &amp;&amp; !bRev &amp;&amp; !endEq) */</comment>
      <expr><name>OP_IdxGT</name></expr>,            <comment type="block">/* 1: (end_constraints &amp;&amp; !bRev &amp;&amp;  endEq) */</comment>
      <expr><name>OP_IdxLE</name></expr>,            <comment type="block">/* 2: (end_constraints &amp;&amp;  bRev &amp;&amp; !endEq) */</comment>
      <expr><name>OP_IdxLT</name></expr>,            <comment type="block">/* 3: (end_constraints &amp;&amp;  bRev &amp;&amp;  endEq) */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of == or IN terms */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>nBtm</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Length of BTM vector */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>nTop</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Length of TOP vector */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                 <comment type="block">/* Base register holding constraint values */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pRangeStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Inequality constraint at range start */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pRangeEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Inequality constraint at range end */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>startEq</name></decl>;</decl_stmt>                 <comment type="block">/* True if range start uses ==, &gt;= or &lt;= */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>endEq</name></decl>;</decl_stmt>                   <comment type="block">/* True if range end uses ==, &gt;= or &lt;= */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>start_constraints</name></decl>;</decl_stmt>       <comment type="block">/* Start of range is constrained */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name></decl>;</decl_stmt>             <comment type="block">/* Number of constraint terms */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>                 <comment type="block">/* The VDBE cursor for the index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtraReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of extra registers needed */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                      <comment type="block">/* Instruction opcode */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStartAff</name></decl>;</decl_stmt>             <comment type="block">/* Affinity for start of range constraint */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEndAff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Affinity for end of range constraint */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>bSeekPastNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True to seek past initial nulls */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>bStopAtNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Add condition to terminate at NULLs */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>omitTable</name></decl>;</decl_stmt>               <comment type="block">/* True if we use the index only */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regBignull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* big-null flag register */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrSeekScan</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Opcode of the OP_SeekScan, if any */</comment>

    <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iIdxCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find any inequality constraint terms for the start and end 
    ** of the range. 
    */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRangeStart</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>nExtraReg</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Like optimization range constraints always occur in pairs */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> 
              <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRangeEnd</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>nExtraReg</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRangeStart</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>                     <comment type="block">/* LIKE opt constraints */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* occur in pairs */</comment>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"LIKE loop counter"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* iLikeRepCntr actually stores 2x the counter register number.  The
        ** bottom bit indicates whether the search order is ASC or DESC. */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bRev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>==</operator><name>SQLITE_SO_DESC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>bRev</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name> <operator>&lt;&lt;=</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name> <operator>|=</operator> <name>bRev</name> <operator>^</operator> <operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>==</operator><name>SQLITE_SO_DESC</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>pRangeStart</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>nEq</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>j</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>j</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bSeekPastNull</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRangeEnd</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the WHERE_BIGNULL_SORT flag is set, then index column nEq uses
    ** a non-default "big-null" sort (either ASC NULLS LAST or DESC NULLS 
    ** FIRST). In both cases separate ordered scans are made of those
    ** index entries for which the column is null and for those for which
    ** it is not. For an ASC sort, the non-NULL entries are scanned first.
    ** For DESC, NULL entries are scanned first.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_TOP_LIMIT</name><operator>|</operator><name>WHERE_BTM_LIMIT</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BIGNULL_SORT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeekPastNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nExtraReg</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nBtm</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nTop</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRangeEnd</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pRangeStart</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>bSeekPastNull</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regBignull</name></name> <operator>=</operator> <name>regBignull</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBignull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBignull</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we are doing a reverse order scan on an ascending index, or
    ** a forward order scan on a descending index, interchange the 
    ** start and end terms (pRangeStart and pRangeEnd).
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nEq</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>&amp;&amp;</operator> <name>bRev</name><operator>==</operator><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>==</operator><name>SQLITE_SO_ASC</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>WhereTerm</name> <operator>*</operator></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>u8</name></expr></argument>, <argument><expr><name>bSeekPastNull</name></expr></argument>, <argument><expr><name>bStopAtNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>u8</name></expr></argument>, <argument><expr><name>nBtm</name></expr></argument>, <argument><expr><name>nTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_SEEKSCAN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* In case OP_SeekScan is used, ensure that the index cursor does not
      ** point to a valid row for the first iteration of this loop. */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate code to evaluate all constraint terms using == or IN
    ** and store the values of those terms in an array of registers
    ** starting at regBase.
    */</comment>
    <expr_stmt><expr><call><name>codeCursorHint</name><argument_list>(<argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regBase</name> <operator>=</operator> <call><name>codeAllEqualityTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pLevel</name></expr></argument>,<argument><expr><name>bRev</name></expr></argument>,<argument><expr><name>nExtraReg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zStartAff</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zStartAff</name> <operator>&amp;&amp;</operator> <name>nTop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zEndAff</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>addrNxt</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>regBignull</name></expr> ?</condition><then> <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBignull</name></name></expr> </then><else>: <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_LE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_GE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_LE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_GE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startEq</name> <operator>=</operator> <operator>!</operator><name>pRangeStart</name> <operator>||</operator> <name><name>pRangeStart</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_LE</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>endEq</name> <operator>=</operator>   <operator>!</operator><name>pRangeEnd</name> <operator>||</operator> <name><name>pRangeEnd</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_LE</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>start_constraints</name> <operator>=</operator> <name>pRangeStart</name> <operator>||</operator> <name>nEq</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Seek the index cursor to the start of the range. */</comment>
    <expr_stmt><expr><name>nConstraint</name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRangeStart</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pRangeStart</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>codeExprOrVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>nBtm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLikeOptimizationStringFixup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStartAff</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>updateRangeAffinityStr</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nBtm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>  
      <expr_stmt><expr><name>nConstraint</name> <operator>+=</operator> <name>nBtm</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>startEq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>bSeekPastNull</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bSeekPastNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>startEq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>start_constraints</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>regBignull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>start_constraints</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name> <operator>-</operator> <name>bSeekPastNull</name></expr></argument>, <argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nConstraint</name><operator>==</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The skip-scan logic inside the call to codeAllEqualityConstraints()
      ** above has already left the cursor sitting on the correct row,
      ** so no further seeking is needed */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>regBignull</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>regBignull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"NULL-scan pass ctr"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Filter</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>,
                             <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>filterPullDown</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aStartOp</name><index>[<expr><operator>(</operator><name>start_constraints</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>startEq</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>bRev</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_SEEKSCAN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>OP_SeekGE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regBignull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* TUNING:  The OP_SeekScan opcode seeks to reduce the number
        ** of expensive seek operations by replacing a single seek with
        ** 1 or more step operations.  The question is, how many steps
        ** should we try before giving up and going with a seek.  The cost
        ** of a seek is proportional to the logarithm of the of the number
        ** of entries in the tree, so basing the number of steps to try
        ** on the estimated number of rows in the btree seems like a good
        ** guess. */</comment>
        <expr_stmt><expr><name>addrSeekScan</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekScan</name></expr></argument>, 
                                         <argument><expr><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pRangeStart</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrSeekScan</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>addrSeekScan</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Last</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeekPastNull</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bStopAtNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>regBignull</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeekPastNull</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>bStopAtNull</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeekPastNull</name><operator>==</operator><operator>!</operator><name>bStopAtNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bStopAtNull</name><operator>==</operator><name>startEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aStartOp</name><index>[<expr><operator>(</operator><name>nConstraint</name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>bRev</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, 
                             <argument><expr><name>nConstraint</name><operator>-</operator><name>startEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Last</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Last</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_SeekGE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Load the value for the inequality constraint at the end of the
    ** range (if any).
    */</comment>
    <expr_stmt><expr><name>nConstraint</name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRangeEnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pRangeEnd</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>addrSeekScan</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* For a seek-scan that has a range on the lowest term of the index,
        ** we have to make the top of the loop be code that sets the end
        ** condition of the range.  Otherwise, the OP_SeekScan might jump
        ** over that initialization, leaving the range-end value set to the
        ** range-start value, resulting in a wrong answer.
        ** See ticket 5981a8c041a3c2f3 (2021-11-02).
        */</comment>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>codeExprOrVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>nTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLikeOptimizationStringFixup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zEndAff</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>updateRangeAffinityStr</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nTop</name></expr></argument>, <argument><expr><name>zEndAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>nTop</name></expr></argument>, <argument><expr><name>zEndAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nConstraint</name> <operator>+=</operator> <name>nTop</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>endEq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bStopAtNull</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>regBignull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>endEq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zStartAff</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zEndAff</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zEndAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Top of the loop body */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check if the index cursor is past the end of the range. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nConstraint</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>regBignull</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Except, skip the end-of-range check while doing the NULL-scan */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>regBignull</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"If NULL-scan 2nd pass"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aEndOp</name><index>[<expr><name>bRev</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name>endEq</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>addrSeekScan</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrSeekScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>regBignull</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* During a NULL-scan, check to see if we have reached the end of
      ** the NULLs */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeekPastNull</name><operator>==</operator><operator>!</operator><name>bStopAtNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bSeekPastNull</name><operator>+</operator><name>bStopAtNull</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nConstraint</name><operator>+</operator><name>bSeekPastNull</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regBignull</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"If NULL-scan 1st pass"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aEndOp</name><index>[<expr><name>bRev</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name>bSeekPastNull</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>,
                           <argument><expr><name>nConstraint</name><operator>+</operator><name>bSeekPastNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_EARLYOUT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekHit</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Seek the table cursor, if required */</comment>
    <expr_stmt><expr><name>omitTable</name> <operator>=</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_OR_SUBCLAUSE</name><operator>|</operator><name>WHERE_RIGHT_JOIN</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>omitTable</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pIdx is a covering index.  No need to access the main table. */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>codeDeferredSeek</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iCur</name><operator>!=</operator><name>iIdxCur</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>iRowidReg</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>,
                           <argument><expr><name>iRowidReg</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If a partial index is driving the loop, try to eliminate WHERE clause
      ** terms from the query that must be true due to the WHERE clause of
      ** the partial index.
      **
      ** 2019-11-02 ticket 623eff57e76d45f6: This optimization does not work
      ** for a LEFT JOIN.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>whereApplyPartialIndexConstraints</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The following assert() is not a requirement, merely an observation:
      ** The OR-optimization doesn't work for the right hand table of
      ** a LEFT JOIN: */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_OR_SUBCLAUSE</name><operator>|</operator><name>WHERE_RIGHT_JOIN</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Record the instruction used to terminate the loop. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bRev</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Prev</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Next</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_UNQ_WANTED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_CONSTRAINT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>omitTable</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_OR_OPTIMIZATION</name></cpp:ifndef>
  if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 5:  Two or more separately indexed terms connected by OR
    **
    ** Example:
    **
    **   CREATE TABLE t1(a,b,c,d);
    **   CREATE INDEX i1 ON t1(a);
    **   CREATE INDEX i2 ON t1(b);
    **   CREATE INDEX i3 ON t1(c);
    **
    **   SELECT * FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)
    **
    ** In the example, there are three indexed terms connected by OR.
    ** The top of the loop looks like this:
    **
    **          Null       1                # Zero the rowset in reg 1
    **
    ** Then, for each indexed term, the following. The arguments to
    ** RowSetTest are such that the rowid of the current row is inserted
    ** into the RowSet. If it is already present, control skips the
    ** Gosub opcode and jumps straight to the code generated by WhereEnd().
    **
    **        sqlite3WhereBegin(&lt;term&gt;)
    **          RowSetTest                  # Insert rowid into rowset
    **          Gosub      2 A
    **        sqlite3WhereEnd()
    **
    ** Following the above, code to terminate the loop. Label A, the target
    ** of the Gosub above, jumps to the instruction right after the Goto.
    **
    **          Null       1                # Zero the rowset in reg 1
    **          Goto       B                # The loop is finished.
    **
    **       A: &lt;loop body&gt;                 # Return data, whatever.
    **
    **          Return     2                # Jump back to the Gosub
    **
    **       B: &lt;after the loop&gt;
    **
    ** Added 2014-05-26: If the table is a WITHOUT ROWID table, then
    ** use an ephemeral index instead of a RowSet to record the primary
    ** keys of the rows we have already seen.
    **
    */</comment>
    <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pOrWc</name></decl>;</decl_stmt>    <comment type="block">/* The OR-clause broken out into subterms */</comment>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pOrTab</name></decl>;</decl_stmt>       <comment type="block">/* Shortened table list or OR-clause generation */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pCov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Potential covering index (or NULL) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCovCur</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* Cursor used for index scans (if any) */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>regReturn</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Register used with OP_Gosub */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Register for RowSet object */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                         <comment type="block">/* Register holding rowid */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iLoopBody</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><comment type="block">/* Start of loop body */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iRetInit</name></decl>;</decl_stmt>                             <comment type="block">/* Address of regReturn init */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>untestedTerms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Some terms not completely tested */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pAndExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* An ".. AND (...)" expression */</comment>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_ORINFO</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrWc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>wc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Return</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>regReturn</name></expr>;</expr_stmt>

    <comment type="block">/* Set up a new SrcList in pOrTab containing the table being scanned
    ** by this loop in the a[0] slot and all notReady tables in a[1..] slots.
    ** This becomes the SrcList in the recursive call to sqlite3WhereBegin().
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNotReady</name></decl>;</decl_stmt>                 <comment type="block">/* The number of notReady tables */</comment>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>origSrc</name></decl>;</decl_stmt>              <comment type="block">/* Original list of tables */</comment>
      <expr_stmt><expr><name>nNotReady</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name> <operator>-</operator> <name>iLevel</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOrTab</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pOrTab</name></expr></argument>)</argument_list></sizeof><operator>+</operator> <name>nNotReady</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pOrTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>notReady</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>nNotReady</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>=</operator> <name><name>pOrTab</name><operator>-&gt;</operator><name>nAlloc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pTabItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>origSrc</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;=</operator><name>nNotReady</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origSrc</name><index>[<expr><name><name>pLevel</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pOrTab</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Initialize the rowset register to contain NULL. An SQL NULL is 
    ** equivalent to an empty rowset.  Or, create an ephemeral index
    ** capable of holding primary keys in the case of a WITHOUT ROWID.
    **
    ** Also initialize regReturn to contain the address of the instruction 
    ** immediately following the OP_Return at the bottom of the loop. This
    ** is required in a few obscure LEFT JOIN cases where control jumps
    ** over the top of the loop into the body of it. In this case the 
    ** correct response for the end-of-loop code (the OP_Return) is to 
    ** fall through to the next instruction, just as an OP_Next does if
    ** called on an uninitialized cursor.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DUPLICATES_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>regRowset</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>regRowset</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iRetInit</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the original WHERE clause is z of the form:  (x1 OR x2 OR ...) AND y
    ** Then for every term xN, evaluate as the subexpression: xN AND y
    ** That way, terms in y that are factored into the disjunction will
    ** be picked up by the recursive calls to sqlite3WhereBegin() below.
    **
    ** Actually, each subexpression is converted to "xN AND w" where w is
    ** the "interesting" terms of z - terms that did not originate in the
    ** ON or USING clause of a LEFT JOIN, and terms that are usable as 
    ** indices.
    **
    ** This optimization also only applies if the (x1 OR x2 OR ...) term
    ** is not contained in the ON clause of a LEFT JOIN.
    ** See ticket http://www.sqlite.org/src/info/f2369304e4
    **
    ** 2022-02-04:  Do not push down slices of a row-value comparison.
    ** In other words, "w" or "y" may not be a slice of a vector.  Otherwise,
    ** the initialization of the right-hand operand of the vector comparison
    ** might not occur, or might occur only in an OR branch that is not
    ** taken.  dbsqlfuzz 80a9fade844b4fb43564efc972bcb2c68270f5d1.
    **
    ** 2022-03-03:  Do not push down expressions that involve subqueries.
    ** The subquery might get coded as a subroutine.  Any table-references
    ** in the subquery might be resolved to index-references for the index on
    ** the OR branch in which the subroutine is coded.  But if the subroutine
    ** is invoked from a different OR branch that uses a different index, such
    ** index-references will not work.  tag-20220303a
    ** https://sqlite.org/forum/forumpost/36937b197273d403
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>iTerm</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iTerm</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>iTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name> <operator>==</operator> <name>pTerm</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_SLICE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>|</operator><name>TERM_SLICE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>eOperator</name> <operator>&amp;</operator> <name>WO_ALL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subquery</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* tag-20220303a */</comment>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pAndExpr</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAndExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pAndExpr</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The extra 0x10000 bit on the opcode is masked off and does not
        ** become part of the new Expr.op.  However, it does make the
        ** op==TK_AND comparison inside of sqlite3PExpr() false, and this
        ** prevents sqlite3PExpr() from applying the AND short-circuit 
        ** optimization, which we do not want here. */</comment>
        <expr_stmt><expr><name>pAndExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_AND</name><operator>|</operator><literal type="number">0x10000</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pAndExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Run a separate WHERE clause for each term of the OR clause.  After
    ** eliminating duplicates from other WHERE clauses, the action for each
    ** sub-WHERE clause is to to invoke the main loop body as a subroutine.
    */</comment>
    <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"MULTI-INDEX OR"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOrTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCur</name> <operator>||</operator> <operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_AND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pSubWInfo</name></decl>;</decl_stmt>           <comment type="block">/* Info for single OR-term scan */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOrExpr</name> <init>= <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Current OR clause term */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDelete</name></decl>;</decl_stmt>                  <comment type="block">/* Local copy of OR clause term */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>jmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Address of jump operation */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTabItem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
               <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pOrExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* See TH3 vtab25.400 and ticket 614b25314c766238 */</comment>
        <expr_stmt><expr><name>pDelete</name> <operator>=</operator> <name>pOrExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pAndExpr</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pAndExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pOrExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOrExpr</name> <operator>=</operator> <name>pAndExpr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Loop through table entries that match term pOrTerm. */</comment>
        <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"INDEX %d"</literal><operator>,</operator> <name>ii</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Subplan for OR-clause:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pSubWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>, <argument><expr><name>pOrExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                      <argument><expr><name>WHERE_OR_SUBCLAUSE</name></expr></argument>, <argument><expr><name>iCovCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSubWInfo</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pSubWInfo</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pSubLoop</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>addrExplain</name> <init>= <expr><call><name>sqlite3WhereExplainOneScan</name><argument_list>(
              <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
          )</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3WhereAddScanStatus</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>addrExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* This is the sub-WHERE clause body.  First skip over
          ** duplicate rows from prior sub-WHERE clauses, and record the
          ** rowid (or PRIMARY KEY) for the current row so that the same
          ** row will be skipped in subsequent sub-WHERE clauses.
          */</comment>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DUPLICATES_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>iSet</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>ii</name><operator>==</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><operator>-</operator><literal type="number">1</literal></expr></then><else>:<expr><name>ii</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>jmp1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetTest</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                          <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>iSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>iPk</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

              <comment type="block">/* Read the PK into an array of temp registers. */</comment>
              <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <for>for<control>(<init><expr><name>iPk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPk</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>iPk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iPk</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>,<argument><expr><name>r</name><operator>+</operator><name>iPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></for>

              <comment type="block">/* Check if the temp table already contains this key. If so,
              ** the row has already been included in the result set and
              ** can be ignored (by jumping past the Gosub below). Otherwise,
              ** insert the key into the temp table and proceed with processing
              ** the row.
              **
              ** Use some of the same optimizations as OP_RowSetTest: If iSet
              ** is zero, assume that the key cannot already be present in
              ** the temp table. And if iSet is -1, assume that there is no 
              ** need to insert the key into the temp table, as it will never 
              ** be tested for.  */</comment> 
              <if_stmt><if>if<condition>( <expr><name>iSet</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>jmp1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name>iSet</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>,
                                     <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>iSet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>

              <comment type="block">/* Release the array of temp registers */</comment>
              <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Invoke the main loop body as a subroutine */</comment>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regReturn</name></expr></argument>, <argument><expr><name>iLoopBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Jump here (skipping the main loop body subroutine) if the
          ** current sub-WHERE row is a duplicate from prior sub-WHEREs. */</comment>
          <if_stmt><if>if<condition>( <expr><name>jmp1</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>jmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* The pSubWInfo-&gt;untestedTerms flag means that this OR term
          ** contained one or more AND term from a notReady table.  The
          ** terms from the notReady table could not be tested and will
          ** need to be tested later.
          */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pSubWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>untestedTerms</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* If all of the OR-connected terms are optimized using the same
          ** index, and the index is opened using the same cursor number
          ** by each call to sqlite3WhereBegin() made by this loop, it may
          ** be possible to use that index as a covering index.
          **
          ** If the call to sqlite3WhereBegin() above resulted in a scan that
          ** uses an index, and this is either the first OR-connected term
          ** processed or the index is the same as that used by all previous
          ** terms, set pCov to the candidate covering index. Otherwise, set 
          ** pCov to NULL to indicate that no candidate covering index will 
          ** be available.
          */</comment>
          <expr_stmt><expr><name>pSubLoop</name> <operator>=</operator> <name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSubLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSubLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSubLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>==</operator><name>pCov</name><operator>)</operator>
           <operator>&amp;&amp;</operator> <operator>(</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name><name>pSubLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iIdxCur</name><operator>==</operator><name>iCovCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pCov</name> <operator>=</operator> <name><name>pSubLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>pCov</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3WhereUsesDeferredSeek</name><argument_list>(<argument><expr><name>pSubWInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>bDeferredSeek</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Finish the loop through table entries that match term pOrTerm. */</comment>
          <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pSubWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name><operator>==</operator><name>pLoop</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_ABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCoveringIdx</name></name> <operator>=</operator> <name>pCov</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCov</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name>iCovCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pAndExpr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pAndExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAndExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRetInit</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLoopBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the P2 operand of the OP_Return opcode that will end the current
    ** loop to point to this spot, which is the top of the next containing
    ** loop.  The byte-code formatter will use that P2 value as a hint to
    ** indent everything in between the this point and the final OP_Return.
    ** See tag-20220407a in vdbe.c and shell.c */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Return</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>untestedTerms</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_OR_OPTIMIZATION */</comment>

  <block>{<block_content>
    <comment type="block">/* Case 6:  There is no usable index.  We must do a complete
    **          scan of the entire table.
    */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aStep</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_Next</name></expr>, <expr><name>OP_Prev</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aStart</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_Rewind</name></expr>, <expr><name>OP_Last</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bRev</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Tables marked isRecursive have only a single row that is stored in
      ** a pseudo-cursor.  No need to Rewind or Next such cursors. */</comment>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>codeCursorHint</name><argument_list>(<argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>aStep</name><index>[<expr><name>bRev</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aStart</name><index>[<expr><name>bRev</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrHalt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrVisit</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Insert code to test every subexpression that can be completely
  ** computed using the current set of tables.
  **
  ** This loop may run between one and three times, depending on the
  ** constraints to be generated. The value of stack variable iLoop
  ** determines the constraints coded by each iteration, as follows:
  **
  ** iLoop==1: Code only expressions that are entirely covered by pIdx.
  ** iLoop==2: Code remaining expressions that do not contain correlated
  **           sub-queries.  
  ** iLoop==3: Code all remaining expressions.
  **
  ** An effort is made to skip unnecessary iterations of the loop.
  */</comment>
  <expr_stmt><expr><name>iLoop</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pIdx</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Next value for iLoop */</comment>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>skipLikeAddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name><operator>==</operator><literal type="number">0</literal>
            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pE</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pE</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>,<argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* Defer processing WHERE clause constraints until after outer
          ** join processing.  tag-20220513a */</comment>
          <continue>continue;</continue>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>==</operator><name>JT_LEFT</name>
               <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>,<argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>m</name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name></expr> )</condition><block>{<block_content>
            <comment type="block">/* An ON clause that is not ripe */</comment>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iLoop</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprCoveredByIndex</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iNext</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iLoop</name><operator>&lt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VARSELECT</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iNext</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKECOND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If the TERM_LIKECOND flag is set, that means that the range search
        ** is sufficient to guarantee that the LIKE operator is true, so we
        ** can skip the call to the like(A,B) function.  But this only works
        ** for strings.  So do not skip the call to the function on the pass
        ** that compares BLOBs. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifdef>
        <continue>continue;</continue>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>u32</name></type> <name>x</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>skipLikeAddr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><name>OP_IfNot</name></expr></then><else>:<expr><name>OP_If</name></expr></else></ternary></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0xffffffff */</comment>
      <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"WhereTerm[%d] (%p) priority=%d"</literal><operator>,</operator>
                         <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><name>j</name><operator>,</operator> <name>pTerm</name><operator>,</operator> <name>iLoop</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4000</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"Coding auxiliary constraint:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereTermPrint</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>skipLikeAddr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>skipLikeAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>iLoop</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>iLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>

  <comment type="block">/* Insert code to test for implied constraints based on transitivity
  ** of the "==" operator.
  **
  ** Example: If the WHERE clause contains "t1.a=t2.b" and "t2.b=123"
  ** and we are coding the t1 loop and the t2 loop has not yet coded,
  ** then we cannot use the "t1.a=t2.b" constraint, but we can code
  ** the implied "t1.a=123" constraint.
  */</comment>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>, <decl><type ref="prev"/><name>sEAlt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pAlt</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pE</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4001 */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4001</literal><operator>)</operator><operator>==</operator><literal type="number">0x4001</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"Coding transitive constraint:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereTermPrint</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAlt</name> <operator>=</operator> <call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>,
                    <argument><expr><name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_IS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pAlt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pAlt</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pAlt</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"begin transitive constraint"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sEAlt</name> <operator>=</operator> <operator>*</operator><name><name>pAlt</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sEAlt</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEAlt</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAlt</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* For a RIGHT OUTER JOIN, record the fact that the current row has
  ** been matched at least once.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereRightJoin</name> <modifier>*</modifier></type><name>pRJ</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* pTab is the right-hand table of the RIGHT JOIN.  Generate code that
    ** will record that the current row of that table has been matched at
    ** least once.  This is accomplished by storing the PK for the row in
    ** both the iMatch index and the regBloom Bloom filter.
    */</comment>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>r</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPk</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nPk</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPk</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iPk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPk</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>iPk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iPk</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>,<argument><expr><name>r</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>iPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>jmp1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>iMatch</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"match against %s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nPk</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>iMatch</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FilterAdd</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regBloom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>jmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* For a LEFT OUTER JOIN, generate code that will record the fact that
  ** at least one row of the right table has matched the left table.  
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrFirst</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"record LEFT JOIN hit"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>code_outer_join_constraints</name>;</goto> <comment type="block">/* WHERE clause constraints */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Create a subroutine used to process all interior loops and code
    ** of the RIGHT JOIN.  During normal operation, the subroutine will
    ** be in-line with the rest of the code.  But at the end, a separate
    ** loop will run that invokes this subroutine for unmatched rows
    ** of pTab, with all tables to left begin set to NULL.
    */</comment>
    <decl_stmt><decl><type><name>WhereRightJoin</name> <modifier>*</modifier></type><name>pRJ</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BeginSubrtn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRJ</name><operator>-&gt;</operator><name>addrSubrtn</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name> <operator>&lt;</operator> <literal type="number">255</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* WHERE clause constraints must be deferred until after outer join
    ** row elimination has completed, since WHERE clause constraints apply
    ** to the results of the OUTER JOIN.  The following loop generates the
    ** appropriate WHERE clause constraint checks.  tag-20220513a.
    */</comment>
  <label><name>code_outer_join_constraints</name>:</label>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x4001 */</comment>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4000</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"All WHERE-clause terms after coding level %d:\n"</literal></expr></argument>,
                       <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereClausePrint</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"End Coding level %d:  notReady=%llx\n"</literal></expr></argument>,
       <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate the code for the loop that finds all non-matched terms
** for a RIGHT JOIN.
*/</comment>
<function><type><name>SQLITE_NOINLINE</name> <name>void</name></type> <name>sqlite3WhereRightJoinLoop</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereRightJoin</name> <modifier>*</modifier></type><name>pRJ</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pSubWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pSubWInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name></type> <name>sFrom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mAll</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"RIGHT-JOIN %s"</literal><operator>,</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeNoJumpsOutsideSubrtn</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>addrSubrtn</name></name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>endSubrtn</name></name></expr></argument>,
                                  <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>iLevel</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>mAll</name> <operator>|=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>iTabCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iIdxCur</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>iIdxCur</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iIdxCur</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mAll</name> <operator>|=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_SLICE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>!=</operator><name>WO_ROWVAL</name></expr>
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <operator>~</operator><name>mAll</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pSubWhere</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSubWhere</name></expr></argument>,
                                 <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sFrom</name><operator>.</operator><name>nSrc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sFrom</name><operator>.</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sFrom</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SrcItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sFrom</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sFrom</name></expr></argument>, <argument><expr><name>pSubWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>WHERE_RIGHT_JOIN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubWInfo</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name> <init>= <expr><call><name>sqlite3WhereContinueLabel</name><argument_list>(<argument><expr><name>pSubWInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPk</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nPk</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPk</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iPk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPk</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>iPk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iPk</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>,<argument><expr><name>r</name><operator>+</operator><name>iPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>jmp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Filter</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regBloom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>iMatch</name></name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>addrSubrtn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pSubWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pSubWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExplainQueryPlanPop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
