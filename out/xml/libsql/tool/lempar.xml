<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/tool/lempar.c"><comment type="block">/*
** 2000-05-29
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Driver template for the LEMON parser generator.
**
** The "lemon" program processes an LALR(1) input grammar file, then uses
** this template to construct a parser.  The "lemon" program inserts text
** at each "%%" line.  Also, any "P-a-r-s-e" identifer prefix (without the
** interstitial "-" characters) contained in this template is changed into
** the value of the %name directive from the grammar.  Otherwise, the content
** of this template is copied straight through into the generate parser
** source file.
**
** The following is the concatenation of all %include directives from the
** input grammar file:
*/</comment>
<comment type="block" format="doxygen">/************ Begin %include sections from the grammar ************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/**************** End of %include directives **********************************/</comment>
<comment type="block">/* These constants specify the various numeric values for terminal symbols.
***************** Begin token definitions *************************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/**************** End token definitions ***************************************/</comment>

<comment type="block">/* The next sections is a series of control #defines.
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used to store the integer codes
**                       that represent terminal and non-terminal symbols.
**                       "unsigned char" is used if there are fewer than
**                       256 symbols.  Larger types otherwise.
**    YYNOCODE           is a number of type YYCODETYPE that is not used for
**                       any terminal or nonterminal symbol.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       (also known as: "terminal symbols") have fall-back
**                       values which should be used if the original symbol
**                       would not parse.  This permits keywords to sometimes
**                       be used as identifiers, for example.
**    YYACTIONTYPE       is the data type used for "action codes" - numbers
**                       that indicate what to do in response to the next
**                       token.
**    ParseTOKENTYPE     is the data type used for minor type for terminal
**                       symbols.  Background: A "minor type" is a semantic
**                       value associated with a terminal or non-terminal
**                       symbols.  For example, for an "ID" terminal symbol,
**                       the minor type might be the name of the identifier.
**                       Each non-terminal can have a different minor type.
**                       Terminal symbols all have the same minor type, though.
**                       This macros defines the minor type for terminal 
**                       symbols.
**    YYMINORTYPE        is the data type used for all minor types.
**                       This is typically a union of many types, one of
**                       which is ParseTOKENTYPE.  The entry in the union
**                       for terminal symbols is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    ParseARG_SDECL     A static variable declaration for the %extra_argument
**    ParseARG_PDECL     A parameter declaration for the %extra_argument
**    ParseARG_PARAM     Code to pass %extra_argument as a subroutine parameter
**    ParseARG_STORE     Code to store %extra_argument into yypParser
**    ParseARG_FETCH     Code to extract %extra_argument from yypParser
**    ParseCTX_*         As ParseARG_ except for %extra_context
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYNTOKEN           Number of terminal symbols
**    YY_MAX_SHIFT       Maximum value for shift actions
**    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
**    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
**    YY_ERROR_ACTION    The yy_action[] code for syntax error
**    YY_ACCEPT_ACTION   The yy_action[] code for accept
**    YY_NO_ACTION       The yy_action[] code for no-op
**    YY_MIN_REDUCE      Minimum value for reduce actions
**    YY_MAX_REDUCE      Maximum value for reduce actions
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INTERFACE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INTERFACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block" format="doxygen">/************* Begin control #defines *****************************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/************* End control #defines *******************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NLOOKAHEAD</name></cpp:macro> <cpp:value>((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))</cpp:value></cpp:define>

<comment type="block">/* Define the yytestcase() macro to be a no-op if is not already defined
** otherwise.
**
** Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yytestcase</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>yytestcase</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 &lt;= N &lt;= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
**     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
**
**   N == YY_ERROR_ACTION               A syntax error has occurred.
**
**   N == YY_ACCEPT_ACTION              The parser accepts its input.
**
**   N == YY_NO_ACTION                  No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
**   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
**     and YY_MAX_REDUCE
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as either:
**
**    (A)   N = yy_action[ yy_shift_ofst[S] + X ]
**    (B)   N = yy_default[S]
**
** The (A) formula is preferred.  The B formula is used instead if
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X.
**
** The formulas above are for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
**
*********** Begin parsing tables **********************************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/********** End of lemon-generated parsing tables *****************************/</comment>

<comment type="block">/* The next table maps tokens (terminal symbols) into fallback tokens.  
** If a construct like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
**
** This feature can be used, for example, to cause some keywords in a language
** to revert to identifiers if they keyword does not apply in the context where
** it appears.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
<specifier>static</specifier> <specifier>const</specifier> <name>YYCODETYPE</name> <name><name>yyFallback</name><index>[]</index></name> <operator>=</operator> <block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYFALLBACK */</comment>

<comment type="block">/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
**
** After the "shift" half of a SHIFTREDUCE action, the stateno field
** actually contains the reduce action for the second half of the
** SHIFTREDUCE.
*/</comment>
<struct>struct <name>yyStackEntry</name> <block>{
  <decl_stmt><decl><type><name>YYACTIONTYPE</name></type> <name>stateno</name></decl>;</decl_stmt>  <comment type="block">/* The state-number, or reduce action in SHIFTREDUCE */</comment>
  <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>major</name></decl>;</decl_stmt>      <comment type="block">/* The major token value.  This is the code
                         ** number for the token at this stack level */</comment>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>minor</name></decl>;</decl_stmt>     <comment type="block">/* The user-supplied minor token value.  This
                         ** is the value of the token  */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>yyStackEntry</name></name></type> <name>yyStackEntry</name>;</typedef>

<comment type="block">/* The state of the parser is completely contained in an instance of
** the following structure */</comment>
<struct>struct <name>yyParser</name> <block>{
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name></decl>;</decl_stmt>          <comment type="block">/* Pointer to top element of the stack */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyhwm</name></decl>;</decl_stmt>                    <comment type="block">/* High-water mark of the stack */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyerrcnt</name></decl>;</decl_stmt>                 <comment type="block">/* Shifts left before out of the error */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>ParseARG_SDECL</name>                <comment type="block">/* A place to hold %extra_argument */</comment>
  <name>ParseCTX_SDECL</name>                <comment type="block">/* A place to hold %extra_context */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <name>int</name></type> <name>yystksz</name></decl>;</decl_stmt>                  <comment type="block">/* Current side of the stack */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yystack</name></decl>;</decl_stmt>        <comment type="block">/* The parser's stack */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name></type> <name>yystk0</name></decl>;</decl_stmt>          <comment type="block">/* First stack entry */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>yyStackEntry</name></type> <name><name>yystack</name><index>[<expr><name>YYSTACKDEPTH</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* The parser's stack */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yystackEnd</name></decl>;</decl_stmt>            <comment type="block">/* Last entry in the stack */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>yyParser</name></name></type> <name>yyParser</name>;</typedef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>yyTraceFILE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>yyTracePrompt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* 
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL 
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt; A FILE* to which trace output should be written.
**      If NULL, then tracing is turned off.
** &lt;li&gt; A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** &lt;/ul&gt;
**
** Outputs:
** None.
*/</comment>
<function><type><name>void</name></type> <name>ParseTrace</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>TraceFILE</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zTracePrompt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>yyTraceFILE</name> <operator>=</operator> <name>TraceFILE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyTracePrompt</name> <operator>=</operator> <name>zTracePrompt</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyTracePrompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if<condition>( <expr><name>yyTracePrompt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyTraceFILE</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYCOVERAGE</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yyTokenName</name><index>[]</index></name> <init>= <expr><block>{ 
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(YYCOVERAGE) || !defined(NDEBUG) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* For tracing reduce actions, the names of all rules are required.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yyRuleName</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Try to increase the size of the parser stack.  Return the number
** of errors.  Return 0 on success.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yyGrowStack</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>newSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>newSize</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>yytos</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>yytos</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>yystack</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name><operator>==</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>yystk0</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>newSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>yystk0</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>, <argument><expr><name>newSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yytos</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack grows from %d to %d entries.\n"</literal></expr></argument>,
              <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Datatype of the argument to the memory allocated passed as the
** second argument to ParseAlloc() below.  This can be changed by
** putting an appropriate #define in the %include section of the input
** grammar.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYMALLOCARGTYPE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYMALLOCARGTYPE</name></cpp:macro> <cpp:value>size_t</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Initialize a new parser that has already been allocated.
*/</comment>
<function><type><name>void</name></type> <name>ParseInit</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>yypRawParser</name></type> <name>ParseCTX_PDECL</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>yypRawParser</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ParseCTX_STORE</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystk0</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stateno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>major</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystackEnd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>YYSTACKDEPTH</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Parse_ENGINEALWAYSONSTACK</name></cpp:ifndef>
<comment type="block">/* 
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to Parse and ParseFree.
*/</comment>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ParseAlloc</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><operator>(</operator><operator>*</operator><name>mallocProc</name><operator>)</operator><operator>(</operator><name>YYMALLOCARGTYPE</name><operator>)</operator> <name>ParseCTX_PDECL</name></expr></argument>)</argument_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>yypParser</name> <operator>=</operator> <operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><call>(<modifier>*</modifier><name>mallocProc</name>)<argument_list>( <argument><expr><operator>(</operator><name>YYMALLOCARGTYPE</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyParser</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>yypParser</name></expr> )</condition><block>{<block_content>
    <function_decl><type><name>ParseCTX_STORE</name></type>
    <name>ParseInit</name><parameter_list>(<parameter><decl><type><name>yypParser</name></type> <name>ParseCTX_PARAM</name></decl></parameter>)</parameter_list>;</function_decl>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>yypParser</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Parse_ENGINEALWAYSONSTACK */</comment>


<comment type="block">/* The following function deletes the "minor type" or semantic value
** associated with a symbol.  The symbol can be either a terminal
** or nonterminal. "yymajor" is the symbol code, and "yypminor" is
** a pointer to the value to be deleted.  The code used to do the 
** deletions is derived from the %destructor and/or %token_destructor
** directives of the input grammar.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_destructor</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,    <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>yymajor</name></decl></parameter>,     <comment type="block">/* Type code for object to destroy */</comment>
  <parameter><decl><type><name>YYMINORTYPE</name> <modifier>*</modifier></type><name>yypminor</name></decl></parameter>   <comment type="block">/* The object to be destroyed */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name>
  <name>ParseCTX_FETCH</name></expr></expr_stmt>
  <switch>switch<condition>( <expr><name>yymajor</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are *not* used
    ** inside the C code.
    */</comment>
<comment type="block" format="doxygen">/********* Begin destructor definitions ***************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator></expr></expr_stmt>
<comment type="block" format="doxygen">/********* End destructor definitions *****************************************/</comment>
    <default>default:</default>  <break>break;</break>   <comment type="block">/* If no destructor action specified: do nothing */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_pop_parser_stack</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>&gt;</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yytos</name> <operator>=</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sPopping %s\n"</literal></expr></argument>,
      <argument><expr><name>yyTracePrompt</name></expr></argument>,
      <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>, <argument><expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yytos</name><operator>-&gt;</operator><name>minor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear all secondary memory allocations from the parser
*/</comment>
<function><type><name>void</name></type> <name>ParseFinalize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>pParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;</operator><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name><operator>!=</operator><operator>&amp;</operator><name><name>pParser</name><operator>-&gt;</operator><name>yystk0</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Parse_ENGINEALWAYSONSTACK</name></cpp:ifndef>
<comment type="block">/* 
** Deallocate and destroy a parser.  Destructors are called for
** all stack elements before shutting the parser down.
**
** If the YYPARSEFREENEVERNULL macro exists (for example because it
** is defined in a %include section of the input grammar) then it is
** assumed that the input pointer is never NULL.
*/</comment>
<function><type><name>void</name></type> <name>ParseFree</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                    <comment type="block">/* The parser to be deleted */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>freeProc</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>     <comment type="block">/* Function used to reclaim memory */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYPARSEFREENEVERNULL</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>ParseFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call>(<modifier>*</modifier><name>freeProc</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Parse_ENGINEALWAYSONSTACK */</comment>

<comment type="block">/*
** Return the peak depth of the stack for a parser.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
<function><type><name>int</name></type> <name>ParseStackPeak</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pParser</name><operator>-&gt;</operator><name>yyhwm</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This array of booleans keeps track of the parser statement
** coverage.  The element yycoverage[X][Y] is set when the parser
** is in state X and has a lookahead token Y.  In a well-tested
** systems, every element of this matrix should end up being set.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYCOVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>yycoverage</name><index>[<expr><name>YYNSTATE</name></expr>]</index><index>[<expr><name>YYNTOKEN</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write into out a description of every state/lookahead combination that
**
**   (1)  has not been used by the parser, and
**   (2)  is not a syntax error.
**
** Return the number of missed state/lookahead combinations.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYCOVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type> <name>ParseCoverage</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>stateno</name></decl>, <decl><type ref="prev"/><name>iLookAhead</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMissed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>stateno</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>stateno</name><operator>&lt;</operator><name>YYNSTATE</name></expr>;</condition> <incr><expr><name>stateno</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>yy_shift_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iLookAhead</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLookAhead</name><operator>&lt;</operator><name>YYNTOKEN</name></expr>;</condition> <incr><expr><name>iLookAhead</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>yy_lookahead</name><index>[<expr><name>i</name><operator>+</operator><name>iLookAhead</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>yycoverage</name><index>[<expr><name>stateno</name></expr>]</index><index>[<expr><name>iLookAhead</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMissed</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>out</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"State %d lookahead %s %s\n"</literal></expr></argument>, <argument><expr><name>stateno</name></expr></argument>,
                <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>yycoverage</name><index>[<expr><name>stateno</name></expr>]</index><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"missed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <return>return <expr><name>nMissed</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
*/</comment>
<function><type><specifier>static</specifier> <name>YYACTIONTYPE</name></type> <name>yy_find_shift_action</name><parameter_list>(
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>iLookAhead</name></decl></parameter>,    <comment type="block">/* The look-ahead token */</comment>
  <parameter><decl><type><name>YYACTIONTYPE</name></type> <name>stateno</name></decl></parameter>      <comment type="block">/* Current state number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>stateno</name><operator>&gt;</operator><name>YY_MAX_SHIFT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>stateno</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>stateno</name> <operator>&lt;=</operator> <name>YY_SHIFT_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYCOVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>yycoverage</name><index>[<expr><name>stateno</name></expr>]</index><index>[<expr><name>iLookAhead</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>yy_shift_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;=</operator><name>YY_ACTTAB_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>+</operator><name>YYNTOKEN</name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><name>YY_NLOOKAHEAD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>!=</operator><name>YYNOCODE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name> <operator>&lt;</operator> <name>YYNTOKEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>iLookAhead</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>YY_NLOOKAHEAD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
      <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>iFallback</name></decl>;</decl_stmt>            <comment type="block">/* Fallback token */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyFallback</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyFallback</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFallback</name> <operator>=</operator> <name><name>yyFallback</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iFallback</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sFALLBACK %s =&gt; %s\n"</literal></expr></argument>,
             <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iFallback</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yyFallback</name><index>[<expr><name>iFallback</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Fallback loop must terminate */</comment>
        <expr_stmt><expr><name>iLookAhead</name> <operator>=</operator> <name>iFallback</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYWILDCARD</name></cpp:ifdef>
      <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>-</operator> <name>iLookAhead</name> <operator>+</operator> <name>YYWILDCARD</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yy_lookahead</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yy_lookahead</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>yy_lookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name>YYWILDCARD</name> <operator>&amp;&amp;</operator> <name>iLookAhead</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sWILDCARD %s =&gt; %s\n"</literal></expr></argument>,
               <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>,
               <argument><expr><name><name>yyTokenName</name><index>[<expr><name>YYWILDCARD</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>
          <return>return <expr><name><name>yy_action</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYWILDCARD */</comment>
      <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yy_action</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yy_action</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name><name>yy_action</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
*/</comment>
<function><type><specifier>static</specifier> <name>YYACTIONTYPE</name></type> <name>yy_find_reduce_action</name><parameter_list>(
  <parameter><decl><type><name>YYACTIONTYPE</name></type> <name>stateno</name></decl></parameter>,     <comment type="block">/* Current state number */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>iLookAhead</name></decl></parameter>     <comment type="block">/* The look-ahead token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>stateno</name><operator>&gt;</operator><name>YY_REDUCE_COUNT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>stateno</name><operator>&lt;=</operator><name>YY_REDUCE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>yy_reduce_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>!=</operator><name>YYNOCODE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>iLookAhead</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>&gt;=</operator><name>YY_ACTTAB_COUNT</name> <operator>||</operator> <name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>YY_ACTTAB_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>iLookAhead</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>yy_action</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following routine is called if the stack overflows.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyStackOverflow</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>)</parameter_list><block>{<block_content>
   <expr_stmt><expr><name>ParseARG_FETCH</name>
   <name>ParseCTX_FETCH</name></expr></expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
   <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack Overflow!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   <while>while<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
   <comment type="block">/* Here code is inserted which will execute if the parser
   ** stack every overflows */</comment>
<comment type="block" format="doxygen">/******** Begin %stack_overflow code ******************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/******** End %stack_overflow code ********************************************/</comment>
   <name>ParseARG_STORE</name> <comment type="block">/* Suppress warning about unused %extra_argument var */</comment>
   <name>ParseCTX_STORE</name></expr></expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Print tracing information for a SHIFT action
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyTraceShift</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yyNewState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>yyNewState</name><operator>&lt;</operator><name>YYNSTATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%s%s '%s', go to state %d\n"</literal></expr></argument>,
         <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name>zTag</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>]</index></name></expr></argument>,
         <argument><expr><name>yyNewState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%s%s '%s', pending reduce %d\n"</literal></expr></argument>,
         <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name>zTag</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>]</index></name></expr></argument>,
         <argument><expr><name>yyNewState</name> <operator>-</operator> <name>YY_MIN_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>yyTraceShift</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>,<parameter><type><name>Z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Perform a shift action.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_shift</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,          <comment type="block">/* The parser to be shifted */</comment>
  <parameter><decl><type><name>YYACTIONTYPE</name></type> <name>yyNewState</name></decl></parameter>,      <comment type="block">/* The new state to shift in */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>yyMajor</name></decl></parameter>,           <comment type="block">/* The major token to shift in */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name></type> <name>yyMinor</name></decl></parameter>        <comment type="block">/* The minor token to shift in */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>-</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name><operator>)</operator><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>-</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> 
  <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystackEnd</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;=</operator><operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>yyNewState</name> <operator>&gt;</operator> <name>YY_MAX_SHIFT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>yyNewState</name> <operator>+=</operator> <name>YY_MIN_REDUCE</name> <operator>-</operator> <name>YY_MIN_SHIFTREDUCE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>yytos</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name> <operator>=</operator> <name>yyNewState</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <name>yyMajor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>minor</name><operator>.</operator><name>yy0</name></name> <operator>=</operator> <name>yyMinor</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>yyTraceShift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><name>yyNewState</name></expr></argument>, <argument><expr><literal type="string">"Shift"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
** of that rule */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>YYCODETYPE</name></type> <name><name>yyRuleInfoLhs</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* For rule J, yyRuleInfoNRhs[J] contains the negative of the number
** of symbols on the right-hand side of that rule. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>signed</name> <name>char</name></type> <name><name>yyRuleInfoNRhs</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_accept</name><parameter_list>(<parameter><decl><type><name>yyParser</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* Forward Declaration */</comment>

<comment type="block">/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
**
** The yyLookahead and yyLookaheadToken parameters provide reduce actions
** access to the lookahead token (if any).  The yyLookahead will be YYNOCODE
** if the lookahead token has already been consumed.  As this procedure is
** only called from one place, optimizing compilers will in-line it, which
** means that the extra parameters have no performance impact.
*/</comment>
<function><type><specifier>static</specifier> <name>YYACTIONTYPE</name></type> <name>yy_reduce</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,         <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>yyruleno</name></decl></parameter>,       <comment type="block">/* Number of the rule by which to reduce */</comment>
  <parameter><decl><type><name>int</name></type> <name>yyLookahead</name></decl></parameter>,             <comment type="block">/* Lookahead token, or YYNOCODE if none */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name> <name>yyLookaheadToken</name></type>  <comment type="block">/* Value of the lookahead token */</comment>
  <name>ParseCTX_PDECL</name></decl></parameter>                   <comment type="block">/* %extra_context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>yygoto</name></decl>;</decl_stmt>                     <comment type="block">/* The next state */</comment>
  <decl_stmt><decl><type><name>YYACTIONTYPE</name></type> <name>yyact</name></decl>;</decl_stmt>             <comment type="block">/* The next action */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yymsp</name></decl>;</decl_stmt>            <comment type="block">/* The top of the parser's stack */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yysize</name></decl>;</decl_stmt>                     <comment type="block">/* Amount to pop the stack */</comment>
  <macro><name>ParseARG_FETCH</name>
  <argument_list>(<argument>void</argument>)</argument_list></macro><expr_stmt><expr><name>yyLookahead</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>yyLookaheadToken</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yymsp</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>yyruleno</name></expr> )</condition><block>{<block_content>
  <comment type="block">/* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line &lt;lineno&gt; &lt;grammarfile&gt;
  **     { ... }           // User supplied code
  **  #line &lt;lineno&gt; &lt;thisfile&gt;
  **     break;
  */</comment>
<comment type="block" format="doxygen">/********** Begin reduce actions **********************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator></expr></expr_stmt>
<comment type="block" format="doxygen">/********** End reduce actions ************************************************/</comment>
  </block_content>}</block></switch><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyruleno</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyRuleInfoLhs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyRuleInfoLhs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yygoto</name> <operator>=</operator> <name><name>yyRuleInfoLhs</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name><name>yyRuleInfoNRhs</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_reduce_action</name><argument_list>(<argument><expr><name><name>yymsp</name><index>[<expr><name>yysize</name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yygoto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There are no SHIFTREDUCE actions on nonterminals because the table
  ** generator has simplified them to pure REDUCE actions. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name>yyact</name><operator>&gt;</operator><name>YY_MAX_SHIFT</name> <operator>&amp;&amp;</operator> <name>yyact</name><operator>&lt;=</operator><name>YY_MAX_SHIFTREDUCE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is not possible for a REDUCE to be followed by an error */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name><operator>!=</operator><name>YY_ERROR_ACTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>yymsp</name> <operator>+=</operator> <name>yysize</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>=</operator> <name>yymsp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>stateno</name></name> <operator>=</operator> <operator>(</operator><name>YYACTIONTYPE</name><operator>)</operator><name>yyact</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yygoto</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>yyTraceShift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><name>yyact</name></expr></argument>, <argument><expr><literal type="string">"... then shift"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>yyact</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following code executes when the parse fails
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_parse_failed</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>           <comment type="block">/* The parser */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name>
  <name>ParseCTX_FETCH</name></expr></expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sFail!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <comment type="block">/* Here code is inserted which will be executed whenever the
  ** parser fails */</comment>
<comment type="block" format="doxygen">/************ Begin %parse_failure code ***************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/************ End %parse_failure code *****************************************/</comment>
  <name>ParseARG_STORE</name> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
  <name>ParseCTX_STORE</name></expr></expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYNOERRORRECOVERY */</comment>

<comment type="block">/*
** The following code executes when a syntax error first occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_syntax_error</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,           <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yymajor</name></decl></parameter>,                   <comment type="block">/* The major type of the error token */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name></type> <name>yyminor</name></decl></parameter>         <comment type="block">/* The minor type of the error token */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name>
  <name>ParseCTX_FETCH</name>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN</name></cpp:macro> <cpp:value>yyminor</cpp:value></cpp:define>
<comment type="block" format="doxygen">/************ Begin %syntax_error code ****************************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/************ End %syntax_error code ******************************************/</comment>
  <name>ParseARG_STORE</name> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
  <name>ParseCTX_STORE</name></expr></expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following is executed when the parser accepts
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_accept</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>           <comment type="block">/* The parser */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name>
  <name>ParseCTX_FETCH</name></expr></expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sAccept!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>==</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Here code is inserted which will be executed whenever the
  ** parser accepts */</comment>
<comment type="block" format="doxygen">/*********** Begin %parse_accept code *****************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/*********** End %parse_accept code *******************************************/</comment>
  <name>ParseARG_STORE</name> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
  <name>ParseCTX_STORE</name></expr></expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "ParseAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt; A pointer to the parser (an opaque structure.)
** &lt;li&gt; The major token number.
** &lt;li&gt; The minor token number.
** &lt;li&gt; An option argument of a grammar-specified type.
** &lt;/ul&gt;
**
** Outputs:
** None.
*/</comment>
<function><type><name>void</name></type> <name>Parse</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>yyp</name></decl></parameter>,                   <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yymajor</name></decl></parameter>,                 <comment type="block">/* The major token code number */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name> <name>yyminor</name></type>       <comment type="block">/* The value for the token */</comment>
  <name>ParseARG_PDECL</name></decl></parameter>               <comment type="block">/* Optional %extra_argument parameter */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>yyminorunion</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>YYACTIONTYPE</name></type> <name>yyact</name></decl>;</decl_stmt>   <comment type="block">/* The parser action. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>yyendofinput</name></decl>;</decl_stmt>     <comment type="block">/* True if we are at the end of input */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyerrorhit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* True if yymajor has invoked an error */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>yyp</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The parser */</comment>
  <decl_stmt><decl><type><name>ParseCTX_FETCH</name>
  <name>ParseARG_STORE</name></type>

  <name>assert</name><argument_list>( <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>yyendofinput</name> <operator>=</operator> <operator>(</operator><name>yymajor</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>yyact</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>yyact</name> <operator>&lt;</operator> <name>YY_MIN_REDUCE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sInput '%s' in state %d\n"</literal></expr></argument>,
              <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sInput '%s' with pending reduce %d\n"</literal></expr></argument>,
              <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>,<argument><expr><name>yyact</name><operator>-</operator><name>YY_MIN_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content> <comment type="block">/* Exit by "break" */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name><operator>==</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_shift_action</name><argument_list>(<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>yyact</name> <operator>&gt;=</operator> <name>YY_MIN_REDUCE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>yyruleno</name> <init>= <expr><name>yyact</name> <operator>-</operator> <name>YY_MIN_REDUCE</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Reduce by this rule */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyruleno</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyRuleName</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyRuleName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>yysize</name> <init>= <expr><name><name>yyRuleInfoNRhs</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>yysize</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sReduce %d [%s]%s, pop back to state %d.\n"</literal></expr></argument>,
            <argument><expr><name>yyTracePrompt</name></expr></argument>,
            <argument><expr><name>yyruleno</name></expr></argument>, <argument><expr><name><name>yyRuleName</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>yyruleno</name><operator>&lt;</operator><name>YYNRULE_WITH_ACTION</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" without external action"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><index>[<expr><name>yysize</name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sReduce %d [%s]%s.\n"</literal></expr></argument>,
            <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name>yyruleno</name></expr></argument>, <argument><expr><name><name>yyRuleName</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>yyruleno</name><operator>&lt;</operator><name>YYNRULE_WITH_ACTION</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" without external action"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

      <comment type="block">/* Check that the stack is large enough to grow by a single entry
      ** if the RHS of the rule is empty.  This ensures that there is room
      ** enough on the stack to push the LHS value */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>yyRuleInfoNRhs</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>-</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name><operator>)</operator><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyhwm</name></name> <operator>==</operator>
                  <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>-</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> 
        <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystackEnd</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>&gt;=</operator><operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>yyact</name> <operator>=</operator> <macro><name>yy_reduce</name><argument_list>(<argument>yypParser</argument>,<argument>yyruleno</argument>,<argument>yymajor</argument>,<argument>yyminor ParseCTX_PARAM</argument>)</argument_list></macro></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>yyact</name> <operator>&lt;=</operator> <name>YY_MAX_SHIFTREDUCE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>yyact</name><operator>==</operator><name>YY_ACCEPT_ACTION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_accept</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name> <operator>==</operator> <name>YY_ERROR_ACTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yyminorunion</name><operator>.</operator><name>yy0</name></name> <operator>=</operator> <name>yyminor</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
      <decl_stmt><decl><type><name>int</name></type> <name>yymx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sSyntax Error!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
      <comment type="block">/* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>yymx</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>yymx</name><operator>==</operator><name>YYERRORSYMBOL</name> <operator>||</operator> <name>yyerrorhit</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sDiscard input token %s\n"</literal></expr></argument>,
             <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <while>while<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>&gt;</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_reduce_action</name><argument_list>(<argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name></expr></argument>,
                                        <argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>yyact</name><operator>&lt;=</operator><name>YY_MAX_SHIFTREDUCE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name> <operator>&lt;=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>||</operator> <name>yymajor</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>yy_parse_failed</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
          <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>yymx</name><operator>!=</operator><name>YYERRORSYMBOL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><name>YYERRORSYMBOL</name></expr></argument>,<argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>yyerrorhit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>yymajor</name><operator>==</operator><name>YYNOCODE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>yyact</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <comment type="block">/* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ** do any kind of error recovery.  Instead, simply invoke the syntax
      ** error routine and continue going as if nothing had happened.
      **
      ** Applications can set this macro (for example inside %include) if
      ** they intend to abandon the parse upon the first syntax error seen.
      */</comment>
      <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>, <argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* YYERRORSYMBOL is not defined */</comment>
      <comment type="block">/* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>, <argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>yyendofinput</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>yy_parse_failed</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
        <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>cDiv</name> <init>= <expr><literal type="char">'['</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sReturn. Stack="</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yytos</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%c%s"</literal></expr></argument>, <argument><expr><name>cDiv</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>i</name><operator>-&gt;</operator><name>major</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cDiv</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the fallback token corresponding to canonical token iToken, or
** 0 if iToken has no fallback.
*/</comment>
<function><type><name>int</name></type> <name>ParseFallback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iToken</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iToken</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyFallback</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyFallback</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>yyFallback</name><index>[<expr><name>iToken</name></expr>]</index></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iToken</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
