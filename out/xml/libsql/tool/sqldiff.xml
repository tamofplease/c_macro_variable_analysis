<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/tool/sqldiff.c"><comment type="block">/*
** 2015-04-06
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This is a utility program that computes the differences in content
** between two SQLite databases.
**
** To compile, simply link against SQLite.
**
** See the showHelp() routine below for a brief description of how to
** run the utility.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>

<comment type="block">/*
** All global variables are gathered into the "g" singleton.
*/</comment>
<struct>struct <name>GlobalVars</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArgv0</name></decl>;</decl_stmt>       <comment type="block">/* Name of program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSchemaOnly</name></decl>;</decl_stmt>          <comment type="block">/* Only show schema differences */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSchemaPK</name></decl>;</decl_stmt>            <comment type="block">/* Use the schema-defined PK, not the true PK */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHandleVtab</name></decl>;</decl_stmt>          <comment type="block">/* Handle fts3, fts4, fts5 and rtree vtabs */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>fDebug</name></decl>;</decl_stmt>          <comment type="block">/* Debug flags */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSchemaCompare</name></decl>;</decl_stmt>       <comment type="block">/* Doing single-table sqlite_schema compare */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>              <comment type="block">/* The database connection */</comment>
}</block> <decl><name>g</name></decl>;</struct>

<comment type="block">/*
** Allowed values for g.fDebug
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_COLUMN_NAMES</name></cpp:macro>  <cpp:value>0x000001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DIFF_SQL</name></cpp:macro>      <cpp:value>0x000002</cpp:value></cpp:define>

<comment type="block">/*
** Dynamic string object
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>Str</name></name></type> <name>Str</name>;</typedef>
<struct>struct <name>Str</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>        <comment type="block">/* Text of the string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>     <comment type="block">/* Bytes allocated in z[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nUsed</name></decl>;</decl_stmt>      <comment type="block">/* Bytes actually used in z[] */</comment>
}</block>;</struct>

<comment type="block">/*
** Initialize a Str object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>strInit</name><parameter_list>(<parameter><decl><type><name>Str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
  
<comment type="block">/*
** Print an error resulting from faulting command-line arguments and
** abort the program.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmdlineError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n\"%s --help\" for more help\n"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Print an error message for an error that occurs at runtime, then
** abort the program.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>runtimeError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free all memory held by a Str object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>strFree</name><parameter_list>(<parameter><decl><type><name>Str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add formatted text to the end of a Str object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>strPrintf</name><parameter_list>(<parameter><decl><type><name>Str</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_vsnprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nNew</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><name>nNew</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+=</operator> <name>nNew</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block">/* Safely quote an SQL identifier.  Use the minimum amount of transformation
** necessary to allow the string to be used with %s.
**
** Space to hold the returned string is obtained from sqlite3_malloc().  The
** caller is responsible for ensuring this space is freed when no longer
** needed.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>safeId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"\""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>x</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>x</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>x</name> <operator>||</operator> <operator>!</operator><call><name>sqlite3_keyword_check</name><argument_list>(<argument><expr><name>zId</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Prepare a new SQL statement.  Print an error and abort if anything
** goes wrong.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>db_vprepare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"SQL statement error: %s\n\"%s\""</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>db_prepare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_vprepare</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a list of strings
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>namelistFree</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>az</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>az</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a list of column names [a] for the table zDb.zTab.  Space to
** hold the list is obtained from sqlite3_malloc() and should released
** using namelistFree() when no longer needed.
**
** Primary key columns are listed first, followed by data columns.
** The number of columns in the primary key is returned in *pnPkey.
**
** Normally [a], the "primary key" in the previous sentence is the true
** primary key - the rowid or INTEGER PRIMARY KEY for ordinary tables
** or the declared PRIMARY KEY for WITHOUT ROWID tables.  However, if
** the g.bSchemaPK flag is set, then the schema-defined PRIMARY KEY is
** used in all cases.  In that case, entries that have NULL values in
** any of their primary key fields will be excluded from the analysis.
**
** If the primary key for a table is the rowid but rowid is inaccessible,
** then this routine returns a NULL pointer.
**
** [a. If the lone, named table is "sqlite_schema", "rootpage" column is
**  omitted and the "type" and "name" columns are made to be the PK.]
**
** Examples:
**    CREATE TABLE t1(a INT UNIQUE, b INTEGER, c TEXT, PRIMARY KEY(c));
**    *pnPKey = 1;
**    az = { "rowid", "a", "b", "c", 0 }  // Normal case
**    az = { "c", "a", "b", 0 }           // g.bSchemaPK==1
**
**    CREATE TABLE t2(a INT UNIQUE, b INTEGER, c TEXT, PRIMARY KEY(b));
**    *pnPKey = 1;
**    az = { "b", "a", "c", 0 }
**
**    CREATE TABLE t3(x,y,z,PRIMARY KEY(y,z));
**    *pnPKey = 1                         // Normal case
**    az = { "rowid", "x", "y", "z", 0 }  // Normal case
**    *pnPKey = 2                         // g.bSchemaPK==1
**    az = { "y", "x", "z", 0 }           // g.bSchemaPK==1
**
**    CREATE TABLE t4(x,y,z,PRIMARY KEY(y,z)) WITHOUT ROWID;
**    *pnPKey = 2
**    az = { "y", "z", "x", 0 }
**
**    CREATE TABLE t5(rowid,_rowid_,oid);
**    az = 0     // The rowid is not accessible
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnNames</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Database ("main" or "aux") to query */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Name of table to return details of */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPKey</name></decl></parameter>,                    <comment type="block">/* OUT: Number of PK columns */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbRowid</name></decl></parameter>                    <comment type="block">/* OUT: True if PK is an implicit rowid */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* List of column names to be returned */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>naz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Number of entries in az[] */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>     <comment type="block">/* SQL statement being run */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPkIdxName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Name of the PRIMARY KEY index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>truePk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* PRAGMA table_info indentifies the PK to use */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Number of PRIMARY KEY columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                <comment type="block">/* Loop counters */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bSchemaPK</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Normal case:  Figure out what the true primary key is for the table.
    **   *  For WITHOUT ROWID tables, the true primary key is the same as
    **      the schema PRIMARY KEY, which is guaranteed to be present.
    **   *  For rowid tables with an INTEGER PRIMARY KEY, the true primary
    **      key is the INTEGER PRIMARY KEY.
    **   *  For all other rowid tables, the rowid is the true primary key.
    */</comment>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %s.index_list=%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="string">"pk"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zPkIdxName</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPkIdxName</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>truePk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %s.index_xinfo=%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPkIdxName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>nKey</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>truePk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>==</operator><name>nKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>truePk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>truePk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nPK</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPkIdxName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>truePk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %s.table_info=%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The g.bSchemaPK==1 case:  Use whatever primary key is declared
    ** in the schema.  The "rowid" will still be used as the primary key
    ** if the table definition does not contain a PRIMARY KEY.
    */</comment>
    <expr_stmt><expr><name>nPK</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %s.table_info=%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nPK</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nPK</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>truePk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="string">"sqlite_schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
            <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="string">"sqlite_master"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* For sqlite_schema, will use type and name as the PK. */</comment>
    <expr_stmt><expr><name>nPK</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>truePk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnPKey</name> <operator>=</operator> <name>nPK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>naz</name> <operator>=</operator> <name>nPK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>az</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nPK</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>az</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>az</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nPK</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>sid</name> <init>= <expr><call><name>safeId</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPKey</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>truePk</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iPKey</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>az</name><index>[<expr><name>iPKey</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name>
          <operator>||</operator> <operator>!</operator><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>sid</name></expr></argument>,<argument><expr><literal type="string">"rootpage"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
               <operator>||</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>sid</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
               <operator>||</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>sid</name></expr></argument>,<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>az</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>az</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>naz</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>az</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>az</name><index>[<expr><name>naz</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>az</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>az</name><index>[<expr><name>naz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If it is non-NULL, set *pbRowid to indicate whether or not the PK of 
  ** this table is an implicit rowid (*pbRowid==1) or not (*pbRowid==0).  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pbRowid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbRowid</name> <operator>=</operator> <operator>(</operator><name><name>az</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If this table has an implicit rowid for a PK, figure out how to refer
  ** to it. There are usually three options - "rowid", "_rowid_" and "oid".
  ** Any of these will work, unless the table has an explicit column of the
  ** same name or the sqlite_schema tables are to be compared. In the latter
  ** case, pretend that the "true" primary key is the name column, which
  ** avoids extraneous diffs against the schemas due to rowid variance. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>az</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azRowid</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"rowid"</literal></expr>, <expr><literal type="string">"_rowid_"</literal></expr>, <expr><literal type="string">"oid"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azRowid</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azRowid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>naz</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>az</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azRowid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name>naz</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azRowid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>az</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>naz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>az</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>az</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>az</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print the sqlite3_value X as an SQL literal.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printQuoted</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>X</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>r1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%!.15g"</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBlob</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zBlob</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"x'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlob</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>zBlob</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Could be an OOM, could be a zero-byte blob */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"X''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>zArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>inctl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ctl</name> <init>= <expr><call><name>iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>ctl</name><operator>&gt;</operator><name>inctl</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>inctl</name> <operator>=</operator> <name>ctl</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%.*s'||X'%02x"</literal></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ctl</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>inctl</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>inctl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'\n||'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%.*s'"</literal></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s'"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Output SQL that will recreate the aux.zTab table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zId</name> <init>= <expr><call><name>safeId</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Name of the table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* List of columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name></decl>;</decl_stmt>                  <comment type="block">/* Number of true primary key columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                 <comment type="block">/* Number of data columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>      <comment type="block">/* SQL statement */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>         <comment type="block">/* Separator string */</comment>
  <decl_stmt><decl><type><name>Str</name></type> <name>ins</name></decl>;</decl_stmt>                  <comment type="block">/* Beginning of the INSERT statement */</comment>

  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"SELECT sql FROM aux.sqlite_schema WHERE name=%Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>g</name><operator>.</operator><name>bSchemaOnly</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>az</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"aux"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>az</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM aux.%s"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ins</name></expr></argument>,<argument><expr><literal type="string">"INSERT INTO %s VALUES"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Str</name></type> <name>sql</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>strInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator>  <literal type="string">"SELECT"</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,<argument><expr><literal type="string">" FROM aux.%s"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" ORDER BY"</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s %d"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ins</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ins</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ins</name></expr></argument>,<argument><expr><literal type="string">") VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>namelistFree</name><argument_list>(<argument><expr><name>az</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name><name>ins</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> <comment type="block">/* endif !g.bSchemaOnly */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"SELECT sql FROM aux.sqlite_schema"</literal>
                     <literal type="string">" WHERE type='index' AND tbl_name=%Q AND sql IS NOT NULL"</literal></expr></argument>,
                     <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Compute all differences for a single table, except if the
** table name is sqlite_schema, ignore the rootpage column.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>diff_one_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zId</name> <init>= <expr><call><name>safeId</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Name of table (translated for us in SQL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Columns in main */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Columns in aux */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name></decl>;</decl_stmt>                  <comment type="block">/* Primary key columns in main */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk2</name></decl>;</decl_stmt>                 <comment type="block">/* Primary key columns in aux */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of columns in main */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n2</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in aux */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nQ</name></decl>;</decl_stmt>                   <comment type="block">/* Number of output columns in the diff query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>         <comment type="block">/* Separator string */</comment>
  <decl_stmt><decl><type><name>Str</name></type> <name>sql</name></decl>;</decl_stmt>                  <comment type="block">/* Comparison query */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>      <comment type="block">/* Query statement to do the diff */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLead</name> <init>=       <comment type="block">/* Becomes line-comment for sqlite_schema */</comment>
    <expr><ternary><condition><expr><operator>(</operator><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"-- "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>strInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>fDebug</name></name><operator>==</operator><name>DEBUG_COLUMN_NAMES</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Simply run columnNames() on all tables of the origin
    ** database and show the results.  This is used for testing
    ** and debugging of the columnNames() function.
    */</comment>
    <expr_stmt><expr><name>az</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"aux"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>az</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Rowid not accessible for %s\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>nPk</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <goto>goto <name>end_diff_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"aux"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"main"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Table missing from second database. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- 2nd DB has no %s table\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE %s;\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>end_diff_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"main"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Table missing from source */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name></expr> )</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- 1st DB has no %s table\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>dump_table</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <goto>goto <name>end_diff_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>az</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>az2</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"aux"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPk2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>az</name> <operator>&amp;&amp;</operator> <name>az2</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>az2</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>az</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>az2</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>az</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name>az2</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name>nPk</name><operator>!=</operator><name>nPk2</name>
   <operator>||</operator> <name><name>az</name><index>[<expr><name>n</name></expr>]</index></name></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Schema mismatch */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%sDROP TABLE %s; -- due to schema mismatch\n"</literal></expr></argument>, <argument><expr><name>zLead</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dump_table</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_diff_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Build the comparison query */</comment>
  <for>for<control>(<init><expr><name>n2</name><operator>=</operator><name>n</name></expr>;</init> <condition><expr><name><name>az2</name><index>[<expr><name>n2</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n2</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ADD COLUMN %s;\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><call><name>safeId</name><argument_list>(<argument><expr><name><name>az2</name><index>[<expr><name>n2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>nQ</name> <operator>=</operator> <name>nPk2</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>n2</name><operator>-</operator><name>nPk2</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n2</name><operator>&gt;</operator><name>nPk2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"SELECT "</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sB.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">", 1%s -- changed row\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>nPk</name><operator>==</operator><name>n</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"       A.%s IS NOT B.%s, B.%s%s\n"</literal></expr></argument>,
                <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>az2</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while<condition>( <expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"       B.%s IS NOT NULL, B.%s%s\n"</literal></expr></argument>,
                <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>az2</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"  FROM main.%s A, aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" WHERE"</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"\n   AND ("</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sA.%s IS NOT B.%s%s\n"</literal></expr></argument>,
                <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>az2</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">")"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"        OR "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while<condition>( <expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sB.%s IS NOT NULL%s\n"</literal></expr></argument>,
                <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>az2</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">")"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"        OR "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" UNION ALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"SELECT "</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sA.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">", 2%s -- deleted row\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>nPk</name><operator>==</operator><name>n</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"       NULL, NULL%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>n2</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"  FROM main.%s A\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WHERE NOT EXISTS(SELECT 1 FROM aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator>          <literal type="string">"                   WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" UNION ALL\nSELECT "</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sB.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">", 3%s -- inserted row\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>nPk</name><operator>==</operator><name>n</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"       1, B.%s%s\n"</literal></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>az2</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"  FROM aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WHERE NOT EXISTS(SELECT 1 FROM main.%s A\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator>          <literal type="string">"                   WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n ORDER BY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>fDebug</name></name> <operator>&amp;</operator> <name>DEBUG_DIFF_SQL</name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL for %s:\n%s\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_diff_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Drop indexes that are missing in the destination */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(
    <argument><expr><literal type="string">"SELECT name FROM main.sqlite_schema"</literal>
    <literal type="string">" WHERE type='index' AND tbl_name=%Q"</literal>
    <literal type="string">"   AND sql IS NOT NULL"</literal>
    <literal type="string">"   AND sql NOT IN (SELECT sql FROM aux.sqlite_schema"</literal>
    <literal type="string">"                    WHERE type='index' AND tbl_name=%Q"</literal>
    <literal type="string">"                      AND sql IS NOT NULL)"</literal></expr></argument>,
    <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>safeId</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX %s;\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Run the query and output differences */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>g</name><operator>.</operator><name>bSchemaOnly</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iType</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iType</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iType</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iType</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>       <comment type="block">/* Change the content of a row */</comment>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%sUPDATE %s"</literal></expr></argument>, <argument><expr><name>zLead</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" SET"</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nPk</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nQ</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s %s="</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><operator>(</operator><name>i</name><operator>+</operator><name>nPk</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><else>else<block>{<block_content>                <comment type="block">/* Delete a row */</comment>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%sDELETE FROM %s"</literal></expr></argument>, <argument><expr><name>zLead</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" WHERE"</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s %s="</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>                  <comment type="block">/* Insert a row */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%sINSERT INTO %s(%s"</literal></expr></argument>, <argument><expr><name>zLead</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>, <argument><expr><name><name>az2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">") VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nPk2</name><operator>+</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nQ</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> <comment type="block">/* endif !g.bSchemaOnly */</comment>

  <comment type="block">/* Create indexes that are missing in the source */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(
    <argument><expr><literal type="string">"SELECT sql FROM aux.sqlite_schema"</literal>
    <literal type="string">" WHERE type='index' AND tbl_name=%Q"</literal>
    <literal type="string">"   AND sql IS NOT NULL"</literal>
    <literal type="string">"   AND sql NOT IN (SELECT sql FROM main.sqlite_schema"</literal>
    <literal type="string">"                    WHERE type='index' AND tbl_name=%Q"</literal>
    <literal type="string">"                      AND sql IS NOT NULL)"</literal></expr></argument>,
    <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end_diff_one_table</name>:</label>
  <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>namelistFree</name><argument_list>(<argument><expr><name>az</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>namelistFree</name><argument_list>(<argument><expr><name>az2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check that table zTab exists and has the same schema in both the "main"
** and "aux" databases currently opened by the global db handle. If they
** do not, output an error message on stderr and exit(1). Otherwise, if
** the schemas do match, return control to the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkSchemasMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><call><name>db_prepare</name><argument_list>(
      <argument><expr><literal type="string">"SELECT A.sql=B.sql FROM main.sqlite_schema A, aux.sqlite_schema B"</literal>
      <literal type="string">" WHERE A.name=%Q AND B.name=%Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"schema changes for table %s"</literal></expr></argument>, <argument><expr><call><name>safeId</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"table %s missing from one or both databases"</literal></expr></argument>, <argument><expr><call><name>safeId</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************************************************************
** The following code is copied from fossil. It is used to generate the
** fossil delta blobs sometimes used in RBU update records.
*/</comment>

<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>u16</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>

<comment type="block">/*
** The width of a hash window in bytes.  The algorithm only works if this
** is a power of 2.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NHASH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
** The current state of the rolling hash.
**
** z[] holds the values that have been hashed.  z[] is a circular buffer.
** z[i] is the first entry and z[(i+NHASH-1)%NHASH] is the last entry of
** the window.
**
** Hash.a is the sum of all elements of hash.z[].  Hash.b is a weighted
** sum.  Hash.b is z[i]*NHASH + z[i+1]*(NHASH-1) + ... + z[i+NHASH-1]*1.
** (Each index for z[] should be module NHASH, of course.  The %NHASH operator
** is omitted in the prior expression for brevity.)
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>hash</name></name></type> <name>hash</name>;</typedef>
<struct>struct <name>hash</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>         <comment type="block">/* Hash values */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>i</name></decl>;</decl_stmt>            <comment type="block">/* Start of the hash window */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><name>NHASH</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* The values that have been hashed */</comment>
}</block>;</struct>

<comment type="block">/*
** Initialize the rolling hash using the first NHASH characters of z[]
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hash_init</name><parameter_list>(<parameter><decl><type><name>hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NHASH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <operator>(</operator><name>NHASH</name><operator>-</operator><name>i</name><operator>)</operator><operator>*</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>a</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Advance the rolling hash by a single character "c"
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hash_next</name><parameter_list>(<parameter><decl><type><name>hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>old</name> <init>= <expr><name><name>pHash</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>NHASH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>-</operator> <name>old</name> <operator>+</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>-</operator> <name>NHASH</name><operator>*</operator><name>old</name> <operator>+</operator> <name><name>pHash</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a 32-bit hash value
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>hash_32bit</name><parameter_list>(<parameter><decl><type><name>hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write an base-64 integer into the given buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>putInt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zDigits</name><index>[]</index></name> <init>=
    <expr><literal type="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/*  123456789 123456789 123456789 123456789 123456789 123456789 123 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>v</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>v</name><operator>&gt;&gt;=</operator><literal type="number">6</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zDigits</name><index>[<expr><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator><operator>++</operator> <operator>=</operator> <name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Return the number digits in the base-64 representation of a positive integer
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>digit_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>x</name><operator>=</operator><literal type="number">64</literal></expr>;</init> <condition><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>v</name><operator>&gt;=</operator><name>x</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">6</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute a 32-bit checksum on the N-byte buffer.  Return the result.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>checksum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>sum0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>sum1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>sum2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>sum3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>(<expr><name>N</name> <operator>&gt;=</operator> <literal type="number">16</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>sum0</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>sum1</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>sum2</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>sum3</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">15</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>N</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>(<expr><name>N</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>sum0</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sum1</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sum2</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sum3</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>N</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>sum3</name> <operator>+=</operator> <operator>(</operator><name>sum2</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>sum1</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>sum0</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
  <switch>switch<condition>(<expr><name>N</name></expr>)</condition><block>{<block_content>
    <case>case <expr><literal type="number">3</literal></expr>:</case>   <expr_stmt><expr><name>sum3</name> <operator>+=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <case>case <expr><literal type="number">2</literal></expr>:</case>   <expr_stmt><expr><name>sum3</name> <operator>+=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <case>case <expr><literal type="number">1</literal></expr>:</case>   <expr_stmt><expr><name>sum3</name> <operator>+=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
    <default>default:</default>  <empty_stmt>;</empty_stmt>
  </block_content>}</block></switch>
  <return>return <expr><name>sum3</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new delta.
**
** The delta is written into a preallocated buffer, zDelta, which
** should be at least 60 bytes longer than the target file, zOut.
** The delta string will be NUL-terminated, but it might also contain
** embedded NUL characters if either the zSrc or zOut files are
** binary.  This function returns the length of the delta string
** in bytes, excluding the final NUL terminator character.
**
** Output Format:
**
** The delta begins with a base64 number followed by a newline.  This
** number is the number of bytes in the TARGET file.  Thus, given a
** delta file z, a program can compute the size of the output file
** simply by reading the first line and decoding the base-64 number
** found there.  The delta_output_size() routine does exactly this.
**
** After the initial size number, the delta consists of a series of
** literal text segments and commands to copy from the SOURCE file.
** A copy command looks like this:
**
**     NNN@MMM,
**
** where NNN is the number of bytes to be copied and MMM is the offset
** into the source file of the first byte (both base-64).   If NNN is 0
** it means copy the rest of the input file.  Literal text is like this:
**
**     NNN:TTTTT
**
** where NNN is the number of bytes of text (base-64) and TTTTT is the text.
**
** The last term is of the form
**
**     NNN;
**
** In this case, NNN is a 32-bit bigendian checksum of the output file
** that can be used to verify that the delta applied correctly.  All
** numbers are in base-64.
**
** Pure text files generate a pure text delta.  Binary files generate a
** delta that may contain some binary data.
**
** Algorithm:
**
** The encoder first builds a hash table to help it find matching
** patterns in the source file.  16-byte chunks of the source file
** sampled at evenly spaced intervals are used to populate the hash
** table.
**
** Next we begin scanning the target file using a sliding 16-byte
** window.  The hash of the 16-byte window in the target is used to
** search for a matching section in the source file.  When a match
** is found, a copy command is added to the delta.  An effort is
** made to extend the matching section to regions that come before
** and after the 16-byte hash window.  A copy command is only issued
** if the result would use less space that just quoting the text
** literally. Literal text is added to the delta for sections that
** do not match or which can not be encoded efficiently using copy
** commands.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rbuDeltaCreate</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>,      <comment type="block">/* The source or pattern file */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>lenSrc</name></decl></parameter>,   <comment type="block">/* Length of the source file */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>,      <comment type="block">/* The target file */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>lenOut</name></decl></parameter>,   <comment type="block">/* Length of the target file */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zDelta</name></decl></parameter>           <comment type="block">/* Write the delta into this buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOrigDelta</name> <init>= <expr><name>zDelta</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>hash</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHash</name></decl>;</decl_stmt>                 <comment type="block">/* Number of hash table entries */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>landmark</name></decl>;</decl_stmt>             <comment type="block">/* Primary hash table */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>collide</name></decl>;</decl_stmt>              <comment type="block">/* Collision chain */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lastRead</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Last byte of zSrc read by a COPY command */</comment>

  <comment type="block">/* Add the target file size to the beginning of the delta
  */</comment>
  <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

  <comment type="block">/* If the source file is very small, it means that we have no
  ** chance of ever doing a copy command.  Just output a single
  ** literal segment for the entire target and exit.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>lenSrc</name><operator>&lt;=</operator><name>NHASH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>lenOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>lenOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><call><name>checksum</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>lenOut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zDelta</name> <operator>-</operator> <name>zOrigDelta</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute the hash table used to locate matching sections in the
  ** source file.
  */</comment>
  <expr_stmt><expr><name>nHash</name> <operator>=</operator> <name>lenSrc</name><operator>/</operator><name>NHASH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>collide</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>nHash</name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>landmark</name> <operator>=</operator> <operator>&amp;</operator><name><name>collide</name><index>[<expr><name>nHash</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>landmark</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nHash</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>collide</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nHash</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>lenSrc</name><operator>-</operator><name>NHASH</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>NHASH</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>hv</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>hash_32bit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>nHash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>collide</name><index>[<expr><name>i</name><operator>/</operator><name>NHASH</name></expr>]</index></name> <operator>=</operator> <name><name>landmark</name><index>[<expr><name>hv</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>landmark</name><index>[<expr><name>hv</name></expr>]</index></name> <operator>=</operator> <name>i</name><operator>/</operator><name>NHASH</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Begin scanning the target file and generating copy commands and
  ** literal sections of the delta.
  */</comment>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* We have already generated everything before zOut[base] */</comment>
  <while>while<condition>( <expr><name>base</name><operator>+</operator><name>NHASH</name><operator>&lt;</operator><name>lenOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSrc</name></decl>, <decl><type ref="prev"/><name>iBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bestCnt</name></decl>, <decl><type ref="prev"/><name>bestOfst</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bestLitsz</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>     <comment type="block">/* Trying to match a landmark against zOut[base+i] */</comment>
    <expr_stmt><expr><name>bestCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>hv</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><literal type="number">250</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>hash_32bit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>nHash</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBlock</name> <operator>=</operator> <name><name>landmark</name><index>[<expr><name>hv</name></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>iBlock</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>limit</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/*
        ** The hash window has identified a potential match against
        ** landmark block iBlock.  But we need to investigate further.
        **
        ** Look for a region in zOut that matches zSrc. Anchor the search
        ** at zSrc[iSrc] and zOut[base+i].  Do not include anything prior to
        ** zOut[base] or after zOut[outLen] nor anything after zSrc[srcLen].
        **
        ** Set cnt equal to the length of the match and set ofst so that
        ** zSrc[ofst] is the first element of the match.  litsz is the number
        ** of characters between zOut[base] and the beginning of the match.
        ** sz will be the overhead (in bytes) needed to encode the copy
        ** command.  Only generate copy command if the overhead of the
        ** copy command is less than the amount of literal text to be copied.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>, <decl><type ref="prev"/><name>ofst</name></decl>, <decl><type ref="prev"/><name>litsz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

        <comment type="block">/* Beginning at iSrc, match forwards as far as we can.  j counts
        ** the number of characters that match */</comment>
        <expr_stmt><expr><name>iSrc</name> <operator>=</operator> <name>iBlock</name><operator>*</operator><name>NHASH</name></expr>;</expr_stmt>
        <for>for<control>(
          <init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>x</name><operator>=</operator><name>iSrc</name></expr><operator>,</operator> <expr><name>y</name><operator>=</operator><name>base</name><operator>+</operator><name>i</name></expr>;</init>
          <condition><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>x</name><operator>&lt;</operator><name>lenSrc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>y</name><operator>&lt;</operator><name>lenOut</name></expr>;</condition>
          <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>x</name><operator>++</operator></expr><operator>,</operator> <expr><name>y</name><operator>++</operator></expr></incr>
        )</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>zSrc</name><index>[<expr><name>x</name></expr>]</index></name><operator>!=</operator><name><name>zOut</name><index>[<expr><name>y</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>

        <comment type="block">/* Beginning at iSrc-1, match backwards as far as we can.  k counts
        ** the number of characters that match */</comment>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>iSrc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>k</name><operator>&lt;=</operator><name>i</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>zSrc</name><index>[<expr><name>iSrc</name><operator>-</operator><name>k</name></expr>]</index></name><operator>!=</operator><name><name>zOut</name><index>[<expr><name>base</name><operator>+</operator><name>i</name><operator>-</operator><name>k</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>

        <comment type="block">/* Compute the offset and size of the matching region */</comment>
        <expr_stmt><expr><name>ofst</name> <operator>=</operator> <name>iSrc</name><operator>-</operator><name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cnt</name> <operator>=</operator> <name>j</name><operator>+</operator><name>k</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>litsz</name> <operator>=</operator> <name>i</name><operator>-</operator><name>k</name></expr>;</expr_stmt>  <comment type="block">/* Number of bytes of literal text before the copy */</comment>
        <comment type="block">/* sz will hold the number of bytes needed to encode the "insert"
        ** command and the copy command, not counting the "insert" text */</comment>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>digit_count</name><argument_list>(<argument><expr><name>i</name><operator>-</operator><name>k</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>digit_count</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>digit_count</name><argument_list>(<argument><expr><name>ofst</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;=</operator><name>sz</name> <operator>&amp;&amp;</operator> <name>cnt</name><operator>&gt;</operator><name>bestCnt</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Remember this match only if it is the best so far and it
          ** does not increase the file size */</comment>
          <expr_stmt><expr><name>bestCnt</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestOfst</name> <operator>=</operator> <name>iSrc</name><operator>-</operator><name>k</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestLitsz</name> <operator>=</operator> <name>litsz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check the next matching block */</comment>
        <expr_stmt><expr><name>iBlock</name> <operator>=</operator> <name><name>collide</name><index>[<expr><name>iBlock</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></while>

      <comment type="block">/* We have a copy command that does not cause the delta to be larger
      ** than a literal insert.  So add the copy command to the delta.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>bestCnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bestLitsz</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Add an insert command before the copy */</comment>
          <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>bestLitsz</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>, <argument><expr><name>bestLitsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>bestLitsz</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base</name> <operator>+=</operator> <name>bestLitsz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>base</name> <operator>+=</operator> <name>bestCnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>bestCnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>bestOfst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bestOfst</name> <operator>+</operator> <name>bestCnt</name> <operator>-</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>lastRead</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>lastRead</name> <operator>=</operator> <name>bestOfst</name> <operator>+</operator> <name>bestCnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bestCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If we reach this point, it means no match is found so far */</comment>
      <if_stmt><if>if<condition>( <expr><name>base</name><operator>+</operator><name>i</name><operator>+</operator><name>NHASH</name><operator>&gt;=</operator><name>lenOut</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* We have reached the end of the file and have not found any
        ** matches.  Do an "insert" for everything that does not match */</comment>
        <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>, <argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>lenOut</name><operator>-</operator><name>base</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>base</name> <operator>=</operator> <name>lenOut</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Advance the hash by one character.  Keep looking for a match */</comment>
      <expr_stmt><expr><call><name>hash_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name><name>zOut</name><index>[<expr><name>base</name><operator>+</operator><name>i</name><operator>+</operator><name>NHASH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>
  <comment type="block">/* Output a final "insert" record to get all the text at the end of
  ** the file that does not match anything in the source file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>base</name><operator>&lt;</operator><name>lenOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>, <argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>lenOut</name><operator>-</operator><name>base</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Output the final checksum record. */</comment>
  <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><call><name>checksum</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>lenOut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>collide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zDelta</name> <operator>-</operator> <name>zOrigDelta</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** End of code copied from fossil.
**************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>strPrintfArray</name><parameter_list>(
  <parameter><decl><type><name>Str</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,                      <comment type="block">/* String object to append to */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl></parameter>,               <comment type="block">/* Separator string */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>,               <comment type="block">/* Format for each entry */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>                <comment type="block">/* Array of strings &amp; its size (or -1) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>&lt;</operator><name>n</name> <operator>||</operator> <name>n</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>getRbudiffQuery</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nPK</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bOtaRowid</name></decl></parameter>,
  <parameter><decl><type><name>Str</name> <modifier>*</modifier></type><name>pSql</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* First the newly inserted rows: **/</comment> 
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", 0, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* Set ota_control to 0 for an insert */</comment>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" FROM aux.%Q AS n WHERE NOT EXISTS (\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"    SELECT 1 FROM "</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" main.%Q AS o WHERE "</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="string">"(n.%Q = o.%Q)"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\n) AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="string">"(n.%Q IS NOT NULL)"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Deleted rows: */</comment>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\nUNION ALL\nSELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>azCol</name><index>[<expr><name>nPK</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>nPK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", 1, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* Set ota_control to 1 for a delete */</comment>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" FROM main.%Q AS n WHERE NOT EXISTS (\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"    SELECT 1 FROM "</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" aux.%Q AS o WHERE "</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="string">"(n.%Q = o.%Q)"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\n) AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="string">"(n.%Q IS NOT NULL)"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Updated rows. If all table columns are part of the primary key, there 
  ** can be no updates. In this case this part of the compound SELECT can
  ** be omitted altogether. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>azCol</name><index>[<expr><name>nPK</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\nUNION ALL\nSELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"n.%s"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" ,\n"</literal></expr></argument>, 
        <argument><expr><literal type="string">"    CASE WHEN n.%s IS o.%s THEN NULL ELSE n.%s END"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>nPK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bOtaRowid</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"' ||\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" ||\n"</literal></expr></argument>, 
        <argument><expr><literal type="string">"    CASE WHEN n.%s IS o.%s THEN '.' ELSE 'x' END"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>nPK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\nAS ota_control, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" ,\n"</literal></expr></argument>, 
        <argument><expr><literal type="string">"    CASE WHEN n.%s IS o.%s THEN NULL ELSE o.%s END"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>nPK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\nFROM main.%Q AS o, aux.%Q AS n\nWHERE "</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="string">"(n.%Q = o.%Q)"</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">" AND ota_control LIKE '%%x%%'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now add an ORDER BY clause to sort everything by PK. */</comment>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"\nORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nPK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>i</name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><literal type="string">", "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rbudiff_one_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bOtaRowid</name></decl>;</decl_stmt>                  <comment type="block">/* True to use an ota_rowid column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPK</name></decl>;</decl_stmt>                        <comment type="block">/* Number of primary key columns in table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl>;</decl_stmt>                   <comment type="block">/* NULL terminated array of col names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Str</name></type> <name>ct</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>             <comment type="block">/* The "CREATE TABLE data_xxx" statement */</comment>
  <decl_stmt><decl><type><name>Str</name></type> <name>sql</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>            <comment type="block">/* Query to find differences */</comment>
  <decl_stmt><decl><type><name>Str</name></type> <name>insert</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>         <comment type="block">/* First part of output INSERT statement */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Total rows in data_xxx table */</comment>

  <comment type="block">/* --rbu mode must use real primary keys. */</comment>
  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>bSchemaPK</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* Check that the schemas of the two tables match. Exit early otherwise. */</comment>
  <expr_stmt><expr><call><name>checkSchemasMatch</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Grab the column names and PK details for the table(s). If no usable PK
  ** columns are found, bail out early.  */</comment>
  <expr_stmt><expr><name>azCol</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bOtaRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"table %s has no usable PK columns"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>nCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>azCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nCol</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

  <comment type="block">/* Build and output the CREATE TABLE statement for the data_xxx table */</comment>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE IF NOT EXISTS 'data_%q'("</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bOtaRowid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><literal type="string">"rbu_rowid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>bOtaRowid</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><literal type="string">", rbu_control);"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the SQL for the query to retrieve data from the two databases */</comment>
  <expr_stmt><expr><call><name>getRbudiffQuery</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nPK</name></expr></argument>, <argument><expr><name>bOtaRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Build the first part of the INSERT statement output for each row
  ** in the data_xxx table. */</comment>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insert</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO 'data_%q' ("</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bOtaRowid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insert</name></expr></argument>, <argument><expr><literal type="string">"rbu_rowid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>strPrintfArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insert</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>bOtaRowid</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insert</name></expr></argument>, <argument><expr><literal type="string">", rbu_control) VALUES("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    
    <comment type="block">/* If this is the first row output, print out the CREATE TABLE 
    ** statement first. And then set ct.z to NULL so that it is not 
    ** printed again.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>ct</name><operator>.</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>ct</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Output the first part of the INSERT statement */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>insert</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRow</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOtaControl</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nOtaControl</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>zOtaControl</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nOtaControl</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOtaControl</name></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nOtaControl</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nPK</name> 
            <operator>&amp;&amp;</operator> <call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name>
            <operator>&amp;&amp;</operator> <call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aSrc</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aFinal</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nFinal</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aDelta</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nDelta</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>aDelta</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nFinal</name> <operator>+</operator> <literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nDelta</name> <operator>=</operator> <call><name>rbuDeltaCreate</name><argument_list>(<argument><expr><name>aSrc</name></expr></argument>, <argument><expr><name>nSrc</name></expr></argument>, <argument><expr><name>aFinal</name></expr></argument>, <argument><expr><name>nFinal</name></expr></argument>, <argument><expr><name>aDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>nDelta</name><operator>&lt;</operator><name>nFinal</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"x'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nDelta</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name><name>aDelta</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zOtaControl</name><index>[<expr><name>i</name><operator>-</operator><name>bOtaRowid</name></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>bDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>bDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>printQuoted</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>zOtaControl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOtaControl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* And the closing bracket of the insert statement */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRow</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Str</name></type> <name>cnt</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO rbu_count VALUES('data_%q', %d);"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>nRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>cnt</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Display a summary of differences between two versions of the same
** table table.
**
**   *  Number of rows changed
**   *  Number of rows added
**   *  Number of rows deleted
**   *  Number of identical rows
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>summarize_one_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zId</name> <init>= <expr><call><name>safeId</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Name of table (translated for us in SQL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Columns in main */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Columns in aux */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name></decl>;</decl_stmt>                  <comment type="block">/* Primary key columns in main */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk2</name></decl>;</decl_stmt>                 <comment type="block">/* Primary key columns in aux */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of columns in main */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n2</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in aux */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>         <comment type="block">/* Separator string */</comment>
  <decl_stmt><decl><type><name>Str</name></type> <name>sql</name></decl>;</decl_stmt>                  <comment type="block">/* Comparison query */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>      <comment type="block">/* Query statement to do the diff */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nUpdate</name></decl>;</decl_stmt>    <comment type="block">/* Number of updated rows */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nUnchanged</name></decl>;</decl_stmt> <comment type="block">/* Number of unmodified rows */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDelete</name></decl>;</decl_stmt>    <comment type="block">/* Number of deleted rows */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nInsert</name></decl>;</decl_stmt>    <comment type="block">/* Number of inserted rows */</comment>

  <expr_stmt><expr><call><name>strInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"aux"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"main"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Table missing from second database. */</comment>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s: missing from second database\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>end_summarize_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"main"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Table missing from source */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s: missing from first database\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_summarize_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>az</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>az2</name> <operator>=</operator> <call><name>columnNames</name><argument_list>(<argument><expr><literal type="string">"aux"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPk2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>az</name> <operator>&amp;&amp;</operator> <name>az2</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>az</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>az2</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>az</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name>az2</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name>nPk</name><operator>!=</operator><name>nPk2</name>
   <operator>||</operator> <name><name>az</name><index>[<expr><name>n</name></expr>]</index></name></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Schema mismatch */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s: incompatible schema\n"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_summarize_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Build the comparison query */</comment>
  <for>for<control>(<init><expr><name>n2</name><operator>=</operator><name>n</name></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>n2</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n2</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1, count(*)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n2</name><operator>==</operator><name>nPk2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">", 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", sum("</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nPk</name></expr>;</init> <condition><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sA.%s IS NOT B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" OR "</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"  FROM main.%s A, aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" UNION ALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT 2, count(*), 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"  FROM main.%s A\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WHERE NOT EXISTS(SELECT 1 FROM aux.%s B "</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" UNION ALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT 3, count(*), 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"  FROM aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WHERE NOT EXISTS(SELECT 1 FROM main.%s A "</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n ORDER BY 1;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>g</name><operator>.</operator><name>fDebug</name></name> <operator>&amp;</operator> <name>DEBUG_DIFF_SQL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL for %s:\n%s\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_summarize_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Run the query and output difference summary */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nUpdate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nInsert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nDelete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nUnchanged</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">1</literal></expr>:</case>
        <expr_stmt><expr><name>nUpdate</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nUnchanged</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>nUpdate</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">2</literal></expr>:</case>
        <expr_stmt><expr><name>nDelete</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">3</literal></expr>:</case>
        <expr_stmt><expr><name>nInsert</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s: %lld changes, %lld inserts, %lld deletes, %lld unchanged\n"</literal></expr></argument>,
          <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>nUpdate</name></expr></argument>, <argument><expr><name>nInsert</name></expr></argument>, <argument><expr><name>nDelete</name></expr></argument>, <argument><expr><name>nUnchanged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end_summarize_one_table</name>:</label>
  <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>namelistFree</name><argument_list>(<argument><expr><name>az</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>namelistFree</name><argument_list>(<argument><expr><name>az2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write a 64-bit signed integer as a varint onto out
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>putsVarint</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>sqlite3_uint64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>p</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><literal type="number">0xff000000</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">7</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><index>[<expr><name>n</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">9</literal><operator>-</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write an SQLite value onto out.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>putValue</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDType</name> <init>= <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>rX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>uX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>iDType</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>iDType</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
      <expr_stmt><expr><name>iX</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iX</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">56</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>-=</operator><literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>uX</name><operator>&gt;&gt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <break>break;</break>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name>rX</name> <operator>=</operator> <call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rX</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">56</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>-=</operator><literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>uX</name><operator>&gt;&gt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <break>break;</break>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case>
      <expr_stmt><expr><name>iX</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>putsVarint</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>iX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>iX</name></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>
      <expr_stmt><expr><name>iX</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>putsVarint</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>iX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>iX</name></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Generate a CHANGESET for all differences from main.zTab to aux.zTab.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>changeset_one_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>          <comment type="block">/* SQL statment */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zId</name> <init>= <expr><call><name>safeId</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* Escaped name of the table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* List of escaped column names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of columns */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiFlg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* 0 if column is not part of PK */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Column numbers for each PK column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Number of PRIMARY KEY columns */</comment>
  <decl_stmt><decl><type><name>Str</name></type> <name>sql</name></decl>;</decl_stmt>                      <comment type="block">/* SQL for the diff query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>                     <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>             <comment type="block">/* List separator */</comment>

  <comment type="block">/* Check that the schemas of the two tables match. Exit early otherwise. */</comment>
  <expr_stmt><expr><call><name>checkSchemasMatch</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"PRAGMA main.table_info=%Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>azCol</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>azCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>aiFlg</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>aiFlg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aiFlg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>nCol</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>safeId</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aiFlg</name><index>[<expr><name>nCol</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>nPk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nPk</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>aiPk</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>aiPk</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aiPk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>runtimeError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>aiPk</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nCol</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_changeset_one_table</name>;</goto></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&gt;</operator><name>nPk</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT %d"</literal></expr></argument>, <argument><expr><name>SQLITE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">",\n       A.%s"</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">",\n       A.%s IS NOT B.%s, A.%s, B.%s"</literal></expr></argument>,
                  <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,<argument><expr><literal type="string">"\n  FROM main.%s A, aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" WHERE"</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"\n   AND ("</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sA.%s IS NOT B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" OR\n        "</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,<argument><expr><literal type="string">")\n UNION ALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT %d"</literal></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">",\n       A.%s"</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">",\n       1, A.%s, NULL"</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"\n  FROM main.%s A\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WHERE NOT EXISTS(SELECT 1 FROM aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator>          <literal type="string">"                   WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n UNION ALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT %d"</literal></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">",\n       B.%s"</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">",\n       1, NULL, B.%s"</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"\n  FROM aux.%s B\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WHERE NOT EXISTS(SELECT 1 FROM main.%s A\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator>          <literal type="string">"                   WHERE"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s A.%s=B.%s"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND"</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s %d"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>aiPk</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>strPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>fDebug</name></name> <operator>&amp;</operator> <name>DEBUG_DIFF_SQL</name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL for %s:\n%s\n"</literal></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_changeset_one_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>putsVarint</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iType</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>iType</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_UPDATE</name></expr>:</case> <block>{<block_content>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_INSERT</name></expr>:</case> <block>{<block_content>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_DELETE</name></expr>:</case> <block>{<block_content>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aiFlg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>putValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
<label><name>end_changeset_one_table</name>:</label>
  <while>while<condition>( <expr><name>nCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><operator>--</operator><name>nCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aiPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aiFlg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the ascii character passed as the only argument is a
** whitespace character. Otherwise return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>is_whitespace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>x</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>x</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>x</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>x</name><operator>==</operator><literal type="char">'\r'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Extract the next SQL keyword or quoted string from buffer zIn and copy it
** (or a prefix of it if it will not fit) into buffer zBuf, size nBuf bytes.
** Return a pointer to the character within zIn immediately following 
** the token or quoted string just extracted.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gobble_token</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name>zBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pOut</name><index>[<expr><name>nBuf</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* quote character, if any */</comment>

  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>is_whitespace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <switch>switch<condition>( <expr><operator>*</operator><name>p</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'`'</literal></expr>:</case> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">'`'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'['</literal></expr>:</case> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>q</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <name>pOut</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><name>q</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>!=</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_whitespace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name><operator>!=</operator><literal type="char">'('</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pOut</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is the implementation of SQL scalar function "module_name":
**
**   module_name(SQL)
**
** The only argument should be an SQL statement of the type that may appear
** in the sqlite_schema table. If the statement is a "CREATE VIRTUAL TABLE"
** statement, then the value returned is the name of the module that it
** uses. Otherwise, if the statement is not a CVT, NULL is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>module_name_func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zToken</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>gobble_token</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><literal type="string">"create"</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>gobble_token</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><literal type="string">"virtual"</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>gobble_token</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>gobble_token</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>gobble_token</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><literal type="string">"using"</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>gobble_token</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the text of an SQL statement that itself returns the list of
** tables to process within the database.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>all_tables_sql</name><parameter_list>()</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bHandleVtab</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, 
        <argument><expr><literal type="string">"CREATE TEMP TABLE tblmap(module COLLATE nocase, postfix);"</literal>
        <literal type="string">"INSERT INTO temp.tblmap VALUES"</literal>
        <literal type="string">"('fts3', '_content'), ('fts3', '_segments'), ('fts3', '_segdir'),"</literal>
  
        <literal type="string">"('fts4', '_content'), ('fts4', '_segments'), ('fts4', '_segdir'),"</literal>
        <literal type="string">"('fts4', '_docsize'), ('fts4', '_stat'),"</literal>
  
        <literal type="string">"('fts5', '_data'), ('fts5', '_idx'), ('fts5', '_content'),"</literal>
        <literal type="string">"('fts5', '_docsize'), ('fts5', '_config'),"</literal>
  
        <literal type="string">"('rtree', '_node'), ('rtree', '_rowid'), ('rtree', '_parent');"</literal></expr></argument>
        , <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(
        <argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"module_name"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>module_name_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <return>return 
      <expr><literal type="string">"SELECT name FROM main.sqlite_schema\n"</literal>
      <literal type="string">" WHERE type='table' AND (\n"</literal>
      <literal type="string">"    module_name(sql) IS NULL OR \n"</literal>
      <literal type="string">"    module_name(sql) IN (SELECT module FROM temp.tblmap)\n"</literal>
      <literal type="string">" ) AND name NOT IN (\n"</literal>
      <literal type="string">"  SELECT a.name || b.postfix \n"</literal>
        <literal type="string">"FROM main.sqlite_schema AS a, temp.tblmap AS b \n"</literal>
        <literal type="string">"WHERE module_name(a.sql) = b.module\n"</literal> 
      <literal type="string">" )\n"</literal>
      <literal type="string">"UNION \n"</literal>
      <literal type="string">"SELECT name FROM aux.sqlite_schema\n"</literal>
      <literal type="string">" WHERE type='table' AND (\n"</literal>
      <literal type="string">"    module_name(sql) IS NULL OR \n"</literal>
      <literal type="string">"    module_name(sql) IN (SELECT module FROM temp.tblmap)\n"</literal>
      <literal type="string">" ) AND name NOT IN (\n"</literal>
      <literal type="string">"  SELECT a.name || b.postfix \n"</literal>
        <literal type="string">"FROM aux.sqlite_schema AS a, temp.tblmap AS b \n"</literal>
        <literal type="string">"WHERE module_name(a.sql) = b.module\n"</literal> 
      <literal type="string">" )\n"</literal>
      <literal type="string">" ORDER BY name"</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return
      <expr><literal type="string">"SELECT name FROM main.sqlite_schema\n"</literal>
      <literal type="string">" WHERE type='table' AND sql NOT LIKE 'CREATE VIRTUAL%%'\n"</literal>
      <literal type="string">" UNION\n"</literal>
      <literal type="string">"SELECT name FROM aux.sqlite_schema\n"</literal>
      <literal type="string">" WHERE type='table' AND sql NOT LIKE 'CREATE VIRTUAL%%'\n"</literal>
      <literal type="string">" ORDER BY name"</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Print sketchy documentation for this utility program
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>showHelp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage: %s [options] DB1 DB2\n"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"Output SQL text that would transform DB1 into DB2.\n"</literal>
<literal type="string">"Options:\n"</literal>
<literal type="string">"  --changeset FILE      Write a CHANGESET into FILE\n"</literal>
<literal type="string">"  -L|--lib LIBRARY      Load an SQLite extension library\n"</literal>
<literal type="string">"  --primarykey          Use schema-defined PRIMARY KEYs\n"</literal>
<literal type="string">"  --rbu                 Output SQL to create/populate RBU table(s)\n"</literal>
<literal type="string">"  --schema              Show only differences in the schema\n"</literal>
<literal type="string">"  --summary             Show only a summary of the differences\n"</literal>
<literal type="string">"  --table TAB           Show only differences in table TAB\n"</literal>
<literal type="string">"  --transaction         Show SQL output inside a transaction\n"</literal>
<literal type="string">"  --vtab                Handle fts3, fts4, fts5 and rtree tables\n"</literal>
<literal type="string">"See https://sqlite.org/sqldiff.html for detailed explanation.\n"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>stdout</name></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDiff</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><name>diff_one_table</name></expr></init>;</function_decl>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>nExt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azExt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>useTransaction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neverUseTransaction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_SINGLETHREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"changeset"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"missing argument to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"cannot open: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>xDiff</name> <operator>=</operator> <name>changeset_one_table</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>neverUseTransaction</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"missing argument to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>g</name><operator>.</operator><name>fDebug</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>showHelp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if><if type="elseif">else
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"lib"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"L"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"missing argument to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>azExt</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>azExt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>azExt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nExt</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>azExt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>azExt</name><index>[<expr><name>nExt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"primarykey"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>g</name><operator>.</operator><name>bSchemaPK</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"rbu"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>xDiff</name> <operator>=</operator> <name>rbudiff_one_table</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>g</name><operator>.</operator><name>bSchemaOnly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"summary"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>xDiff</name> <operator>=</operator> <name>summarize_one_table</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"missing argument to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zTab</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name> <operator>=</operator>
          <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
          <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_master"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"transaction"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>useTransaction</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"vtab"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>g</name><operator>.</operator><name>bHandleVtab</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"unknown option: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zDb1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zDb1</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zDb2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zDb2</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"unknown argument: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zDb2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"two database arguments required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>bSchemaOnly</name></name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>.</operator><name>bSchemaCompare</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"The --schema option is useless with --table %s ."</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><name>zDb1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"cannot open database file \"%s\""</literal></expr></argument>, <argument><expr><name>zDb1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM sqlite_schema"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>zErrMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"\"%s\" does not appear to be a valid SQLite database"</literal></expr></argument>, <argument><expr><name>zDb1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3_enable_load_extension</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_load_extension</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azExt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>zErrMsg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"error loading %s: %s"</literal></expr></argument>, <argument><expr><name><name>azExt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>azExt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"ATTACH %Q as aux;"</literal></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>zErrMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"cannot attach database \"%s\""</literal></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM aux.sqlite_schema"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>zErrMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmdlineError</name><argument_list>(<argument><expr><literal type="string">"\"%s\" does not appear to be a valid SQLite database"</literal></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>neverUseTransaction</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>useTransaction</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>useTransaction</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"BEGIN TRANSACTION;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>xDiff</name><operator>==</operator><name>rbudiff_one_table</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE IF NOT EXISTS rbu_count"</literal>
           <literal type="string">"(tbl TEXT PRIMARY KEY COLLATE NOCASE, cnt INTEGER) "</literal>
           <literal type="string">"WITHOUT ROWID;\n"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>xDiff</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Handle tables one by one */</comment>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>db_prepare</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>all_tables_sql</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>xDiff</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>useTransaction</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"COMMIT;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* TBD: Handle trigger differences */</comment>
  <comment type="block">/* TBD: Handle view differences */</comment>
  <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
