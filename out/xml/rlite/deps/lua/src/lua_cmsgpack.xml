<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/rlite/deps/lua/src/lua_cmsgpack.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUACMSGPACK_NAME</name></cpp:macro>        <cpp:value>"cmsgpack"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUACMSGPACK_SAFE_NAME</name></cpp:macro>   <cpp:value>"cmsgpack_safe"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUACMSGPACK_VERSION</name></cpp:macro>     <cpp:value>"lua-cmsgpack 0.4.0"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUACMSGPACK_COPYRIGHT</name></cpp:macro>   <cpp:value>"Copyright (C) 2012, Salvatore Sanfilippo"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUACMSGPACK_DESCRIPTION</name></cpp:macro> <cpp:value>"MessagePack C implementation for Lua"</cpp:value></cpp:define>

<comment type="block">/* Allows a preprocessor directive to override MAX_NESTING */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LUACMSGPACK_MAX_NESTING</name></cpp:ifndef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUACMSGPACK_MAX_NESTING</name></cpp:macro>  <cpp:value>16</cpp:value></cpp:define> <comment type="block">/* Max tables nesting. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Check if float or double can be an integer without loss of precision */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INT_TYPE_EQUIVALENT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!isinf(x) &amp;&amp; (T)(x) == (x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INT64_EQUIVALENT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IS_INT_TYPE_EQUIVALENT(x, int64_t)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INT_EQUIVALENT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IS_INT_TYPE_EQUIVALENT(x, int)</cpp:value></cpp:define>

<comment type="block">/* If size of pointer is equal to a 4 byte integer, we're on 32 bits. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UINTPTR_MAX</name> <operator>==</operator> <name>UINT_MAX</name></expr></cpp:if>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS_32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS_32</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BITS_32</name></expr></cpp:if>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_pushunsigned</name><parameter_list>(<parameter><type><name>L</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lua_pushnumber(L, n)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_pushunsigned</name><parameter_list>(<parameter><type><name>L</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lua_pushinteger(L, n)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* =============================================================================
 * MessagePack implementation and bindings for Lua 5.1/5.2.
 * Copyright(C) 2012 Salvatore Sanfilippo &lt;antirez@gmail.com&gt;
 *
 * http://github.com/antirez/lua-cmsgpack
 *
 * For MessagePack specification check the following web site:
 * http://wiki.msgpack.org/display/MSGPACK/Format+specification
 *
 * See Copyright Notice at the end of this file.
 *
 * CHANGELOG:
 * 19-Feb-2012 (ver 0.1.0): Initial release.
 * 20-Feb-2012 (ver 0.2.0): Tables encoding improved.
 * 20-Feb-2012 (ver 0.2.1): Minor bug fixing.
 * 20-Feb-2012 (ver 0.3.0): Module renamed lua-cmsgpack (was lua-msgpack).
 * 04-Apr-2014 (ver 0.3.1): Lua 5.2 support and minor bug fix.
 * 07-Apr-2014 (ver 0.4.0): Multiple pack/unpack, lua allocator, efficiency.
 * ========================================================================== */</comment>

<comment type="block">/* -------------------------- Endian conversion --------------------------------
 * We use it only for floats and doubles, all the other conversions performed
 * in an endian independent fashion. So the only thing we need is a function
 * that swaps a binary string if arch is little endian (and left it untouched
 * otherwise). */</comment>

<comment type="block">/* Reverse memory bytes if arch is little endian. Given the conceptual
 * simplicity of the Lua build system we prefer check for endianess at runtime.
 * The performance difference should be acceptable. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memrevifle</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name>   <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>,
                    <decl><type ref="prev"><modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>+</operator><name>len</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
                    <decl><type ref="prev"/><name>aux</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>test</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>testp</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>test</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>testp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Big endian, nothing to do. */</comment>
    <expr_stmt><expr><name>len</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>e</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>e</name> <operator>=</operator> <name>aux</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* ---------------------------- String buffer ----------------------------------
 * This is a simple implementation of string buffers. The only operation
 * supported is creating empty buffers and appending bytes to it.
 * The string buffer uses 2x preallocation on every realloc for O(N) append
 * behavior.  */</comment>

<typedef>typedef <type><struct>struct <name>mp_buf</name> <block>{
    <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <name>free</name>;</decl_stmt>
}</block></struct></type> <name>mp_buf</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>mp_realloc</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>osize</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>local_realloc</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>osize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>local_realloc</name> <operator>=</operator> <call><name>lua_getallocf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ud</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>local_realloc</name><argument_list>(<argument><expr><name>ud</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_buf</name> <modifier>*</modifier></type><name>mp_buf_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Old size = 0; new size = sizeof(*buf) */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>mp_buf</name><operator>*</operator><operator>)</operator><call><name>mp_realloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_buf_append</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>newlen</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>+</operator><name>len</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>mp_realloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>newlen</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b</name></name><operator>+</operator><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mp_buf_free</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>mp_realloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* realloc to 0 = free */</comment>
    <expr_stmt><expr><call><name>mp_realloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------------- String cursor ----------------------------------
 * This simple data structure is used for parsing. Basically you create a cursor
 * using a string pointer and a length, then it is possible to access the
 * current string position with cursor-&gt;p, check the remaining length
 * in cursor-&gt;left, and finally consume more string using
 * mp_cur_consume(cursor,len), to advance 'p' and subtract 'left'.
 * An additional field cursor-&gt;error is set to zero on initialization and can
 * be used to report errors. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_CUR_ERROR_NONE</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_CUR_ERROR_EOF</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>   <comment type="block">/* Not enough data to complete operation. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_CUR_ERROR_BADFMT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>   <comment type="block">/* Bad data format */</comment>

<typedef>typedef <type><struct>struct <name>mp_cur</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
}</block></struct></type> <name>mp_cur</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_cur_init</name><parameter_list>(<parameter><decl><type><name>mp_cur</name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>MP_CUR_ERROR_NONE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mp_cur_consume</name><parameter_list>(<parameter><type><name>_c</name></type></parameter>,<parameter><type><name>_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { _c-&gt;p += _len; _c-&gt;left -= _len; } while(0)</cpp:value></cpp:define>

<comment type="block">/* When there is not enough room we set an error in the cursor and return. This
 * is very common across the code so we have a macro to make the code look
 * a bit simpler. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mp_cur_need</name><parameter_list>(<parameter><type><name>_c</name></type></parameter>,<parameter><type><name>_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    if (_c-&gt;left &lt; _len) { \
        _c-&gt;err = MP_CUR_ERROR_EOF; \
        return; \
    } \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* ------------------------- Low level MP encoding -------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_bytes</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hdr</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hdrlen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xa0</literal> <operator>|</operator> <operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* fix raw */</comment>
        <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xda</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">0xff00</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>len</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xdb</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">0xff000000</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">0xff0000</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">0xff00</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>len</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* we assume IEEE 754 internal format for single and double precision floats. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_double</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>f</name> <init>= <expr><name>d</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <operator>(</operator><name>double</name><operator>)</operator><name>f</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xca</literal></expr>;</expr_stmt>    <comment type="block">/* float IEEE 754 */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memrevifle</name><argument_list>(<argument><expr><name>b</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xcb</literal></expr>;</expr_stmt>    <comment type="block">/* double IEEE 754 */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memrevifle</name><argument_list>(<argument><expr><name>b</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_int</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>enclen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>    <comment type="block">/* positive fixnum */</comment>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xcc</literal></expr>;</expr_stmt>        <comment type="block">/* uint 8 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xcd</literal></expr>;</expr_stmt>        <comment type="block">/* uint 16 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0xffffffffLL</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xce</literal></expr>;</expr_stmt>        <comment type="block">/* uint 32 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xcf</literal></expr>;</expr_stmt>        <comment type="block">/* uint 64 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00000000000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">32</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>signed</name> <name>char</name><operator>)</operator><name>n</name><operator>)</operator></expr>;</expr_stmt>   <comment type="block">/* negative fixnum */</comment>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xd0</literal></expr>;</expr_stmt>        <comment type="block">/* int 8 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">32768</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xd1</literal></expr>;</expr_stmt>        <comment type="block">/* int 16 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">2147483648LL</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xd2</literal></expr>;</expr_stmt>        <comment type="block">/* int 32 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xd3</literal></expr>;</expr_stmt>        <comment type="block">/* int 64 */</comment>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00000000000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_array</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>enclen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">15</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x90</literal> <operator>|</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* fix array */</comment>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">65535</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xdc</literal></expr>;</expr_stmt>                <comment type="block">/* array 16 */</comment>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xdd</literal></expr>;</expr_stmt>                <comment type="block">/* array 32 */</comment>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_map</name><parameter_list>(<parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>enclen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">15</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* fix map */</comment>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">65535</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xde</literal></expr>;</expr_stmt>                <comment type="block">/* map 16 */</comment>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xdf</literal></expr>;</expr_stmt>                <comment type="block">/* map 32 */</comment>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------- Lua types encoding --------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_string</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lua_tolstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mp_encode_bytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_bool</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0xc3</literal></expr> </then><else>: <expr><literal type="number">0xc2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Lua 5.3 has a built in 64-bit integer type */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_integer</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">503</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>BITS_32</name></expr></cpp:if>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>i</name> <init>= <expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i</name> <init>= <expr><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>mp_encode_int</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Lua 5.2 and lower only has 64-bit doubles, so we need to
 * detect if the double may be representable as an int
 * for Lua &lt; 5.3 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_number</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_INT64_EQUIVALENT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>mp_encode_lua_integer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>mp_encode_double</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a lua table into a message pack list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_table_as_array</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">502</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>lua_objlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>lua_rawlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>mp_encode_array</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_encode_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>level</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Convert a lua table into a message pack key-value map. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_table_as_map</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* First step: count keys into table. No other way to do it with the
     * Lua API, we need to iterate a first time. Note that an alternative
     * would be to do a single run, and then hack the buffer to insert the
     * map opcodes for message pack. Too hackish for this lib. */</comment>
    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>lua_next</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* remove value, keep key for next iteration. */</comment>
        <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Step two: actually encoding of the map. */</comment>
    <expr_stmt><expr><call><name>mp_encode_map</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>lua_next</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Stack: ... key value */</comment>
        <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Stack: ... key value key */</comment>
        <expr_stmt><expr><call><name>mp_encode_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>level</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* encode key */</comment>
        <expr_stmt><expr><call><name>mp_encode_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>level</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* encode val */</comment>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Returns true if the Lua table on top of the stack is exclusively composed
 * of keys from numerical keys from 1 up to N, with N being the total number
 * of elements, without any hole in the middle. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>table_is_an_array</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">503</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Stack top on function entry */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>stacktop</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>stacktop</name> <operator>=</operator> <call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>lua_next</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Stack: ... key value */</comment>
        <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Stack: ... key */</comment>
        <comment type="block">/* The &lt;= 0 check is valid here because we're comparing indexes. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">503</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>LUA_TNUMBER</name> <operator>!=</operator> <call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name>n</name> <operator>=</operator> <call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>!</operator><call><name>IS_INT_EQUIVALENT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>n</name> <operator>=</operator> <call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stacktop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <name>max</name></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>max</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* We have the total number of elements in "count". Also we have
     * the max index encountered in "max". We can't reach this code
     * if there are indexes &lt;= 0. If you also note that there can not be
     * repeated keys into a table, you have that if max==count you are sure
     * that there are all the keys form 1 to count (both included). */</comment>
    <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stacktop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>max</name> <operator>==</operator> <name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If the length operator returns non-zero, that is, there is at least
 * an object at key '1', we serialize to message pack list. Otherwise
 * we use a map. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_table</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>table_is_an_array</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_encode_lua_table_as_array</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_encode_lua_table_as_map</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_null</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>L</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xc0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mp_buf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mp_encode_lua_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Limit the encoding of nested tables to a specified maximum depth, so that
     * we survive when called against circular references in tables. */</comment>
    <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>LUA_TTABLE</name> <operator>&amp;&amp;</operator> <name>level</name> <operator>==</operator> <name>LUACMSGPACK_MAX_NESTING</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <name>LUA_TNIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <switch>switch<condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_TSTRING</name></expr>:</case> <expr_stmt><expr><call><name>mp_encode_lua_string</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LUA_TBOOLEAN</name></expr>:</case> <expr_stmt><expr><call><name>mp_encode_lua_bool</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LUA_TNUMBER</name></expr>:</case>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">503</literal></expr></cpp:if>
        <expr_stmt><expr><call><name>mp_encode_lua_number</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>mp_encode_lua_integer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>mp_encode_lua_number</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>LUA_TTABLE</name></expr>:</case> <expr_stmt><expr><call><name>mp_encode_lua_table</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>mp_encode_lua_null</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Packs all arguments as a stream for multiple upacking later.
 * Returns error if no arguments provided.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mp_pack</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_buf</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"MessagePack pack needs input."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>mp_buf_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Copy argument i to top of stack for _encode processing;
         * the encode function pops it from the stack when complete. */</comment>
        <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>mp_encode_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>b</name></name></expr></argument>,<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Reuse the buffer for the next operation by
         * setting its free count to the total buffer size
         * and the current position to zero. */</comment>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>mp_buf_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Concatenate all nargs buffers together */</comment>
    <expr_stmt><expr><call><name>lua_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------- Decoding --------------------------------- */</comment>

<function_decl><type><name>void</name></type> <name>mp_decode_to_lua_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_cur</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>mp_decode_to_lua_array</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_cur</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>UINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>index</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_decode_to_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mp_decode_to_lua_hash</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_cur</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>UINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>mp_decode_to_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* key */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>mp_decode_to_lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* value */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Decode a Message Pack raw object pointed by the string cursor 'c' to
 * a Lua type, that is left as the only result on the stack. */</comment>
<function><type><name>void</name></type> <name>mp_decode_to_lua_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>mp_cur</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we return more than 18 elements, we must resize the stack to
     * fit all our return values.  But, there is no way to
     * determine how many objects a msgpack will unpack to up front, so
     * we request a +1 larger stack on each iteration (noop if stack is
     * big enough, and when stack does require resize it doubles in size) */</comment>
    <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
        <argument><expr><literal type="string">"too many return values at once; "</literal>
        <literal type="string">"use unpack_one or unpack_limit instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">0xcc</literal></expr>:</case>  <comment type="block">/* uint 8 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushunsigned</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xd0</literal></expr>:</case>  <comment type="block">/* int 8 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><name>signed</name> <name>char</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xcd</literal></expr>:</case>  <comment type="block">/* uint 16 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushunsigned</name><argument_list>(<argument><expr><name>L</name></expr></argument>,
            <argument><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
             <name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xd1</literal></expr>:</case>  <comment type="block">/* int 16 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><name>int16_t</name><operator>)</operator>
            <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
             <name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xce</literal></expr>:</case>  <comment type="block">/* uint 32 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushunsigned</name><argument_list>(<argument><expr><name>L</name></expr></argument>,
            <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
             <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xd2</literal></expr>:</case>  <comment type="block">/* int 32 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,
            <argument><expr><operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
             <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xcf</literal></expr>:</case>  <comment type="block">/* uint 64 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushunsigned</name><argument_list>(<argument><expr><name>L</name></expr></argument>,
            <argument><expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
             <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_cur_consume</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">0xd3</literal></expr>:</case>  <comment type="block">/* int 64 */</comment>
        <expr_stmt><expr><call><name>mp_cur_need</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">503</literal></expr></cpp:if>
        <macro><name>lua_pushnumber</name><argument_list>(<argument>L</argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <argument>lua_pushinteger(L,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            ((int64_t)c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">56</literal>) |
            ((int64_t)c-&gt;p[<literal type="number">2</literal>] &lt;&lt; <literal type="number">48</literal>) |
            ((int64_t)c-&gt;p[<literal type="number">3</literal>] &lt;&lt; <literal type="number">40</literal>) |
            ((int64_t)c-&gt;p[<literal type="number">4</literal>] &lt;&lt; <literal type="number">32</literal>) |
            ((int64_t)c-&gt;p[<literal type="number">5</literal>] &lt;&lt; <literal type="number">24</literal>) |
            ((int64_t)c-&gt;p[<literal type="number">6</literal>] &lt;&lt; <literal type="number">16</literal>) |
            ((int64_t)c-&gt;p[<literal type="number">7</literal>] &lt;&lt; <literal type="number">8</literal>) |
             (int64_t)c-&gt;p[<literal type="number">8</literal>]);
        mp_cur_consume(c,<literal type="number">9</literal>);
        break;
    case <literal type="number">0xc0</literal>:  <comment type="block">/* nil */</comment>
        lua_pushnil(L);
        mp_cur_consume(c,<literal type="number">1</literal>);
        break;
    case <literal type="number">0xc3</literal>:  <comment type="block">/* true */</comment>
        lua_pushboolean(L,<literal type="number">1</literal>);
        mp_cur_consume(c,<literal type="number">1</literal>);
        break;
    case <literal type="number">0xc2</literal>:  <comment type="block">/* false */</comment>
        lua_pushboolean(L,<literal type="number">0</literal>);
        mp_cur_consume(c,<literal type="number">1</literal>);
        break;
    case <literal type="number">0xca</literal>:  <comment type="block">/* float */</comment>
        mp_cur_need(c,<literal type="number">5</literal>);
        assert(sizeof(float) == <literal type="number">4</literal>);
        {
            float f;
            memcpy(&amp;f,c-&gt;p+<literal type="number">1</literal>,<literal type="number">4</literal>);
            memrevifle(&amp;f,<literal type="number">4</literal>);
            lua_pushnumber(L,f);
            mp_cur_consume(c,<literal type="number">5</literal>);
        }
        break;
    case <literal type="number">0xcb</literal>:  <comment type="block">/* double */</comment>
        mp_cur_need(c,<literal type="number">9</literal>);
        assert(sizeof(double) == <literal type="number">8</literal>);
        {
            double d;
            memcpy(&amp;d,c-&gt;p+<literal type="number">1</literal>,<literal type="number">8</literal>);
            memrevifle(&amp;d,<literal type="number">8</literal>);
            lua_pushnumber(L,d);
            mp_cur_consume(c,<literal type="number">9</literal>);
        }
        break;
    case <literal type="number">0xda</literal>:  <comment type="block">/* raw 16 */</comment>
        mp_cur_need(c,<literal type="number">3</literal>);
        {
            size_t l = (c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">8</literal>) | c-&gt;p[<literal type="number">2</literal>];
            mp_cur_need(c,<literal type="number">3</literal>+l);
            lua_pushlstring(L,(char*)c-&gt;p+<literal type="number">3</literal>,l);
            mp_cur_consume(c,<literal type="number">3</literal>+l);
        }
        break;
    case <literal type="number">0xdb</literal>:  <comment type="block">/* raw 32 */</comment>
        mp_cur_need(c,<literal type="number">5</literal>);
        {
            size_t l = ((size_t)c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">24</literal>) |
                       ((size_t)c-&gt;p[<literal type="number">2</literal>] &lt;&lt; <literal type="number">16</literal>) |
                       ((size_t)c-&gt;p[<literal type="number">3</literal>] &lt;&lt; <literal type="number">8</literal>) |
                       (size_t)c-&gt;p[<literal type="number">4</literal>];
            mp_cur_consume(c,<literal type="number">5</literal>);
            mp_cur_need(c,l);
            lua_pushlstring(L,(char*)c-&gt;p,l);
            mp_cur_consume(c,l);
        }
        break;
    case <literal type="number">0xdc</literal>:  <comment type="block">/* array 16 */</comment>
        mp_cur_need(c,<literal type="number">3</literal>);
        {
            size_t l = (c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">8</literal>) | c-&gt;p[<literal type="number">2</literal>];
            mp_cur_consume(c,<literal type="number">3</literal>);
            mp_decode_to_lua_array(L,c,l);
        }
        break;
    case <literal type="number">0xdd</literal>:  <comment type="block">/* array 32 */</comment>
        mp_cur_need(c,<literal type="number">5</literal>);
        {
            size_t l = ((size_t)c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">24</literal>) |
                       ((size_t)c-&gt;p[<literal type="number">2</literal>] &lt;&lt; <literal type="number">16</literal>) |
                       ((size_t)c-&gt;p[<literal type="number">3</literal>] &lt;&lt; <literal type="number">8</literal>) |
                       (size_t)c-&gt;p[<literal type="number">4</literal>];
            mp_cur_consume(c,<literal type="number">5</literal>);
            mp_decode_to_lua_array(L,c,l);
        }
        break;
    case <literal type="number">0xde</literal>:  <comment type="block">/* map 16 */</comment>
        mp_cur_need(c,<literal type="number">3</literal>);
        {
            size_t l = (c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">8</literal>) | c-&gt;p[<literal type="number">2</literal>];
            mp_cur_consume(c,<literal type="number">3</literal>);
            mp_decode_to_lua_hash(L,c,l);
        }
        break;
    case <literal type="number">0xdf</literal>:  <comment type="block">/* map 32 */</comment>
        mp_cur_need(c,<literal type="number">5</literal>);
        {
            size_t l = ((size_t)c-&gt;p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">24</literal>) |
                       ((size_t)c-&gt;p[<literal type="number">2</literal>] &lt;&lt; <literal type="number">16</literal>) |
                       ((size_t)c-&gt;p[<literal type="number">3</literal>] &lt;&lt; <literal type="number">8</literal>) |
                       (size_t)c-&gt;p[<literal type="number">4</literal>];
            mp_cur_consume(c,<literal type="number">5</literal>);
            mp_decode_to_lua_hash(L,c,l);
        }
        break;
    default:    <comment type="block">/* types that can't be idenitified by first byte value. */</comment>
        if ((c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0x80</literal>) == <literal type="number">0</literal>) {   <comment type="block">/* positive fixnum */</comment>
            lua_pushunsigned(L,c-&gt;p[<literal type="number">0</literal>]);
            mp_cur_consume(c,<literal type="number">1</literal>);
        } else if ((c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0xe0</literal>) == <literal type="number">0xe0</literal>) {  <comment type="block">/* negative fixnum */</comment>
            lua_pushinteger(L,(signed char)c-&gt;p[<literal type="number">0</literal>]);
            mp_cur_consume(c,<literal type="number">1</literal>);
        } else if ((c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0xe0</literal>) == <literal type="number">0xa0</literal>) {  <comment type="block">/* fix raw */</comment>
            size_t l = c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0x1f</literal>;
            mp_cur_need(c,<literal type="number">1</literal>+l);
            lua_pushlstring(L,(char*)c-&gt;p+<literal type="number">1</literal>,l);
            mp_cur_consume(c,<literal type="number">1</literal>+l);
        } else if ((c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0xf0</literal>) == <literal type="number">0x90</literal>) {  <comment type="block">/* fix map */</comment>
            size_t l = c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0xf</literal>;
            mp_cur_consume(c,<literal type="number">1</literal>);
            mp_decode_to_lua_array(L,c,l);
        } else if ((c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0xf0</literal>) == <literal type="number">0x80</literal>) {  <comment type="block">/* fix map */</comment>
            size_t l = c-&gt;p[<literal type="number">0</literal>] &amp; <literal type="number">0xf</literal>;
            mp_cur_consume(c,<literal type="number">1</literal>);
            mp_decode_to_lua_hash(L,c,l);
        } else {
            c-&gt;err = MP_CUR_ERROR_BADFMT;
        }
    }
}

static int mp_unpack_full(lua_State *L, int limit, int offset) {
    size_t len;
    const char *s;
    mp_cur c;
    int cnt; <comment type="block">/* Number of objects unpacked */</comment>
    int decode_all = (!limit &amp;&amp; !offset);

    s = luaL_checklstring(L,<literal type="number">1</literal>,&amp;len); <comment type="block">/* if no match, exits */</comment>

    if (offset &lt; <literal type="number">0</literal> || limit &lt; <literal type="number">0</literal>) <comment type="block">/* requesting negative off or lim is invalid */</comment>
        return luaL_error(L,
            <literal type="string">"Invalid request to unpack with offset of %d and limit of %d."</literal>,
            offset, len);
    else if (offset &gt; len)
        return luaL_error(L,
            <literal type="string">"Start offset %d greater than input length %d."</literal>, offset, len);

    if (decode_all) limit = INT_MAX;

    mp_cur_init(&amp;c,(const unsigned char *)s+offset,len-offset);

    <comment type="block">/* We loop over the decode because this could be a stream
     * of multiple top-level values serialized together */</comment>
    for(cnt = <literal type="number">0</literal>; c.left &gt; <literal type="number">0</literal> &amp;&amp; cnt &lt; limit; cnt++) {
        mp_decode_to_lua_type(L,&amp;c);

        if (c.err == MP_CUR_ERROR_EOF) {
            return luaL_error(L,<literal type="string">"Missing bytes in input."</literal>);
        } else if (c.err == MP_CUR_ERROR_BADFMT) {
            return luaL_error(L,<literal type="string">"Bad data format in input."</literal>);
        }
    }

    if (!decode_all) {
        <comment type="block">/* c-&gt;left is the remaining size of the input buffer.
         * subtract the entire buffer size from the unprocessed size
         * to get our next start offset */</comment>
        int offset = len - c.left;
        <comment type="block">/* Return offset -1 when we have have processed the entire buffer. */</comment>
        lua_pushinteger(L, c.left == <literal type="number">0</literal> ? -<literal type="number">1</literal> : offset);
        <comment type="block">/* Results are returned with the arg elements still
         * in place. Lua takes care of only returning
         * elements above the args for us.
         * In this case, we have one arg on the stack
         * for this function, so we insert our first return
         * value at position 2. */</comment>
        lua_insert(L, <literal type="number">2</literal>);
        cnt += <literal type="number">1</literal>; <comment type="block">/* increase return count by one to make room for offset */</comment>
    }

    return cnt;
}

static int mp_unpack(lua_State *L) {
    return mp_unpack_full(L, <literal type="number">0</literal>, <literal type="number">0</literal>);
}

static int mp_unpack_one(lua_State *L) {
    int offset = luaL_optinteger(L, <literal type="number">2</literal>, <literal type="number">0</literal>);
    <comment type="block">/* Variable pop because offset may not exist */</comment>
    lua_pop(L, lua_gettop(L)-<literal type="number">1</literal>);
    return mp_unpack_full(L, <literal type="number">1</literal>, offset);
}

static int mp_unpack_limit(lua_State *L) {
    int limit = luaL_checkinteger(L, <literal type="number">2</literal>);
    int offset = luaL_optinteger(L, <literal type="number">3</literal>, <literal type="number">0</literal>);
    <comment type="block">/* Variable pop because offset may not exist */</comment>
    lua_pop(L, lua_gettop(L)-<literal type="number">1</literal>);

    return mp_unpack_full(L, limit, offset);
}

static int mp_safe(lua_State *L) {
    int argc</argument>, <argument>err</argument>, <argument>total_results;

    argc = lua_gettop(L);

    <comment type="block">/* This adds our function to the bottom of the stack
     * (the "call this function" position) */</comment>
    lua_pushvalue(L, lua_upvalueindex(<literal type="number">1</literal>));
    lua_insert(L, <literal type="number">1</literal>);

    err = lua_pcall(L, argc, LUA_MULTRET, <literal type="number">0</literal>);
    total_results = lua_gettop(L);

    if (!err) {
        return total_results;
    } else {
        lua_pushnil(L);
        lua_insert(L,-<literal type="number">2</literal>);
        return <literal type="number">2</literal>;
    }
}

<comment type="block">/* -------------------------------------------------------------------------- */</comment>
static const struct luaL_Reg cmds[] = {
    {<literal type="string">"pack"</literal></argument>, <argument>mp_pack}</argument>,
    <argument>{<literal type="string">"unpack"</literal></argument>, <argument>mp_unpack}</argument>,
    <argument>{<literal type="string">"unpack_one"</literal></argument>, <argument>mp_unpack_one}</argument>,
    <argument>{<literal type="string">"unpack_limit"</literal></argument>, <argument>mp_unpack_limit}</argument>,
    <argument>{<literal type="number">0</literal>}
};

static int luaopen_create(lua_State *L) {
    int i;
    <comment type="block">/* Manually construct our module table instead of
     * relying on _register or _newlib */</comment>
    lua_newtable(L);

    for (i = <literal type="number">0</literal>; i &lt; (sizeof(cmds)/sizeof(*cmds) - <literal type="number">1</literal>); i++) {
        lua_pushcfunction(L, cmds[i].func);
        lua_setfield(L, -<literal type="number">2</literal>, cmds[i].name);
    }

    <comment type="block">/* Add metadata */</comment>
    lua_pushliteral(L, LUACMSGPACK_NAME);
    lua_setfield(L, -<literal type="number">2</literal>, <literal type="string">"_NAME"</literal>);
    lua_pushliteral(L, LUACMSGPACK_VERSION);
    lua_setfield(L, -<literal type="number">2</literal>, <literal type="string">"_VERSION"</literal>);
    lua_pushliteral(L, LUACMSGPACK_COPYRIGHT);
    lua_setfield(L, -<literal type="number">2</literal>, <literal type="string">"_COPYRIGHT"</literal>);
    lua_pushliteral(L, LUACMSGPACK_DESCRIPTION);
    lua_setfield(L, -<literal type="number">2</literal>, <literal type="string">"_DESCRIPTION"</literal>);
    return <literal type="number">1</literal>;
}

LUALIB_API int luaopen_cmsgpack(lua_State *L) {
    luaopen_create(L);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">502</literal></expr></cpp:if>
    <comment type="block">/* Register name globally for 5.1 */</comment>
    lua_pushvalue(L, -<literal type="number">1</literal>);
    lua_setglobal(L, LUACMSGPACK_NAME);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    return <literal type="number">1</literal>;
}

LUALIB_API int luaopen_cmsgpack_safe(lua_State *L) {
    int i;

    luaopen_cmsgpack(L);

    <comment type="block">/* Wrap all functions in the safe handler */</comment>
    for (i = <literal type="number">0</literal>; i &lt; (sizeof(cmds)/sizeof(*cmds) - <literal type="number">1</literal>); i++) {
        lua_getfield(L, -<literal type="number">1</literal>, cmds[i].name);
        lua_pushcclosure(L, mp_safe, <literal type="number">1</literal>);
        lua_setfield(L, -<literal type="number">2</literal>, cmds[i].name);
    }

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">502</literal></expr></cpp:if>
    <comment type="block">/* Register name globally for 5.1 */</comment>
    lua_pushvalue(L, -<literal type="number">1</literal>);
    lua_setglobal(L, LUACMSGPACK_SAFE_NAME);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    return <literal type="number">1</literal>;
}</argument></argument_list></macro></block_content></block></switch></block_content></block></function>

<comment type="block" format="doxygen">/******************************************************************************
* Copyright (C) 2012 Salvatore Sanfilippo.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/</comment>
</unit>
