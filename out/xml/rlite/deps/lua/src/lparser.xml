<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/rlite/deps/lua/src/lparser.c"><comment type="block">/*
** $Id: lparser.c,v 2.42.1.4 2011/10/21 19:31:42 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lparser_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lopcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasmultret</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((k) == VCALL || (k) == VVARARG)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getlocvar</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaY_checklimit</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>l</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>if ((v)&gt;(l)) errorlimit(fs,l,m)</cpp:value></cpp:define>


<comment type="block">/*
** nodes for block list (list of active blocks)
*/</comment>
<typedef>typedef <type><struct>struct <name>BlockCnt</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>BlockCnt</name></name> <modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>  <comment type="block">/* chain */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>breaklist</name></decl>;</decl_stmt>  <comment type="block">/* list of jumps out of this loop */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>nactvar</name></decl>;</decl_stmt>  <comment type="block">/* # active locals outside the breakable structure */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>upval</name></decl>;</decl_stmt>  <comment type="block">/* true if some variable in the block is an upvalue */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>isbreakable</name></decl>;</decl_stmt>  <comment type="block">/* true if `block' is a loop */</comment>
}</block></struct></type> <name>BlockCnt</name>;</typedef>



<comment type="block">/*
** prototypes for recursive non-terminal functions
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expr</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>void</name></type> <name>anchor_token</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_NAME</name> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_STRING</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaX_newstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>error_expected</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,
      <argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LUA_QS</name> <literal type="string">" expected"</literal></expr></argument>, <argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>errorlimit</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
    <expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"main function has more than %d %s"</literal></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr> </then><else>:
    <expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"function at line %d has more than %d %s"</literal></expr></argument>,
                            <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>testnext</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>c</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>check</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>error_expected</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>checknext</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_condition</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ if (!(c)) luaX_syntaxerror(ls, msg); }</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <name>void</name></type> <name>check_match</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>who</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>error_expected</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,
             <argument><expr><name>LUA_QS</name> <literal type="string">" expected (to close "</literal> <name>LUA_QS</name> <literal type="string">" at line %d)"</literal></expr></argument>,
              <argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>who</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TString</name> <modifier>*</modifier></type><name>str_checkname</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>init_exp</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>expkind</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>codestring</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><call><name>luaK_stringK</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>checkname</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>registerlocalvar</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>oldsize</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>,
                  <argument><expr><name>LocVar</name></expr></argument>, <argument><expr><name>SHRT_MAX</name></expr></argument>, <argument><expr><literal type="string">"too many local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>varname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr>]</index></name><operator>.</operator><name>varname</name> <operator>=</operator> <name>varname</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_localvarliteral</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>new_localvar(ls, luaX_newstring(ls, "" v, (sizeof(v)/sizeof(char))-1), n)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>new_localvar</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>LUAI_MAXVARS</name></expr></argument>, <argument><expr><literal type="string">"local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>actvar</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>n</name></expr>]</index></name> <operator>=</operator> <macro><name>cast</name><argument_list>(<argument>unsigned short</argument>, <argument>registerlocalvar(ls, name)</argument>)</argument_list></macro></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>adjustlocalvars</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>+</operator> <name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>nvars</name></expr>;</condition> <incr><expr><name>nvars</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>-</operator> <name>nvars</name></expr></argument>)</argument_list></call><operator>.</operator><name>startpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>removevars</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tolevel</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&gt;</operator> <name>tolevel</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>--</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>endpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>indexupvalue</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>oldsize</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>k</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>&amp;&amp;</operator> <name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <comment type="block">/* new one */</comment>
  <expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>LUAI_MAXUPVALUES</name></expr></argument>, <argument><expr><literal type="string">"upvalues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>,
                  <argument><expr><name>TString</name> <operator>*</operator></expr></argument>, <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>]</index></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name> <operator>||</operator> <name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>]</index></name><operator>.</operator><name>k</name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>]</index></name><operator>.</operator><name>info</name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>searchvar</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* not found */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>markupval</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>bl</name> <operator>&amp;&amp;</operator> <name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&gt;</operator> <name>level</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bl</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name>bl</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>singlevaraux</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no more levels? */</comment>
    <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>VGLOBAL</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* default is global variable */</comment>
    <return>return <expr><name>VGLOBAL</name></expr>;</return>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name>searchvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* look up at current level */</comment>
    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>VLOCAL</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>markupval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* local will be used as an upval */</comment>
      <return>return <expr><name>VLOCAL</name></expr>;</return>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* not found at current level; try upper one */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>VGLOBAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>VGLOBAL</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>indexupvalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else was LOCAL or UPVAL */</comment>
      <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VUPVAL</name></expr>;</expr_stmt>  <comment type="block">/* upvalue in this level */</comment>
      <return>return <expr><name>VUPVAL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>singlevar</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>VGLOBAL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_stringK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* info points to global name */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>adjust_assign</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nexps</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><name>nvars</name> <operator>-</operator> <name>nexps</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>extra</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* includes call itself */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>luaK_setreturns</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* last exp. provides the difference */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>extra</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* close last expression */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>reg</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaK_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>enterlevel</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>ls</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>&gt;</operator> <name>LUAI_MAXCCALLS</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"chunk has too many syntax levels"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leavelevel</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((ls)-&gt;L-&gt;nCcalls--)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>enterblock</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>, <parameter><decl><type><name>lu_byte</name></type> <name>isbreakable</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>breaklist</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>isbreakable</name></name> <operator>=</operator> <name>isbreakable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name>bl</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>leaveblock</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>removevars</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSE</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* a block either controls scope or breaks (never both) */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>bl</name><operator>-&gt;</operator><name>isbreakable</name></name> <operator>||</operator> <operator>!</operator><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>  <comment type="block">/* free registers */</comment>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>breaklist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>pushclosure</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>oldsize</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>, <argument><expr><name>Proto</name> <operator>*</operator></expr></argument>,
                  <argument><expr><name>MAXARG_Bx</name></expr></argument>, <argument><expr><literal type="string">"constant table overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>f</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VRELOCABLE</name></expr></argument>, <argument><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSURE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>func</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>OpCode</name></type> <name>o</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>k</name> <operator>==</operator> <name>VLOCAL</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_MOVE</name></expr> </then><else>: <expr><name>OP_GETUPVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>open_func</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>luaF_newproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr>;</expr_stmt>  <comment type="block">/* linked list of funcstates */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name> <operator>=</operator> <name>ls</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* registers 0/1 are always valid */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* anchor table of constants and prototype (to avoid being collected) */</comment>
  <expr_stmt><expr><call><name>sethvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setptvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>close_func</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>removevars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* final return */</comment>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name>Instruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr></argument>, <argument><expr><name>Proto</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr></argument>, <argument><expr><name>LocVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>, <argument><expr><name>TString</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>luaG_checkcode</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
  <comment type="block">/* last token read was anchored in defunct function; must reanchor it */</comment>
  <if_stmt><if>if <condition>(<expr><name>fs</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>anchor_token</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* remove table and prototype from the stack */</comment>
</block_content>}</block></function>


<function><type><name>Proto</name> <modifier>*</modifier></type><name>luaY_parser</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ZIO</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>Mbuffer</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>LexState</name></name></type> <name>lexstate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>FuncState</name></name></type> <name>funcstate</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>lexstate</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_setinput</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>open_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>funcstate</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>=</operator> <name>VARARG_ISVARARG</name></expr>;</expr_stmt>  <comment type="block">/* main func. is always vararg */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read first token */</comment>
  <expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>, <argument><expr><name>TK_EOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>funcstate</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>funcstate</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>nups</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>lexstate</name><operator>.</operator><name>fs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>funcstate</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*============================================================*/</comment>
<comment type="block">/* GRAMMAR RULES */</comment>
<comment type="block">/*============================================================*/</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>field</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* field -&gt; ['.' | ':'] NAME */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip the dot or colon */</comment>
  <expr_stmt><expr><call><name>checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>yindex</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* index -&gt; '[' expr ']' */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip the '[' */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_exp2val</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/</comment>


<struct>struct <name>ConsControl</name> <block>{
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>  <comment type="block">/* last list item read */</comment>
  <decl_stmt><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>  <comment type="block">/* table descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nh</name></decl>;</decl_stmt>  <comment type="block">/* total number of `record' elements */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>na</name></decl>;</decl_stmt>  <comment type="block">/* total number of array elements */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tostore</name></decl>;</decl_stmt>  <comment type="block">/* number of array elements pending to be stored */</comment>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>void</name></type> <name>recfield</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* recfield -&gt; (NAME | `['exp1`]') = exp1 */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reg</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rkkey</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_NAME</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>nh</name></name></expr></argument>, <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">"items in a constructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* ls-&gt;t.token == '[' */</comment>
    <expr_stmt><expr><call><name>yindex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nh</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rkkey</name> <operator>=</operator> <call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETTABLE</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>rkkey</name></expr></argument>, <argument><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>  <comment type="block">/* free registers */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>closelistfield</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* there is no list item */</comment>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name> <operator>==</operator> <name>LFIELDS_PER_FLUSH</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* flush */</comment>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* no more items pending */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>lastlistfield</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* do not count last expression (unknown number of elements) */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>listfield</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">"items in a constructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>constructor</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* constructor -&gt; ?? */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_NEWTABLE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ConsControl</name></name></type> <name>cc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>na</name></name> <operator>=</operator> <name><name>cc</name><operator>.</operator><name>nh</name></name> <operator>=</operator> <name><name>cc</name><operator>.</operator><name>tostore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>VRELOCABLE</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>VVOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no value (yet) */</comment>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* fix it at stack top (for gc) */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cc</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VVOID</name> <operator>||</operator> <name><name>cc</name><operator>.</operator><name>tostore</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>closelistfield</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TK_NAME</name></expr>:</case> <block>{<block_content>  <comment type="block">/* may be listfields or recfields */</comment>
        <expr_stmt><expr><call><name>luaX_lookahead</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>token</name></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* expression? */</comment>
          <expr_stmt><expr><call><name>listfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>recfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* constructor_item -&gt; recfield */</comment>
        <expr_stmt><expr><call><name>recfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>  <comment type="block">/* constructor_part -&gt; listfield */</comment>
        <expr_stmt><expr><call><name>listfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block> while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lastlistfield</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>luaO_int2fb</name><argument_list>(<argument><expr><name><name>cc</name><operator>.</operator><name>na</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* set initial array size */</comment>
  <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>luaO_int2fb</name><argument_list>(<argument><expr><name><name>cc</name><operator>.</operator><name>nh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* set initial table size */</comment>
</block_content>}</block></function>

<comment type="block">/* }====================================================================== */</comment>



<function><type><specifier>static</specifier> <name>void</name></type> <name>parlist</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* parlist -&gt; [ param { `,' param } ] */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nparams</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* is `parlist' not empty? */</comment>
    <do>do <block>{<block_content>
      <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TK_NAME</name></expr>:</case> <block>{<block_content>  <comment type="block">/* param -&gt; NAME */</comment>
          <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nparams</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>TK_DOTS</name></expr>:</case> <block>{<block_content>  <comment type="block">/* param -&gt; `...' */</comment>
          <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_COMPAT_VARARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
          <comment type="block">/* use `arg' as default name */</comment>
          <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>, <argument><expr><name>nparams</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>=</operator> <name>VARARG_HASARG</name> <operator>|</operator> <name>VARARG_NEEDSARG</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>|=</operator> <name>VARARG_ISVARARG</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <default>default:</default> <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"&lt;name&gt; or "</literal> <call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call> <literal type="string">" expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></switch>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>&amp;&amp;</operator> <call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>numparams</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>-</operator> <operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>&amp;</operator> <name>VARARG_HASARG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* reserve register for parameters */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>body</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>needself</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* body -&gt;  `(' parlist `)' chunk END */</comment>
  <decl_stmt><decl><type><name>FuncState</name></type> <name>new_fs</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>open_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>needself</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"self"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>parlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>lastlinedefined</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_FUNCTION</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pushclosure</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>explist1</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* explist1 -&gt; expr { `,' expr } */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* at least one expression */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>funcargs</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>nparams</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'('</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs -&gt; `(' [ explist1 ] `)' */</comment>
      <if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"ambiguous syntax (function call x new statement)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* arg list is empty? */</comment>
        <expr_stmt><expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt></block_content></block></if>
      <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs -&gt; constructor */</comment>
      <expr_stmt><expr><call><name>constructor</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs -&gt; STRING */</comment>
      <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* must use `seminfo' before `next' */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"function arguments expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* base register for call */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>nparams</name> <operator>=</operator> <name>LUA_MULTRET</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* open call */</comment>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* close last argument */</comment>
    <expr_stmt><expr><name>nparams</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <operator>(</operator><name>base</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>VCALL</name></expr></argument>, <argument><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CALL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>nparams</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>base</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* call remove function and arguments and leaves
                            (unless changed) one result */</comment>
</block_content>}</block></function>




<comment type="block">/*
** {======================================================================
** Expression parsing
** =======================================================================
*/</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>prefixexp</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* prefixexp -&gt; NAME | '(' expr ')' */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'('</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_NAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>singlevar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"unexpected symbol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>primaryexp</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* primaryexp -&gt;
        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>prefixexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* field */</comment>
        <expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* `[' exp1 `]' */</comment>
        <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yindex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">':'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* `:' NAME funcargs */</comment>
        <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaK_self</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>funcargs</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'('</literal></expr>:</case> <case>case <expr><name>TK_STRING</name></expr>:</case> <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs */</comment>
        <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>funcargs</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <return>return;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>simpleexp</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |
                  constructor | FUNCTION body | primaryexp */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_NUMBER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKNUM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NIL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VNIL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VTRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_FALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VFALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_DOTS</name></expr>:</case> <block>{<block_content>  <comment type="block">/* vararg */</comment>
      <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name></expr></argument>,
                      <argument><expr><literal type="string">"cannot use "</literal> <call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call> <literal type="string">" outside a vararg function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>&amp;=</operator> <operator>~</operator><name>VARARG_NEEDSARG</name></expr>;</expr_stmt>  <comment type="block">/* don't need 'arg' */</comment>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VVARARG</name></expr></argument>, <argument><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_VARARG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* constructor */</comment>
      <expr_stmt><expr><call><name>constructor</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>UnOpr</name></type> <name>getunopr</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <return>return <expr><name>OPR_NOT</name></expr>;</return>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case> <return>return <expr><name>OPR_MINUS</name></expr>;</return>
    <case>case <expr><literal type="char">'#'</literal></expr>:</case> <return>return <expr><name>OPR_LEN</name></expr>;</return>
    <default>default:</default> <return>return <expr><name>OPR_NOUNOPR</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>getbinopr</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'+'</literal></expr>:</case> <return>return <expr><name>OPR_ADD</name></expr>;</return>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case> <return>return <expr><name>OPR_SUB</name></expr>;</return>
    <case>case <expr><literal type="char">'*'</literal></expr>:</case> <return>return <expr><name>OPR_MUL</name></expr>;</return>
    <case>case <expr><literal type="char">'/'</literal></expr>:</case> <return>return <expr><name>OPR_DIV</name></expr>;</return>
    <case>case <expr><literal type="char">'%'</literal></expr>:</case> <return>return <expr><name>OPR_MOD</name></expr>;</return>
    <case>case <expr><literal type="char">'^'</literal></expr>:</case> <return>return <expr><name>OPR_POW</name></expr>;</return>
    <case>case <expr><name>TK_CONCAT</name></expr>:</case> <return>return <expr><name>OPR_CONCAT</name></expr>;</return>
    <case>case <expr><name>TK_NE</name></expr>:</case> <return>return <expr><name>OPR_NE</name></expr>;</return>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <return>return <expr><name>OPR_EQ</name></expr>;</return>
    <case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <return>return <expr><name>OPR_LT</name></expr>;</return>
    <case>case <expr><name>TK_LE</name></expr>:</case> <return>return <expr><name>OPR_LE</name></expr>;</return>
    <case>case <expr><literal type="char">'&gt;'</literal></expr>:</case> <return>return <expr><name>OPR_GT</name></expr>;</return>
    <case>case <expr><name>TK_GE</name></expr>:</case> <return>return <expr><name>OPR_GE</name></expr>;</return>
    <case>case <expr><name>TK_AND</name></expr>:</case> <return>return <expr><name>OPR_AND</name></expr>;</return>
    <case>case <expr><name>TK_OR</name></expr>:</case> <return>return <expr><name>OPR_OR</name></expr>;</return>
    <default>default:</default> <return>return <expr><name>OPR_NOBINOPR</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>left</name></decl>;</decl_stmt>  <comment type="block">/* left priority for each binary operator */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>right</name></decl>;</decl_stmt> <comment type="block">/* right priority */</comment>
}</block> <decl><name><name>priority</name><index>[]</index></name> <init>= <expr><block>{  <comment type="block">/* ORDER OPR */</comment>
   <expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,  <comment type="block">/* `+' `-' `/' `%' */</comment>
   <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,                 <comment type="block">/* power and concat (right associative) */</comment>
   <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,                  <comment type="block">/* equality and inequality */</comment>
   <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,  <comment type="block">/* order */</comment>
   <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>                   <comment type="block">/* logical (and/or) */</comment>
}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNARY_PRIORITY</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>  <comment type="block">/* priority for unary operators */</comment>


<comment type="block">/*
** subexpr -&gt; (simpleexp | unop subexpr) { binop subexpr }
** where `binop' is any binary operator with a priority higher than `limit'
*/</comment>
<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>subexpr</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BinOpr</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnOpr</name></type> <name>uop</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>uop</name> <operator>=</operator> <call><name>getunopr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>uop</name> <operator>!=</operator> <name>OPR_NOUNOPR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>UNARY_PRIORITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_prefix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>uop</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>simpleexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <comment type="block">/* expand while operators have priorities higher than `limit' */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>getbinopr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>op</name> <operator>!=</operator> <name>OPR_NOBINOPR</name> <operator>&amp;&amp;</operator> <name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>left</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>expdesc</name></type> <name>v2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BinOpr</name></type> <name>nextop</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_infix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* read sub-expression with higher priority */</comment>
    <expr_stmt><expr><name>nextop</name> <operator>=</operator> <call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_posfix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>nextop</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>op</name></expr>;</return>  <comment type="block">/* return first untreated operator */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>expr</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }==================================================================== */</comment>



<comment type="block">/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/</comment>


<function><type><specifier>static</specifier> <name>int</name></type> <name>block_follow</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>token</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_ELSE</name></expr>:</case> <case>case <expr><name>TK_ELSEIF</name></expr>:</case> <case>case <expr><name>TK_END</name></expr>:</case>
    <case>case <expr><name>TK_UNTIL</name></expr>:</case> <case>case <expr><name>TK_EOS</name></expr>:</case>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>block</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* block -&gt; chunk */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>bl</name><operator>.</operator><name>breaklist</name></name> <operator>==</operator> <name>NO_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** structure to chain all variables in the left-hand side of an
** assignment
*/</comment>
<struct>struct <name>LHS_assign</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>  <comment type="block">/* variable (global, local, upvalue, or indexed) */</comment>
}</block>;</struct>


<comment type="block">/*
** check whether, in an assignment to a local variable, the local variable
** is needed in a previous assignment (to a table). If so, save original
** local value in a safe place and use this safe copy in the previous
** assignment.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_conflict</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>LHS_assign</name></name> <modifier>*</modifier></type><name>lh</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* eventual position to save local variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>conflict</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>lh</name></expr>;</condition> <incr><expr><name>lh</name> <operator>=</operator> <name><name>lh</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VINDEXED</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* conflict? */</comment>
        <expr_stmt><expr><name>conflict</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>  <comment type="block">/* previous assignment will use safe copy */</comment>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* conflict? */</comment>
        <expr_stmt><expr><name>conflict</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>  <comment type="block">/* previous assignment will use safe copy */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>conflict</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_MOVE</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* make copy */</comment>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>assignment</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>LHS_assign</name></name> <modifier>*</modifier></type><name>lh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>VLOCAL</name> <operator>&lt;=</operator> <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>&amp;&amp;</operator> <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>&lt;=</operator> <name>VINDEXED</name></expr></argument>,
                      <argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* assignment -&gt; `,' primaryexp assignment */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name></type> <name>nv</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>nv</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>lh</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nv</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nv</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>check_conflict</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>lh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nv</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>LUAI_MAXCCALLS</name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name></expr></argument>,
                    <argument><expr><literal type="string">"variables in assignment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assignment</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nv</name></expr></argument>, <argument><expr><name>nvars</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* assignment -&gt; `=' explist1 */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nexps</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nexps</name> <operator>!=</operator> <name>nvars</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>nexps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>nexps</name> <operator>&gt;</operator> <name>nvars</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-=</operator> <name>nexps</name> <operator>-</operator> <name>nvars</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* remove extra values */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_setoneret</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close last expression */</comment>
      <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>  <comment type="block">/* avoid default */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>VNONRELOC</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* default assignment */</comment>
  <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>cond</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* cond -&gt; exp */</comment>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read condition */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VNIL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>v</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VFALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* `falses' are all equal here */</comment>
  <expr_stmt><expr><call><name>luaK_goiftrue</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>v</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>breakstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>upval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>bl</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bl</name><operator>-&gt;</operator><name>isbreakable</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>upval</name> <operator>|=</operator> <name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bl</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bl</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"no loop to break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>upval</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSE</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bl</name><operator>-&gt;</operator><name>breaklist</name></name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>whilestat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* whilestat -&gt; WHILE cond DO block END */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>whileinit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip WHILE */</comment>
  <expr_stmt><expr><name>whileinit</name> <operator>=</operator> <call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>whileinit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_WHILE</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* false conditions finish the loop */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>repeatstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* repeatstat -&gt; REPEAT block UNTIL cond */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>repeat_init</name> <init>= <expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl1</name></decl>, <decl><type ref="prev"/><name>bl2</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* loop block */</comment>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* scope block */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip REPEAT */</comment>
  <expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_UNTIL</name></expr></argument>, <argument><expr><name>TK_REPEAT</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read condition (inside scope block) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bl2</name><operator>.</operator><name>upval</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no upvalues? */</comment>
    <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish scope */</comment>
    <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>, <argument><expr><name>repeat_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close the loop */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* complete semantics when there are upvalues */</comment>
    <expr_stmt><expr><call><name>breakstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* if condition then break */</comment>
    <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else... */</comment>
    <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish scope... */</comment>
    <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* and repeat */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish loop */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>exp1</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>e</name><operator>.</operator><name>k</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>forbody</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isnum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* forbody -&gt; DO block */</comment>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>prep</name></decl>, <decl><type ref="prev"/><name>endfor</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control variables */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>prep</name> <operator>=</operator> <ternary><condition><expr><name>isnum</name></expr> ?</condition><then> <expr><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_FORPREP</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NO_JUMP</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* scope for declared variables */</comment>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* end of scope for declared variables */</comment>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>prep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>endfor</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>isnum</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_FORLOOP</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NO_JUMP</name></expr></argument>)</argument_list></call></expr> </then><else>:
                     <expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_TFORLOOP</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pretend that `OP_FOR' starts the loop */</comment>
  <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>isnum</name></expr> ?</condition><then> <expr><name>endfor</name></expr> </then><else>: <expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>prep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>fornum</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* fornum -&gt; NAME = exp1,exp1[,exp1] forbody */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for index)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for limit)"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for step)"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* initial value */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* limit */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* optional step */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* default step = 1 */</comment>
    <expr_stmt><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADK</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><call><name>luaK_numberK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>forbody</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>forlist</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>indexname</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* forlist -&gt; NAME {,NAME} IN explist1 forbody */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nvars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* create control variables */</comment>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for generator)"</literal></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for control)"</literal></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* create declared variables */</comment>
  <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>indexname</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_checkstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* extra space to call generator */</comment>
  <expr_stmt><expr><call><name>forbody</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>nvars</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>forstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* forstat -&gt; FOR (fornum | forlist) END */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* scope for loop and control variables */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip `for' */</comment>
  <expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* first variable name */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'='</literal></expr>:</case> <expr_stmt><expr><call><name>fornum</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">','</literal></expr>:</case> <case>case <expr><name>TK_IN</name></expr>:</case> <expr_stmt><expr><call><name>forlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <literal type="string">" or "</literal> <call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"in"</literal></expr></argument>)</argument_list></call> <literal type="string">" expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_FOR</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* loop scope (`break' jumps to this point) */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>test_then_block</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* test_then_block -&gt; [IF | ELSEIF] cond THEN block */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip IF or ELSEIF */</comment>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_THEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* `then' part */</comment>
  <return>return <expr><name>condexit</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ifstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>escapelist</name> <init>= <expr><name>NO_JUMP</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>flist</name> <operator>=</operator> <call><name>test_then_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* IF cond THEN block */</comment>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_ELSEIF</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flist</name> <operator>=</operator> <call><name>test_then_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ELSEIF cond THEN block */</comment>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_ELSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip ELSE (after patch, for correct line info) */</comment>
    <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* `else' part */</comment>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>escapelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_IF</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>localfunc</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>VLOCAL</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* debug information will only see the variable after this point! */</comment>
  <expr_stmt><expr><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><name>startpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>localstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nvars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nexps</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>nexps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>funcname</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* funcname -&gt; NAME {field} [`:' NAME] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>needself</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>singlevar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>needself</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>needself</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>funcstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* funcstat -&gt; FUNCTION funcname body */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>needself</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip FUNCTION */</comment>
  <expr_stmt><expr><name>needself</name> <operator>=</operator> <call><name>funcname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>needself</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* definition `happens' in the first line */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>exprstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* stat -&gt; func | assignment */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* stat -&gt; func */</comment>
    <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* call statement uses no results */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* stat -&gt; assignment */</comment>
    <expr_stmt><expr><name><name>v</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assignment</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>retstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* stat -&gt; RETURN explist */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>nret</name></decl>;</decl_stmt>  <comment type="block">/* registers with returned values */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip RETURN */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>block_follow</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>nret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* return no values */</comment>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name>nret</name> <operator>=</operator> <call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* optional return values */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name> <operator>&amp;&amp;</operator> <name>nret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* tail call? */</comment>
        <expr_stmt><expr><call><name>SET_OPCODE</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OP_TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GETARG_A</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>first</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nret</name> <operator>=</operator> <name>LUA_MULTRET</name></expr>;</expr_stmt>  <comment type="block">/* return all values */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>nret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* only one single value? */</comment>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* values must go to the `stack' */</comment>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>  <comment type="block">/* return all `active' values */</comment>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>nret</name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>luaK_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>nret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>statement</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* may be needed for error messages */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_IF</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; ifstat */</comment>
      <expr_stmt><expr><call><name>ifstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_WHILE</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; whilestat */</comment>
      <expr_stmt><expr><call><name>whilestat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_DO</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; DO block END */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip DO */</comment>
      <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_DO</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_FOR</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; forstat */</comment>
      <expr_stmt><expr><call><name>forstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_REPEAT</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; repeatstat */</comment>
      <expr_stmt><expr><call><name>repeatstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>funcstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* stat -&gt; funcstat */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_LOCAL</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; localstat */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip LOCAL */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_FUNCTION</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* local function? */</comment>
        <expr_stmt><expr><call><name>localfunc</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>localstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_RETURN</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; retstat */</comment>
      <expr_stmt><expr><call><name>retstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* must be last statement */</comment>
    </block_content>}</block>
    <case>case <expr><name>TK_BREAK</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; breakstat */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip BREAK */</comment>
      <expr_stmt><expr><call><name>breakstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* must be last statement */</comment>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>exprstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* to avoid warnings */</comment>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>chunk</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* chunk -&gt; { stat [`;'] } */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>islast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>!</operator><name>islast</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>block_follow</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>islast</name> <operator>=</operator> <call><name>statement</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>&amp;&amp;</operator>
               <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>  <comment type="block">/* free registers */</comment>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }====================================================================== */</comment>
</unit>
