<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/rlite/src/scripting.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * Copyright (c) 2015, Sebastian Waisbrot &lt;seppo0010 at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *	 this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *	 notice, this list of conditions and the following disclaimer in the
 *	 documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *	 to endorse or promote products derived from this software without
 *	 specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/rlite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/hirlite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/sha1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/rand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lua.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lauxlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lualib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RLITE_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RLITE_VERBOSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RLITE_NOTICE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RLITE_WARNING</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RLITE_LOG_RAW</name></cpp:macro> <cpp:value>(1&lt;&lt;10)</cpp:value></cpp:define> <comment type="block">/* Modifier to log without timestamp */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RLITE_DEFAULT_VERBOSITY</name></cpp:macro> <cpp:value>RLITE_NOTICE</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>sha1hex</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>digest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type> <name>setScript</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>scriptlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>hash</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>sha1hex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>scriptlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RL_CALL</name><argument_list>(<argument><expr><name>rl_select_internal</name></expr></argument>, <argument><expr><name>RL_OK</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>RLITE_INTERNAL_DB_LUA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RL_CALL</name><argument_list>(<argument><expr><name>rl_set</name></expr></argument>, <argument><expr><name>RL_OK</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>hash</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>script</name></expr></argument>, <argument><expr><name>scriptlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>rl_select_internal</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>RLITE_INTERNAL_DB_NO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getScript</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>hash</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>scriptlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RL_CALL</name><argument_list>(<argument><expr><name>rl_select_internal</name></expr></argument>, <argument><expr><name>RL_OK</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>RLITE_INTERNAL_DB_LUA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RL_CALL</name><argument_list>(<argument><expr><name>rl_get</name></expr></argument>, <argument><expr><name>RL_OK</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>hash</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>script</name></expr></argument>, <argument><expr><name>scriptlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>rl_select_internal</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>RLITE_INTERNAL_DB_NO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rliteLogRaw</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> <name>UNUSED</name><parameter_list>(<parameter><decl><type><name>level</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>UNUSED</name><parameter_list>(<parameter><decl><type><name>fmt</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// TODO</comment>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>rliteLog</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> <name>UNUSED</name><parameter_list>(<parameter><decl><type><name>level</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>UNUSED</name><parameter_list>(<parameter><decl><type><name>fmt</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// TODO</comment>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>rliteToLuaType_Int</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rliteToLuaType_Bulk</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rliteToLuaType_Status</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rliteToLuaType_Error</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rliteToLuaType_MultiBulk</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rlite_math_random</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rlite_math_randomseed</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Take a Redis reply in the Redis protocol format and convert it into a
 * Lua type. Thanks to this function, and the introduction of not connected
 * clients, it is trivial to implement the rlite() lua function.
 *
 * Basically we take the arguments, execute the Redis command in the context
 * of a non connected client, then take the generated reply and convert it
 * into a suitable Lua type. With this trick the scripting feature does not
 * need the introduction of a full Redis internals API. Basically the script
 * is like a normal client that bypasses all the slow I/O paths.
 *
 * Note: in this function we do not do any sanity check as the reply is
 * generated by Redis directly. This allows us to go faster.
 * The reply string can be altered during the parsing as it is discarded
 * after the conversion is completed.
 *
 * Errors are returned as a table with a single 'err' field set to the
 * error string.
 */</comment>

<function><type><name>void</name></type> <name>rliteToLuaType</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>RLITE_REPLY_INTEGER</name></expr>:</case>
		<expr_stmt><expr><call><name>rliteToLuaType_Int</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>RLITE_REPLY_NIL</name></expr>:</case>
		<expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>RLITE_REPLY_STRING</name></expr>:</case>
		<expr_stmt><expr><call><name>rliteToLuaType_Bulk</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>RLITE_REPLY_STATUS</name></expr>:</case>
		<expr_stmt><expr><call><name>rliteToLuaType_Status</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>RLITE_REPLY_ERROR</name></expr>:</case>
		<expr_stmt><expr><call><name>rliteToLuaType_Error</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>RLITE_REPLY_ARRAY</name></expr>:</case>
		<expr_stmt><expr><call><name>rliteToLuaType_MultiBulk</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rliteToLuaType_Int</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name><name>reply</name><operator>-&gt;</operator><name>integer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rliteToLuaType_Bulk</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rliteToLuaType_Status</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"ok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rliteToLuaType_Error</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"err"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rliteToLuaType_MultiBulk</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rliteToLuaType</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>luaPushError</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>lua_Debug</name></type> <name>dbg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"err"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Attempt to figure out where this function was called, if possible */</comment>
	<if_stmt><if>if<condition>(<expr><call><name>lua_getstack</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lua_getinfo</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"nSl"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// 4 for formatting, 1 for null termination, 35 ought to be enough for an integer</comment>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dbg</name><operator>.</operator><name>source</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">40</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s: %d: %s"</literal></expr></argument>,
			<argument><expr><name><name>dbg</name><operator>.</operator><name>source</name></name></expr></argument>, <argument><expr><name><name>dbg</name><operator>.</operator><name>currentline</name></name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Sort the array currently in the stack. We do this to make the output
 * of commands like KEYS or SMEMBERS something deterministic when called
 * from Lua (to play well with AOf/replication).
 *
 * The array is sorted using table.sort itself, and assuming all the
 * list elements are strings. */</comment>
<function><type><name>void</name></type> <name>luaSortArray</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Initial Stack: array */</comment>
	<expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	   <comment type="block">/* Stack: array, table, table.sort */</comment>
	<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	  <comment type="block">/* Stack: array, table, table.sort, array */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Stack: array, table, error */</comment>

		<comment type="block">/* We are not interested in the error, we assume that the problem is
		 * that there are 'false' elements inside the array, so we try
		 * again with a slower function but able to handle this case, that
		 * is: table.sort(table, __rlite__compare_helper) */</comment>
		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			 <comment type="block">/* Stack: array, table */</comment>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Stack: array, table, sort */</comment>
		<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	   <comment type="block">/* Stack: array, table, table.sort */</comment>
		<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	  <comment type="block">/* Stack: array, table, table.sort, array */</comment>
		<expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"__rlite__compare_helper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Stack: array, table, table.sort, array, __rlite__compare_helper */</comment>
		<expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Stack: array (sorted), table */</comment>
	<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			 <comment type="block">/* Stack: array (sorted) */</comment>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>lua_State</name> <modifier>*</modifier></type><name>lua</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>rliteClient</name> <modifier>*</modifier></type><name>lua_caller</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>rliteClient</name> <modifier>*</modifier></type><name>lua_client</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lua_random_dirty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lua_write_dirty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>long</name></type> <name>lua_time_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>long</name></type> <name>lua_time_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lua_timedout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lua_kill</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CMD_OBJCACHE_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CMD_OBJCACHE_MAX_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>luaRedisGenericCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>raise_error</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rliteCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>lua_client</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>

	<comment type="block">/* Cached across calls. */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name> <modifier>*</modifier></type><name>argvlen</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>argv_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>inuse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Recursive calls detection. */</comment>

	<comment type="block">/* By using Lua debug hooks it is possible to trigger a recursive call
	 * to luaRedisGenericCommand(), which normally should never happen.
	 * To make this function reentrant is futile and makes it slower, but
	 * we should at least detect such a misuse, and abort. */</comment>
	<if_stmt><if>if <condition>(<expr><name>inuse</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>recursion_warning</name> <init>=
			<expr><literal type="string">"luaRedisGenericCommand() recursive call detected. "</literal>
			<literal type="string">"Are you doing funny stuff with Lua debug hooks?"</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>rliteLog</name><argument_list>(<argument><expr><name>RLITE_WARNING</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name>recursion_warning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>recursion_warning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>inuse</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Require at least one argument */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,
			<argument><expr><literal type="string">"Please specify at least one argument for rlite.call()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inuse</name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build the arguments vector */</comment>
	<if_stmt><if>if <condition>(<expr><name>argv_size</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>rl_realloc</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argvlen</name> <operator>=</operator> <call><name>rl_realloc</name><argument_list>(<argument><expr><name>argvlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argv_size</name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>obj_s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>obj_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>dbuf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNUMBER</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* We can't use lua_tolstring() for number -&gt; string conversion
			 * since Lua uses a format specifier that loses precision. */</comment>
			<decl_stmt><decl><type><name>lua_Number</name></type> <name>num</name> <init>= <expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>obj_len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>dbuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%.17g"</literal></expr></argument>,<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>obj_s</name> <operator>=</operator> <name>dbuf</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>obj_s</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>obj_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>obj_s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Not a string. */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>obj_s</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>obj_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Check if one of the arguments passed by the Lua script
	 * is not a string or an integer (lua_isstring() return true for
	 * integers as well). */</comment>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,
			<argument><expr><literal type="string">"Lua rlite() command arguments must be strings or integers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inuse</name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Setup our fake client for command execution */</comment>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name></name> <operator>=</operator> <name>argvlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

	<comment type="block">/* Command lookup */</comment>
	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>rliteLookupCommand</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name> <operator>!=</operator> <name>argc</name><operator>)</operator> <operator>||</operator>
				   <operator>(</operator><name>argc</name> <operator>&lt;</operator> <operator>-</operator><name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,
				<argument><expr><literal type="string">"Wrong number of args calling Redis command From Lua script"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"Unknown Redis command called from Lua script"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There are commands that are not allowed inside scripts. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RLITE_CMD_NOSCRIPT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"This Redis command is not allowed from scripts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Write commands are forbidden against read-only slaves, or if a
	 * command marked as non-deterministic was already called in the context
	 * of this script. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RLITE_CMD_WRITE</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lua_random_dirty</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,
				<argument><expr><literal type="string">"Write commands not allowed after non deterministic commands"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RLITE_CMD_RANDOM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lua_random_dirty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RLITE_CMD_WRITE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lua_write_dirty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Run the command */</comment>
	<expr_stmt><expr><call><name>rliteAppendCommandClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rliteGetReply</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>raise_error</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>RLITE_REPLY_ERROR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>raise_error</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>rliteToLuaType</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Sort the output array if needed, assuming it is a non-null multi bulk
	 * reply as expected. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RLITE_CMD_SORT_FOR_SCRIPT</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>RLITE_REPLY_ARRAY</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>luaSortArray</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>rliteFreeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>!=</operator> <name>argv</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>argv_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>raise_error</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* If we are here we should have an error in the stack, in the
		 * form of a table with an "err" field. Extract the string to
		 * return the plain error. */</comment>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"err"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inuse</name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><call><name>lua_error</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>inuse</name><operator>--</operator></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaRedisCallCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>luaRedisGenericCommand</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaRedisPCallCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>luaRedisGenericCommand</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This adds rlite.sha1hex(string) to Lua scripts using the same hashing
 * function used for sha1ing lua scripts. */</comment>
<function><type><name>int</name></type> <name>luaRedisSha1hexCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>digest</name><index>[<expr><literal type="number">41</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"wrong number of arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sha1hex</name><argument_list>(<argument><expr><name>digest</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns a table with a single field 'field' set to the string value
 * passed as argument. This helper function is handy when returning
 * a Redis Protocol error or status reply from Lua:
 *
 * return rlite.error_reply("ERR Some Error")
 * return rlite.status_reply("ERR Some Error")
 */</comment>
<function><type><name>int</name></type> <name>luaRedisReturnSingleFieldTable</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>lua_type</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TSTRING</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"wrong number or type of arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaRedisErrorReplyCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>luaRedisReturnSingleFieldTable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"err"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaRedisStatusReplyCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>luaRedisReturnSingleFieldTable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"ok"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaLogCommand</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>log</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>strs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>strlens</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"rlite.log() requires two arguments or more."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lua_isnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><name>argc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"First argument must be a number (log level)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>lua_tonumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>level</name> <argument_list type="generic">&lt; <argument><expr><name>RLITE_DEBUG</name> <operator>||</operator> <name>level</name></expr></argument> &gt;</argument_list></name> <name>RLITE_WARNING</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>luaPushError</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"Invalid debug level."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>totalsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>strs</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strs</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>strlens</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strlens</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>strs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>strlens</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>strs</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><name>argc</name><operator>)</operator><operator>+</operator><name>j</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>strlens</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name><name>strlens</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>log</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>totalsize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>log</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>strs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>strlens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>log</name><index>[<expr><name>totalsize</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>strs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>strlens</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name><name>strlens</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>log</name><index>[<expr><name>totalsize</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rliteLogRaw</name><argument_list>(<argument><expr><name>level</name></expr></argument>,<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>luaMaskCountHook</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><function_decl><type><name>lua_Debug</name> <modifier>*</modifier></type><name>UNUSED</name><parameter_list>(<parameter><decl><type><name>ar</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>elapsed</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>rl_mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>lua_time_start</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&gt;=</operator> <name>lua_time_limit</name> <operator>&amp;&amp;</operator> <name>lua_timedout</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rliteLog</name><argument_list>(<argument><expr><name>RLITE_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Lua slow script detected: still in execution after %lld milliseconds. You can try killing the script using the SCRIPT KILL command."</literal></expr></argument>,<argument><expr><name>elapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lua_timedout</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>lua_kill</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rliteLog</name><argument_list>(<argument><expr><name>RLITE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Lua script killed by user with SCRIPT KILL."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"Script killed by user with SCRIPT KILL..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_error</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>luaLoadLib</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libname</name></decl></parameter>, <parameter><decl><type><name>lua_CFunction</name></type> <name>luafunc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>luafunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>LUALIB_API</name> <name>int</name></type> (<name>luaopen_cjson</name>) <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LUALIB_API</name> <name>int</name></type> (<name>luaopen_struct</name>) <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LUALIB_API</name> <name>int</name></type> (<name>luaopen_cmsgpack</name>) <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LUALIB_API</name> <name>int</name></type> (<name>luaopen_bit</name>) <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>luaLoadLibraries</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>luaopen_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>LUA_TABLIBNAME</name></expr></argument>, <argument><expr><name>luaopen_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>LUA_STRLIBNAME</name></expr></argument>, <argument><expr><name>luaopen_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>LUA_MATHLIBNAME</name></expr></argument>, <argument><expr><name>luaopen_math</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>LUA_DBLIBNAME</name></expr></argument>, <argument><expr><name>luaopen_debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"cjson"</literal></expr></argument>, <argument><expr><name>luaopen_cjson</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"struct"</literal></expr></argument>, <argument><expr><name>luaopen_struct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"cmsgpack"</literal></expr></argument>, <argument><expr><name>luaopen_cmsgpack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaLoadLib</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"bit"</literal></expr></argument>, <argument><expr><name>luaopen_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* Stuff that we don't load currently, for sandboxing concerns. */</comment>
	luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
	luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Remove a functions that we don't want to expose to the Redis scripting
 * environment. */</comment>
<function><type><name>void</name></type> <name>luaRemoveUnsupportedFunctions</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"loadfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function installs metamethods in the global table _G that prevent
 * the creation of globals accidentally.
 *
 * It should be the last to be called in the scripting engine initialization
 * sequence, because it may interact with creation of globals. */</comment>
<function><type><name>void</name></type> <name>scriptingEnableGlobalsProtection</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* strict.lua from: http://metalua.luaforge.net/src/lib/strict.lua.html.
	 * Modified to be adapted to Redis. */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name> <init>=<expr><literal type="string">""</literal>
	<literal type="string">"local mt = {}\n"</literal>
	<literal type="string">"setmetatable(_G, mt)\n"</literal>
	<literal type="string">"mt.__newindex = function (t, n, v)\n"</literal>
	<literal type="string">"  if debug.getinfo(2) then\n"</literal>
	<literal type="string">"	local w = debug.getinfo(2, \"S\").what\n"</literal>
	<literal type="string">"	if w ~= \"main\" and w ~= \"C\" then\n"</literal>
	<literal type="string">"	  error(\"Script attempted to create global variable '\"..tostring(n)..\"'\", 2)\n"</literal>
	<literal type="string">"	end\n"</literal>
	<literal type="string">"  end\n"</literal>
	<literal type="string">"  rawset(t, n, v)\n"</literal>
	<literal type="string">"end\n"</literal>
	<literal type="string">"mt.__index = function (t, n)\n"</literal>
	<literal type="string">"  if debug.getinfo(2) and debug.getinfo(2, \"S\").what ~= \"C\" then\n"</literal>
	<literal type="string">"	error(\"Script attempted to access unexisting global variable '\"..tostring(n)..\"'\", 2)\n"</literal>
	<literal type="string">"  end\n"</literal>
	<literal type="string">"  return rawget(t, n)\n"</literal>
	<literal type="string">"end\n"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>code</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="string">"@enable_strict_lua"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize the scripting environment.
 * It is possible to call this function to reset the scripting environment
 * assuming that we call scriptingRelease() before.
 * See scriptingReset() for more information. */</comment>
<function><type><name>void</name></type> <name>scriptingInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>lua</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>lua</name> <operator>=</operator> <call><name>lua_open</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>luaLoadLibraries</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaRemoveUnsupportedFunctions</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize a dictionary we use to map SHAs to scripts.
	 * This is useful for replication, as we need to replicate EVALSHA
	 * as EVAL, so we need to remember the associated script. */</comment>

	<comment type="block">/* Register the rlite commands table and fields */</comment>
	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rlite.call */</comment>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>luaRedisCallCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rlite.pcall */</comment>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"pcall"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>luaRedisPCallCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rlite.log and log levels. */</comment>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"log"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>luaLogCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"LOG_DEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>RLITE_DEBUG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"LOG_VERBOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>RLITE_VERBOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"LOG_NOTICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>RLITE_NOTICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"LOG_WARNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>RLITE_WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rlite.sha1hex */</comment>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"sha1hex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>luaRedisSha1hexCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rlite.error_reply and rlite.status_reply */</comment>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"error_reply"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>luaRedisErrorReplyCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"status_reply"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>luaRedisStatusReplyCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally set the table as 'redis' global var. */</comment>
	<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"redis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace math.random and math.randomseed with our implementations. */</comment>
	<expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"math"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"random"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>rlite_math_random</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"randomseed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>rlite_math_randomseed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"math"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a helper function that we use to sort the multi bulk output of non
	 * deterministic commands, when containing 'false' elements. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>compare_func</name> <init>=	<expr><literal type="string">"function __rlite__compare_helper(a,b)\n"</literal>
								<literal type="string">"  if a == false then a = '' end\n"</literal>
								<literal type="string">"  if b == false then b = '' end\n"</literal>
								<literal type="string">"  return a&lt;b\n"</literal>
								<literal type="string">"end\n"</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>compare_func</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>compare_func</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="string">"@cmp_func_def"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Add a helper function we use for pcall error reporting.
	 * Note that when the error is in the C function we want to report the
	 * information about the caller, that's what makes sense from the point
	 * of view of the user debugging a script. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errh_func</name> <init>=	   <expr><literal type="string">"function __rlite__err__handler(err)\n"</literal>
								<literal type="string">"  local i = debug.getinfo(2,'nSl')\n"</literal>
								<literal type="string">"  if i and i.what == 'C' then\n"</literal>
								<literal type="string">"	i = debug.getinfo(3,'nSl')\n"</literal>
								<literal type="string">"  end\n"</literal>
								<literal type="string">"  if i then\n"</literal>
								<literal type="string">"	return i.source .. ':' .. i.currentline .. ': ' .. err\n"</literal>
								<literal type="string">"  else\n"</literal>
								<literal type="string">"	return err\n"</literal>
								<literal type="string">"  end\n"</literal>
								<literal type="string">"end\n"</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>errh_func</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errh_func</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="string">"@err_handler_def"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Create the (non connected) client that we use to execute Redis commands
	 * inside the Lua interpreter.
	 * Note: there is no need to create it again when this function is called
	 * by scriptingReset(). */</comment>
	<if_stmt><if>if <condition>(<expr><name>lua_client</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>lua_client</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lua_client</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lua_client</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>RLITE_LUA_CLIENT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Lua beginners often don't use "local", this is likely to introduce
	 * subtle bugs in their code. To prevent problems we protect accesses
	 * to global variables. */</comment>
	<expr_stmt><expr><call><name>scriptingEnableGlobalsProtection</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Release resources related to Lua scripting.
 * This function is used in order to reset the scripting environment. */</comment>
<function><type><name>void</name></type> <name>scriptingRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_close</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>scriptingReset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>scriptingRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>scriptingInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Perform the SHA1 of the input string. We use this both for hashing script
 * bodies in order to obtain the Lua function name, and in the implementation
 * of rlite.sha1().
 *
 * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an
 * hexadecimal number, plus 1 byte for null term. */</comment>
<function><type><name>void</name></type> <name>sha1hex</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>digest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SHA1_CTX</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cset</name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SHA1Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHA1Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>script</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHA1Final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>digest</name><index>[<expr><name>j</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>cset</name><index>[<expr><operator>(</operator><operator>(</operator><name><name>hash</name><index>[<expr><name>j</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xF0</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>digest</name><index>[<expr><name>j</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cset</name><index>[<expr><operator>(</operator><name><name>hash</name><index>[<expr><name>j</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xF</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>digest</name><index>[<expr><literal type="number">40</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>rliteReply</name> <modifier>*</modifier></type><name>luaReplyToStringReply</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rliteReply</name><modifier>*</modifier></type> <name>reply</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_err</name> <init>= <expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>_err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>_err</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>_err</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>err</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>err</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>_err</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>err</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>createStringTypeObject</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>reply</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaReplyToRedisReply</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><call><name>lua_type</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>LUA_TSTRING</name></expr>:</case>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lua_tostring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>lua_strlen</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>LUA_TBOOLEAN</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createLongLongObject</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createNullReplyObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<case>case <expr><name>LUA_TNUMBER</name></expr>:</case>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createLongLongObject</name><argument_list>(<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>LUA_TTABLE</name></expr>:</case>
		<comment type="block">/* We need to check if it is an array, an error, or a status reply.
		 * Error are returned as a single element table with 'err' field.
		 * Status replies are returned as single element table with 'ok' field */</comment>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"err"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>lua_type</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>LUA_TSTRING</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>luaReplyToStringReply</name><argument_list>(<argument><expr><name>RLITE_REPLY_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"ok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>lua_type</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>LUA_TSTRING</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>luaReplyToStringReply</name><argument_list>(<argument><expr><name>RLITE_REPLY_STATUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name>rliteReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>createArrayObject</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Discard the 'ok' field value we popped */</comment>
			<while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>j</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>lua_type</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>LUA_TNIL</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>luaReplyToRedisReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal> <operator>==</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rl_realloc</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rliteReply</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
						<comment type="line">// TODO: free stuff, panic</comment>
						<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<comment type="line">// TODO: shrink reply-&gt;element</comment>
			<expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <name>reply</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createNullReplyObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Set an array of Redis String Objects as a Lua array (table) stored into a
 * global variable. */</comment>
<function><type><name>void</name></type> <name>luaSetGlobalArray</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>elev</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>elevlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elec</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>elec</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name><name>elev</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>elevlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Define a lua function with the specified function name and body.
 * The function name musts be a 2 characters long string, since all the
 * functions we defined in the Lua context are in the form:
 *
 *   f_&lt;hex sha1 sum&gt;
 *
 * On success RLITE_OK is returned, and nothing is left on the Lua stack.
 * On error RLITE_ERR is returned and an appropriate error is set in the
 * client context. */</comment>
<function><type><name>int</name></type> <name>luaCreateFunction</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>lua</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bodylen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><literal type="string">"function "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><literal type="string">"() "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><literal type="string">" end"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>funcnamelen</name> <init>= <expr><literal type="number">42</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>funcdeflen</name> <init>= <expr><name>bodylen</name> <operator>+</operator> <name>funcnamelen</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>funcdef</name> <init>= <expr><call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>funcdeflen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>funcdef</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcdeflen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>funcdef</name><index>[<expr><name>funcdeflen</name></expr>]</index></name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>funcnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcdeflen</name> <operator>+=</operator> <name>funcnamelen</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>funcdef</name><index>[<expr><name>funcdeflen</name></expr>]</index></name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcdeflen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>funcdef</name><index>[<expr><name>funcdeflen</name></expr>]</index></name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>bodylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcdeflen</name> <operator>+=</operator> <name>bodylen</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>funcdef</name><index>[<expr><name>funcdeflen</name></expr>]</index></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcdeflen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>funcdef</name><index>[<expr><name>funcdeflen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>funcdef</name></expr></argument>,<argument><expr><name>funcdeflen</name></expr></argument>,<argument><expr><literal type="string">"@user_script"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>err</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"ERR Error compiling script (new function): %s"</literal></expr></argument>,
			<argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>funcdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>RLITE_ERR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>funcdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>err</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"ERR Error running script (new function): %s"</literal></expr></argument>,
			<argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>RLITE_ERR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We also save a SHA1 -&gt; Original script map in a dictionary
	 * so that we can replicate / write in the AOF all the
	 * EVALSHA commands as EVAL using the original script. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>setScript</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>bodylen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>RL_OK</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>retval</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>RLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>evalGenericCommand</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>evalsha</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>scriptingInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lua_client</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>funcname</name><index>[<expr><literal type="number">43</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>numkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delhook</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>

	<comment type="block">/* We want the same PRNG sequence at every call so that our PRNG is
	 * not affected by external state. */</comment>
	<expr_stmt><expr><call><name>rliteSrand48</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We set this flag to zero to remember that so far no random command
	 * was called. This way we can allow the user to call commands like
	 * SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command
	 * is called (otherwise the replication and AOF would end with non
	 * deterministic sequences).
	 *
	 * Thanks to this flag we'll raise an error every time a write command
	 * is called after a random command was used. */</comment>
	<expr_stmt><expr><name>lua_random_dirty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lua_write_dirty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Get the number of arguments that are keys */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numkeys</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RLITE_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>numkeys</name> <operator>&gt;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><literal type="string">"Number of keys can't be greater than number of args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>numkeys</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><literal type="string">"Number of keys can't be negative"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We obtain the script SHA1, then check if this function is already
	 * defined into the Lua state */</comment>
	<expr_stmt><expr><name><name>funcname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>evalsha</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Hash the code if this is an EVAL call */</comment>
		<expr_stmt><expr><call><name>sha1hex</name><argument_list>(<argument><expr><name>funcname</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* We already have the SHA if it is a EVALSHA */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sha</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Convert to lowercase. We don't use tolower since the function
		 * managed to always show up in the profiler output consuming
		 * a non trivial amount of time. */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>funcname</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>sha</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>sha</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr> ?</condition><then>
				<expr><name><name>sha</name><index>[<expr><name>j</name></expr>]</index></name><operator>+</operator><operator>(</operator><literal type="char">'a'</literal><operator>-</operator><literal type="char">'A'</literal><operator>)</operator></expr> </then><else>: <expr><name><name>sha</name><index>[<expr><name>j</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>funcname</name><index>[<expr><literal type="number">42</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>bodylen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>getScript</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>funcname</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>body</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bodylen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>RL_OK</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><name>RLITE_NOSCRIPTERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>luaCreateFunction</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>lua</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>bodylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Push the pcall error handler function on the stack. */</comment>
	<expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><literal type="string">"__rlite__err__handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to lookup the Lua function */</comment>
	<expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lua_isnil</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* remove the nil from the stack */</comment>
		<comment type="block">/* Function not defined... let's define it if we have the
		 * body of the function. If this is an EVALSHA call we can just
		 * return an error. */</comment>
		<if_stmt><if>if <condition>(<expr><name>evalsha</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* remove the error handler from the stack. */</comment>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><name>RLITE_NOSCRIPTERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>luaCreateFunction</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>funcname</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLITE_ERR</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* remove the error handler from the stack. */</comment>
			<comment type="block">/* The error is sent to the client by luaCreateFunction()
			 * itself when it returns RLITE_ERR. */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Now the following is guaranteed to return non nil */</comment>
		<expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>lua</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>lua_isnil</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="line">// TODO: panic</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Populate the argv and keys table accordingly to the arguments that
	 * EVAL received. */</comment>
	<expr_stmt><expr><call><name>luaSetGlobalArray</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"KEYS"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">3</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name></name><operator>+</operator><literal type="number">3</literal></expr></argument>,<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>luaSetGlobalArray</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="string">"ARGV"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">3</literal><operator>+</operator><name>numkeys</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name></name><operator>+</operator><literal type="number">3</literal><operator>+</operator><name>numkeys</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">3</literal><operator>-</operator><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set a hook in order to be able to stop the script execution if it
	 * is running for too much time.
	 * We set the hook only if the time limit is enabled as the hook will
	 * make the Lua script execution slower. */</comment>
	<expr_stmt><expr><name>lua_caller</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lua_time_start</name> <operator>=</operator> <call><name>rl_mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lua_kill</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lua_time_limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>lua_sethook</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>luaMaskCountHook</name></expr></argument>,<argument><expr><name>LUA_MASKCOUNT</name></expr></argument>,<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>delhook</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* At this point whether this script was never seen before or if it was
	 * already defined, we can call it. We have zero arguments and expect
	 * a single return value. */</comment>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>lua_pcall</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform some cleanup that we need to do both on error and success. */</comment>
	<if_stmt><if>if <condition>(<expr><name>delhook</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_sethook</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>luaMaskCountHook</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Disable hook */</comment>
	<if_stmt><if>if <condition>(<expr><name>lua_timedout</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>lua_timedout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Restore the readable handler that was unregistered when the
		 * script timeout was detected. */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>lua_caller</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Call the Lua garbage collector from time to time to avoid a
	 * full cycle performed by Lua, which adds too latency.
	 *
	 * The call is performed every LUA_GC_CYCLE_PERIOD executed commands
	 * (and for LUA_GC_CYCLE_PERIOD collection steps) because calling it
	 * for every command uses too much CPU. */</comment>
	<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_GC_CYCLE_PERIOD</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>gc_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>gc_count</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>gc_count</name> <operator>==</operator> <name>LUA_GC_CYCLE_PERIOD</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>lua_gc</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><name>LUA_GCSTEP</name></expr></argument>,<argument><expr><name>LUA_GC_CYCLE_PERIOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>gc_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>err</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"Error running script (call to %s): %s\n"</literal></expr></argument>,
			<argument><expr><name>funcname</name></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Consume the Lua reply and remove error handler. */</comment>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* On success convert the Lua return value into Redis protocol, and
		 * send it to * the client. */</comment>
		<expr_stmt><expr><call><name>luaReplyToRedisReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>lua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Convert and consume the reply. */</comment>
		<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>lua</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Remove the error handler. */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>evalCommand</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>evalGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>evalShaCommand</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">40</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* We know that a match is not possible if the provided SHA is
		 * not the right length. So we return an error ASAP, this way
		 * evalGenericCommand() can be implemented without string length
		 * sanity check */</comment>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><name>RLITE_NOSCRIPTERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>evalGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We replace math.random() with our implementation that is not affected
 * by specific libc random() implementations and will output the same sequence
 * (for the same seed) in every arch. */</comment>

<comment type="block">/* The following implementation is the one shipped with Lua itself but with
 * rand() replaced by rliteLrand48(). */</comment>
<function><type><name>int</name></type> <name>rlite_math_random</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* the `%' avoids the (rare) case of r==1, and is needed also because on
	 some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */</comment>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><call><name>rliteLrand48</name><argument_list>()</argument_list></call><operator>%</operator><name>RLITE_LRAND48_MAX</name><operator>)</operator> <operator>/</operator>
								<operator>(</operator><name>lua_Number</name><operator>)</operator><name>RLITE_LRAND48_MAX</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* check number of arguments */</comment>
	<case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* no arguments */</comment>
	  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Number between 0 and 1 */</comment>
	  <break>break;</break>
	</block_content>}</block>
	<case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* only upper limit */</comment>
	  <decl_stmt><decl><type><name>int</name></type> <name>u</name> <init>= <expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;=</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"interval is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>floor</name><argument_list>(<argument><expr><name>r</name><operator>*</operator><name>u</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* int between 1 and `u' */</comment>
	  <break>break;</break>
	</block_content>}</block>
	<case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* lower and upper limits */</comment>
	  <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>u</name> <init>= <expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l</name><operator>&lt;=</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"interval is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>floor</name><argument_list>(<argument><expr><name>r</name><operator>*</operator><operator>(</operator><name>u</name><operator>-</operator><name>l</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>+</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* int between `l' and `u' */</comment>
	  <break>break;</break>
	</block_content>}</block>
	<default>default:</default> <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"wrong number of arguments"</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rlite_math_randomseed</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>rliteSrand48</name><argument_list>(<argument><expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * SCRIPT command for script environment introspection and control
 * ------------------------------------------------------------------------- */</comment>

<function><type><name>void</name></type> <name>scriptCommand</name><parameter_list>(<parameter><decl><type><name>rliteClient</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"flush"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>scriptingReset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createStatusObject</name><argument_list>(<argument><expr><name>RLITE_STR_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"exists"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createArrayObject</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>createLongLongObject</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>getScript</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RL_OK</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"load"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>sha</name><index>[<expr><literal type="number">41</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sha1hex</name><argument_list>(<argument><expr><name>sha</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setScript</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argvlen</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sha</name></expr></argument>,<argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"kill"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lua_caller</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createCStringObject</name><argument_list>(<argument><expr><literal type="string">"NOTBUSY No scripts in execution right now.\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lua_write_dirty</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createCStringObject</name><argument_list>(<argument><expr><literal type="string">"UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>lua_kill</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createStatusObject</name><argument_list>(<argument><expr><name>RLITE_STR_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>createErrorObject</name><argument_list>(<argument><expr><literal type="string">"ERR Unknown SCRIPT subcommand or wrong # of args."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
