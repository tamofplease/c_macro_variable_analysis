<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/rlite/src/hyperloglog.c"><comment type="block">/* hyperloglog.c - Redis HyperLogLog probabilistic cardinality approximation.
 * This file implements the algorithm and the exported Redis commands.
 *
 * Copyright (c) 2014, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rlite/hyperloglog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<comment type="block">/* The Redis HyperLogLog implementation is based on the following ideas:
 *
 * * The use of a 64 bit hash function as proposed in [1], in order to don't
 *   limited to cardinalities up to 10^9, at the cost of just 1 additional
 *   bit per register.
 * * The use of 16384 6-bit registers for a great level of accuracy, using
 *   a total of 12k per key.
 * * The use of the Redis string data type. No new type is introduced.
 * * No attempt is made to compress the data structure as in [1]. Also the
 *   algorithm used is the original HyperLogLog Algorithm as in [2], with
 *   the only difference that a 64 bit hash function is used, so no correction
 *   is performed for values near 2^32 as in [1].
 *
 * [1] Heule, Nunkesser, Hall: HyperLogLog in Practice: Algorithmic
 *     Engineering of a State of The Art Cardinality Estimation Algorithm.
 *
 * [2] P. Flajolet, Ãric Fusy, O. Gandouet, and F. Meunier. Hyperloglog: The
 *     analysis of a near-optimal cardinality estimation algorithm.
 *
 * Redis uses two representations:
 *
 * 1) A "dense" representation where every entry is represented by
 *    a 6-bit integer.
 * 2) A "sparse" representation using run length compression suitable
 *    for representing HyperLogLogs with many registers set to 0 in
 *    a memory efficient way.
 *
 *
 * HLL header
 * ===
 *
 * Both the dense and sparse representation have a 16 byte header as follows:
 *
 * +------+---+-----+----------+
 * | HYLL | E | N/U | Cardin.  |
 * +------+---+-----+----------+
 *
 * The first 4 bytes are a magic string set to the bytes "HYLL".
 * "E" is one byte encoding, currently set to HLL_DENSE or
 * HLL_SPARSE. N/U are three not used bytes.
 *
 * The "Cardin." field is a 64 bit integer stored in little endian format
 * with the latest cardinality computed that can be reused if the data
 * structure was not modified since the last computation (this is useful
 * because there are high probabilities that HLLADD operations don't
 * modify the actual data structure and hence the approximated cardinality).
 *
 * When the most significant bit in the most significant byte of the cached
 * cardinality is set, it means that the data structure was modified and
 * we can't reuse the cached value that must be recomputed.
 *
 * Dense representation
 * ===
 *
 * The dense representation used by Redis is the following:
 *
 * +--------+--------+--------+------//      //--+
 * |11000000|22221111|33333322|55444444 ....     |
 * +--------+--------+--------+------//      //--+
 *
 * The 6 bits counters are encoded one after the other starting from the
 * LSB to the MSB, and using the next bytes as needed.
 *
 * Sparse representation
 * ===
 *
 * The sparse representation encodes registers using a run length
 * encoding composed of three opcodes, two using one byte, and one using
 * of two bytes. The opcodes are called ZERO, XZERO and VAL.
 *
 * ZERO opcode is represented as 00xxxxxx. The 6-bit integer represented
 * by the six bits 'xxxxxx', plus 1, means that there are N registers set
 * to 0. This opcode can represent from 1 to 64 contiguous registers set
 * to the value of 0.
 *
 * XZERO opcode is represented by two bytes 01xxxxxx yyyyyyyy. The 14-bit
 * integer represented by the bits 'xxxxxx' as most significant bits and
 * 'yyyyyyyy' as least significant bits, plus 1, means that there are N
 * registers set to 0. This opcode can represent from 0 to 16384 contiguous
 * registers set to the value of 0.
 *
 * VAL opcode is represented as 1vvvvvxx. It contains a 5-bit integer
 * representing the value of a register, and a 2-bit integer representing
 * the number of contiguous registers set to that value 'vvvvv'.
 * To obtain the value and run length, the integers vvvvv and xx must be
 * incremented by one. This opcode can represent values from 1 to 32,
 * repeated from 1 to 4 times.
 *
 * The sparse representation can't represent registers with a value greater
 * than 32, however it is very unlikely that we find such a register in an
 * HLL with a cardinality where the sparse representation is still more
 * memory efficient than the dense representation. When this happens the
 * HLL is converted to the dense representation.
 *
 * The sparse representation is purely positional. For example a sparse
 * representation of an empty HLL is just: XZERO:16384.
 *
 * An HLL having only 3 non-zero registers at position 1000, 1020, 1021
 * respectively set to 2, 3, 3, is represented by the following three
 * opcodes:
 *
 * XZERO:1000 (Registers 0-999 are set to 0)
 * VAL:2,1    (1 register set to value 2, that is register 1000)
 * ZERO:19    (Registers 1001-1019 set to 0)
 * VAL:3,2    (2 registers set to value 3, that is registers 1020,1021)
 * XZERO:15362 (Registers 1022-16383 set to 0)
 *
 * In the example the sparse representation used just 7 bytes instead
 * of 12k in order to represent the HLL registers. In general for low
 * cardinality there is a big win in terms of space efficiency, traded
 * with CPU time since the sparse representation is slower to access:
 *
 * The following table shows average cardinality vs bytes used, 100
 * samples per cardinality (when the set was not representable because
 * of registers with too big value, the dense representation size was used
 * as a sample).
 *
 * 100 267
 * 200 485
 * 300 678
 * 400 859
 * 500 1033
 * 600 1205
 * 700 1375
 * 800 1544
 * 900 1713
 * 1000 1882
 * 2000 3480
 * 3000 4879
 * 4000 6089
 * 5000 7138
 * 6000 8042
 * 7000 8823
 * 8000 9500
 * 9000 10088
 * 10000 10591
 *
 * The dense representation uses 12288 bytes, so there is a big win up to
 * a cardinality of ~2000-3000. For bigger cardinalities the constant times
 * involved in updating the sparse representation is not justified by the
 * memory savings. The exact maximum length of the sparse representation
 * when this implementation switches to the dense representation is
 * configured via the define server.hll_sparse_max_bytes.
 */</comment>

<struct>struct <name>hllhdr</name> <block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* "HYLL" */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>encoding</name></decl>;</decl_stmt>   <comment type="block">/* HLL_DENSE or HLL_SPARSE. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>notused</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Reserved for future use, must be zero. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>card</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Cached cardinality, little endian. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>registers</name><index>[]</index></name></decl>;</decl_stmt> <comment type="block">/* Data bytes. */</comment>
}</block>;</struct>

<comment type="block">/* The cached cardinality MSB is used to signal validity of the cached value. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_INVALIDATE_CACHE</name><parameter_list>(<parameter><type><name>hdr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_VALID_CACHE</name><parameter_list>(<parameter><type><name>hdr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_P</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> <comment type="block">/* The greater is P, the smaller the error. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_REGISTERS</name></cpp:macro> <cpp:value>(1&lt;&lt;HLL_P)</cpp:value></cpp:define> <comment type="block">/* With P=14, 16384 registers. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_P_MASK</name></cpp:macro> <cpp:value>(HLL_REGISTERS-1)</cpp:value></cpp:define> <comment type="block">/* Mask to index register. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_BITS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define> <comment type="block">/* Enough to count up to 63 leading zeroes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_REGISTER_MAX</name></cpp:macro> <cpp:value>((1&lt;&lt;HLL_BITS)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_HDR_SIZE</name></cpp:macro> <cpp:value>sizeof(struct hllhdr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_SIZE</name></cpp:macro> <cpp:value>(HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> <comment type="block">/* Dense encoding. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Sparse encoding. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_RAW</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define> <comment type="block">/* Only used internally, never exposed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_MAX_ENCODING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><name>size_t</name></type> <name>rl_hll_sparse_max_bytes</name> <init>= <expr><literal type="number">3000</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* =========================== Low level bit macros ========================= */</comment>

<comment type="block">/* Macros to access the dense representation.
 *
 * We need to get and set 6 bit counters in an array of 8 bit bytes.
 * We use macros to make sure the code is inlined since speed is critical
 * especially in order to compute the approximated cardinality in
 * HLLCOUNT where we need to access all the registers at once.
 * For the same reason we also want to avoid conditionals in this code path.
 *
 * +--------+--------+--------+------//
 * |11000000|22221111|33333322|55444444
 * +--------+--------+--------+------//
 *
 * Note: in the above representation the most significant bit (MSB)
 * of every byte is on the left. We start using bits from the LSB to MSB,
 * and so forth passing to the next byte.
 *
 * Example, we want to access to counter at pos = 1 ("111111" in the
 * illustration above).
 *
 * The index of the first byte b0 containing our data is:
 *
 *  b0 = 6 * pos / 8 = 0
 *
 *   +--------+
 *   |11000000|  &lt;- Our byte at b0
 *   +--------+
 *
 * The position of the first bit (counting from the LSB = 0) in the byte
 * is given by:
 *
 *  fb = 6 * pos % 8 -&gt; 6
 *
 * Right shift b0 of 'fb' bits.
 *
 *   +--------+
 *   |11000000|  &lt;- Initial value of b0
 *   |00000011|  &lt;- After right shift of 6 pos.
 *   +--------+
 *
 * Left shift b1 of bits 8-fb bits (2 bits)
 *
 *   +--------+
 *   |22221111|  &lt;- Initial value of b1
 *   |22111100|  &lt;- After left shift of 2 bits.
 *   +--------+
 *
 * OR the two bits, and finally AND with 111111 (63 in decimal) to
 * clean the higher order bits we are not interested in:
 *
 *   +--------+
 *   |00000011|  &lt;- b0 right shifted
 *   |22111100|  &lt;- b1 left shifted
 *   |22111111|  &lt;- b0 OR b1
 *   |  111111|  &lt;- (b0 OR b1) AND 63, our value.
 *   +--------+
 *
 * We can try with a different example, like pos = 0. In this case
 * the 6-bit counter is actually contained in a single byte.
 *
 *  b0 = 6 * pos / 8 = 0
 *
 *   +--------+
 *   |11000000|  &lt;- Our byte at b0
 *   +--------+
 *
 *  fb = 6 * pos % 8 = 0
 *
 *  So we right shift of 0 bits (no shift in practice) and
 *  left shift the next byte of 8 bits, even if we don't use it,
 *  but this has the effect of clearing the bits so the result
 *  will not be affacted after the OR.
 *
 * -------------------------------------------------------------------------
 *
 * Setting the register is a bit more complex, let's assume that 'val'
 * is the value we want to set, already in the right range.
 *
 * We need two steps, in one we need to clear the bits, and in the other
 * we need to bitwise-OR the new bits.
 *
 * Let's try with 'pos' = 1, so our first byte at 'b' is 0,
 *
 * "fb" is 6 in this case.
 *
 *   +--------+
 *   |11000000|  &lt;- Our byte at b0
 *   +--------+
 *
 * To create a AND-mask to clear the bits about this position, we just
 * initialize the mask with the value 63, left shift it of "fs" bits,
 * and finally invert the result.
 *
 *   +--------+
 *   |00111111|  &lt;- "mask" starts at 63
 *   |11000000|  &lt;- "mask" after left shift of "ls" bits.
 *   |00111111|  &lt;- "mask" after invert.
 *   +--------+
 *
 * Now we can bitwise-AND the byte at "b" with the mask, and bitwise-OR
 * it with "val" left-shifted of "ls" bits to set the new bits.
 *
 * Now let's focus on the next byte b1:
 *
 *   +--------+
 *   |22221111|  &lt;- Initial value of b1
 *   +--------+
 *
 * To build the AND mask we start again with the 63 value, right shift
 * it by 8-fb bits, and invert it.
 *
 *   +--------+
 *   |00111111|  &lt;- "mask" set at 2&amp;6-1
 *   |00001111|  &lt;- "mask" after the right shift by 8-fb = 2 bits
 *   |11110000|  &lt;- "mask" after bitwise not.
 *   +--------+
 *
 * Now we can mask it with b+1 to clear the old bits, and bitwise-OR
 * with "val" left-shifted by "rs" bits to set the new value.
 */</comment>

<comment type="block">/* Note: if we access the last counter, we will also access the b+1 byte
 * that is out of the array, but sds strings always have an implicit null
 * term, so the byte exists, and we can skip the conditional (or the need
 * to allocate 1 byte more explicitly). */</comment>

<comment type="block">/* Store the value of the register at position 'regnum' into variable 'target'.
 * 'p' is an array of unsigned bytes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_GET_REGISTER</name><parameter_list>(<parameter><type><name>target</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>regnum</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    uint8_t *_p = (uint8_t*) p; \
    unsigned long _byte = regnum*HLL_BITS/8; \
    unsigned long _fb = regnum*HLL_BITS&amp;7; \
    unsigned long _fb8 = 8 - _fb; \
    unsigned long b0 = _p[_byte]; \
    unsigned long b1 = _p[_byte+1]; \
    target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* Set the value of the register at position 'regnum' to 'val'.
 * 'p' is an array of unsigned bytes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_SET_REGISTER</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>regnum</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    uint8_t *_p = (uint8_t*) p; \
    unsigned long _byte = regnum*HLL_BITS/8; \
    unsigned long _fb = regnum*HLL_BITS&amp;7; \
    unsigned long _fb8 = 8 - _fb; \
    unsigned long _v = val; \
    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \
    _p[_byte] |= _v &lt;&lt; _fb; \
    _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \
    _p[_byte+1] |= _v &gt;&gt; _fb8; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* Macros to access the sparse representation.
 * The macros parameter is expected to be an uint8_t pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_BIT</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define> <comment type="block">/* 01xxxxxx */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_BIT</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define> <comment type="block">/* 1vvvvvxx */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_ZERO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0xc0) == 0)</cpp:value></cpp:define> <comment type="block">/* 00xxxxxx */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_XZERO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_VAL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(p)) &amp; HLL_SPARSE_VAL_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0x3f)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_VALUE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0x3)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_MAX_VALUE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_MAX_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_MAX_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_MAX_LEN</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>val</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    *(p) = (((val)-1)&lt;&lt;2|((len)-1))|HLL_SPARSE_VAL_BIT; \
} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    *(p) = (len)-1; \
} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    int _l = (len)-1; \
    *(p) = (_l&gt;&gt;8) | HLL_SPARSE_XZERO_BIT; \
    *((p)+1) = (_l&amp;0xff); \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* ========================= HyperLogLog algorithm  ========================= */</comment>

<comment type="block">/* Our hash function is MurmurHash2, 64 bit version.
 * It was modified for Redis in order to provide the same result in
 * big and little endian archs (endian neutral). */</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>MurmurHash64A</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>m</name> <init>= <expr><literal type="number">0xc6a4a7935bd1e995</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">47</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name> <init>= <expr><name>seed</name> <operator>^</operator> <operator>(</operator><name>len</name> <operator>*</operator> <name>m</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>data</name> <operator>+</operator> <operator>(</operator><name>len</name><operator>-</operator><operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>data</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>BYTE_ORDER</name> <operator>==</operator> <name>LITTLE_ENDIAN</name><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>^=</operator> <name>k</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <switch>switch<condition>(<expr><name>len</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
    </block_content>}</block></switch><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
    <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Given a string element to add to the HyperLogLog, returns the length
 * of the pattern 000..1 of the element hash. As a side effect 'regp' is
 * set to the register index this element hashes to. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hllPatLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>regp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>bit</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* Count the number of zeroes starting from bit HLL_REGISTERS
     * (that is a power of two corresponding to the first bit we don't use
     * as index). The max run can be 64-P+1 bits.
     *
     * Note that the final "1" ending the sequence of zeroes must be
     * included in the count, so if we find "001" the count is 3, and
     * the smallest count possible is no zeroes at all, just a 1 bit
     * at the first position, that is a count of 1.
     *
     * This may sound like inefficient, but actually in the average case
     * there are high probabilities to find a 1 after a few iterations. */</comment>
    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>MurmurHash64A</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><literal type="number">0xadc83b19ULL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>index</name> <operator>=</operator> <name>hash</name> <operator>&amp;</operator> <name>HLL_P_MASK</name></expr>;</expr_stmt> <comment type="block">/* Register index. */</comment>
    <expr_stmt><expr><name>hash</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">63</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Make sure the loop terminates. */</comment>
    <expr_stmt><expr><name>bit</name> <operator>=</operator> <name>HLL_REGISTERS</name></expr>;</expr_stmt> <comment type="block">/* First bit not used to address the register. */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Initialized to 1 since we count the "00000...1" pattern. */</comment>
    <while>while<condition>(<expr><operator>(</operator><name>hash</name> <operator>&amp;</operator> <name>bit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>bit</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>regp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>index</name></expr>;</expr_stmt>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ================== Dense representation implementation  ================== */</comment>

<comment type="block">/* "Add" the element in the dense hyperloglog data structure.
 * Actually nothing is added, but the max 0 pattern counter of the subset
 * the element belongs to is incremented if needed.
 *
 * 'registers' is expected to have room for HLL_REGISTERS plus an
 * additional byte on the right. This requirement is met by sds strings
 * automatically since they are implicitly null terminated.
 *
 * The function always succeed, however if as a result of the operation
 * the approximated cardinality changed, 1 is returned. Otherwise 0
 * is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hllDenseAdd</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>oldcount</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>index</name></decl>;</decl_stmt>

    <comment type="block">/* Update the register if this element produced a longer run of zeroes. */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>hllPatLen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>oldcount</name></expr></argument>,<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>oldcount</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Compute SUM(2^-reg) in the dense representation.
 * PE is an array with a pre-computer table of values 2^-reg indexed by reg.
 * As a side effect the integer pointed by 'ezp' is set to the number
 * of zero registers. */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>hllDenseSum</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>PE</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ezp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>ez</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Redis default is to use 16384 registers 6 bits each. The code works
     * with other values by modifying the defines, but for our target value
     * we take a faster path with unrolled loops. */</comment>
    <if_stmt><if>if <condition>(<expr><name>HLL_REGISTERS</name> <operator>==</operator> <literal type="number">16384</literal> <operator>&amp;&amp;</operator> <name>HLL_BITS</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>registers</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r0</name></decl>, <decl><type ref="prev"/><name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>r3</name></decl>, <decl><type ref="prev"/><name>r4</name></decl>, <decl><type ref="prev"/><name>r5</name></decl>, <decl><type ref="prev"/><name>r6</name></decl>, <decl><type ref="prev"/><name>r7</name></decl>, <decl><type ref="prev"/><name>r8</name></decl>, <decl><type ref="prev"/><name>r9</name></decl>,
                      <decl><type ref="prev"/><name>r10</name></decl>, <decl><type ref="prev"/><name>r11</name></decl>, <decl><type ref="prev"/><name>r12</name></decl>, <decl><type ref="prev"/><name>r13</name></decl>, <decl><type ref="prev"/><name>r14</name></decl>, <decl><type ref="prev"/><name>r15</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* Handle 16 registers per iteration. */</comment>
            <expr_stmt><expr><name>r0</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r0</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r1</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r3</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r3</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r4</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r4</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r5</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r5</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r6</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r6</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r7</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r7</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r8</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r8</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r9</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r9</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r10</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r10</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r11</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r11</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r12</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r12</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r13</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r13</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r14</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r14</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>r15</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>r15</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Additional parens will allow the compiler to optimize the
             * code more with a loss of precision that is not very relevant
             * here (floating point math is not commutative!). */</comment>
            <expr_stmt><expr><name>E</name> <operator>+=</operator> <operator>(</operator><name><name>PE</name><index>[<expr><name>r0</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r1</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>PE</name><index>[<expr><name>r2</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r3</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>PE</name><index>[<expr><name>r4</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r5</name></expr>]</index></name><operator>)</operator> <operator>+</operator>
                 <operator>(</operator><name><name>PE</name><index>[<expr><name>r6</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r7</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>PE</name><index>[<expr><name>r8</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r9</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>PE</name><index>[<expr><name>r10</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r11</name></expr>]</index></name><operator>)</operator> <operator>+</operator>
                 <operator>(</operator><name><name>PE</name><index>[<expr><name>r12</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r13</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>PE</name><index>[<expr><name>r14</name></expr>]</index></name> <operator>+</operator> <name><name>PE</name><index>[<expr><name>r15</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>reg</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>reg</name></expr></argument>,<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt>
                <comment type="block">/* Increment E at the end of the loop. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name>reg</name></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* Precomputed 2^(-reg[j]). */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>E</name> <operator>+=</operator> <name>ez</name></expr>;</expr_stmt> <comment type="block">/* Add 2^0 'ez' times. */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ezp</name> <operator>=</operator> <name>ez</name></expr>;</expr_stmt>
    <return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ================== Sparse representation implementation  ================= */</comment>

<comment type="block">/* Convert the HLL with sparse representation given as input in its dense
 * representation. Both representations are represented by SDS strings, and
 * the input representation is rl_freed as a side effect.
 *
 * The function returns 0 if the sparse representation was valid,
 * otherwise 1 is returned if the representation was corrupted. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hllSparseToDense</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sparse</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>sparselen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newstr</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>newstrlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dense</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oldhdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator><name>sparse</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>sparse</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name><operator>+</operator><name>sparselen</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the representation is already the right one return ASAP. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>sparse</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Create a string of the right size filled with zero bytes.
     * Note that the cached cardinality is set to 0 as a side effect
     * that is exactly the cardinality of an empty HLL. */</comment>
    <expr_stmt><expr><name>dense</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>HLL_DENSE_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>dense</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>hdr</name> <operator>=</operator> <operator>*</operator><name>oldhdr</name></expr>;</expr_stmt> <comment type="block">/* This will copy the magic and cached cardinality. */</comment>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_DENSE</name></expr>;</expr_stmt>

    <comment type="block">/* Now read the sparse representation and set non-zero registers
     * accordingly. */</comment>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><name>runlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name>regval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* If the sparse representation was valid, we expect to find idx
     * set to HLL_REGISTERS. */</comment>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>HLL_REGISTERS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Free the old representation and set the new one. */</comment>
    <expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>sparse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>newstr</name> <operator>=</operator> <name>dense</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>newstrlen</name> <operator>=</operator> <name>HLL_DENSE_SIZE</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* "Add" the element in the sparse hyperloglog data structure.
 * Actually nothing is added, but the max 0 pattern counter of the subset
 * the element belongs to is incremented if needed.
 *
 * The object 'o' is the String object holding the HLL. The function requires
 * a reference to the object in order to be able to enlarge the string if
 * needed.
 *
 * On success, the function returns 1 if the cardinality changed, or 0
 * if the register for this element was not updated.
 * On error (if the representation is invalid) -1 is returned.
 *
 * As a side effect the function may promote the HLL representation from
 * sparse to dense: this happens when a register requires to be set to a value
 * not representable with the sparse representation, or when the resulting
 * size would be greater than server.hll_sparse_max_bytes. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hllSparseAdd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>oldcount</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sparse</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>first</name></decl>, <decl><type ref="prev"/><name>span</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>is_zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_xzero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Update the register if this element produced a longer run of zeroes. */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>hllPatLen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the count is too big to be representable by the sparse representation
     * switch to dense representation. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>HLL_SPARSE_VAL_MAX_VALUE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* When updating a sparse representation, sometimes we may need to
     * enlarge the buffer for up to 3 bytes in the worst case (XZERO split
     * into XZERO-VAL-XZERO). Make sure there is enough space right now
     * so that the pointers we take during the execution of the function
     * will be valid all the time. */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rl_realloc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>strlen</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>str</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

    <comment type="block">/* Step 1: we need to locate the opcode we need to modify to check
     * if a value update is actually needed. */</comment>
    <expr_stmt><expr><name>sparse</name> <operator>=</operator> <name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>str</name><operator>)</operator> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>strlen</name> <operator>-</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Points to previos opcode at the end of the loop. */</comment>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Points to the next opcode at the end of the loop. */</comment>
    <expr_stmt><expr><name>span</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>oplen</name></decl>;</decl_stmt>

        <comment type="block">/* Set span to the number of registers covered by this opcode.
         *
         * This is the most performance critical loop of the sparse
         * representation. Sorting the conditionals from the most to the
         * least frequent opcode in many-bytes sparse HLLs is faster. */</comment>
        <expr_stmt><expr><name>oplen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_VAL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* XZERO. */</comment>
            <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>oplen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Break if this opcode covers the register as 'index'. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;=</operator> <name>first</name><operator>+</operator><name>span</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>oplen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>first</name> <operator>+=</operator> <name>span</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>span</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Invalid format. */</comment>

    <expr_stmt><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr> </then><else>: <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>next</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Cache current opcode type to avoid using the macro again and
     * again for something that will not change.
     * Also cache the run-length of the opcode. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_zero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_xzero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>is_val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Step 2: After the loop:
     *
     * 'first' stores to the index of the first register covered
     *  by the current opcode, which is pointed by 'p'.
     *
     * 'next' ad 'prev' store respectively the next and previous opcode,
     *  or NULL if the opcode at 'p' is respectively the last or first.
     *
     * 'span' is set to the number of registers covered by the current
     *  opcode.
     *
     * There are different cases in order to update the data structure
     * in place without generating it from scratch:
     *
     * A) If it is a VAL opcode already set to a value &gt;= our 'count'
     *    no update is needed, regardless of the VAL run-length field.
     *    In this case PFADD returns 0 since no changes are performed.
     *
     * B) If it is a VAL opcode with len = 1 (representing only our
     *    register) and the value is less than 'count', we just update it
     *    since this is a trivial case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_val</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>oldcount</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Case A. */</comment>
        <if_stmt><if>if <condition>(<expr><name>oldcount</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Case B. */</comment>
        <if_stmt><if>if <condition>(<expr><name>runlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>updated</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* C) Another trivial to handle case is a ZERO opcode with a len of 1.
     * We can just replace it with a VAL opcode with our value and len of 1. */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>&amp;&amp;</operator> <name>runlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>updated</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* D) General case.
     *
     * The other cases are more complex: our register requires to be updated
     * and is either currently represented by a VAL opcode with len &gt; 1,
     * by a ZERO opcode with len &gt; 1, or by an XZERO opcode.
     *
     * In those cases the original opcode must be split into muliple
     * opcodes. The worst case is an XZERO split in the middle resuling into
     * XZERO - VAL - XZERO, so the resulting sequence max length is
     * 5 bytes.
     *
     * We perform the split writing the new sequence into the 'new' buffer
     * with 'newlen' as length. Later the new sequence is inserted in place
     * of the old one, possibly moving what is on the right a few bytes
     * if the new sequence is longer than the older one. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>seq</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name> <init>= <expr><name>seq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><name>first</name><operator>+</operator><name>span</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Last register covered by the sequence. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>||</operator> <name>is_xzero</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Handle splitting of ZERO / XZERO. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>first</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>index</name><operator>-</operator><name>first</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>HLL_SPARSE_ZERO_MAX_LEN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_ZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>last</name><operator>-</operator><name>index</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>HLL_SPARSE_ZERO_MAX_LEN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_ZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Handle splitting of VAL. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>curval</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>first</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>index</name><operator>-</operator><name>first</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curval</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>last</name><operator>-</operator><name>index</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curval</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Step 3: substitute the new sequence with the old one.
     *
     * Note that we already allocated space on the sds string
     * calling sdsMakeRoomFor(). */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>seqlen</name> <init>= <expr><name>n</name><operator>-</operator><name>seq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>oldlen</name> <init>= <expr><ternary><condition><expr><name>is_xzero</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>deltalen</name> <init>= <expr><name>seqlen</name><operator>-</operator><name>oldlen</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>deltalen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>strlen</name><operator>+</operator><name>deltalen</name><operator>)</operator> <operator>&gt;</operator> <name>rl_hll_sparse_max_bytes</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>deltalen</name> <operator>&amp;&amp;</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>next</name><operator>+</operator><name>deltalen</name></expr></argument>,<argument><expr><name>next</name></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>strlen</name> <operator>+=</operator> <name>deltalen</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>seq</name></expr></argument>,<argument><expr><name>seqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>+=</operator> <name>deltalen</name></expr>;</expr_stmt>

<label><name>updated</name>:</label>
    <comment type="block">/* Step 4: Merge adjacent values if possible.
     *
     * The representation was updated, however the resulting representation
     * may not be optimal: adjacent VAL opcodes can sometimes be merged into
     * a single one. */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>prev</name></expr> ?</condition><then> <expr><name>prev</name></expr> </then><else>: <expr><name>sparse</name></expr></else></ternary></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scanlen</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Scan up to 5 upcodes starting from prev. */</comment>
    <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>scanlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* We need two adjacent VAL opcodes to try a merge, having
         * the same value, and a len that fits the VAL opcode max len. */</comment>
        <if_stmt><if>if <condition>(<expr><name>p</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>HLL_SPARSE_IS_VAL</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>v1</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>HLL_SPARSE_VAL_MAX_LEN</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>strlen</name><operator>--</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
                    <comment type="block">/* After a merge we reiterate without incrementing 'p'
                     * in order to try to merge the just merged value with
                     * a value on its right. */</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Invalidate the cached cardinality. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>promote</name>:</label> <comment type="block">/* Promote to dense representation. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Corrupted HLL. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <comment type="block">/* We need to call hllDenseAdd() to perform the operation after the
     * conversion. However the result must be 1, since if we need to
     * convert from sparse to dense a register requires to be updated.
     *
     * Note that this in turn means that PFADD will make sure the command
     * is propagated to slaves / AOF, so if there is a sparse -&gt; dense
     * convertion, it will be performed in all the slaves as well. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dense_retval</name> <init>= <expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><name>elesize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
    <return>return <expr><name>dense_retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute SUM(2^-reg) in the sparse representation.
 * PE is an array with a pre-computer table of values 2^-reg indexed by reg.
 * As a side effect the integer pointed by 'ezp' is set to the number
 * of zero registers. */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>hllSparseSum</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sparse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sparselen</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>PE</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ezp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>invalid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ez</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>sparse</name><operator>+</operator><name>sparselen</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>sparse</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ez</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <comment type="block">/* Increment E at the end of the loop. */</comment>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ez</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <comment type="block">/* Increment E at the end of the loop. */</comment>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name>regval</name></expr>]</index></name><operator>*</operator><name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>HLL_REGISTERS</name> <operator>&amp;&amp;</operator> <name>invalid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>invalid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>E</name> <operator>+=</operator> <name>ez</name></expr>;</expr_stmt> <comment type="block">/* Add 2^0 'ez' times. */</comment>
    <expr_stmt><expr><operator>*</operator><name>ezp</name> <operator>=</operator> <name>ez</name></expr>;</expr_stmt>
    <return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================= HyperLogLog Count ==============================
 * This is the core of the algorithm where the approximated count is computed.
 * The function uses the lower level hllDenseSum() and hllSparseSum() functions
 * as helpers to compute the SUM(2^-reg) part of the computation, which is
 * representation-specific, while all the rest is common. */</comment>

<comment type="block">/* Implements the SUM operation for uint8_t data type which is only used
 * internally as speedup for PFCOUNT with multiple keys. */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>hllRawSum</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>PE</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ezp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>ez</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>word</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator> <name>registers</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bytes</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name><operator>/</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ez</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <name>word</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>E</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>ez</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>word</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>E</name> <operator>+=</operator> <name>ez</name></expr>;</expr_stmt> <comment type="block">/* 2^(-reg[j]) is 1 when m is 0, add it 'ez' times for every
                zero register in the HLL. */</comment>
    <expr_stmt><expr><operator>*</operator><name>ezp</name> <operator>=</operator> <name>ez</name></expr>;</expr_stmt>
    <return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the approximated cardinality of the set based on the harmonic
 * mean of the registers values. 'hdr' points to the start of the SDS
 * representing the String object holding the HLL representation.
 *
 * If the sparse representation of the HLL object is not valid, the integer
 * pointed by 'invalid' is set to non-zero, otherwise it is left untouched.
 *
 * hllCount() supports a special internal-only encoding of HLL_RAW, that
 * is, hdr-&gt;registers will point to an uint8_t array of HLL_REGISTERS element.
 * This is useful in order to speedup PFCOUNT when called against multiple
 * keys (no need to work with 6-bit integers encoding). */</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>hllCount</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>invalid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>m</name> <init>= <expr><name>HLL_REGISTERS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>E</name></decl>, <decl><type ref="prev"/><name>alpha</name> <init>= <expr><literal type="number">0.7213</literal><operator>/</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><literal type="number">1.079</literal><operator>/</operator><name>m</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>ez</name></decl>;</decl_stmt> <comment type="block">/* Number of registers equal to 0. */</comment>

    <comment type="block">/* We precompute 2^(-reg[j]) in a small table in order to
     * speedup the computation of SUM(2^-register[0..i]). */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name><name>PE</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>initialized</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>PE</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* 2^(-reg[j]) is 1 when m is 0. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* 2^(-reg[j]) is the same as 1/2^reg[j]. */</comment>
            <expr_stmt><expr><name><name>PE</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal><operator>/</operator><operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>initialized</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute SUM(2^-register[0..i]). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>hllDenseSum</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>PE</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ez</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>hllSparseSum</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>, <argument><expr><name>strlen</name><operator>-</operator><name>HLL_HDR_SIZE</name></expr></argument>,<argument><expr><name>PE</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ez</name></expr></argument>,<argument><expr><name>invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_RAW</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>hllRawSum</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>PE</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ez</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Muliply the inverse of E for alpha_m * m^2 to have the raw estimate. */</comment>
    <expr_stmt><expr><name>E</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>/</operator><name>E</name><operator>)</operator><operator>*</operator><name>alpha</name><operator>*</operator><name>m</name><operator>*</operator><name>m</name></expr>;</expr_stmt>

    <comment type="block">/* Use the LINEARCOUNTING algorithm for small cardinalities.
     * For larger values but up to 72000 HyperLogLog raw approximation is
     * used since linear counting error starts to increase. However HyperLogLog
     * shows a strong bias in the range 2.5*16384 - 72000, so we try to
     * compensate for it. */</comment>
    <if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <name>m</name><operator>*</operator><literal type="number">2.5</literal> <operator>&amp;&amp;</operator> <name>ez</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>E</name> <operator>=</operator> <name>m</name><operator>*</operator><call><name>log</name><argument_list>(<argument><expr><name>m</name><operator>/</operator><name>ez</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* LINEARCOUNTING() */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">16384</literal> <operator>&amp;&amp;</operator> <name>E</name> <operator>&lt;</operator> <literal type="number">72000</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We did polynomial regression of the bias for this range, this
         * way we can compute the bias for a given cardinality and correct
         * according to it. Only apply the correction for P=14 that's what
         * we use and the value the correction was verified with. */</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>bias</name> <init>= <expr><literal type="number">5.9119</literal><operator>*</operator><literal type="number">1.0e-18</literal><operator>*</operator><operator>(</operator><name>E</name><operator>*</operator><name>E</name><operator>*</operator><name>E</name><operator>*</operator><name>E</name><operator>)</operator>
                      <operator>-</operator><literal type="number">1.4253</literal><operator>*</operator><literal type="number">1.0e-12</literal><operator>*</operator><operator>(</operator><name>E</name><operator>*</operator><name>E</name><operator>*</operator><name>E</name><operator>)</operator><operator>+</operator>
                      <literal type="number">1.2940</literal><operator>*</operator><literal type="number">1.0e-7</literal><operator>*</operator><operator>(</operator><name>E</name><operator>*</operator><name>E</name><operator>)</operator>
                      <operator>-</operator><literal type="number">5.2921</literal><operator>*</operator><literal type="number">1.0e-3</literal><operator>*</operator><name>E</name><operator>+</operator>
                      <literal type="number">83.3216</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>E</name> <operator>-=</operator> <name>E</name><operator>*</operator><operator>(</operator><name>bias</name><operator>/</operator><literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* We don't apply the correction for E &gt; 1/30 of 2^32 since we use
     * a 64 bit function and 6 bit counters. To apply the correction for
     * 1/30 of 2^64 is not needed since it would require a huge set
     * to approach such a value. */</comment>
    <return>return <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>E</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hllAdd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>HLL_DENSE</name></expr>:</case> <return>return <expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><name>elesize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>HLL_SPARSE</name></expr>:</case> <return>return <expr><call><name>hllSparseAdd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>, <argument><expr><name>_str</name></expr></argument>, <argument><expr><name>_strlen</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> <comment type="block">/* Invalid representation. */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Merge by computing MAX(registers[i],hll[i]) the HyperLogLog 'hll'
 * with an array of uint8_t HLL_REGISTERS registers pointed by 'max'.
 *
 * The hll object must be already validated via isHLLObject()
 * or in some other way.
 *
 * If the HyperLogLog is sparse and is found to be invalid, 1
 * is returned, otherwise the function always succeeds. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hllMerge</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>val</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <name><name>max</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>max</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>hdr</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name> <operator>+</operator> <name>strlen</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while<condition>(<expr><name>runlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>regval</name> <operator>&gt;</operator> <name><name>max</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>max</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>regval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================== HyperLogLog commands ========================== */</comment>

<comment type="block">/* Create an HLL object. We always create the HLL using sparse encoding.
 * This will be upgraded to the dense representation as needed. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createHLLObject</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sparselen</name> <init>= <expr><name>HLL_HDR_SIZE</name> <operator>+</operator>
                    <operator>(</operator><operator>(</operator><operator>(</operator><name>HLL_REGISTERS</name><operator>+</operator><operator>(</operator><name>HLL_SPARSE_XZERO_MAX_LEN</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator>
                     <name>HLL_SPARSE_XZERO_MAX_LEN</name><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>aux</name></decl>;</decl_stmt>

    <comment type="block">/* Populate the sparse representation with as many XZERO opcodes as
     * needed to represent all the registers. */</comment>
    <expr_stmt><expr><name>aux</name> <operator>=</operator> <name>HLL_REGISTERS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>sparselen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>aux</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>xzero</name> <init>= <expr><name>HLL_SPARSE_XZERO_MAX_LEN</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>xzero</name> <operator>&gt;</operator> <name>aux</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xzero</name> <operator>=</operator> <name>aux</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>xzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>aux</name> <operator>-=</operator> <name>xzero</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>p</name><operator>-</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>s</name><operator>)</operator> <operator>==</operator> <name>sparselen</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Create the actual object. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>,<argument><expr><literal type="string">"HYLL"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_SPARSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>sparselen</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check if the object is a String with a valid HLL representation.
 * Return 0 if this is true, otherwise return 1. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isHLLObject</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>strlen</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <comment type="block">/* Magic should be "HYLL". */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'H'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'Y'</literal> <operator>||</operator>
        <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>&gt;</operator> <name>HLL_MAX_ENCODING</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Dense representation string length should match exactly. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name> <operator>&amp;&amp;</operator>
        <name>strlen</name> <operator>!=</operator> <name>HLL_DENSE_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* All tests passed. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>invalid</name>:</label>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PFADD var ele ele ele ... ele =&gt; :0 or :1 */</comment>
<function><type><name>int</name></type> <name>rl_str_pfadd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>argvlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>updated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Create the key with a string value of the exact length to
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>createHLLObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Perform the low level ADD operation for every element. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>hllAdd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>updated</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PFCOUNT var -&gt; approximated cardinality of set. */</comment>
<function><type><name>int</name></type> <name>rl_str_pfcount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>argvlen</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_card</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>updatevalue</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>updatevaluelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>card</name></decl>;</decl_stmt>

    <comment type="block">/* Case 1: multi-key keys, cardinality of the union.
     *
     * When multiple keys are specified, PFCOUNT actually computes
     * the cardinality of the merge of the N HLLs specified. */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>max</name><index>[<expr><name>HLL_HDR_SIZE</name><operator>+</operator><name>HLL_REGISTERS</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>registers</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Compute an HLL with M[i] = MAX(M[i]_j). */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>max</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_RAW</name></expr>;</expr_stmt> <comment type="block">/* Special internal-only encoding. */</comment>
        <expr_stmt><expr><name>registers</name> <operator>=</operator> <name>max</name> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* Check type and size. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Assume empty HLL for non existing var. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* Merge with this HLL with our 'max' HHL by setting max[i]
             * to MAX(max[i],hll[i]). */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>hllMerge</name><argument_list>(<argument><expr><name>registers</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Compute cardinality of the resulting set. */</comment>
        <comment type="line">// TODO: probably not 0</comment>
        <expr_stmt><expr><operator>*</operator><name>_card</name> <operator>=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Case 2: cardinality of the single HLL.
     *
     * The user specified a single key. Either return the cached value
     * or compute one and update the cache. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No key? Cardinality is zero since no element was added, otherwise
         * we would have a key as HLLADD creates it as a side effect. */</comment>
        <expr_stmt><expr><operator>*</operator><name>_card</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Check if the cached cardinality is valid. */</comment>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_VALID_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Just return the cached value. */</comment>
            <expr_stmt><expr><name>card</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>invalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Recompute it and update the cached value. */</comment>
            <expr_stmt><expr><name>card</name> <operator>=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>invalid</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>card</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">40</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">56</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <comment type="block">/* This is not considered a read-only command even if the
             * data structure is not modified, since the cached value
             * may be modified and given that the HLL is a Redis string
             * we need to propagate the change. */</comment>
            <if_stmt><if>if <condition>(<expr><name>updatevalue</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>updatevalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>hdr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>updatevalue</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>updatevaluelen</name> <operator>=</operator> <name><name>argvlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>_card</name> <operator>=</operator> <name>card</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rl_str_pfmerge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>argvlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>max</name><index>[<expr><name>HLL_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Compute an HLL with M[i] = MAX(M[i]_j).
     * We we the maximum into the max array of registers. We'll write
     * it to the target variable later. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Check type and size. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Assume empty HLL for non existing var. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Merge with this HLL with our 'max' HHL by setting max[i]
         * to MAX(max[i],hll[i]). */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>hllMerge</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>createHLLObject</name><argument_list>(<argument><expr><name>_str</name></expr></argument>, <argument><expr><name>_strlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Only support dense objects as destination. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><operator>*</operator><name>_str</name></expr></argument>, <argument><expr><operator>*</operator><name>_strlen</name></expr></argument>, <argument><expr><name>_str</name></expr></argument>, <argument><expr><name>_strlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Write the resulting HLL to the destination HLL registers and
     * invalidate the cached value. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>_str</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================== Testing / Debugging  ========================== */</comment>

<comment type="block">/* PFSELFTEST
 * This command performs a self-test of the HLL registers implementation.
 * Something that is not easy to test from within the outside. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_TEST_CYCLES</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>rl_str_pfselftest</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bitcounters</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>HLL_DENSE_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>bitcounters</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hdr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>bytecounters</name><index>[<expr><name>HLL_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Test 1: access registers.
     * The test is conceived to test that the different counters of our data
     * structure are accessible and that setting their values both result in
     * the correct value to be retained and not affect adjacent values. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_TEST_CYCLES</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Set the HLL counters and an array of unsigned byes of the
         * same size to the same set of random values. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name> <init>= <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>HLL_REGISTER_MAX</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* Check that we are able to retrieve the same values. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* Test 2: approximation error.
     * The test adds unique elements and check that the estimated value
     * is always reasonable bounds.
     *
     * We check that the error is smaller than a few times than the expected
     * standard error, to make it very unlikely for the test to fail because
     * of a "bad" run.
     *
     * The test is performed with both dense and sparse HLLs at the same
     * time also verifying that the computed cardinality is the same. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name><operator>-</operator><name>HLL_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>createHLLObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>relerr</name> <init>= <expr><literal type="number">1.04</literal><operator>/</operator><call><name>sqrt</name><argument_list>(<argument><expr><name>HLL_REGISTERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>checkpoint</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>seed</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>|</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>ele</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <literal type="number">10000000</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>ele</name> <operator>=</operator> <name>j</name> <operator>^</operator> <name>seed</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hllAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ele</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure that for small cardinalities we use sparse
         * encoding. */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>rl_hll_sparse_max_bytes</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hdr2</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>o</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>hdr2</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check that dense and sparse representations agree. */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name> <operator>&amp;&amp;</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>HLL_DENSE_SIZE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>o</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">3</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check error. */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>abserr</name> <init>= <expr><name>checkpoint</name> <operator>-</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>HLL_DENSE_SIZE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>maxerr</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>relerr</name><operator>*</operator><literal type="number">6</literal><operator>*</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Adjust the max error we expect for cardinality 10
             * since from time to time it is statistically likely to get
             * much higher error due to collision, resulting into a false
             * positive. */</comment>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxerr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>abserr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>abserr</name> <operator>=</operator> <operator>-</operator><name>abserr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>abserr</name> <operator>&gt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>maxerr</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">4</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>checkpoint</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>bitcounters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rl_free</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rl_str_pfdebug_getreg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier><modifier>*</modifier></type><name>elements</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>HLL_REGISTERS</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>elements</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>HLL_REGISTERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>elements</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>val</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>elements</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>val</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>objlen</name></type></parameter>, <parameter><type><name>objalloc</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>srclen</name></type></parameter>)</parameter_list></cpp:macro>\
    <cpp:value>while (objlen + srclen &gt; objalloc) {\
        unsigned char *tmp = rl_realloc(obj, sizeof(unsigned char) * objalloc * 2);\
        if (!tmp) {\
            rl_free(obj);\
            return -4;\
        }\
        obj = tmp;\
        objalloc *= 2;\
    }\
    memcpy(&amp;obj[objlen], src, srclen);\
    objlen += srclen;</cpp:value></cpp:define>

<function><type><name>int</name></type> <name>rl_str_pfdebug_decode</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>response</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>responselen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name><operator>+</operator><name>strlen</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>decodedlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>decodedall</name> <init>= <expr><name>strlen</name> <operator>*</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>decoded</name> <init>= <expr><call><name>rl_malloc</name><argument_list>(<argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <name>decodedall</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>tmplen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmplen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="string">"z:%d "</literal></expr></argument>, <argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>decodedlen</name></expr></argument>, <argument><expr><name>decodedall</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmplen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="string">"Z:%d "</literal></expr></argument>, <argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>decodedlen</name></expr></argument>, <argument><expr><name>decodedall</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmplen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="string">"v:%d,%d "</literal></expr></argument>,<argument><expr><name>regval</name></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>decodedlen</name></expr></argument>, <argument><expr><name>decodedall</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>decodedlen</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>rl_realloc</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>decodedlen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>response</name> <operator>=</operator> <name>decoded</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>responselen</name> <operator>=</operator> <name>decodedlen</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rl_str_pfdebug_encoding</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>response</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>responselen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>encodingstr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"dense"</literal></expr>,<expr><literal type="string">"sparse"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>responselen</name> <operator>=</operator> <literal type="number">5</literal> <operator>+</operator> <name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>response</name> <operator>=</operator> <call><name>rl_malloc</name><argument_list>(<argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>*</operator><name>responselen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>response</name></expr></argument>, <argument><expr><name><name>encodingstr</name><index>[<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>responselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rl_str_pfdebug_todense</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>strlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>_str</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>_strlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isHLLObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>conv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>conv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>_str</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>_strlen</name> <operator>=</operator> <name>strlen</name></expr>;</expr_stmt>
    <return>return <expr><name>conv</name></expr>;</return>
</block_content>}</block></function>
</unit>
