<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/Zip/deflate.c"><comment type="block">/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin &amp; Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&amp;G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://tools.ietf.org/html/rfc1951
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */</comment>

<comment type="block">/* @(#) $Id$ */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>deflate_copyright</name><index>[]</index></name> <init>=
   <expr><literal type="string">" deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler "</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */</comment>

<comment type="block">/* ===========================================================================
 *  Function prototypes.
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>need_more</name></decl>,      <comment type="block">/* block not completed, need more input or more output */</comment>
    <decl><name>block_done</name></decl>,     <comment type="block">/* block flush performed */</comment>
    <decl><name>finish_started</name></decl>, <comment type="block">/* finish started, need only more output at next deflate */</comment>
    <decl><name>finish_done</name></decl>     <comment type="block">/* finish done, accept no more input or output */</comment>
}</block></enum></type> <name>block_state</name>;</typedef>

<typedef>typedef <macro><name>block_state</name> <argument_list>(<argument>*compress_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<comment type="block">/* Compression function. Returns the block state after the call. */</comment>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fill_window</name></type>    <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_stored</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_fast</name></type>   <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_slow</name></type>   <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_rle</name></type>    <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_huff</name></type>   <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>lm_init</name></type>        <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>putShortMSB</name></type>    <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>uInt</name> <name>b</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>flush_pending</name></type>  <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>read_buf</name></type>        <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>Bytef</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>unsigned</name> <name>size</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ASMV</name></cpp:ifdef>
      <decl_stmt><decl><type><name>void</name> <name>match_init</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt> <comment type="block">/* asm code initialization */</comment>
      <decl_stmt><decl><type><name>uInt</name> <name>longest_match</name></type>  <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>IPos</name> <name>cur_match</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>local</name> <name>uInt</name> <name>longest_match</name></type>  <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>IPos</name> <name>cur_match</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name>  <name>void</name> <name>check_match</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>IPos</name> <name>start</name><operator>,</operator> <name>IPos</name> <name>match</name><operator>,</operator>
                            <name>int</name> <name>length</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Local data
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NIL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/* Tail of hash chains */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TOO_FAR</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>TOO_FAR</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */</comment>

<comment type="block">/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */</comment>
<typedef>typedef <type><struct>struct <name>config_s</name> <block>{
   <decl_stmt><decl><type><name>ush</name></type> <name>good_length</name></decl>;</decl_stmt> <comment type="block">/* reduce lazy search above this match length */</comment>
   <decl_stmt><decl><type><name>ush</name></type> <name>max_lazy</name></decl>;</decl_stmt>    <comment type="block">/* do not perform lazy search above this match length */</comment>
   <decl_stmt><decl><type><name>ush</name></type> <name>nice_length</name></decl>;</decl_stmt> <comment type="block">/* quit search above this match length */</comment>
   <decl_stmt><decl><type><name>ush</name></type> <name>max_chain</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>config</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*      good lazy nice chain */</comment>
<comment type="block">/* 0 */</comment> <expr><block>{<expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>, <expr><name>deflate_stored</name></expr>}</block></expr>,  <comment type="block">/* store only */</comment>
<comment type="block">/* 1 */</comment> <expr><block>{<expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">8</literal></expr>,    <expr><literal type="number">4</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* max speed, no lazy matches */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*      good lazy nice chain */</comment>
<comment type="block">/* 0 */</comment> <expr><block>{<expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>, <expr><name>deflate_stored</name></expr>}</block></expr>,  <comment type="block">/* store only */</comment>
<comment type="block">/* 1 */</comment> <expr><block>{<expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">8</literal></expr>,    <expr><literal type="number">4</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>, <comment type="block">/* max speed, no lazy matches */</comment>
<comment type="block">/* 2 */</comment> <expr><block>{<expr><literal type="number">4</literal></expr>,    <expr><literal type="number">5</literal></expr>, <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">8</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,
<comment type="block">/* 3 */</comment> <expr><block>{<expr><literal type="number">4</literal></expr>,    <expr><literal type="number">6</literal></expr>, <expr><literal type="number">32</literal></expr>,   <expr><literal type="number">32</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,

<comment type="block">/* 4 */</comment> <expr><block>{<expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>, <expr><literal type="number">16</literal></expr>,   <expr><literal type="number">16</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,  <comment type="block">/* lazy matches */</comment>
<comment type="block">/* 5 */</comment> <expr><block>{<expr><literal type="number">8</literal></expr>,   <expr><literal type="number">16</literal></expr>, <expr><literal type="number">32</literal></expr>,   <expr><literal type="number">32</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 6 */</comment> <expr><block>{<expr><literal type="number">8</literal></expr>,   <expr><literal type="number">16</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 7 */</comment> <expr><block>{<expr><literal type="number">8</literal></expr>,   <expr><literal type="number">32</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">256</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 8 */</comment> <expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">258</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 9 */</comment> <expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">258</literal></expr>, <expr><literal type="number">258</literal></expr>, <expr><literal type="number">4096</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* max compression */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4
 * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different
 * meaning.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EQUAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/* result of memcmp for equal strings */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUMMY_DECL</name></cpp:ifndef>
<struct>struct <name>static_tree_desc_s</name> <block>{<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>}</block>;</struct> <comment type="block">/* for buggy compilers */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANK</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((f) &lt;&lt; 1) - ((f) &gt; 4 ? 9 : 0))</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_HASH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</cpp:value></cpp:define>


<comment type="block">/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>match_head</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
    match_head = s-&gt;head[s-&gt;ins_h], \
    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>match_head</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
    match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], \
    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_HASH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>s-&gt;head[s-&gt;hash_size-1] = NIL; \
    zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</cpp:value></cpp:define>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>level</name></type></decl></parameter>, <parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{<block_content>
    <return>return <expr><call><name>deflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><name>MAX_WBITS</name></expr></argument>, <argument><expr><name>DEF_MEM_LEVEL</name></expr></argument>,
                         <argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
    <comment type="block">/* To do: ignore strm-&gt;next_in if we use it as window */</comment>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit2_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>level</name></type></decl></parameter>, <parameter><decl><type><name>method</name></type></decl></parameter>, <parameter><decl><type><name>windowBits</name></type></decl></parameter>, <parameter><decl><type><name>memLevel</name></type></decl></parameter>, <parameter><decl><type><name>strategy</name></type></decl></parameter>,
                  <parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>method</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>windowBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>memLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>strategy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wrap</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>my_version</name><index>[]</index></name> <init>= <expr><name>ZLIB_VERSION</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ushf</name> <modifier>*</modifier></type><name>overlay</name></decl>;</decl_stmt>
    <comment type="block">/* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is &lt;= 24 bits.
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>my_version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
        <name>stream_size</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_SOLO</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>=</operator> <name>zcalloc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <operator>(</operator><name>voidpf</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_SOLO</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>=</operator> <name>zcfree</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* suppress zlib wrapper */</comment>
        <expr_stmt><expr><name>wrap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>windowBits</name> <operator>=</operator> <operator>-</operator><name>windowBits</name></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><name>windowBits</name> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>wrap</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>       <comment type="block">/* write gzip wrapper instead */</comment>
        <expr_stmt><expr><name>windowBits</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>memLevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>memLevel</name></expr></argument> &gt;</argument_list></name> <name>MAX_MEM_LEVEL</name> <operator>||</operator> <name>method</name> <operator>!=</operator> <name>Z_DEFLATED</name> <operator>||</operator>
        <name><name>windowBits</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>windowBits</name></expr></argument> &gt;</argument_list></name> <literal type="number">15</literal> <operator>||</operator> <name><name>level</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>level</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal> <operator>||</operator>
        <name><name>strategy</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>strategy</name></expr></argument> &gt;</argument_list></name> <name>Z_FIXED</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>windowBits</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* until 256-byte window bug fixed */</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>deflate_state</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name> <operator>=</operator> <name>strm</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <name>wrap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name> <operator>=</operator> <name>windowBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>=</operator> <name>memLevel</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_shift</name></name> <operator>=</operator>  <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name><operator>+</operator><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>MIN_MATCH</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name>   <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator>  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>head</name></name>   <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator>  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>      <comment type="block">/* nothing written to s-&gt;window yet */</comment>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>memLevel</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* 16K elements by default */</comment>

    <expr_stmt><expr><name>overlay</name> <operator>=</operator> <operator>(</operator><name>ushf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>=</operator> <operator>(</operator><name>uchf</name> <operator>*</operator><operator>)</operator> <name>overlay</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">2L</literal><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>FINISH_STATE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_MEM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>=</operator> <name>overlay</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>l_buf</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>method</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>)</operator><name>method</name></expr>;</expr_stmt>

    <return>return <expr><call><name>deflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetDictionary</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>dictionary</name></type></decl></parameter>, <parameter><decl><type><name>dictLength</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>dictionary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>dictLength</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wrap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>avail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_const</name> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name>dictionary</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>wrap</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>wrap</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>wrap</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>INIT_STATE</name><operator>)</operator> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* when using zlib wrappers, compute Adler-32 for provided dictionary */</comment>
    <if_stmt><if>if <condition>(<expr><name>wrap</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                    <comment type="block">/* avoid computing Adler-32 in read_buf */</comment>

    <comment type="block">/* if dictionary would fill window, just replace the history */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictLength</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>wrap</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>            <comment type="block">/* already empty otherwise */</comment>
            <expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>dictionary</name> <operator>+=</operator> <name>dictLength</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>  <comment type="block">/* use the tail */</comment>
        <expr_stmt><expr><name>dictLength</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* insert dictionary into window and hash */</comment>
    <expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>dictLength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>z_const</name> <name>Bytef</name> <operator>*</operator><operator>)</operator><name>dictionary</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator> <operator>(</operator><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <do>do <block>{<block_content>
            <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name> <operator>+</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name><index>[<expr><name>str</name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><name>str</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>avail</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <name>wrap</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateResetKeep</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt> <comment type="block">/* use zfree if we ever allocate msg dynamically */</comment>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>data_type</name></name> <operator>=</operator> <name>Z_UNKNOWN</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>deflate_state</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <operator>-</operator><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>;</expr_stmt> <comment type="block">/* was made negative by deflate(..., Z_FINISH); */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr> ?</condition><then> <expr><name>INIT_STATE</name></expr> </then><else>: <expr><name>BUSY_STATE</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
        <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <name>Z_NO_FLUSH</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_tr_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateReset</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>deflateResetKeep</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>lm_init</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetHeader</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>head</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_headerp</name></type> <name>head</name></decl>;</decl_stmt>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflatePending</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>pending</name></type></decl></parameter>, <parameter><decl><type><name>bits</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>pending</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pending</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>pending</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>bits</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>bi_valid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflatePrime</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>bits</name></type></decl></parameter>, <parameter><decl><type><name>value</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>put</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>Buf_size</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_BUF_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>put</name> <operator>=</operator> <name>Buf_size</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>put</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>put</name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>|=</operator> <operator>(</operator><name>ush</name><operator>)</operator><operator>(</operator><operator>(</operator><name>value</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>put</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>+=</operator> <name>put</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_tr_flush_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>&gt;&gt;=</operator> <name>put</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>-=</operator> <name>put</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>bits</name></expr>)</condition>;</do>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateParams</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>level</name></type></decl></parameter>, <parameter><decl><type><name>strategy</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>level</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>level</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal> <operator>||</operator> <name><name>strategy</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>strategy</name></expr></argument> &gt;</argument_list></name> <name>Z_FIXED</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>func</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>strategy</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>||</operator> <name>func</name> <operator>!=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>func</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Flush the last buffer: */</comment>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>deflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>Z_BUF_ERROR</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>err</name> <operator>=</operator> <name>Z_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>!=</operator> <name>level</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name>   <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>max_lazy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>good_match</name></name>       <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>good_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name>       <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nice_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>max_chain</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateTune</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>good_length</name></type></decl></parameter>, <parameter><decl><type><name>max_lazy</name></type></decl></parameter>, <parameter><decl><type><name>nice_length</name></type></decl></parameter>, <parameter><decl><type><name>max_chain</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>good_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_lazy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nice_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_chain</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>good_match</name></name> <operator>=</operator> <name>good_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name> <operator>=</operator> <name>max_lazy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name> <operator>=</operator> <name>nice_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name> <operator>=</operator> <name>max_chain</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds for
 * every combination of windowBits and memLevel.  But even the conservative
 * upper bound of about 14% expansion does not seem onerous for output buffer
 * allocation.
 */</comment>
<function><type><name>uLong</name> <name>ZEXPORT</name></type> <name>deflateBound</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>sourceLen</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLong</name></type> <name>sourceLen</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLong</name></type> <name>complen</name></decl>, <decl><type ref="prev"/><name>wraplen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

    <comment type="block">/* conservative upper bound for compressed data */</comment>
    <expr_stmt><expr><name>complen</name> <operator>=</operator> <name>sourceLen</name> <operator>+</operator>
              <operator>(</operator><operator>(</operator><name>sourceLen</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>sourceLen</name> <operator>+</operator> <literal type="number">63</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>

    <comment type="block">/* if can't get parameters, return conservative bound plus zlib wrapper */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>complen</name> <operator>+</operator> <literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* compute wrapper length */</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>                                 <comment type="block">/* raw deflate */</comment>
        <expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">1</literal></expr>:</case>                                 <comment type="block">/* zlib wrapper */</comment>
        <expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">6</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">2</literal></expr>:</case>                                 <comment type="block">/* gzip wrapper */</comment>
        <expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>          <comment type="block">/* user-supplied gzip header */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wraplen</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><name>wraplen</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator></expr>)</condition>;</do></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><name>wraplen</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator></expr>)</condition>;</do></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wraplen</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
    <default>default:</default>                                <comment type="block">/* for compiler happiness */</comment>
        <expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* if not default parameters, return conservative bound */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name> <operator>!=</operator> <literal type="number">15</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>!=</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>complen</name> <operator>+</operator> <name>wraplen</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* default settings: return tight bound for that case */</comment>
    <return>return <expr><name>sourceLen</name> <operator>+</operator> <operator>(</operator><name>sourceLen</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>sourceLen</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator> <operator>+</operator>
           <operator>(</operator><name>sourceLen</name> <operator>&gt;&gt;</operator> <literal type="number">25</literal><operator>)</operator> <operator>+</operator> <literal type="number">13</literal> <operator>-</operator> <literal type="number">6</literal> <operator>+</operator> <name>wraplen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>putShortMSB</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>b</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>b</name></decl>;</decl_stmt>
<block>{<block_content>
    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name>b</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm-&gt;next_out buffer and copying into it.
 * (See also read_buf()).
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>flush_pending</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>_tr_flush_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name>  <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name>  <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name>  <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflate</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>old_flush</name></decl>;</decl_stmt> <comment type="block">/* value of flush param for previous deflate call */</comment>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <name>flush</name> <operator>&gt;</operator> <name>Z_BLOCK</name> <operator>||</operator> <name>flush</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>FINISH_STATE</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>!=</operator> <name>Z_FINISH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name> <operator>=</operator> <name>strm</name></expr>;</expr_stmt> <comment type="block">/* just in case */</comment>
    <expr_stmt><expr><name>old_flush</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <name>flush</name></expr>;</expr_stmt>

    <comment type="block">/* Write the header */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>INIT_STATE</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">139</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:
                            <expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>Z_HUFFMAN_ONLY</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then>
                             <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>OS_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>text</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                            <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                            <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>==</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                            <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                            <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name></name> <operator>==</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary><operator>)</operator></expr></argument>
                        )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:
                            <expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>Z_HUFFMAN_ONLY</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then>
                             <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>os</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>,
                                        <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>EXTRA_STATE</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uInt</name></type> <name>header</name> <init>= <expr><operator>(</operator><name>Z_DEFLATED</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name><operator>-</operator><literal type="number">8</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uInt</name></type> <name>level_flags</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>Z_HUFFMAN_ONLY</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>header</name> <operator>|=</operator> <operator>(</operator><name>level_flags</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>header</name> <operator>|=</operator> <name>PRESET_DICT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>header</name> <operator>+=</operator> <literal type="number">31</literal> <operator>-</operator> <operator>(</operator><name>header</name> <operator>%</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Save the adler32 of the preset dictionary: */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>EXTRA_STATE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start of bytes to update crc */</comment>

            <while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name>beg</name></expr></argument>,
                                            <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>beg</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name>beg</name></expr></argument>,
                                    <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>NAME_STATE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>NAME_STATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>NAME_STATE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start of bytes to update crc */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

            <do>do <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name>beg</name></expr></argument>,
                                            <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>beg</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name>beg</name></expr></argument>,
                                    <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>COMMENT_STATE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>COMMENT_STATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>COMMENT_STATE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start of bytes to update crc */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

            <do>do <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name>beg</name></expr></argument>,
                                            <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>beg</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name>beg</name></expr></argument>,
                                    <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>HCRC_STATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>HCRC_STATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>HCRC_STATE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Flush as much pending output as possible */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>Z_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RANK</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>RANK</name><argument_list>(<argument><expr><name>old_flush</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
               <name>flush</name> <operator>!=</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* User must not provide more input after the first FINISH: */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>FINISH_STATE</name> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Start a new block or continue the current one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator><name>flush</name> <operator>!=</operator> <name>Z_NO_FLUSH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>FINISH_STATE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>block_state</name></type> <name>bstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>bstate</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_HUFFMAN_ONLY</name></expr> ?</condition><then> <expr><call><name>deflate_huff</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr> </then><else>:
                    <expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_RLE</name></expr> ?</condition><then> <expr><call><name>deflate_rle</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr> </then><else>:
                        <expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>func</name><operator>)</operator><operator>)</operator><operator>(</operator><name>s</name><operator>,</operator> <name>flush</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>bstate</name> <operator>==</operator> <name>finish_started</name> <operator>||</operator> <name>bstate</name> <operator>==</operator> <name>finish_done</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>FINISH_STATE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bstate</name> <operator>==</operator> <name>need_more</name> <operator>||</operator> <name>bstate</name> <operator>==</operator> <name>finish_started</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* avoid BUF_ERROR next call, see above */</comment>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>Z_OK</name></expr>;</return>
            <comment type="block">/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */</comment>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bstate</name> <operator>==</operator> <name>block_done</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_PARTIAL_FLUSH</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>_tr_align</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_BLOCK</name></expr>)</condition> <block>{<block_content> <comment type="block">/* FULL_FLUSH or SYNC_FLUSH */</comment>
                <expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FULL_FLUSH</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* forget history */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* avoid BUF_ERROR at next call, see above */</comment>
              <return>return <expr><name>Z_OK</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bug2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_FINISH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_END</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Write the trailer */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <operator>-</operator><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* write the trailer only once! */</comment>
    <return>return <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Z_OK</name></expr> </then><else>: <expr><name>Z_STREAM_END</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateEnd</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>INIT_STATE</name> <operator>&amp;&amp;</operator>
        <name>status</name> <operator>!=</operator> <name>EXTRA_STATE</name> <operator>&amp;&amp;</operator>
        <name>status</name> <operator>!=</operator> <name>NAME_STATE</name> <operator>&amp;&amp;</operator>
        <name>status</name> <operator>!=</operator> <name>COMMENT_STATE</name> <operator>&amp;&amp;</operator>
        <name>status</name> <operator>!=</operator> <name>HCRC_STATE</name> <operator>&amp;&amp;</operator>
        <name>status</name> <operator>!=</operator> <name>BUSY_STATE</name> <operator>&amp;&amp;</operator>
        <name>status</name> <operator>!=</operator> <name>FINISH_STATE</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Deallocate in reverse order of allocations: */</comment>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>

    <return>return <expr><ternary><condition><expr><name>status</name> <operator>==</operator> <name>BUSY_STATE</name></expr> ?</condition><then> <expr><name>Z_DATA_ERROR</name></expr> </then><else>: <expr><name>Z_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateCopy</name> <parameter_list>(<parameter><decl><type><name>dest</name></type></decl></parameter>, <parameter><decl><type><name>source</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>source</name></decl>;</decl_stmt>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSEG_64K</name></cpp:ifdef>
    <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ushf</name> <modifier>*</modifier></type><name>overlay</name></decl>;</decl_stmt>


    <if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name>dest</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>source</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ds</name> <operator>=</operator> <operator>(</operator><name>deflate_state</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ds</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator> <name>ds</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>ds</name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>ss</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>strm</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>prev</name></name>   <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator>  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>head</name></name>   <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator>  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>overlay</name> <operator>=</operator> <operator>(</operator><name>ushf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>=</operator> <operator>(</operator><name>uchf</name> <operator>*</operator><operator>)</operator> <name>overlay</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>window</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>ds</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>ds</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* following zmemcpy do not work for 16-bit MSDOS */</comment>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ds</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ss</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ds</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ss</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>hash_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><name><name>ds</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>-</operator> <name><name>ss</name><operator>-&gt;</operator><name>pending_buf</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>=</operator> <name>overlay</name> <operator>+</operator> <name><name>ds</name><operator>-&gt;</operator><name>lit_bufsize</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>l_buf</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name><name>ds</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>l_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>dyn_ltree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>d_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>dyn_dtree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>bl_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>bl_tree</name></name></expr>;</expr_stmt>

    <return>return <expr><name>Z_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MAXSEG_64K */</comment>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm-&gt;next_in buffer and copying from it.
 * (See also flush_pending()).
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>read_buf</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>size</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name>  <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name>  <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>lm_init</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><literal type="number">2L</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the default configuration parameters:
     */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name>   <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>max_lazy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>good_match</name></name>       <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>good_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name>       <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>nice_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>max_chain</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ASMV</name></cpp:ifdef>
    <expr_stmt><expr><call><name>match_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* initialize the asm code */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<comment type="block">/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
 * OUT assertion: the match length is not greater than s-&gt;lookahead.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ASMV</name></cpp:ifndef>
<comment type="block">/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */</comment>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>cur_match</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt>                             <comment type="block">/* current match */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>chain_length</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name></expr></init></decl>;</decl_stmt><comment type="block">/* max hash chain length */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* current string */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>                       <comment type="block">/* matched string */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>len</name></decl>;</decl_stmt>                           <comment type="block">/* length of current match */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>best_len</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* best match length so far */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nice_match</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* stop if match long enough */</comment>
    <decl_stmt><decl><type><name>IPos</name></type> <name>limit</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;</operator> <operator>(</operator><name>IPos</name><operator>)</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
        <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <operator>(</operator><name>IPos</name><operator>)</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Stop when cur_match becomes &lt;= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */</comment>
    <decl_stmt><decl><type><name>Posf</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>wmask</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNALIGNED_OK</name></cpp:ifdef>
    <comment type="block">/* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>strend</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>register</specifier> <name>ush</name></type> <name>scan_start</name> <init>= <expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><name>scan</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>register</specifier> <name>ush</name></type> <name>scan_end</name>   <init>= <expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+</operator><name>best_len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>strend</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Byte</name></type> <name>scan_end1</name>  <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Byte</name></type> <name>scan_end</name>   <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>MAX_MATCH</name> <operator>==</operator> <literal type="number">258</literal></expr></argument>, <argument><expr><literal type="string">"Code too clever"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do not waste too much time if we already have a good match: */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>good_match</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>chain_length</name> <operator>&gt;&gt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uInt</name><operator>)</operator><name>nice_match</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nice_match</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr><literal type="string">"need lookahead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><literal type="string">"no future"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>cur_match</name></expr>;</expr_stmt>

        <comment type="block">/* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>MAX_MATCH</name> <operator>==</operator> <literal type="number">258</literal><operator>)</operator></expr></cpp:if>
        <comment type="block">/* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+</operator><name>best_len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>scan_end</name> <operator>||</operator>
            <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><name>match</name> <operator>!=</operator> <name>scan_start</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"scan[2]?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name><operator>++</operator></expr><operator>,</operator> <expr><name>match</name><operator>++</operator></expr>;</expr_stmt>
        <do>do <block>{<block_content>
        </block_content>}</block> while <condition>(<expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                 <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                 <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                 <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                 <name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>
        <comment type="block">/* The funny "do {}" generates better code on most compilers */</comment>

        <comment type="block">/* Here, scan &lt;= window+strstart+257 */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>scan</name> <operator>==</operator> <operator>*</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scan</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>MAX_MATCH</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name><operator>-</operator><name>scan</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <name>strend</name> <operator>-</operator> <operator>(</operator><name>MAX_MATCH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* UNALIGNED_OK */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>best_len</name></expr>]</index></name>   <operator>!=</operator> <name>scan_end</name>  <operator>||</operator>
            <name><name>match</name><index>[<expr><name>best_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>scan_end1</name> <operator>||</operator>
            <operator>*</operator><name>match</name>            <operator>!=</operator> <operator>*</operator><name>scan</name>     <operator>||</operator>
            <operator>*</operator><operator>++</operator><name>match</name>          <operator>!=</operator> <name><name>scan</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>      <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS &gt;= 8.
         */</comment>
        <expr_stmt><expr><name>scan</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>match</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>scan</name> <operator>==</operator> <operator>*</operator><name>match</name></expr></argument>, <argument><expr><literal type="string">"match[2]?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */</comment>
        <do>do <block>{<block_content>
        </block_content>}</block> while <condition>(<expr><operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
                 <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
                 <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
                 <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
                 <name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>MAX_MATCH</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name> <operator>-</operator> <name>scan</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <name>strend</name> <operator>-</operator> <name>MAX_MATCH</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UNALIGNED_OK */</comment>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>best_len</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>=</operator> <name>cur_match</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>best_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>nice_match</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNALIGNED_OK</name></cpp:ifdef>
            <expr_stmt><expr><name>scan_end</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+</operator><name>best_len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>scan_end1</name>  <operator>=</operator> <name><name>scan</name><index>[<expr><name>best_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan_end</name>   <operator>=</operator> <name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>(</operator><name>cur_match</name> <operator>=</operator> <name><name>prev</name><index>[<expr><name>cur_match</name> <operator>&amp;</operator> <name>wmask</name></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <name>limit</name>
             <operator>&amp;&amp;</operator> <operator>--</operator><name>chain_length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uInt</name><operator>)</operator><name>best_len</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>uInt</name><operator>)</operator><name>best_len</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ASMV */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* FASTEST */</comment>

<comment type="block">/* ---------------------------------------------------------------------------
 * Optimized version for FASTEST only
 */</comment>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>cur_match</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt>                             <comment type="block">/* current match */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* current string */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>                       <comment type="block">/* matched string */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>len</name></decl>;</decl_stmt>                           <comment type="block">/* length of current match */</comment>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>strend</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>MAX_MATCH</name> <operator>==</operator> <literal type="number">258</literal></expr></argument>, <argument><expr><literal type="string">"Code too clever"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr><literal type="string">"need lookahead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><literal type="string">"no future"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>cur_match</name></expr>;</expr_stmt>

    <comment type="block">/* Return failure if the match length is less than 2:
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>scan</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>match</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>scan</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS &gt;= 8.
     */</comment>
    <expr_stmt><expr><name>scan</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>match</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>scan</name> <operator>==</operator> <operator>*</operator><name>match</name></expr></argument>, <argument><expr><literal type="string">"match[2]?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */</comment>
    <do>do <block>{<block_content>
    </block_content>}</block> while <condition>(<expr><operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
             <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
             <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
             <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>
             <name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>MAX_MATCH</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name> <operator>-</operator> <name>scan</name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>MIN_MATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>MIN_MATCH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>=</operator> <name>cur_match</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>uInt</name><operator>)</operator><name>len</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>uInt</name><operator>)</operator><name>len</name></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FASTEST */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<comment type="block">/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>check_match</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>start</name></type></decl></parameter>, <parameter><decl><type><name>match</name></type></decl></parameter>, <parameter><decl><type><name>length</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<block>{<block_content>
    <comment type="block">/* check that the match is indeed a match */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>zmemcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>match</name></expr></argument>,
                <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EQUAL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" start %u, match %u, length %d\n"</literal></expr></argument>,
                <argument><expr><name>start</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <do>do <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c%c"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>match</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>start</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>--</operator><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
        <expr_stmt><expr><call><name>z_error</name><argument_list>(<argument><expr><literal type="string">"invalid match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>z_verbose</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"\\[%d,%d]"</literal></expr></argument>, <argument><expr><name>start</name><operator>-</operator><name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <do>do <block>{<block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>start</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>--</operator><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>check_match</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>match</name></type></parameter>, <parameter><type><name>length</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>

<comment type="block">/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD
 * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>fill_window</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>register</specifier> <name>Posf</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>more</name></decl>;</decl_stmt>    <comment type="block">/* Amount of free space at the end of the window. */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>wsize</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr><literal type="string">"already enough lookahead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do <block>{<block_content>
        <expr_stmt><expr><name>more</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/* Deal with !@#$% 64K limit: */</comment>
        <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>more</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>more</name> <operator>=</operator> <name>wsize</name></expr>;</expr_stmt>

            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>more</name> <operator>==</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)
                 */</comment>
                <expr_stmt><expr><name>more</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;=</operator> <name>wsize</name><operator>+</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

            <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><name>wsize</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>wsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>-=</operator> <name>wsize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name>    <operator>-=</operator> <name>wsize</name></expr>;</expr_stmt> <comment type="block">/* we now have strstart &gt;= MAX_DIST */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>-=</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>wsize</name></expr>;</expr_stmt>

            <comment type="block">/* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level &gt; 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */</comment>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <do>do <block>{<block_content>
                <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>*</operator><operator>--</operator><name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>m</name> <operator>&gt;=</operator> <name>wsize</name></expr> ?</condition><then> <expr><name>m</name><operator>-</operator><name>wsize</name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>

            <expr_stmt><expr><name>n</name> <operator>=</operator> <name>wsize</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>prev</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <do>do <block>{<block_content>
                <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>*</operator><operator>--</operator><name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>m</name> <operator>&gt;=</operator> <name>wsize</name></expr> ?</condition><then> <expr><name>m</name><operator>-</operator><name>wsize</name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
                <comment type="block">/* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */</comment>
            </block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>more</name> <operator>+=</operator> <name>wsize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* If there was no sliding:
         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
         *    more == window_size - lookahead - strstart
         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * =&gt; more &gt;= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.
         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>more</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"more &lt; 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read_buf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

        <comment type="block">/* Initialize the hash value now that we have some input: */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uInt</name></type> <name>str</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> <operator>!=</operator> <literal type="number">3</literal></expr></cpp:if>
            <expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name><operator>-</operator><literal type="number">3</literal> <name>more</name> <name>times</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name> <operator>+</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name><index>[<expr><name>str</name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><name>str</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name><operator>--</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>&lt;</operator> <name>MIN_MATCH</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */</comment>

    </block_content>}</block> while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <comment type="block">/* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ulg</name></type> <name>curr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <operator>(</operator><name>ulg</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ulg</name></type> <name>init</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <name>curr</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Previous high water mark below current data -- zero WIN_INIT
             * bytes or up to end of window, whichever is less.
             */</comment>
            <expr_stmt><expr><name>init</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name>curr</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>init</name> <operator>&gt;</operator> <name>WIN_INIT</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>init</name> <operator>=</operator> <name>WIN_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>zmemzero</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>curr</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <name>init</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>curr</name> <operator>+</operator> <name>WIN_INIT</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* High water mark at or above current data, but below current data
             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
             * to end of window, whichever is less.
             */</comment>
            <expr_stmt><expr><name>init</name> <operator>=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>curr</name> <operator>+</operator> <name>WIN_INIT</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>init</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>init</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>zmemzero</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>+=</operator> <name>init</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name>MIN_LOOKAHEAD</name></expr></argument>,
           <argument><expr><literal type="string">"not enough room for search"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK_ONLY</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>last</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \
                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \
                   (charf *)Z_NULL), \
                (ulg)((long)s-&gt;strstart - s-&gt;block_start), \
                (last)); \
   s-&gt;block_start = s-&gt;strstart; \
   flush_pending(s-&gt;strm); \
   Tracev((stderr,"[FLUSH]")); \
}</cpp:value></cpp:define>

<comment type="block">/* Same but force premature exit if necessary. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>last</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
   FLUSH_BLOCK_ONLY(s, last); \
   if (s-&gt;strm-&gt;avail_out == 0) return (last) ? finish_started : need_more; \
}</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_stored</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <comment type="block">/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>max_block_size</name> <init>= <expr><literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ulg</name></type> <name>max_start</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>max_block_size</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>-</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max_block_size</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>-</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy as much as possible from input to output: */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <comment type="block">/* Fill the window as much as possible: */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name><operator>+</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator>
                   <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>&gt;=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><literal type="string">"slide too late"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>need_more</name></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* flush the current block */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>&gt;=</operator> <literal type="number">0L</literal></expr></argument>, <argument><expr><literal type="string">"block gone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Emit a stored block if pending_buf will be full: */</comment>
        <expr_stmt><expr><name>max_start</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>+</operator> <name>max_block_size</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;=</operator> <name>max_start</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* strstart == 0 is possible when wraparound on 16-bit machine */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name>max_start</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>max_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>&gt;=</operator> <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>finish_done</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>block_done</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_fast</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name></decl>;</decl_stmt>       <comment type="block">/* head of the hash chain */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>           <comment type="block">/* set if current block must be flushed */</comment>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <comment type="block">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>need_more</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* flush the current block */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</comment>
        <expr_stmt><expr><name>hash_head</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Find the longest match, discarding those &lt;= prev_length.
         * At this point we have always match_length &lt; MIN_MATCH
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>hash_head</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name>hash_head</name> <operator>&lt;=</operator> <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* longest_match() sets match_start */</comment>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>match_start</name></name></expr></argument>,
                           <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>

            <comment type="block">/* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>max_insert_length</name></name> <operator>&amp;&amp;</operator>
                <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* string at strstart already in table */</comment>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */</comment>
                </block_content>}</block> while <condition>(<expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> <operator>!=</operator> <literal type="number">3</literal></expr></cpp:if>
                <expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name><operator>-</operator><literal type="number">3</literal> <name>more</name> <name>times</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* No match, output a literal byte */</comment>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr> </then><else>: <expr><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>finish_done</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>block_done</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<comment type="block">/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_slow</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name></decl>;</decl_stmt>          <comment type="block">/* head of hash chain */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>              <comment type="block">/* set if current block must be flushed */</comment>

    <comment type="block">/* Process the input block. */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <comment type="block">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>need_more</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* flush the current block */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</comment>
        <expr_stmt><expr><name>hash_head</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Find the longest match, discarding those &lt;= prev_length.
         */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr><operator>,</operator> <expr><name><name>s</name><operator>-&gt;</operator><name>prev_match</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_start</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>hash_head</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name> <operator>&amp;&amp;</operator>
            <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name>hash_head</name> <operator>&lt;=</operator> <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* longest_match() sets match_start */</comment>

            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&lt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_FILTERED</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TOO_FAR</name> <operator>&lt;=</operator> <literal type="number">32767</literal></expr></cpp:if>
                <operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>==</operator> <name>MIN_MATCH</name> <operator>&amp;&amp;</operator>
                    <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>&gt;</operator> <name>TOO_FAR</name><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <operator>)</operator></expr>)</condition> <block>{<block_content>

                <comment type="block">/* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */</comment>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uInt</name></type> <name>max_insert</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Do not insert strings in hash table beyond this. */</comment>

            <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_match</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_match</name></name></expr></argument>,
                           <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <do>do <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name>max_insert</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> while <condition>(<expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */</comment>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>FLUSH_BLOCK_ONLY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>need_more</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* There is no previous match to compare with, wait for
             * the next step to decide.
             */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>flush</name> <operator>!=</operator> <name>Z_NO_FLUSH</name></expr></argument>, <argument><expr><literal type="string">"no flush?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr> </then><else>: <expr><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>finish_done</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>block_done</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FASTEST */</comment>

<comment type="block">/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_rle</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>             <comment type="block">/* set if current block must be flushed */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>prev</name></decl>;</decl_stmt>              <comment type="block">/* byte at distance one to match */</comment>
    <decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>scan</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>strend</name></decl>;</decl_stmt>   <comment type="block">/* scan goes up to strend for length of run */</comment>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <comment type="block">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;=</operator> <name>MAX_MATCH</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;=</operator> <name>MAX_MATCH</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>need_more</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* flush the current block */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* See how many times the previous byte repeats */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>scan</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>*</operator><name>scan</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>strend</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name></expr>;</expr_stmt>
                <do>do <block>{<block_content>
                </block_content>}</block> while <condition>(<expr><name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>
                         <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>
                         <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>
                         <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>
                         <name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MAX_MATCH</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name> <operator>-</operator> <name>scan</name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Emit match if have run of MIN_MATCH or longer, else emit literal */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* No match, output a literal byte */</comment>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>finish_done</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>block_done</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_huff</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>             <comment type="block">/* set if current block must be flushed */</comment>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <comment type="block">/* Make sure that we have a literal to write. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>need_more</name></expr>;</return></block_content></block></if></if_stmt>
                <break>break;</break>      <comment type="block">/* flush the current block */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Output a literal byte */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>finish_done</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>block_done</name></expr>;</return>
</block_content>}</block></function>
</unit>
