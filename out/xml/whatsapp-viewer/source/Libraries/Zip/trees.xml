<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/Zip/trees.c"><comment type="block">/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2012 Jean-loup Gailly
 * detect_data_type() function provided freely by Cosmin Truta, 2006
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */</comment>

<comment type="block">/* @(#) $Id$ */</comment>

<comment type="block">/* #define GEN_TREES_H */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Constants
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BL_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<comment type="block">/* Bit length codes must not exceed MAX_BL_BITS bits */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_BLOCK</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<comment type="block">/* end of block literal code */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP_3_6</name></cpp:macro>      <cpp:value>16</cpp:value></cpp:define>
<comment type="block">/* repeat previous bit length 3-6 times (2 bits of repeat count) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPZ_3_10</name></cpp:macro>    <cpp:value>17</cpp:value></cpp:define>
<comment type="block">/* repeat a zero length 3-10 times  (3 bits of repeat count) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPZ_11_138</name></cpp:macro>  <cpp:value>18</cpp:value></cpp:define>
<comment type="block">/* repeat a zero length 11-138 times  (7 bits of repeat count) */</comment>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_lbits</name><index>[<expr><name>LENGTH_CODES</name></expr>]</index></name> <comment type="block">/* extra bits for each length code */</comment>
   <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_dbits</name><index>[<expr><name>D_CODES</name></expr>]</index></name> <comment type="block">/* extra bits for each distance code */</comment>
   <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">9</literal></expr>,<expr><literal type="number">9</literal></expr>,<expr><literal type="number">10</literal></expr>,<expr><literal type="number">10</literal></expr>,<expr><literal type="number">11</literal></expr>,<expr><literal type="number">11</literal></expr>,<expr><literal type="number">12</literal></expr>,<expr><literal type="number">12</literal></expr>,<expr><literal type="number">13</literal></expr>,<expr><literal type="number">13</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_blbits</name><index>[<expr><name>BL_CODES</name></expr>]</index></name><comment type="block">/* extra bits for each bit length code */</comment>
   <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>uch</name></type> <name><name>bl_order</name><index>[<expr><name>BL_CODES</name></expr>]</index></name>
   <init>= <expr><block>{<expr><literal type="number">16</literal></expr>,<expr><literal type="number">17</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">9</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">10</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">11</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">12</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">13</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">14</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">15</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */</comment>

<comment type="block">/* ===========================================================================
 * Local data. These are initialized only once.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIST_CODE_LEN</name></cpp:macro>  <cpp:value>512</cpp:value></cpp:define> <comment type="block">/* see definition of array dist_code below */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* non ANSI compilers may not accept trees.h */</comment>

<decl_stmt><decl><type><name>local</name> <name>ct_data</name></type> <name><name>static_ltree</name><index>[<expr><name>L_CODES</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */</comment>

<decl_stmt><decl><type><name>local</name> <name>ct_data</name></type> <name><name>static_dtree</name><index>[<expr><name>D_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */</comment>

<decl_stmt><decl><type><name>uch</name></type> <name><name>_dist_code</name><index>[<expr><name>DIST_CODE_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */</comment>

<decl_stmt><decl><type><name>uch</name></type> <name><name>_length_code</name><index>[<expr><name>MAX_MATCH</name><operator>-</operator><name>MIN_MATCH</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* length code for each normalized match length (0 == MIN_MATCH) */</comment>

<decl_stmt><decl><type><name>local</name> <name>int</name></type> <name><name>base_length</name><index>[<expr><name>LENGTH_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* First normalized length for each code (0 = MIN_MATCH) */</comment>

<decl_stmt><decl><type><name>local</name> <name>int</name></type> <name><name>base_dist</name><index>[<expr><name>D_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* First normalized distance for each code (0 = distance of 1) */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"trees.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GEN_TREES_H */</comment>

<struct>struct <name>static_tree_desc_s</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> <modifier>*</modifier></type><name>static_tree</name></decl>;</decl_stmt>  <comment type="block">/* static tree or NULL */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>intf</name> <modifier>*</modifier></type><name>extra_bits</name></decl>;</decl_stmt>      <comment type="block">/* extra bits for each code or NULL */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>extra_base</name></decl>;</decl_stmt>          <comment type="block">/* base index for extra_bits */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>elems</name></decl>;</decl_stmt>               <comment type="block">/* max number of elements in the tree */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>max_length</name></decl>;</decl_stmt>          <comment type="block">/* max bit length for the codes */</comment>
}</block>;</struct>

<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type>  <name>static_l_desc</name> <init>=
<expr><block>{<expr><name>static_ltree</name></expr>, <expr><name>extra_lbits</name></expr>, <expr><name>LITERALS</name><operator>+</operator><literal type="number">1</literal></expr>, <expr><name>L_CODES</name></expr>, <expr><name>MAX_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type>  <name>static_d_desc</name> <init>=
<expr><block>{<expr><name>static_dtree</name></expr>, <expr><name>extra_dbits</name></expr>, <expr><literal type="number">0</literal></expr>,          <expr><name>D_CODES</name></expr>, <expr><name>MAX_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type>  <name>static_bl_desc</name> <init>=
<expr><block>{<expr><operator>(</operator><specifier>const</specifier> <name>ct_data</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>, <expr><name>extra_blbits</name></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>BL_CODES</name></expr>, <expr><name>MAX_BL_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ===========================================================================
 * Local (static) routines in this file.
 */</comment>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>tr_static_init</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>init_block</name></type>     <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>pqdownheap</name></type>     <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>ct_data</name> <operator>*</operator><name>tree</name><operator>,</operator> <name>int</name> <name>k</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_bitlen</name></type>     <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>tree_desc</name> <operator>*</operator><name>desc</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_codes</name></type>      <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><name>tree</name><operator>,</operator> <name>int</name> <name>max_code</name><operator>,</operator> <name>ushf</name> <operator>*</operator><name>bl_count</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>build_tree</name></type>     <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>tree_desc</name> <operator>*</operator><name>desc</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>scan_tree</name></type>      <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>ct_data</name> <operator>*</operator><name>tree</name><operator>,</operator> <name>int</name> <name>max_code</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_tree</name></type>      <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>ct_data</name> <operator>*</operator><name>tree</name><operator>,</operator> <name>int</name> <name>max_code</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name>  <name>build_bl_tree</name></type>  <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_all_trees</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>lcodes</name><operator>,</operator> <name>int</name> <name>dcodes</name><operator>,</operator>
                              <name>int</name> <name>blcodes</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>compress_block</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <specifier>const</specifier> <name>ct_data</name> <operator>*</operator><name>ltree</name><operator>,</operator>
                              <specifier>const</specifier> <name>ct_data</name> <operator>*</operator><name>dtree</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name>  <name>detect_data_type</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>unsigned</name> <name>bi_reverse</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>value</name><operator>,</operator> <name>int</name> <name>length</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>bi_windup</name></type>      <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>bi_flush</name></type>       <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>copy_block</name></type>     <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>charf</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>unsigned</name> <name>len</name><operator>,</operator>
                              <name>int</name> <name>header</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEN_TREES_H</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_trees_header</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>send_code</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>tree</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>send_bits(s, tree[c].Code, tree[c].Len)</cpp:value></cpp:define>
   <comment type="block">/* Send a code of the given tree. c and tree must not have side effects */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* DEBUG */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>send_code</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>tree</name></type></parameter>)</parameter_list></cpp:macro> \
     <cpp:value>{ if (z_verbose&gt;2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>put_short</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
    put_byte(s, (uch)((w) &amp; 0xff)); \
    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \
}</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_bits</name></type>      <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>value</name><operator>,</operator> <name>int</name> <name>length</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>local</name> <name>void</name></type> <name>send_bits</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>value</name></type></decl></parameter>, <parameter><decl><type><name>length</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>  <comment type="block">/* value to send */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt> <comment type="block">/* number of bits */</comment>
<block>{<block_content>
    <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">" l %2d v %4x "</literal><operator>,</operator> <name>length</name><operator>,</operator> <name>value</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>length</name> <operator>&lt;=</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><literal type="string">"invalid length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name> <operator>+=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>length</name></expr>;</expr_stmt>

    <comment type="block">/* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>Buf_size</name> <operator>-</operator> <name>length</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>|=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>value</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>value</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>Buf_size</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>+=</operator> <name>length</name> <operator>-</operator> <name>Buf_size</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>|=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>value</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !DEBUG */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>send_bits</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>value</name></type></parameter>, <parameter><type><name>length</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>{ int len = length;\
  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\
    int val = value;\
    s-&gt;bi_buf |= (ush)val &lt;&lt; s-&gt;bi_valid;\
    put_short(s, s-&gt;bi_buf);\
    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\
    s-&gt;bi_valid += len - Buf_size;\
  } else {\
    s-&gt;bi_buf |= (ush)(value) &lt;&lt; s-&gt;bi_valid;\
    s-&gt;bi_valid += len;\
  }\
}</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>


<comment type="block">/* the arguments must not have side effects */</comment>

<comment type="block">/* ===========================================================================
 * Initialize the various 'constant' tables.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>tr_static_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>static_init_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>        <comment type="block">/* iterates over tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>     <comment type="block">/* bit counter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>   <comment type="block">/* length value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>     <comment type="block">/* code value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>;</decl_stmt>     <comment type="block">/* distance index */</comment>
    <decl_stmt><decl><type><name>ush</name></type> <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* number of codes at each bit length for an optimal tree */</comment>

    <if_stmt><if>if <condition>(<expr><name>static_init_done</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* For some embedded targets, global variables are not initialized: */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_INIT_GLOBAL_POINTERS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>static_l_desc</name><operator>.</operator><name>static_tree</name></name> <operator>=</operator> <name>static_ltree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_l_desc</name><operator>.</operator><name>extra_bits</name></name> <operator>=</operator> <name>extra_lbits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_d_desc</name><operator>.</operator><name>static_tree</name></name> <operator>=</operator> <name>static_dtree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_d_desc</name><operator>.</operator><name>extra_bits</name></name> <operator>=</operator> <name>extra_dbits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_bl_desc</name><operator>.</operator><name>extra_bits</name></name> <operator>=</operator> <name>extra_blbits</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialize the mapping length (0..255) -&gt; length code (0..28) */</comment>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>code</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>code</name> <operator>&lt;</operator> <name>LENGTH_CODES</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>code</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>base_length</name><index>[<expr><name>code</name></expr>]</index></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name><name>extra_lbits</name><index>[<expr><name>code</name></expr>]</index></name><operator>)</operator></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>_length_code</name><index>[<expr><name>length</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uch</name><operator>)</operator><name>code</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>length</name> <operator>==</operator> <literal type="number">256</literal></expr></argument>, <argument><expr><literal type="string">"tr_static_init: length != 256"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */</comment>
    <expr_stmt><expr><name><name>_length_code</name><index>[<expr><name>length</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uch</name><operator>)</operator><name>code</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</comment>
    <expr_stmt><expr><name>dist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>code</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>code</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>code</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name><operator>)</operator></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>_dist_code</name><index>[<expr><name>dist</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uch</name><operator>)</operator><name>code</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>dist</name> <operator>==</operator> <literal type="number">256</literal></expr></argument>, <argument><expr><literal type="string">"tr_static_init: dist != 256"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dist</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt> <comment type="block">/* from now on, all distances are divided by 128 */</comment>
    <for>for <control>( <init>;</init> <condition><expr><name>code</name> <operator>&lt;</operator> <name>D_CODES</name></expr>;</condition> <incr><expr><name>code</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name> <operator>=</operator> <name>dist</name> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name><operator>-</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>_dist_code</name><index>[<expr><literal type="number">256</literal> <operator>+</operator> <name>dist</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uch</name><operator>)</operator><name>code</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>dist</name> <operator>==</operator> <literal type="number">256</literal></expr></argument>, <argument><expr><literal type="string">"tr_static_init: 256+dist != 512"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct the codes of the static literal tree */</comment>
    <for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bits</name> <operator>&lt;=</operator> <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">143</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">8</literal></expr><operator>,</operator> <expr><name><name>bl_count</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">9</literal></expr><operator>,</operator> <expr><name><name>bl_count</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">279</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">7</literal></expr><operator>,</operator> <expr><name><name>bl_count</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">287</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">8</literal></expr><operator>,</operator> <expr><name><name>bl_count</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <comment type="block">/* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */</comment>
    <expr_stmt><expr><call><name>gen_codes</name><argument_list>(<argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><operator>)</operator><name>static_ltree</name></expr></argument>, <argument><expr><name>L_CODES</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>bl_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The static distance tree is trivial: */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>D_CODES</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>static_dtree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>static_dtree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Code</name> <operator>=</operator> <call><name>bi_reverse</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>static_init_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>GEN_TREES_H</name></cpp:ifdef>
    <expr_stmt><expr><call><name>gen_trees_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(GEN_TREES_H) || !defined(STDC) */</comment>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEN_TREES_H</name></cpp:ifdef>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
<cpp:include>#    <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SEPARATOR</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>last</name></type></parameter>, <parameter><type><name>width</name></type></parameter>)</parameter_list></cpp:macro> \
      <cpp:value>((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>gen_trees_header</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"trees.h"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>header</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Can't open trees.h"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
            <argument><expr><literal type="string">"/* header created automatically with -DGEN_TREES_H */\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"local const ct_data static_ltree[L_CODES+2] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>L_CODES</name><operator>+</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"{{%3u},{%3u}}%s"</literal></expr></argument>, <argument><expr><name><name>static_ltree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Code</name></expr></argument>,
                <argument><expr><name><name>static_ltree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Len</name></expr></argument>, <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>L_CODES</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"local const ct_data static_dtree[D_CODES] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>D_CODES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"{{%2u},{%2u}}%s"</literal></expr></argument>, <argument><expr><name><name>static_dtree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Code</name></expr></argument>,
                <argument><expr><name><name>static_dtree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Len</name></expr></argument>, <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>D_CODES</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DIST_CODE_LEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"%2u%s"</literal></expr></argument>, <argument><expr><name><name>_dist_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>DIST_CODE_LEN</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
        <argument><expr><literal type="string">"const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_MATCH</name><operator>-</operator><name>MIN_MATCH</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"%2u%s"</literal></expr></argument>, <argument><expr><name><name>_length_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>MAX_MATCH</name><operator>-</operator><name>MIN_MATCH</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"local const int base_length[LENGTH_CODES] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LENGTH_CODES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"%1u%s"</literal></expr></argument>, <argument><expr><name><name>base_length</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LENGTH_CODES</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"local const int base_dist[D_CODES] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>D_CODES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"%5u%s"</literal></expr></argument>, <argument><expr><name><name>base_dist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>D_CODES</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GEN_TREES_H */</comment>

<comment type="block">/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */</comment>
<function><type><name>void</name> <name>ZLIB_INTERNAL</name></type> <name>_tr_init</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <expr_stmt><expr><call><name>tr_static_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>l_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>l_desc</name><operator>.</operator><name>stat_desc</name></name> <operator>=</operator> <operator>&amp;</operator><name>static_l_desc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>d_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>d_desc</name><operator>.</operator><name>stat_desc</name></name> <operator>=</operator> <operator>&amp;</operator><name>static_d_desc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_desc</name><operator>.</operator><name>stat_desc</name></name> <operator>=</operator> <operator>&amp;</operator><name>static_bl_desc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialize the first block of the first file: */</comment>
    <expr_stmt><expr><call><name>init_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Initialize a new block.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>init_block</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt> <comment type="block">/* iterates over tree elements */</comment>

    <comment type="block">/* Initialize the trees. */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>L_CODES</name></expr>;</condition>  <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>D_CODES</name></expr>;</condition>  <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>BL_CODES</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><name>END_BLOCK</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>static_len</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLEST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/* Index within the heap array of least frequent node in the Huffman tree */</comment>


<comment type="block">/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pqremove</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>tree</name></type></parameter>, <parameter><type><name>top</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>{\
    top = s-&gt;heap[SMALLEST]; \
    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smaller</name><parameter_list>(<parameter><type><name>tree</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>m</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>(tree[n].Freq &lt; tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>pqdownheap</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>tree</name></type></decl></parameter>, <parameter><decl><type><name>k</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>  <comment type="block">/* the tree to restore */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>               <comment type="block">/* node to move down */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>k</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* left son of k */</comment>
    <while>while <condition>(<expr><name>j</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Set j to the smallest of the two sons: */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name> <operator>&amp;&amp;</operator>
            <call><name>smaller</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Exit if v is smaller than both sons */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>smaller</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Exchange v with the smallest son */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

        <comment type="block">/* And continue down the tree, setting j to the left son of k */</comment>
        <expr_stmt><expr><name>j</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>gen_bitlen</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>desc</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tree_desc</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>    <comment type="block">/* the tree descriptor */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>ct_data</name> <modifier>*</modifier></type><name>tree</name>        <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>dyn_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name>         <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>max_code</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> <modifier>*</modifier></type><name>stree</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>stat_desc</name><operator>-&gt;</operator><name>static_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>intf</name> <modifier>*</modifier></type><name>extra</name>    <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>stat_desc</name><operator>-&gt;</operator><name>extra_bits</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>base</name>             <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>stat_desc</name><operator>-&gt;</operator><name>extra_base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_length</name>       <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>stat_desc</name><operator>-&gt;</operator><name>max_length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>              <comment type="block">/* heap index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>           <comment type="block">/* iterate over the tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>           <comment type="block">/* bit length */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>xbits</name></decl>;</decl_stmt>          <comment type="block">/* extra bits */</comment>
    <decl_stmt><decl><type><name>ush</name></type> <name>f</name></decl>;</decl_stmt>              <comment type="block">/* frequency */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>overflow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* number of elements with bit length too large */</comment>

    <for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bits</name> <operator>&lt;=</operator> <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */</comment>
    <expr_stmt><expr><name><name>tree</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>heap_max</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* root of the heap */</comment>

    <for>for <control>(<init><expr><name>h</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap_max</name></name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>h</name> <operator>&lt;</operator> <name>HEAP_SIZE</name></expr>;</condition> <incr><expr><name>h</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>tree</name><index>[<expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Dad</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&gt;</operator> <name>max_length</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bits</name> <operator>=</operator> <name>max_length</name></expr><operator>,</operator> <expr><name>overflow</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>bits</name></expr>;</expr_stmt>
        <comment type="block">/* We overwrite tree[n].Dad which is no longer needed */</comment>

        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>max_code</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* not a leaf node */</comment>

        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>xbits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>base</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xbits</name> <operator>=</operator> <name><name>extra</name><index>[<expr><name>n</name><operator>-</operator><name>base</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name> <operator>+=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>f</name> <operator>*</operator> <operator>(</operator><name>bits</name> <operator>+</operator> <name>xbits</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>stree</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>static_len</name></name> <operator>+=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>f</name> <operator>*</operator> <operator>(</operator><name><name>stree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>+</operator> <name>xbits</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>overflow</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"\nbit length overflow\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* This happens for example on obj2 and pic of the Calgary corpus */</comment>

    <comment type="block">/* Find the first bit length which could increase: */</comment>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>bits</name> <operator>=</operator> <name>max_length</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bits</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>      <comment type="block">/* move one leaf down the tree */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>bits</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* move one overflow item as its brother */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>max_length</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
        <comment type="block">/* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */</comment>
        <expr_stmt><expr><name>overflow</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>overflow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <comment type="block">/* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */</comment>
    <for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <name>max_length</name></expr>;</init> <condition><expr><name>bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>bits</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><operator>--</operator><name>h</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>m</name> <operator>&gt;</operator> <name>max_code</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>!=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"code %d bits %d-&gt;%d\n"</literal><operator>,</operator> <name>m</name><operator>,</operator> <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Len</name><operator>,</operator> <name>bits</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>long</name><operator>)</operator><name>bits</name> <operator>-</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Len</name><operator>)</operator>
                              <operator>*</operator><operator>(</operator><name>long</name><operator>)</operator><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Freq</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>bits</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>gen_codes</name> <parameter_list>(<parameter><decl><type><name>tree</name></type></decl></parameter>, <parameter><decl><type><name>max_code</name></type></decl></parameter>, <parameter><decl><type><name>bl_count</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>ct_data</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>             <comment type="block">/* the tree to decorate */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>              <comment type="block">/* largest code with non zero frequency */</comment>
    <decl_stmt><decl><type><name>ushf</name> <modifier>*</modifier></type><name>bl_count</name></decl>;</decl_stmt>            <comment type="block">/* number of codes at each bit length */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>ush</name></type> <name><name>next_code</name><index>[<expr><name>MAX_BITS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* next code value for each bit length */</comment>
    <decl_stmt><decl><type><name>ush</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* running code value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>                  <comment type="block">/* bit index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                     <comment type="block">/* code index */</comment>

    <comment type="block">/* The distribution counts are first used to generate the code values
     * without bit reversal.
     */</comment>
    <for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>bits</name> <operator>&lt;=</operator> <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>next_code</name><index>[<expr><name>bits</name></expr>]</index></name> <operator>=</operator> <name>code</name> <operator>=</operator> <operator>(</operator><name>code</name> <operator>+</operator> <name><name>bl_count</name><index>[<expr><name>bits</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>code</name> <operator>+</operator> <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>MAX_BITS</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>,
            <argument><expr><literal type="string">"inconsistent bit counts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"\ngen_codes: max_code %d "</literal><operator>,</operator> <name>max_code</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>  <condition><expr><name>n</name> <operator>&lt;=</operator> <name>max_code</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Len</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Now reverse the bits */</comment>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Code</name> <operator>=</operator> <call><name>bi_reverse</name><argument_list>(<argument><expr><name><name>next_code</name><index>[<expr><name>len</name></expr>]</index></name><operator>++</operator></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Tracecv</name><argument_list>(<argument><expr><name>tree</name> <operator>!=</operator> <name>static_ltree</name></expr></argument>, <argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"\nn %3d %c l %2d c %4x (%x) "</literal><operator>,</operator>
             <name>n</name><operator>,</operator> <operator>(</operator><ternary><condition><expr><call><name>isgraph</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary><operator>)</operator><operator>,</operator> <name>len</name><operator>,</operator> <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Code</name><operator>,</operator> <name><name>next_code</name><index>[<expr><name>len</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>build_tree</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>desc</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tree_desc</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt> <comment type="block">/* the tree descriptor */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>ct_data</name> <modifier>*</modifier></type><name>tree</name>         <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>dyn_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> <modifier>*</modifier></type><name>stree</name>  <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>stat_desc</name><operator>-&gt;</operator><name>static_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>elems</name>             <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>stat_desc</name><operator>-&gt;</operator><name>elems</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>          <comment type="block">/* iterate over heap elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* largest code with non zero frequency */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>node</name></decl>;</decl_stmt>          <comment type="block">/* new node being created */</comment>

    <comment type="block">/* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name><name>s</name><operator>-&gt;</operator><name>heap_max</name></name> <operator>=</operator> <name>HEAP_SIZE</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>elems</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><operator>++</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <name>max_code</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */</comment>
    <while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><operator>++</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>max_code</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><operator>++</operator><name>max_code</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>node</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name><operator>--</operator></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>stree</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>static_len</name></name> <operator>-=</operator> <name><name>stree</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>Len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* node is 0 or 1 so it does not have extra bits */</comment>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>max_code</name></name> <operator>=</operator> <name>max_code</name></expr>;</expr_stmt>

    <comment type="block">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name><operator>/</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pqdownheap</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <name>elems</name></expr>;</expr_stmt>              <comment type="block">/* next internal node of the tree */</comment>
    <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>pqremove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* n = node of least frequency */</comment>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* m = node of next least frequency */</comment>

        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>heap_max</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt> <comment type="block">/* keep the nodes sorted by frequency */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>heap_max</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

        <comment type="block">/* Create a new node father of n and m */</comment>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>=</operator> <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>+</operator> <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Freq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>node</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uch</name><operator>)</operator><operator>(</operator><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>m</name></expr>]</index></name></expr> ?</condition><then>
                                <expr><name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>n</name></expr>]</index></name></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>depth</name><index>[<expr><name>m</name></expr>]</index></name></expr></else></ternary><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Dad</name> <operator>=</operator> <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Dad</name> <operator>=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>node</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUMP_BL_TREE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>tree</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"\nnode %d(%d), sons %d(%d) %d(%d)"</literal></expr></argument>,
                    <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>Freq</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>Freq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* and insert the new node in the heap */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name> <operator>=</operator> <name>node</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqdownheap</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>SMALLEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block> while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>heap_len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>heap_max</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */</comment>
    <expr_stmt><expr><call><name>gen_bitlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>tree_desc</name> <operator>*</operator><operator>)</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The field len is now set, we can generate the bit codes */</comment>
    <expr_stmt><expr><call><name>gen_codes</name> <argument_list>(<argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><operator>)</operator><name>tree</name></expr></argument>, <argument><expr><name>max_code</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>scan_tree</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>tree</name></type></decl></parameter>, <parameter><decl><type><name>max_code</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>   <comment type="block">/* the tree to be scanned */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>    <comment type="block">/* and its largest code of non zero frequency */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                     <comment type="block">/* iterates over all tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>prevlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* last emitted length */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>curlen</name></decl>;</decl_stmt>                <comment type="block">/* length of current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nextlen</name> <init>= <expr><name><name>tree</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Len</name></expr></init></decl>;</decl_stmt> <comment type="block">/* length of next code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* repeat count of the current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* max repeat count */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>min_count</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* min repeat count */</comment>

    <if_stmt><if>if <condition>(<expr><name>nextlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">138</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>tree</name><index>[<expr><name>max_code</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Len</name> <operator>=</operator> <operator>(</operator><name>ush</name><operator>)</operator><literal type="number">0xffff</literal></expr>;</expr_stmt> <comment type="block">/* guard */</comment>

    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;=</operator> <name>max_code</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>curlen</name> <operator>=</operator> <name>nextlen</name></expr>;</expr_stmt> <expr_stmt><expr><name>nextlen</name> <operator>=</operator> <name><name>tree</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Len</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&lt;</operator> <name>max_count</name> <operator>&amp;&amp;</operator> <name>curlen</name> <operator>==</operator> <name>nextlen</name></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>min_count</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name>curlen</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>curlen</name> <operator>!=</operator> <name>prevlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name>curlen</name></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name>REP_3_6</name></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name>REPZ_3_10</name></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name>REPZ_11_138</name></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>prevlen</name> <operator>=</operator> <name>curlen</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nextlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">138</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curlen</name> <operator>==</operator> <name>nextlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">6</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">7</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>send_tree</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>tree</name></type></decl></parameter>, <parameter><decl><type><name>max_code</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt> <comment type="block">/* the tree to be scanned */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>       <comment type="block">/* and its largest code of non zero frequency */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                     <comment type="block">/* iterates over all tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>prevlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* last emitted length */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>curlen</name></decl>;</decl_stmt>                <comment type="block">/* length of current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nextlen</name> <init>= <expr><name><name>tree</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Len</name></expr></init></decl>;</decl_stmt> <comment type="block">/* length of next code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* repeat count of the current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* max repeat count */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>min_count</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* min repeat count */</comment>

    <comment type="block">/* tree[max_code+1].Len = -1; */</comment>  <comment type="block">/* guard already set */</comment>
    <if_stmt><if>if <condition>(<expr><name>nextlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">138</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;=</operator> <name>max_code</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>curlen</name> <operator>=</operator> <name>nextlen</name></expr>;</expr_stmt> <expr_stmt><expr><name>nextlen</name> <operator>=</operator> <name><name>tree</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Len</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&lt;</operator> <name>max_count</name> <operator>&amp;&amp;</operator> <name>curlen</name> <operator>==</operator> <name>nextlen</name></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>min_count</name></expr>)</condition> <block>{<block_content>
            <do>do <block>{<block_content> <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>--</operator><name>count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>curlen</name> <operator>!=</operator> <name>prevlen</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" 3_6?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REP_3_6</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REPZ_3_10</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REPZ_11_138</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name><operator>-</operator><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>prevlen</name> <operator>=</operator> <name>curlen</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nextlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">138</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curlen</name> <operator>==</operator> <name>nextlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">6</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>max_count</name> <operator>=</operator> <literal type="number">7</literal></expr><operator>,</operator> <expr><name>min_count</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>build_bl_tree</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>max_blindex</name></decl>;</decl_stmt>  <comment type="block">/* index of last bit length code of non zero freq */</comment>

    <comment type="block">/* Determine the bit length frequencies for literal and distance trees */</comment>
    <expr_stmt><expr><call><name>scan_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>l_desc</name><operator>.</operator><name>max_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scan_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>d_desc</name><operator>.</operator><name>max_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build the bit length tree: */</comment>
    <expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>tree_desc</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bl_desc</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */</comment>

    <comment type="block">/* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */</comment>
    <for>for <control>(<init><expr><name>max_blindex</name> <operator>=</operator> <name>BL_CODES</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>max_blindex</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>max_blindex</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name><name>bl_order</name><index>[<expr><name>max_blindex</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>Len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Update opt_len to include the bit length tree and counts */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name> <operator>+=</operator> <literal type="number">3</literal><operator>*</operator><operator>(</operator><name>max_blindex</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">5</literal><operator>+</operator><literal type="number">5</literal><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\ndyn trees: dyn %ld, stat %ld"</literal><operator>,</operator>
            <name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>static_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>max_blindex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>send_all_trees</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>lcodes</name></type></decl></parameter>, <parameter><decl><type><name>dcodes</name></type></decl></parameter>, <parameter><decl><type><name>blcodes</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lcodes</name></decl>, <decl><type ref="prev"/><name>dcodes</name></decl>, <decl><type ref="prev"/><name>blcodes</name></decl>;</decl_stmt> <comment type="block">/* number of codes for each tree */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rank</name></decl>;</decl_stmt>                    <comment type="block">/* index in bl_order */</comment>

    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>lcodes</name> <operator>&gt;=</operator> <literal type="number">257</literal> <operator>&amp;&amp;</operator> <name>dcodes</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>blcodes</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"not enough codes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>lcodes</name> <operator>&lt;=</operator> <name>L_CODES</name> <operator>&amp;&amp;</operator> <name>dcodes</name> <operator>&lt;=</operator> <name>D_CODES</name> <operator>&amp;&amp;</operator> <name>blcodes</name> <operator>&lt;=</operator> <name>BL_CODES</name></expr></argument>,
            <argument><expr><literal type="string">"too many codes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\nbl counts: "</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lcodes</name><operator>-</operator><literal type="number">257</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not +255 as stated in appnote.txt */</comment>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dcodes</name><operator>-</operator><literal type="number">1</literal></expr></argument>,   <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>blcodes</name><operator>-</operator><literal type="number">4</literal></expr></argument>,  <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not -3 as stated in appnote.txt */</comment>
    <for>for <control>(<init><expr><name>rank</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rank</name> <operator>&lt;</operator> <name>blcodes</name></expr>;</condition> <incr><expr><name>rank</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\nbl code %2d "</literal><operator>,</operator> <name><name>bl_order</name><index>[<expr><name>rank</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bl_tree</name><index>[<expr><name><name>bl_order</name><index>[<expr><name>rank</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>Len</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\nbl tree: sent %ld"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>send_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name></name></expr></argument>, <argument><expr><name>lcodes</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* literal tree */</comment>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\nlit tree: sent %ld"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>send_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>ct_data</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name></name></expr></argument>, <argument><expr><name>dcodes</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* distance tree */</comment>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\ndist tree: sent %ld"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Send a stored block
 */</comment>
<function><type><name>void</name> <name>ZLIB_INTERNAL</name></type> <name>_tr_stored_block</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>stored_len</name></type></decl></parameter>, <parameter><decl><type><name>last</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charf</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>       <comment type="block">/* input block */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>stored_len</name></decl>;</decl_stmt>   <comment type="block">/* length of input block */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name></decl>;</decl_stmt>         <comment type="block">/* one if this is the last block for a file */</comment>
<block>{<block_content>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>STORED_BLOCK</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>last</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* send block type */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>ulg</name><operator>)</operator><operator>~</operator><literal type="number">7L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+=</operator> <operator>(</operator><name>stored_len</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>copy_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>stored_len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* with header */</comment>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
 */</comment>
<function><type><name>void</name> <name>ZLIB_INTERNAL</name></type> <name>_tr_flush_bits</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <expr_stmt><expr><call><name>bi_flush</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */</comment>
<function><type><name>void</name> <name>ZLIB_INTERNAL</name></type> <name>_tr_align</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>STATIC_TREES</name><operator>&lt;&lt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>static_ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+=</operator> <literal type="number">10L</literal></expr>;</expr_stmt> <comment type="block">/* 3 for block type, 7 for EOB */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>bi_flush</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */</comment>
<function><type><name>void</name> <name>ZLIB_INTERNAL</name></type> <name>_tr_flush_block</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>stored_len</name></type></decl></parameter>, <parameter><decl><type><name>last</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charf</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>       <comment type="block">/* input block, or NULL if too old */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>stored_len</name></decl>;</decl_stmt>   <comment type="block">/* length of input block */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name></decl>;</decl_stmt>         <comment type="block">/* one if this is the last block for a file */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>ulg</name></type> <name>opt_lenb</name></decl>, <decl><type ref="prev"/><name>static_lenb</name></decl>;</decl_stmt> <comment type="block">/* opt_len and static_len in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_blindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* index of last bit length code of non zero freq */</comment>

    <comment type="block">/* Build the Huffman trees unless a stored block is forced */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

        <comment type="block">/* Check if the file is binary or text */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>data_type</name></name> <operator>==</operator> <name>Z_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>data_type</name></name> <operator>=</operator> <call><name>detect_data_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Construct the literal and distance trees */</comment>
        <expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>tree_desc</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>l_desc</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\nlit data: dyn %ld, stat %ld"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name><operator>,</operator>
                <name><name>s</name><operator>-&gt;</operator><name>static_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>tree_desc</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>d_desc</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\ndist data: dyn %ld, stat %ld"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name><operator>,</operator>
                <name><name>s</name><operator>-&gt;</operator><name>static_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */</comment>

        <comment type="block">/* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */</comment>
        <expr_stmt><expr><name>max_blindex</name> <operator>=</operator> <call><name>build_bl_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Determine the best encoding. Compute the block lengths in bytes. */</comment>
        <expr_stmt><expr><name>opt_lenb</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name><operator>+</operator><literal type="number">3</literal><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">3</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>static_lenb</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>static_len</name></name><operator>+</operator><literal type="number">3</literal><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">3</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u "</literal><operator>,</operator>
                <name>opt_lenb</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name><operator>,</operator> <name>static_lenb</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>static_len</name></name><operator>,</operator> <name>stored_len</name><operator>,</operator>
                <name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>static_lenb</name> <operator>&lt;=</operator> <name>opt_lenb</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt_lenb</name> <operator>=</operator> <name>static_lenb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf</name> <operator>!=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"lost buf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opt_lenb</name> <operator>=</operator> <name>static_lenb</name> <operator>=</operator> <name>stored_len</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt> <comment type="block">/* force a stored block */</comment>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FORCE_STORED</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* force stored block */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>stored_len</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>opt_lenb</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                       <comment type="block">/* 4: two words for the lengths */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
         * transform a block into a stored block.
         */</comment>
        <expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stored_len</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FORCE_STATIC</name></cpp:ifdef>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>static_lenb</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* force static trees */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_FIXED</name> <operator>||</operator> <name>static_lenb</name> <operator>==</operator> <name>opt_lenb</name></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>STATIC_TREES</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>last</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>compress_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ct_data</name> <operator>*</operator><operator>)</operator><name>static_ltree</name></expr></argument>,
                       <argument><expr><operator>(</operator><specifier>const</specifier> <name>ct_data</name> <operator>*</operator><operator>)</operator><name>static_dtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+=</operator> <literal type="number">3</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>static_len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>DYN_TREES</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>last</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>send_all_trees</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>l_desc</name><operator>.</operator><name>max_code</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>d_desc</name><operator>.</operator><name>max_code</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,
                       <argument><expr><name>max_blindex</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>compress_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ct_data</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name></name></expr></argument>,
                       <argument><expr><operator>(</operator><specifier>const</specifier> <name>ct_data</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+=</operator> <literal type="number">3</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>opt_len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name></expr></argument>, <argument><expr><literal type="string">"bad compressed size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */</comment>
    <expr_stmt><expr><call><name>init_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>bi_windup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>  <comment type="block">/* align on byte boundary */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"\ncomprlen %lu(%lu) "</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>,</operator>
           <name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name><operator>-</operator><literal type="number">7</literal><operator>*</operator><name>last</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<comment type="block">/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */</comment>
<function><type><name>int</name> <name>ZLIB_INTERNAL</name></type> <name>_tr_tally</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>dist</name></type></decl></parameter>, <parameter><decl><type><name>lc</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>  <comment type="block">/* distance of matched string */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>lc</name></decl>;</decl_stmt>    <comment type="block">/* match length-MIN_MATCH or unmatched char (if dist==0) */</comment>
<block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>d_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>dist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>l_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uch</name><operator>)</operator><name>lc</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dist</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* lc is the unmatched char */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><name>lc</name></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Here, lc is the match length - MIN_MATCH */</comment>
        <expr_stmt><expr><name>dist</name><operator>--</operator></expr>;</expr_stmt>             <comment type="block">/* dist = match distance - 1 */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ush</name><operator>)</operator><name>dist</name> <operator>&lt;</operator> <operator>(</operator><name>ush</name><operator>)</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>ush</name><operator>)</operator><name>lc</name> <operator>&lt;=</operator> <operator>(</operator><name>ush</name><operator>)</operator><operator>(</operator><name>MAX_MATCH</name><operator>-</operator><name>MIN_MATCH</name><operator>)</operator> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>ush</name><operator>)</operator><call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>ush</name><operator>)</operator><name>D_CODES</name></expr></argument>,  <argument><expr><literal type="string">"_tr_tally: bad match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><name><name>_length_code</name><index>[<expr><name>lc</name></expr>]</index></name><operator>+</operator><name>LITERALS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name><index>[<expr><call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>Freq</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRUNCATE_BLOCK</name></cpp:ifdef>
    <comment type="block">/* Try to guess if it is profitable to stop the current block here */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name> <operator>&amp;</operator> <literal type="number">0x1fff</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Compute an upper bound for the compressed length */</comment>
        <decl_stmt><decl><type><name>ulg</name></type> <name>out_length</name> <init>= <expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name><operator>*</operator><literal type="number">8L</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ulg</name></type> <name>in_length</name> <init>= <expr><operator>(</operator><name>ulg</name><operator>)</operator><operator>(</operator><operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dcode</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>dcode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dcode</name> <operator>&lt;</operator> <name>D_CODES</name></expr>;</condition> <incr><expr><name>dcode</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>out_length</name> <operator>+=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_dtree</name><index>[<expr><name>dcode</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>*</operator>
                <operator>(</operator><literal type="number">5L</literal><operator>+</operator><name><name>extra_dbits</name><index>[<expr><name>dcode</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>out_length</name> <operator>&gt;&gt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"\nlast_lit %u, in %ld, out ~%ld(%ld%%) "</literal><operator>,</operator>
               <name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name><operator>,</operator> <name>in_length</name><operator>,</operator> <name>out_length</name><operator>,</operator>
               <literal type="number">100L</literal> <operator>-</operator> <name>out_length</name><operator>*</operator><literal type="number">100L</literal><operator>/</operator><name>in_length</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name><operator>/</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>out_length</name> <operator>&lt;</operator> <name>in_length</name><operator>/</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    <comment type="block">/* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */</comment>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>compress_block</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>ltree</name></type></decl></parameter>, <parameter><decl><type><name>dtree</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> <modifier>*</modifier></type><name>ltree</name></decl>;</decl_stmt> <comment type="block">/* literal tree */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> <modifier>*</modifier></type><name>dtree</name></decl>;</decl_stmt> <comment type="block">/* distance tree */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>      <comment type="block">/* distance of matched string */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lc</name></decl>;</decl_stmt>             <comment type="block">/* match length or unmatched char (if dist == 0) */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>lx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* running index in l_buf */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>code</name></decl>;</decl_stmt>      <comment type="block">/* the code to send */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>extra</name></decl>;</decl_stmt>          <comment type="block">/* number of extra bits to send */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <do>do <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>d_buf</name><index>[<expr><name>lx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>l_buf</name><index>[<expr><name>lx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dist</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* send a literal byte */</comment>
            <expr_stmt><expr><call><name>Tracecv</name><argument_list>(<argument><expr><call><name>isgraph</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">" '%c' "</literal><operator>,</operator> <name>lc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Here, lc is the match length - MIN_MATCH */</comment>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name><name>_length_code</name><index>[<expr><name>lc</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>code</name><operator>+</operator><name>LITERALS</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* send the length code */</comment>
            <expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>extra_lbits</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>lc</name> <operator>-=</operator> <name><name>base_length</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* send the extra length bits */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>dist</name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* dist is now the match distance - 1 */</comment>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>code</name> <operator>&lt;</operator> <name>D_CODES</name></expr></argument>, <argument><expr><literal type="string">"bad d_code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>dtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* send the distance code */</comment>
            <expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>dist</name> <operator>-=</operator> <name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* send the extra distance bits */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt> <comment type="block">/* literal or match pair ? */</comment>

        <comment type="block">/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pending</name></name><operator>)</operator> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>lx</name></expr></argument>,
               <argument><expr><literal type="string">"pendingBuf overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block> while <condition>(<expr><name>lx</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition>;</do></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>detect_data_type</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <comment type="block">/* black_mask is the bit mask of black-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>black_mask</name> <init>= <expr><literal type="number">0xf3ffc07fUL</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <comment type="block">/* Check for non-textual ("black-listed") bytes. */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;=</operator> <literal type="number">31</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>black_mask</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>black_mask</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>Z_BINARY</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* Check for textual ("white-listed") bytes. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>!=</operator> <literal type="number">0</literal>
            <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_TEXT</name></expr>;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">32</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>LITERALS</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>Freq</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>Z_TEXT</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* There are no "black-listed" or "white-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */</comment>
    <return>return <expr><name>Z_BINARY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */</comment>
<function><type><name>local</name> <name>unsigned</name></type> <name>bi_reverse</name><parameter_list>(<parameter><decl><type><name>code</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>code</name></decl>;</decl_stmt> <comment type="block">/* the value to invert */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>       <comment type="block">/* its bit length */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>|=</operator> <name>code</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>res</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>--</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
    <return>return <expr><name>res</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>bi_flush</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>bi_windup</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name><operator>+</operator><literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">7</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>copy_block</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>, <parameter><decl><type><name>header</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charf</name>    <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>    <comment type="block">/* the input data */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>     <comment type="block">/* its length */</comment>
    <decl_stmt><decl><type><name>int</name></type>      <name>header</name></decl>;</decl_stmt>  <comment type="block">/* true if block header must be written */</comment>
<block>{<block_content>
    <expr_stmt><expr><call><name>bi_windup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* align on byte boundary */</comment>

    <if_stmt><if>if <condition>(<expr><name>header</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>ush</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>ush</name><operator>)</operator><operator>~</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name> <operator>+=</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">16</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name> <operator>+=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>len</name><operator>&lt;&lt;</operator><literal type="number">3</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>*</operator><name>buf</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function></block_content></block></function>
</unit>
