<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/Zip/inflate.c"><comment type="block">/* inflate.c -- zlib decompression
 * Copyright (C) 1995-2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
 * Change history:
 *
 * 1.2.beta0    24 Nov 2002
 * - First version -- complete rewrite of inflate to simplify code, avoid
 *   creation of window when not needed, minimize use of window when it is
 *   needed, make inffast.c even faster, implement gzip decoding, and to
 *   improve code readability and style over the previous zlib inflate code
 *
 * 1.2.beta1    25 Nov 2002
 * - Use pointers for available input and output checking in inffast.c
 * - Remove input and output counters in inffast.c
 * - Change inffast.c entry and loop from avail_in &gt;= 7 to &gt;= 6
 * - Remove unnecessary second byte pull from length extra in inffast.c
 * - Unroll direct copy to three copies per loop in inffast.c
 *
 * 1.2.beta2    4 Dec 2002
 * - Change external routine names to reduce potential conflicts
 * - Correct filename to inffixed.h for fixed tables in inflate.c
 * - Make hbuf[] unsigned char to match parameter type in inflate.c
 * - Change strm-&gt;next_out[-state-&gt;offset] to *(strm-&gt;next_out - state-&gt;offset)
 *   to avoid negation problem on Alphas (64 bit) in inflate.c
 *
 * 1.2.beta3    22 Dec 2002
 * - Add comments on state-&gt;bits assertion in inffast.c
 * - Add comments on op field in inftrees.h
 * - Fix bug in reuse of allocated window after inflateReset()
 * - Remove bit fields--back to byte structure for speed
 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
 * - Use local copies of stream next and avail values, as well as local bit
 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
 *
 * 1.2.beta4    1 Jan 2003
 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
 * - Move a comment on output buffer sizes from inffast.c to inflate.c
 * - Add comments in inffast.c to introduce the inflate_fast() routine
 * - Rearrange window copies in inflate_fast() for speed and simplification
 * - Unroll last copy for window match in inflate_fast()
 * - Use local copies of window variables in inflate_fast() for speed
 * - Pull out common wnext == 0 case for speed in inflate_fast()
 * - Make op and len in inflate_fast() unsigned for consistency
 * - Add FAR to lcode and dcode declarations in inflate_fast()
 * - Simplified bad distance check in inflate_fast()
 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
 *   source file infback.c to provide a call-back interface to inflate for
 *   programs like gzip and unzip -- uses window as output buffer to avoid
 *   window copying
 *
 * 1.2.beta5    1 Jan 2003
 * - Improved inflateBack() interface to allow the caller to provide initial
 *   input in strm.
 * - Fixed stored blocks bug in inflateBack()
 *
 * 1.2.beta6    4 Jan 2003
 * - Added comments in inffast.c on effectiveness of POSTINC
 * - Typecasting all around to reduce compiler warnings
 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
 *   make compilers happy
 * - Changed type of window in inflateBackInit() to unsigned char *
 *
 * 1.2.beta7    27 Jan 2003
 * - Changed many types to unsigned or unsigned short to avoid warnings
 * - Added inflateCopy() function
 *
 * 1.2.0        9 Mar 2003
 * - Changed inflateBack() interface to provide separate opaque descriptors
 *   for the in() and out() functions
 * - Changed inflateBack() argument and in_func typedef to swap the length
 *   and buffer address return values for the input function
 * - Check next_in and next_out for Z_NULL on entry to inflate()
 *
 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inftrees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inflate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inffast.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAKEFIXED</name></cpp:ifdef>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>BUILDFIXED</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>BUILDFIXED</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* function prototypes */</comment>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fixedtables</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>updatewindow</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <name>FAR</name> <operator>*</operator><name>end</name><operator>,</operator>
                           <name>unsigned</name> <name>copy</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BUILDFIXED</name></cpp:ifdef>
   <decl_stmt><decl><type><name>void</name> <name>makefixed</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>unsigned</name> <name>syncsearch</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>FAR</name> <operator>*</operator><name>have</name><operator>,</operator> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <name>FAR</name> <operator>*</operator><name>buf</name><operator>,</operator>
                              <name>unsigned</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateResetKeep</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name></expr>)</condition><block type="pseudo"><block_content>        <comment type="block">/* to support ill-conceived Java test suite */</comment>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>HEAD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>havedict</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dmax</name></name> <operator>=</operator> <literal type="number">32768U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hold</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>distcode</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sane</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate: reset\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateReset</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><call><name>inflateResetKeep</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateReset2</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>windowBits</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>wrap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get the state */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* extract wrap request from windowBits parameter */</comment>
    <if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>wrap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>windowBits</name> <operator>=</operator> <operator>-</operator><name>windowBits</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>wrap</name> <operator>=</operator> <operator>(</operator><name>windowBits</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>&lt;</operator> <literal type="number">48</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>windowBits</name> <operator>&amp;=</operator> <literal type="number">15</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* set number of window bits, free window if different */</comment>
    <if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>windowBits</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>windowBits</name></expr></argument> &gt;</argument_list></name> <literal type="number">15</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>wbits</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>windowBits</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* update state and reset the rest of it */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <name>wrap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wbits</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>windowBits</name></expr>;</expr_stmt>
    <return>return <expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateInit2_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>windowBits</name></type></decl></parameter>, <parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>ZLIB_VERSION</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
        <name>stream_size</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>                 <comment type="block">/* in case we return an error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_SOLO</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>=</operator> <name>zcalloc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <operator>(</operator><name>voidpf</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_SOLO</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>=</operator> <name>zcfree</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator>
            <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate: allocated\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name>state</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflateReset2</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>windowBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateInit_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{<block_content>
    <return>return <expr><call><name>inflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>DEF_WBITS</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflatePrime</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>bits</name></type></decl></parameter>, <parameter><decl><type><name>value</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hold</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>Z_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&gt;</operator> <literal type="number">16</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>+</operator> <name>bits</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>value</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hold</name></name> <operator>+=</operator> <name>value</name> <operator>&lt;&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>+=</operator> <name>bits</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>fixedtables</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BUILDFIXED</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>virgin</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>code</name> <modifier>*</modifier></type><name>lenfix</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>distfix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>code</name></type> <name><name>fixed</name><index>[<expr><literal type="number">544</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* build fixed huffman tables if first call (may not be thread safe) */</comment>
    <if_stmt><if>if <condition>(<expr><name>virgin</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>sym</name></decl>, <decl><type ref="prev"/><name>bits</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <name>code</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

        <comment type="block">/* literal/length table */</comment>
        <expr_stmt><expr><name>sym</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">144</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></while>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></while>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">280</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></while>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">288</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name>fixed</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lenfix</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inflate_table</name><argument_list>(<argument><expr><name>LENS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><literal type="number">288</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>next</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>bits</name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* distance table */</comment>
        <expr_stmt><expr><name>sym</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>distfix</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inflate_table</name><argument_list>(<argument><expr><name>DISTS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>next</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>bits</name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* do this just once */</comment>
        <expr_stmt><expr><name>virgin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !BUILDFIXED */</comment>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>"inffixed.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* BUILDFIXED */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <name>lenfix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distcode</name></name> <operator>=</operator> <name>distfix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAKEFIXED</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   those tables to stdout, which would be piped to inffixed.h.  A small program
   can simply call makefixed to do this:

    void makefixed(void);

    int main(void)
    {
        makefixed();
        return 0;
    }

   Then that can be linked with zlib built with MAKEFIXED defined and run:

    a.out &gt; inffixed.h
 */</comment>
<function><type><name>void</name></type> <name>makefixed</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name></type> <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fixedtables</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"    /* inffixed.h -- table for decoding fixed codes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"     * Generated automatically by makefixed()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"     */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"    /* WARNING: this file should *not* be used by applications."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"       It is part of the implementation of this library and is"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"       subject to change. Applications should only use zlib.h."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"     */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">9</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"    static const code lenfix[%u] = {"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>low</name> <operator>%</operator> <literal type="number">7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n        "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{%u,%u,%d}"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>low</name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator> <operator>==</operator> <literal type="number">99</literal></expr> ?</condition><then> <expr><literal type="number">64</literal></expr> </then><else>: <expr><name><name>state</name><operator>.</operator><name>lencode</name><index>[<expr><name>low</name></expr>]</index></name><operator>.</operator><name>op</name></expr></else></ternary></expr></argument>,
               <argument><expr><name><name>state</name><operator>.</operator><name>lencode</name><index>[<expr><name>low</name></expr>]</index></name><operator>.</operator><name>bits</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>lencode</name><index>[<expr><name>low</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>low</name> <operator>==</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"\n    };"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n    static const code distfix[%u] = {"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>low</name> <operator>%</operator> <literal type="number">6</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n        "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{%u,%u,%d}"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>distcode</name><index>[<expr><name>low</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>distcode</name><index>[<expr><name>low</name></expr>]</index></name><operator>.</operator><name>bits</name></expr></argument>,
               <argument><expr><name><name>state</name><operator>.</operator><name>distcode</name><index>[<expr><name>low</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>low</name> <operator>==</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"\n    };"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MAKEFIXED */</comment>

<comment type="block">/*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>updatewindow</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>end</name></type></decl></parameter>, <parameter><decl><type><name>copy</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>copy</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* if it hasn't been done already, allocate space for the window */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <name>FAR</name> <operator>*</operator><operator>)</operator>
                        <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wbits</name></name></expr></argument>,
                               <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if window not in use yet, initialize */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wbits</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* copy state-&gt;wsize or less output bytes into the circular window */</comment>
    <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dist</name> <operator>&gt;</operator> <name>copy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>copy</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>copy</name> <operator>-=</operator> <name>dist</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>copy</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>+=</operator> <name>dist</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>+=</operator> <name>dist</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Macros for inflate(): */</comment>

<comment type="block">/* check function to use adler32() for zlib or crc32() for gzip */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE</name><parameter_list>(<parameter><type><name>check</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(state-&gt;flags ? crc32(check, buf, len) : adler32(check, buf, len))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE</name><parameter_list>(<parameter><type><name>check</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>adler32(check, buf, len)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* check macros for header crc */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CRC2</name><parameter_list>(<parameter><type><name>check</name></type></parameter>, <parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \
        check = crc32(check, hbuf, 2); \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CRC4</name><parameter_list>(<parameter><type><name>check</name></type></parameter>, <parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \
        hbuf[2] = (unsigned char)((word) &gt;&gt; 16); \
        hbuf[3] = (unsigned char)((word) &gt;&gt; 24); \
        check = crc32(check, hbuf, 4); \
    } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Load registers with state in inflate() for speed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        put = strm-&gt;next_out; \
        left = strm-&gt;avail_out; \
        next = strm-&gt;next_in; \
        have = strm-&gt;avail_in; \
        hold = state-&gt;hold; \
        bits = state-&gt;bits; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Restore state from registers in inflate() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        strm-&gt;next_out = put; \
        strm-&gt;avail_out = left; \
        strm-&gt;next_in = next; \
        strm-&gt;avail_in = have; \
        state-&gt;hold = hold; \
        state-&gt;bits = bits; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Clear the input bit accumulator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITBITS</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold = 0; \
        bits = 0; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PULLBYTE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) &lt;&lt; bits; \
        bits += 8; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEEDBITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        while (bits &lt; (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Return the low n bits of the bit accumulator (n &lt; 16) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</cpp:value></cpp:define>

<comment type="block">/* Remove n bits from the bit accumulator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROPBITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold &gt;&gt;= (n); \
        bits -= (unsigned)(n); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Remove zero to seven bits as needed to go to a byte boundary */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEBITS</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold &gt;&gt;= bits &amp; 7; \
        bits -= bits &amp; 7; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn't enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want &lt; need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a "goto inf_leave" is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm-&gt;avail_in or strm-&gt;avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm-&gt;next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */</comment>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflate</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_const</name> <name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>    <comment type="block">/* next input */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>put</name></decl>;</decl_stmt>     <comment type="block">/* next output */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>have</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>        <comment type="block">/* available input and output */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hold</name></decl>;</decl_stmt>         <comment type="block">/* bit buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bits</name></decl>;</decl_stmt>              <comment type="block">/* bits in bit buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>           <comment type="block">/* save starting available input and output */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>copy</name></decl>;</decl_stmt>              <comment type="block">/* number of stored or match bytes to copy */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>    <comment type="block">/* where to copy match bytes from */</comment>
    <decl_stmt><decl><type><name>code</name></type> <name>here</name></decl>;</decl_stmt>                  <comment type="block">/* current decoding table entry */</comment>
    <decl_stmt><decl><type><name>code</name></type> <name>last</name></decl>;</decl_stmt>                  <comment type="block">/* parent table entry */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* length to copy for repeats, bits to drop */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>                    <comment type="block">/* return code */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hbuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* buffer for gzip header crc calculation */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>order</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <init>= <comment type="block">/* permutation of code lengths */</comment>
        <expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">15</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>TYPE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPEDO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>      <comment type="block">/* skip check */</comment>
    <expr_stmt><expr><call><name>LOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <name>have</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>out</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_OK</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>HEAD</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPEDO</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>hold</name> <operator>==</operator> <literal type="number">0x8b1f</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* gzip header */</comment>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>FLAGS</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>           <comment type="block">/* expect zlib header */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<decl_stmt><expr><operator>!</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator></expr></decl_stmt>   <comment type="block">/* check if zlib header allowed */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if>if <condition>(
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr><operator>(</operator><operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hold</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <literal type="number">31</literal></expr>)</condition></if></if_stmt></condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"incorrect header check"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_DEFLATED</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"unknown compression method"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wbits</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wbits</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wbits</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid window size"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dmax</name></name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:   zlib header ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <ternary><condition><expr><name>hold</name> <operator>&amp;</operator> <literal type="number">0x200</literal></expr> ?</condition><then> <expr><name>DICTID</name></expr> </then><else>: <expr><name>TYPE</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
        <case>case <expr><name>FLAGS</name></expr>:</case>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>hold</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>!=</operator> <name>Z_DEFLATED</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"unknown compression method"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0xe000</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"unknown header flags set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>text</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>hold</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TIME</name></expr>;</expr_stmt>
        <case>case <expr><name>TIME</name></expr>:</case>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>hold</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CRC4</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>OS</name></expr>;</expr_stmt>
        <case>case <expr><name>OS</name></expr>:</case>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>xflags</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>hold</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>os</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>hold</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>EXLEN</name></expr>;</expr_stmt>
        <case>case <expr><name>EXLEN</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0400</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>hold</name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>hold</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>EXTRA</name></expr>;</expr_stmt>
        <case>case <expr><name>EXTRA</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0400</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>have</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>have</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator>
                        <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
                                <argument><expr><ternary><condition><expr><name>len</name> <operator>+</operator> <name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra_max</name></name></expr> ?</condition><then>
                                <expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>extra_max</name></name> <operator>-</operator> <name>len</name></expr> </then><else>: <expr><name>copy</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>have</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>NAME</name></expr>;</expr_stmt>
        <case>case <expr><name>NAME</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0800</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>have</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>next</name><index>[<expr><name>copy</name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator>
                            <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator>
                            <name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>name_max</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>name</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block> while <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name>copy</name> <operator>&lt;</operator> <name>have</name></expr>)</condition>;</do>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>have</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>COMMENT</name></expr>;</expr_stmt>
        <case>case <expr><name>COMMENT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x1000</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>have</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>next</name><index>[<expr><name>copy</name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator>
                            <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>comment</name></name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator>
                            <name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>comm_max</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>comment</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block> while <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name>copy</name> <operator>&lt;</operator> <name>have</name></expr>)</condition>;</do>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>have</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>HCRC</name></expr>;</expr_stmt>
        <case>case <expr><name>HCRC</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0x0200</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>hold</name> <operator>!=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"header crc mismatch"</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>hcrc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>DICTID</name></expr>:</case>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>ZSWAP32</name><argument_list>(<argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DICT</name></expr>;</expr_stmt>
        <case>case <expr><name>DICT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>havedict</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>Z_NEED_DICT</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
        <case>case <expr><name>TYPE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_BLOCK</name> <operator>||</operator> <name>flush</name> <operator>==</operator> <name>Z_TREES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
        <case>case <expr><name>TYPEDO</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>BYTEBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>CHECK</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case>                             <comment type="block">/* stored block */</comment>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:     stored block%s\n"</literal><operator>,</operator>
                        <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="string">" (last)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>STORED</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr>:</case>                             <comment type="block">/* fixed block */</comment>
                <expr_stmt><expr><call><name>fixedtables</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:     fixed codes block%s\n"</literal><operator>,</operator>
                        <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="string">" (last)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN_</name></expr>;</expr_stmt>             <comment type="block">/* decode codes */</comment>
                <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_TREES</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>inf_leave</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>                             <comment type="block">/* dynamic block */</comment>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:     dynamic codes block%s\n"</literal><operator>,</operator>
                        <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="string">" (last)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TABLE</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr>:</case>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid block type"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>STORED</name></expr>:</case>
            <expr_stmt><expr><call><name>BYTEBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                         <comment type="block">/* go to byte boundary */</comment>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>hold</name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>hold</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>^</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid stored block lengths"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>hold</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       stored length %u\n"</literal><operator>,</operator>
                    <name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>COPY_</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_TREES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
        <case>case <expr><name>COPY_</name></expr>:</case>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>COPY</name></expr>;</expr_stmt>
        <case>case <expr><name>COPY</name></expr>:</case>
            <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>have</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>have</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>left</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>put</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>have</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>put</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       stored end\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TABLE</name></expr>:</case>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">257</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ndist</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ncode</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PKZIP_BUG_WORKAROUND</name></cpp:ifndef>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>&gt;</operator> <literal type="number">286</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>ndist</name></name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"too many length or distance symbols"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       table sizes ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LENLENS</name></expr>;</expr_stmt>
        <case>case <expr><name>LENLENS</name></expr>:</case>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ncode</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>order</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><call><name>BITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>&lt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>order</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>code</name> <name>FAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate_table</name><argument_list>(<argument><expr><name>CODES</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>,
                                <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid code lengths set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       code lengths ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>CODELENS</name></expr>;</expr_stmt>
        <case>case <expr><name>CODELENS</name></expr>:</case>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>ndist</name></name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lencode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>here</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid bit length repeat"</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">17</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">11</literal> <operator>+</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>+</operator> <name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>ndist</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid bit length repeat"</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <while>while <condition>(<expr><name>copy</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></while>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

            <comment type="block">/* handle error breaks in while */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BAD</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* check for end-of-block code (better have one) */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid code -- missing end-of-block"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>code</name> <name>FAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate_table</name><argument_list>(<argument><expr><name>LENS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>,
                                <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid literal/lengths set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distcode</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>code</name> <name>FAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate_table</name><argument_list>(<argument><expr><name>DISTS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>nlen</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ndist</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distances set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       codes ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN_</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_TREES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
        <case>case <expr><name>LEN_</name></expr>:</case>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt>
        <case>case <expr><name>LEN</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>have</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <name>left</name> <operator>&gt;=</operator> <literal type="number">258</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>inflate_fast</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>TYPE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lencode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>last</name> <operator>=</operator> <name>here</name></expr>;</expr_stmt>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lencode</name><index>[<expr><name><name>last</name><operator>.</operator><name>val</name></name> <operator>+</operator>
                            <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>last</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name><name>last</name><operator>.</operator><name>bits</name></name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>+=</operator> <name><name>last</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>+=</operator> <name><name>here</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>here</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <ternary><condition><expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>&gt;=</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <name><name>here</name><operator>.</operator><name>val</name></name> <operator>&lt;</operator> <literal type="number">0x7f</literal></expr> ?</condition><then>
                        <expr><literal type="string">"inflate:         literal '%c'\n"</literal></expr> </then><else>:
                        <expr><literal type="string">"inflate:         literal 0x%02x\n"</literal></expr></else></ternary><operator>,</operator> <name><name>here</name><operator>.</operator><name>val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LIT</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:         end of block\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid literal/length code"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LENEXT</name></expr>;</expr_stmt>
        <case>case <expr><name>LENEXT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>+=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:         length %u\n"</literal><operator>,</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>was</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DIST</name></expr>;</expr_stmt>
        <case>case <expr><name>DIST</name></expr>:</case>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>distcode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>last</name> <operator>=</operator> <name>here</name></expr>;</expr_stmt>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>distcode</name><index>[<expr><name><name>last</name><operator>.</operator><name>val</name></name> <operator>+</operator>
                            <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>last</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name><name>last</name><operator>.</operator><name>bits</name></name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>+=</operator> <name><name>last</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>+=</operator> <name><name>here</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distance code"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>here</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DISTEXT</name></expr>;</expr_stmt>
        <case>case <expr><name>DISTEXT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>back</name></name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFLATE_STRICT</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>dmax</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distance too far back"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:         distance %u\n"</literal><operator>,</operator> <name><name>state</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MATCH</name></expr>;</expr_stmt>
        <case>case <expr><name>MATCH</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>out</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;</operator> <name>copy</name></expr>)</condition> <block>{<block_content>         <comment type="block">/* copy from window */</comment>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name>copy</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>whave</name></name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sane</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distance too far back"</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR</name></cpp:ifdef>
                    <expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate.c too far\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>copy</name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>whave</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>left</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>left</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                    <do>do <block>{<block_content>
                        <expr_stmt><expr><operator>*</operator><name>put</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block> while <condition>(<expr><operator>--</operator><name>copy</name></expr>)</condition>;</do>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>copy</name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>-</operator> <name>copy</name><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>-</operator> <name>copy</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else <block>{<block_content>                              <comment type="block">/* copy from output */</comment>
                <expr_stmt><expr><name>from</name> <operator>=</operator> <name>put</name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>left</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>left</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
            <do>do <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>put</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><operator>--</operator><name>copy</name></expr>)</condition>;</do>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>LIT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>inf_leave</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>put</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>left</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CHECK</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>out</name> <operator>-=</operator> <name>left</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>out</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>total</name></name> <operator>+=</operator> <name>out</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator>
                        <call><name>UPDATE</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name>put</name> <operator>-</operator> <name>out</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
                     <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name></expr> ?</condition><then> <expr><name>hold</name></expr> </then><else>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                     <expr><call><name>ZSWAP32</name><argument_list>(<argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"incorrect data check"</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:   check matches trailer\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LENGTH</name></expr>;</expr_stmt>
        <case>case <expr><name>LENGTH</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>flags</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>hold</name> <operator>!=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>total</name></name> <operator>&amp;</operator> <literal type="number">0xffffffffUL</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"incorrect length check"</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:   length matches trailer\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DONE</name></expr>;</expr_stmt>
        <case>case <expr><name>DONE</name></expr>:</case>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_STREAM_END</name></expr>;</expr_stmt>
            <goto>goto <name>inf_leave</name>;</goto>
        <case>case <expr><name>BAD</name></expr>:</case>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>inf_leave</name>;</goto>
        <case>case <expr><name>MEM</name></expr>:</case>
            <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
        <case>case <expr><name>SYNC</name></expr>:</case>
        <default>default:</default>
            <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
        </block_content>}</block></switch></block_content></block></for>

    <comment type="block">/*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */</comment>
  <label><name>inf_leave</name>:</label>
    <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>||</operator> <operator>(</operator><name>out</name> <operator>!=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>&lt;</operator> <name>BAD</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>&lt;</operator> <name>CHECK</name> <operator>||</operator> <name>flush</name> <operator>!=</operator> <name>Z_FINISH</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>updatewindow</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><name>out</name> <operator>-</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MEM</name></expr>;</expr_stmt>
            <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>in</name> <operator>-=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>out</name> <operator>-=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name>in</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>out</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>total</name></name> <operator>+=</operator> <name>out</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&amp;&amp;</operator> <name>out</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator>
            <call><name>UPDATE</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>-</operator> <name>out</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>data_type</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="number">64</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                      <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>TYPE</name></expr> ?</condition><then> <expr><literal type="number">128</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                      <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>LEN_</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>COPY_</name></expr> ?</condition><then> <expr><literal type="number">256</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>in</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>out</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>flush</name> <operator>==</operator> <name>Z_FINISH</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_BUF_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateEnd</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate: end\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateGetDictionary</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>dictionary</name></type></decl></parameter>, <parameter><decl><type><name>dictLength</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>dictionary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name> <modifier>*</modifier></type><name>dictLength</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <comment type="block">/* check state */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* copy dictionary */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>&amp;&amp;</operator> <name>dictionary</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr></argument>,
                <argument><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>dictionary</name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr></argument>,
                <argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictLength</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>dictLength</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>whave</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateSetDictionary</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>dictionary</name></type></decl></parameter>, <parameter><decl><type><name>dictLength</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>dictionary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>dictLength</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>dictid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <comment type="block">/* check state */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>DICT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* check for correct dictionary identifier */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>DICT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dictid</name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictid</name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><name>dictid</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dictid</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>check</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>Z_DATA_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>updatewindow</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>dictionary</name> <operator>+</operator> <name>dictLength</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MEM</name></expr>;</expr_stmt>
        <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>havedict</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:   dictionary set\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateGetHeader</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>head</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gz_headerp</name></type> <name>head</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <comment type="block">/* check state */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* save header structure */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   or when out of input.  When called, *have is the number of pattern bytes
   found in order so far, in 0..3.  On return *have is updated to the new
   state.  If on return *have equals four, then the pattern was found and the
   return value is how many bytes were read including the last byte of the
   pattern.  If *have is less than four, then the pattern has not been found
   yet and the return value is len.  In the latter case, syncsearch() can be
   called again with more data and the *have state.  *have is initialized to
   zero for the first call.
 */</comment>
<function><type><name>local</name> <name>unsigned</name></type> <name>syncsearch</name><parameter_list>(<parameter><decl><type><name>have</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>unsigned</name> <name>FAR</name> <modifier>*</modifier></type><name>have</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>got</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>got</name> <operator>=</operator> <operator>*</operator><name>have</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>next</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>got</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>buf</name><index>[<expr><name>next</name></expr>]</index></name><operator>)</operator> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name>got</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>got</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><name>next</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>got</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>got</name> <operator>=</operator> <literal type="number">4</literal> <operator>-</operator> <name>got</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>next</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>have</name> <operator>=</operator> <name>got</name></expr>;</expr_stmt>
    <return>return <expr><name>next</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateSync</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* number of bytes to look at or looked at */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>      <comment type="block">/* temporary to save total_in and total_out */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* to restore bit buffer to byte string */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <comment type="block">/* check parameters */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_BUF_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* if first time, start search in bit buffer */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>SYNC</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>SYNC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hold</name></name> <operator>&lt;&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>hold</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hold</name></name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>syncsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>)</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* search available input */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>syncsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* return no joy or set up to restart inflate() on a new block */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_DATA_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr>;</expr_stmt>  <expr_stmt><expr><name>out</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>  <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateSyncPoint</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <return>return <expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>STORED</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateCopy</name><parameter_list>(<parameter><decl><type><name>dest</name></type></decl></parameter>, <parameter><decl><type><name>source</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>source</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>window</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>wsize</name></decl>;</decl_stmt>

    <comment type="block">/* check input */</comment>
    <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>source</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <name><name>source</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal> <operator>||</operator> <name><name>source</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>source</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* allocate space */</comment>
    <expr_stmt><expr><name>copy</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator>
           <call><name>ZALLOC</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>window</name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>window</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <name>FAR</name> <operator>*</operator><operator>)</operator>
                 <call><name>ZALLOC</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wbits</name></name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>window</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* copy state */</comment>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>copy</name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name> <operator>&amp;&amp;</operator>
        <name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name> <operator>+</operator> <name>ENOUGH</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <name><name>copy</name><operator>-&gt;</operator><name>codes</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>distcode</name></name> <operator>=</operator> <name><name>copy</name><operator>-&gt;</operator><name>codes</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>distcode</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>copy</name><operator>-&gt;</operator><name>codes</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>window</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>wsize</name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wbits</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>wsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <name>window</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name>copy</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateUndermine</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>subvert</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>subvert</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sane</name></name> <operator>=</operator> <operator>!</operator><name>subvert</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR</name></cpp:ifdef>
    <return>return <expr><name>Z_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sane</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>Z_DATA_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>long</name> <name>ZEXPORT</name></type> <name>inflateMark</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>back</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator>
        <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>COPY</name></expr> ?</condition><then> <expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr> </then><else>:
            <expr><operator>(</operator><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>MATCH</name></expr> ?</condition><then> <expr><name><name>state</name><operator>-&gt;</operator><name>was</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
