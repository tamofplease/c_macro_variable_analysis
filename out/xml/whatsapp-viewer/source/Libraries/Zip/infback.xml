<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/Zip/infback.c"><comment type="block">/* infback.c -- inflate using a call-back interface
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
   This code is largely copied from inflate.c.  Normally either infback.o or
   inflate.o would be linked into an application--not both.  The interface
   with inffast.c is retained so that optimized assembler-coded versions of
   inflate_fast() can be used with either inflate.c or infback.c.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inftrees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inflate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inffast.h"</cpp:file></cpp:include>

<comment type="block">/* function prototypes */</comment>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fixedtables</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block">/*
   strm provides memory allocation functions in zalloc and zfree, or
   Z_NULL to use the library memory allocation functions.

   windowBits is in the range 8..15, and window is a user-supplied
   window and output buffer that is 2**windowBits bytes.
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateBackInit_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>windowBits</name></type></decl></parameter>, <parameter><decl><type><name>window</name></type></decl></parameter>, <parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>window</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>ZLIB_VERSION</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
        <name>stream_size</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name>window</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>
        <name><name>windowBits</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>windowBits</name></expr></argument> &gt;</argument_list></name> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>                 <comment type="block">/* in case we return an error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_SOLO</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>=</operator> <name>zcalloc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <operator>(</operator><name>voidpf</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_SOLO</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>=</operator> <name>zcfree</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate: allocated\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name>state</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dmax</name></name> <operator>=</operator> <literal type="number">32768U</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wbits</name></name> <operator>=</operator> <name>windowBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>windowBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <name>window</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wnext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>fixedtables</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BUILDFIXED</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>virgin</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>code</name> <modifier>*</modifier></type><name>lenfix</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>distfix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>code</name></type> <name><name>fixed</name><index>[<expr><literal type="number">544</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* build fixed huffman tables if first call (may not be thread safe) */</comment>
    <if_stmt><if>if <condition>(<expr><name>virgin</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>sym</name></decl>, <decl><type ref="prev"/><name>bits</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <name>code</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

        <comment type="block">/* literal/length table */</comment>
        <expr_stmt><expr><name>sym</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">144</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></while>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></while>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">280</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></while>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">288</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name>fixed</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lenfix</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inflate_table</name><argument_list>(<argument><expr><name>LENS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><literal type="number">288</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>next</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>bits</name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* distance table */</comment>
        <expr_stmt><expr><name>sym</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name>sym</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>distfix</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inflate_table</name><argument_list>(<argument><expr><name>DISTS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>next</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>bits</name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* do this just once */</comment>
        <expr_stmt><expr><name>virgin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !BUILDFIXED */</comment>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>"inffixed.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* BUILDFIXED */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <name>lenfix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distcode</name></name> <operator>=</operator> <name>distfix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Macros for inflateBack(): */</comment>

<comment type="block">/* Load returned state from inflate_fast() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        put = strm-&gt;next_out; \
        left = strm-&gt;avail_out; \
        next = strm-&gt;next_in; \
        have = strm-&gt;avail_in; \
        hold = state-&gt;hold; \
        bits = state-&gt;bits; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Set state from registers for inflate_fast() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        strm-&gt;next_out = put; \
        strm-&gt;avail_out = left; \
        strm-&gt;next_in = next; \
        strm-&gt;avail_in = have; \
        state-&gt;hold = hold; \
        state-&gt;bits = bits; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Clear the input bit accumulator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITBITS</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold = 0; \
        bits = 0; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Assure that some input is available.  If input is requested, but denied,
   then return a Z_BUF_ERROR from inflateBack(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PULL</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (have == 0) { \
            have = in(in_desc, &amp;next); \
            if (have == 0) { \
                next = Z_NULL; \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Get a byte of input into the bit accumulator, or return from inflateBack()
   with an error if there is no input available. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PULLBYTE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        PULL(); \
        have--; \
        hold += (unsigned long)(*next++) &lt;&lt; bits; \
        bits += 8; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflateBack() with
   an error. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEEDBITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        while (bits &lt; (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Return the low n bits of the bit accumulator (n &lt; 16) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</cpp:value></cpp:define>

<comment type="block">/* Remove n bits from the bit accumulator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROPBITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold &gt;&gt;= (n); \
        bits -= (unsigned)(n); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Remove zero to seven bits as needed to go to a byte boundary */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEBITS</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold &gt;&gt;= bits &amp; 7; \
        bits -= bits &amp; 7; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Assure that some output space is available, by writing out the window
   if it's full.  If the write fails, return from inflateBack() with a
   Z_BUF_ERROR. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROOM</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (left == 0) { \
            put = state-&gt;window; \
            left = state-&gt;wsize; \
            state-&gt;whave = left; \
            if (out(out_desc, put, left)) { \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/*
   strm provides the memory allocation functions and window buffer on input,
   and provides information on the unused input on return.  For Z_DATA_ERROR
   returns, strm will also provide an error message.

   in() and out() are the call-back input and output functions.  When
   inflateBack() needs more input, it calls in().  When inflateBack() has
   filled the window with output, or when it completes with data in the
   window, it calls out() to write out the data.  The application must not
   change the provided input until in() is called again or inflateBack()
   returns.  The application must not change the window/output buffer until
   inflateBack() returns.

   in() and out() are called with a descriptor parameter provided in the
   inflateBack() call.  This parameter can be a structure that provides the
   information required to do the read or write, as well as accumulated
   information on the input and output such as totals and check values.

   in() should return zero on failure.  out() should return non-zero on
   failure.  If either in() or out() fails, than inflateBack() returns a
   Z_BUF_ERROR.  strm-&gt;next_in can be checked for Z_NULL to see whether it
   was in() or out() that caused in the error.  Otherwise,  inflateBack()
   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   error, or Z_MEM_ERROR if it could not allocate memory for the state.
   inflateBack() can also return Z_STREAM_ERROR if the input parameters
   are not correct, i.e. strm is Z_NULL or the state was not initialized.
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateBack</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>in</name></type></decl></parameter>, <parameter><decl><type><name>in_desc</name></type></decl></parameter>, <parameter><decl><type><name>out</name></type></decl></parameter>, <parameter><decl><type><name>out_desc</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>in_func</name></type> <name>in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <name>FAR</name> <modifier>*</modifier></type><name>in_desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>out_func</name></type> <name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <name>FAR</name> <modifier>*</modifier></type><name>out_desc</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>inflate_state</name></name> <name>FAR</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_const</name> <name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>    <comment type="block">/* next input */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>put</name></decl>;</decl_stmt>     <comment type="block">/* next output */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>have</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>        <comment type="block">/* available input and output */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hold</name></decl>;</decl_stmt>         <comment type="block">/* bit buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bits</name></decl>;</decl_stmt>              <comment type="block">/* bits in bit buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>copy</name></decl>;</decl_stmt>              <comment type="block">/* number of stored or match bytes to copy */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>    <comment type="block">/* where to copy match bytes from */</comment>
    <decl_stmt><decl><type><name>code</name></type> <name>here</name></decl>;</decl_stmt>                  <comment type="block">/* current decoding table entry */</comment>
    <decl_stmt><decl><type><name>code</name></type> <name>last</name></decl>;</decl_stmt>                  <comment type="block">/* parent table entry */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* length to copy for repeats, bits to drop */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>                    <comment type="block">/* return code */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>order</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <init>= <comment type="block">/* permutation of code lengths */</comment>
        <expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">15</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check that the strm exists and that the state was initialized */</comment>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>inflate_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* Reset the state */</comment>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>have</name> <operator>=</operator> <ternary><condition><expr><name>next</name> <operator>!=</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>hold</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>put</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>;</expr_stmt>

    <comment type="block">/* Inflate until end of block marked as last */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TYPE</name></expr>:</case>
            <comment type="block">/* determine and dispatch block type */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>BYTEBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DONE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case>                             <comment type="block">/* stored block */</comment>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:     stored block%s\n"</literal><operator>,</operator>
                        <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="string">" (last)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>STORED</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr>:</case>                             <comment type="block">/* fixed block */</comment>
                <expr_stmt><expr><call><name>fixedtables</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:     fixed codes block%s\n"</literal><operator>,</operator>
                        <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="string">" (last)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt>              <comment type="block">/* decode codes */</comment>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>                             <comment type="block">/* dynamic block */</comment>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:     dynamic codes block%s\n"</literal><operator>,</operator>
                        <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><literal type="string">" (last)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TABLE</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr>:</case>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid block type"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>STORED</name></expr>:</case>
            <comment type="block">/* get and verify stored block length */</comment>
            <expr_stmt><expr><call><name>BYTEBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                         <comment type="block">/* go to byte boundary */</comment>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>hold</name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>hold</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>^</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid stored block lengths"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>hold</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       stored length %u\n"</literal><operator>,</operator>
                    <name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* copy stored block from input to output */</comment>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ROOM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>have</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>have</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name>left</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>put</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>have</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>put</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       stored end\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>TABLE</name></expr>:</case>
            <comment type="block">/* get dynamic table entries descriptor */</comment>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">257</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ndist</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ncode</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PKZIP_BUG_WORKAROUND</name></cpp:ifndef>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>&gt;</operator> <literal type="number">286</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>ndist</name></name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"too many length or distance symbols"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       table sizes ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* get code length code lengths (not a typo) */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ncode</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>order</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><call><name>BITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>&lt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>order</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <operator>(</operator><name>code</name> <specifier>const</specifier> <name>FAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate_table</name><argument_list>(<argument><expr><name>CODES</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>,
                                <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid code lengths set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       code lengths ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* get length and distance code code lengths */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>ndist</name></name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lencode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>here</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid bit length repeat"</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">17</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">11</literal> <operator>+</operator> <call><name>BITS</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name> <operator>+</operator> <name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nlen</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>ndist</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid bit length repeat"</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <while>while <condition>(<expr><name>copy</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>have</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></while>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

            <comment type="block">/* handle error breaks in while */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BAD</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* check for end-of-block code (better have one) */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>lens</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid code -- missing end-of-block"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>codes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lencode</name></name> <operator>=</operator> <operator>(</operator><name>code</name> <specifier>const</specifier> <name>FAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate_table</name><argument_list>(<argument><expr><name>LENS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>,
                                <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid literal/lengths set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distcode</name></name> <operator>=</operator> <operator>(</operator><name>code</name> <specifier>const</specifier> <name>FAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate_table</name><argument_list>(<argument><expr><name>DISTS</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lens</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>nlen</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ndist</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distances set"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:       codes ok\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt>

        <case>case <expr><name>LEN</name></expr>:</case>
            <comment type="block">/* use inflate_fast() if we have enough input and output */</comment>
            <if_stmt><if>if <condition>(<expr><name>have</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <name>left</name> <operator>&gt;=</operator> <literal type="number">258</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>-</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>inflate_fast</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* get a literal, length, or end-of-block code */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lencode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lenbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>last</name> <operator>=</operator> <name>here</name></expr>;</expr_stmt>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lencode</name><index>[<expr><name><name>last</name><operator>.</operator><name>val</name></name> <operator>+</operator>
                            <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>last</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name><name>last</name><operator>.</operator><name>bits</name></name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>here</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

            <comment type="block">/* process literal */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <ternary><condition><expr><name><name>here</name><operator>.</operator><name>val</name></name> <operator>&gt;=</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <name><name>here</name><operator>.</operator><name>val</name></name> <operator>&lt;</operator> <literal type="number">0x7f</literal></expr> ?</condition><then>
                        <expr><literal type="string">"inflate:         literal '%c'\n"</literal></expr> </then><else>:
                        <expr><literal type="string">"inflate:         literal 0x%02x\n"</literal></expr></else></ternary><operator>,</operator> <name><name>here</name><operator>.</operator><name>val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ROOM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>put</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>LEN</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* process end of block */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:         end of block\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TYPE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* invalid code */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid literal/length code"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* length code -- get extra bits, if any */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>+=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:         length %u\n"</literal><operator>,</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* get distance code */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>distcode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>distbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>last</name> <operator>=</operator> <name>here</name></expr>;</expr_stmt>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>distcode</name><index>[<expr><name><name>last</name><operator>.</operator><name>val</name></name> <operator>+</operator>
                            <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>last</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name><name>last</name><operator>.</operator><name>bits</name></name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>last</name><operator>.</operator><name>bits</name></name> <operator>+</operator> <name><name>here</name><operator>.</operator><name>bits</name></name><operator>)</operator> <operator>&lt;=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>here</name><operator>.</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>here</name><operator>.</operator><name>op</name></name> <operator>&amp;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distance code"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>here</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

            <comment type="block">/* get distance extra bits, if any */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>here</name><operator>.</operator><name>op</name></name><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>whave</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr> ?</condition><then>
                                                <expr><name>left</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"invalid distance too far back"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate:         distance %u\n"</literal><operator>,</operator> <name><name>state</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* copy match from window to output */</comment>
            <do>do <block>{<block_content>
                <expr_stmt><expr><call><name>ROOM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&lt;</operator> <name>left</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>from</name> <operator>=</operator> <name>put</name> <operator>+</operator> <name>copy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>left</name> <operator>-</operator> <name>copy</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else <block>{<block_content>
                    <expr_stmt><expr><name>from</name> <operator>=</operator> <name>put</name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>copy</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>copy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>put</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><operator>--</operator><name>copy</name></expr>)</condition>;</do>
            </block_content>}</block> while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
            <break>break;</break>

        <case>case <expr><name>DONE</name></expr>:</case>
            <comment type="block">/* inflate stream terminated properly -- write leftover output */</comment>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_STREAM_END</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>wsize</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>out</name><argument_list>(<argument><expr><name>out_desc</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wsize</name></name> <operator>-</operator> <name>left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_BUF_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>inf_leave</name>;</goto>

        <case>case <expr><name>BAD</name></expr>:</case>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>inf_leave</name>;</goto>

        <default>default:</default>                <comment type="block">/* can't happen, but makes compilers happy */</comment>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>inf_leave</name>;</goto>
        </block_content>}</block></switch></block_content></block></for>

    <comment type="block">/* Return unused input */</comment>
  <label><name>inf_leave</name>:</label>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>have</name></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateBackEnd</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"inflate: end\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
