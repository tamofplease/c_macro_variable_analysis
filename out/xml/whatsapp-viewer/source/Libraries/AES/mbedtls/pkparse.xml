<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/AES/mbedtls/pkparse.c"><comment type="block">/*
 *  Public Key layer for parsing key files and structures
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_CONFIG_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> MBEDTLS_CONFIG_FILE</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PK_PARSE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asn1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oid.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rsa.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecp.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECDSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecdsa.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PEM_PARSE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pem.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS5_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pkcs5.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS12_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pkcs12.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PLATFORM_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_calloc</name></cpp:macro>    <cpp:value>calloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_free</name></cpp:macro>       <cpp:value>free</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_FS_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Implementation that should never be optimized out by the compiler */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mbedtls_zeroize</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter> )</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt> <while>while<condition>( <expr><name>n</name><operator>--</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Load all data from a file into a given buffer.
 *
 * The file is expected to contain either PEM or DER encoded data.
 * A terminating null byte is always appended. It is included in the announced
 * length only if the data looks like it is PEM encoded.
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_pk_load_file</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>size</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>( <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fseek</name><argument_list>( <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>size</name> <operator>=</operator> <call><name>ftell</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fseek</name><argument_list>( <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <operator>*</operator><name>buf</name> <operator>=</operator> <call><name>mbedtls_calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_ALLOC_FAILED</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>fread</name><argument_list>( <argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>f</name></expr></argument> )</argument_list></call> <operator>!=</operator> <operator>*</operator><name>n</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><operator>*</operator><name>buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>buf</name><operator>)</operator><index>[<expr><operator>*</operator><name>n</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>( <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"-----BEGIN "</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>++</operator><operator>*</operator><name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load and parse a private key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_pk_parse_keyfile</name><parameter_list>( <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_load_file</name><argument_list>( <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pwd</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_parse_key</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_parse_key</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
                <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>pwd</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>( <argument><expr><name>pwd</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_zeroize</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load and parse a public key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_pk_parse_public_keyfile</name><parameter_list>( <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_load_file</name><argument_list>( <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_parse_public_key</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_zeroize</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_FS_IO */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Minimally parse an ECParameters buffer to and mbedtls_asn1_buf
 *
 * ECParameters ::= CHOICE {
 *   namedCurve         OBJECT IDENTIFIER
 *   specifiedCurve     SpecifiedECDomain -- = SEQUENCE { ... }
 *   -- implicitCurve   NULL
 * }
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_get_ecparams</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
                            <parameter><decl><type><name>mbedtls_asn1_buf</name> <modifier>*</modifier></type><name>params</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <comment type="block">/* Tag may be either OID or SEQUENCE */</comment>
    <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>params</name><operator>-&gt;</operator><name>tag</name></name> <operator>!=</operator> <name>MBEDTLS_ASN1_OID</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PK_PARSE_EC_EXTENDED</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>tag</name></name> <operator>!=</operator> <operator>(</operator> <name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name> <operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_UNEXPECTED_TAG</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>tag</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>+=</operator> <name><name>params</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>end</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PK_PARSE_EC_EXTENDED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Parse a SpecifiedECDomain (SEC 1 C.2) and (mostly) fill the group with it.
 * WARNING: the resulting group should only be used with
 * pk_group_id_from_specified(), since its base point may not be set correctly
 * if it was encoded compressed.
 *
 *  SpecifiedECDomain ::= SEQUENCE {
 *      version SpecifiedECDomainVersion(ecdpVer1 | ecdpVer2 | ecdpVer3, ...),
 *      fieldID FieldID {{FieldTypes}},
 *      curve Curve,
 *      base ECPoint,
 *      order INTEGER,
 *      cofactor INTEGER OPTIONAL,
 *      hash HashAlgorithm OPTIONAL,
 *      ...
 *  }
 *
 * We only support prime-field as field type, and ignore hash and cofactor.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_group_from_specified</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_asn1_buf</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>end</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name><name>params</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end_field</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_curve</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ver</name></decl>;</decl_stmt>

    <comment type="block">/* SpecifiedECDomainVersion ::= INTEGER { 1, 2, 3 } */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ver</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>ver</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>ver</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * FieldID { FIELD-ID:IOSet } ::= SEQUENCE { -- Finite field
     *       fieldType FIELD-ID.&amp;id({IOSet}),
     *       parameters FIELD-ID.&amp;Type({IOSet}{@fieldType})
     * }
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>end_field</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * FIELD-ID ::= TYPE-IDENTIFIER
     * FieldTypes FIELD-ID ::= {
     *       { Prime-p IDENTIFIED BY prime-field } |
     *       { Characteristic-two IDENTIFIED BY characteristic-two-field }
     * }
     * prime-field OBJECT IDENTIFIER ::= { id-fieldType 1 }
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end_field</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OID</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>len</name> <operator>!=</operator> <call><name>MBEDTLS_OID_SIZE</name><argument_list>( <argument><expr><name>MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD</name></expr></argument> )</argument_list></call> <operator>||</operator>
        <call><name>memcmp</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* Prime-p ::= INTEGER -- Field of size p. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end_field</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>pbits</name></name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>!=</operator> <name>end_field</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Curve ::= SEQUENCE {
     *       a FieldElement,
     *       b FieldElement,
     *       seed BIT STRING OPTIONAL
     *       -- Shall be present if used in SpecifiedECDomain
     *       -- with version equal to ecdpVer2 or ecdpVer3
     * }
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>end_curve</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * FieldElement ::= OCTET STRING
     * containing an integer in the case of a prime field
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end_curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end_curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* Ignore seed BIT STRING OPTIONAL */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end_curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_BIT_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>!=</operator> <name>end_curve</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * ECPoint ::= OCTET STRING
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_point_read_binary</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name></name></expr></argument>,
                                      <argument><expr><operator>(</operator> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we can't read the point because it's compressed, cheat by
         * reading only the X coordinate and the parity bit of Y.
         */</comment>
        <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</name> <operator>||</operator>
            <operator>(</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x02</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x03</literal> <operator>)</operator> <operator>||</operator>
            <name>len</name> <operator>!=</operator> <call><name>mbedtls_mpi_size</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>X</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>Y</name></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * order INTEGER
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allow optional elements by purposefully not enforcing p == end here.
     */</comment>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the group id associated with an (almost filled) group as generated by
 * pk_group_from_specified(), or return an error if unknown.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_group_id_from_group</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_group_id</name> <modifier>*</modifier></type><name>grp_id</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_group</name></type> <name>ref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group_id</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_group_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>( <init><expr><name>id</name> <operator>=</operator> <call><name>mbedtls_ecp_grp_id_list</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><operator>*</operator><name>id</name> <operator>!=</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <comment type="block">/* Load the group associated to that id */</comment>
        <expr_stmt><expr><call><name>mbedtls_ecp_group_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><operator>*</operator><name>id</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Compare to the group we were given, starting with easy tests */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>pbits</name></name> <operator>==</operator> <name><name>ref</name><operator>.</operator><name>pbits</name></name> <operator>&amp;&amp;</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name> <operator>==</operator> <name><name>ref</name><operator>.</operator><name>nbits</name></name> <operator>&amp;&amp;</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>A</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>B</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>G</name><operator>.</operator><name>X</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>G</name><operator>.</operator><name>Z</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <comment type="block">/* For Y we may only know the parity bit, so compare only that */</comment>
            <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>.</operator><name>G</name><operator>.</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr> )</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></for>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_ecp_group_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>grp_id</name> <operator>=</operator> <operator>*</operator><name>id</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>id</name> <operator>==</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a SpecifiedECDomain (SEC 1 C.2) and find the associated group ID
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_group_id_from_specified</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_asn1_buf</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
                                       <parameter><decl><type><name>mbedtls_ecp_group_id</name> <modifier>*</modifier></type><name>grp_id</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_group</name></type> <name>grp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_group_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_group_from_specified</name><argument_list>( <argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pk_group_id_from_group</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><name>grp_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_ecp_group_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PK_PARSE_EC_EXTENDED */</comment>

<comment type="block">/*
 * Use EC parameters to initialise an EC group
 *
 * ECParameters ::= CHOICE {
 *   namedCurve         OBJECT IDENTIFIER
 *   specifiedCurve     SpecifiedECDomain -- = SEQUENCE { ... }
 *   -- implicitCurve   NULL
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_use_ecparams</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_asn1_buf</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_group_id</name></type> <name>grp_id</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>params</name><operator>-&gt;</operator><name>tag</name></name> <operator>==</operator> <name>MBEDTLS_ASN1_OID</name></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_oid_get_ec_grp</name><argument_list>( <argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grp_id</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PK_PARSE_EC_EXTENDED</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_group_id_from_specified</name><argument_list>( <argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grp_id</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * grp may already be initilialized; if so, make sure IDs match
     */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>MBEDTLS_ECP_DP_NONE</name> <operator>&amp;&amp;</operator> <name><name>grp</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>grp_id</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>grp_id</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EC public key is an EC point
 *
 * The caller is responsible for clearing the structure upon failure if
 * desired. Take care to pass along the possible ECP_FEATURE_UNAVAILABLE
 * return code of mbedtls_ecp_point_read_binary() and leave p in a usable state.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_get_ecpubkey</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
                            <parameter><decl><type><name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>key</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_point_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <operator>*</operator><name>p</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_check_pubkey</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We know mbedtls_ecp_point_read_binary consumed all bytes or failed
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>end</name></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 *  RSAPublicKey ::= SEQUENCE {
 *      modulus           INTEGER,  -- n
 *      publicExponent    INTEGER   -- e
 *  }
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_get_rsapubkey</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
                             <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>rsa</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name> <operator>+</operator> <name>len</name> <operator>!=</operator> <name>end</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>E</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>end</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_rsa_check_pubkey</name><argument_list>( <argument><expr><name>rsa</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>rsa</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>mbedtls_mpi_size</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>

<comment type="block">/* Get a PK algorithm identifier
 *
 *  AlgorithmIdentifier  ::=  SEQUENCE  {
 *       algorithm               OBJECT IDENTIFIER,
 *       parameters              ANY DEFINED BY algorithm OPTIONAL  }
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_get_pk_alg</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
                          <parameter><decl><type><name>mbedtls_pk_type_t</name> <modifier>*</modifier></type><name>pk_alg</name></decl></parameter>, <parameter><decl><type><name>mbedtls_asn1_buf</name> <modifier>*</modifier></type><name>params</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_asn1_buf</name></type> <name>alg_oid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mbedtls_asn1_buf</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_alg</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alg_oid</name></expr></argument>, <argument><expr><name>params</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_ALG</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_oid_get_pk_alg</name><argument_list>( <argument><expr><operator>&amp;</operator><name>alg_oid</name></expr></argument>, <argument><expr><name>pk_alg</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No parameters with RSA (only for EC)
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_RSA</name> <operator>&amp;&amp;</operator>
            <operator>(</operator> <operator>(</operator> <name><name>params</name><operator>-&gt;</operator><name>tag</name></name> <operator>!=</operator> <name>MBEDTLS_ASN1_NULL</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>tag</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>)</operator> <operator>||</operator>
                <name><name>params</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>)</operator></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_ALG</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  SubjectPublicKeyInfo  ::=  SEQUENCE  {
 *       algorithm            AlgorithmIdentifier,
 *       subjectPublicKey     BIT STRING }
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_pk_parse_subpubkey</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
                        <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>pk</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_asn1_buf</name></type> <name>alg_params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_pk_type_t</name></type> <name>pk_alg</name> <init>= <expr><name>MBEDTLS_PK_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_pk_info_t</name> <modifier>*</modifier></type><name>pk_info</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
                    <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_get_pk_alg</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pk_alg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alg_params</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_bitstring_null</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name> <operator>+</operator> <name>len</name> <operator>!=</operator> <name>end</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pk_info</name> <operator>=</operator> <call><name>mbedtls_pk_info_from_type</name><argument_list>( <argument><expr><name>pk_alg</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_setup</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>pk_info</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_RSA</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pk_get_rsapubkey</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><call><name>mbedtls_pk_rsa</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    if<condition>( <expr><name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_ECKEY_DH</name> <operator>||</operator> <name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_ECKEY</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pk_use_ecparams</name><argument_list>( <argument><expr><operator>&amp;</operator><name>alg_params</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>mbedtls_pk_ec</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call><operator>-&gt;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pk_get_ecpubkey</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><call><name>mbedtls_pk_ec</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>end</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PK_INVALID_PUBKEY</name>
              <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Parse a PKCS#1 encoded private RSA key
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_parse_key_pkcs1_der</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>rsa</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                                   <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>keylen</name></expr>;</expr_stmt>

    <comment type="block">/*
     * This function parses the RSAPrivateKey (PKCS#1)
     *
     *  RSAPrivateKey ::= SEQUENCE {
     *      version           Version,
     *      modulus           INTEGER,  -- n
     *      publicExponent    INTEGER,  -- e
     *      privateExponent   INTEGER,  -- d
     *      prime1            INTEGER,  -- p
     *      prime2            INTEGER,  -- q
     *      exponent1         INTEGER,  -- d mod (p-1)
     *      exponent2         INTEGER,  -- d mod (q-1)
     *      coefficient       INTEGER,  -- (inverse of q) mod p
     *      otherPrimeInfos   OtherPrimeInfos OPTIONAL
     *  }
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>ver</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>rsa</name><operator>-&gt;</operator><name>ver</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_VERSION</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>N</name></name></expr></argument>  )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>E</name></name></expr></argument>  )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>D</name></name></expr></argument>  )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>P</name></name></expr></argument>  )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>  )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>DP</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>QP</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_rsa_free</name><argument_list>( <argument><expr><name>rsa</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>rsa</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>mbedtls_mpi_size</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>!=</operator> <name>end</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_rsa_free</name><argument_list>( <argument><expr><name>rsa</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_rsa_check_privkey</name><argument_list>( <argument><expr><name>rsa</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_rsa_free</name><argument_list>( <argument><expr><name>rsa</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Parse a SEC1 encoded private EC key
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_parse_key_sec1_der</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>eck</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                                  <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>, <decl><type ref="prev"/><name>pubkey_done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_asn1_buf</name></type> <name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name> <operator>+</operator> <name>keylen</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end2</name></decl>;</decl_stmt>

    <comment type="block">/*
     * RFC 5915, or SEC1 Appendix C.4
     *
     * ECPrivateKey ::= SEQUENCE {
     *      version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
     *      privateKey     OCTET STRING,
     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
     *      publicKey  [1] BIT STRING OPTIONAL
     *    }
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>version</name> <operator>!=</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_VERSION</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_ecp_keypair_free</name><argument_list>( <argument><expr><name>eck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pubkey_done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>!=</operator> <name>end</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Is 'parameters' present?
         */</comment>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
                        <argument><expr><name>MBEDTLS_ASN1_CONTEXT_SPECIFIC</name> <operator>|</operator> <name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_get_ecparams</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_use_ecparams</name><argument_list>( <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>grp</name></name></expr></argument> )</argument_list></call>  <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>mbedtls_ecp_keypair_free</name><argument_list>( <argument><expr><name>eck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_ASN1_UNEXPECTED_TAG</name></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_ecp_keypair_free</name><argument_list>( <argument><expr><name>eck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Is 'publickey' present? If not, or if we can't read it (eg because it
         * is compressed), create it from the private key.
         */</comment>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
                        <argument><expr><name>MBEDTLS_ASN1_CONTEXT_SPECIFIC</name> <operator>|</operator> <name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>end2</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

            <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_bitstring_null</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>( <expr><name>p</name> <operator>+</operator> <name>len</name> <operator>!=</operator> <name>end2</name></expr> )</condition><block type="pseudo"><block_content>
                <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                        <name>MBEDTLS_ERR_ASN1_LENGTH_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_get_ecpubkey</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end2</name></expr></argument>, <argument><expr><name>eck</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pubkey_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * The only acceptable failure mode of pk_get_ecpubkey() above
                 * is if the point format is not recognized.
                 */</comment>
                <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</name></expr> )</condition><block type="pseudo"><block_content>
                    <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_ASN1_UNEXPECTED_TAG</name></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_ecp_keypair_free</name><argument_list>( <argument><expr><name>eck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator> <name>pubkey_done</name> <operator>&amp;&amp;</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>G</name></name></expr></argument>,
                                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_ecp_keypair_free</name><argument_list>( <argument><expr><name>eck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_check_privkey</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>eck</name><operator>-&gt;</operator><name>d</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_ecp_keypair_free</name><argument_list>( <argument><expr><name>eck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>

<comment type="block">/*
 * Parse an unencrypted PKCS#8 encoded private key
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_parse_key_pkcs8_unencrypted_der</name><parameter_list>(
                                    <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>pk</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>,
                                    <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_asn1_buf</name></type> <name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name> <operator>+</operator> <name>keylen</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_pk_type_t</name></type> <name>pk_alg</name> <init>= <expr><name>MBEDTLS_PK_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_pk_info_t</name> <modifier>*</modifier></type><name>pk_info</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This function parses the PrivatKeyInfo object (PKCS#8 v1.2 = RFC 5208)
     *
     *    PrivateKeyInfo ::= SEQUENCE {
     *      version                   Version,
     *      privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
     *      privateKey                PrivateKey,
     *      attributes           [0]  IMPLICIT Attributes OPTIONAL }
     *
     *    Version ::= INTEGER
     *    PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
     *    PrivateKey ::= OCTET STRING
     *
     *  The PrivateKey OCTET STRING is a SEC1 ECPrivateKey
     */</comment>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>version</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_VERSION</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_get_pk_alg</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pk_alg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator>
                <name>MBEDTLS_ERR_ASN1_OUT_OF_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pk_info</name> <operator>=</operator> <call><name>mbedtls_pk_info_from_type</name><argument_list>( <argument><expr><name>pk_alg</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_setup</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>pk_info</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_RSA</name></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs1_der</name><argument_list>( <argument><expr><call><name>mbedtls_pk_rsa</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    if<condition>( <expr><name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_ECKEY</name> <operator>||</operator> <name>pk_alg</name> <operator>==</operator> <name>MBEDTLS_PK_ECKEY_DH</name></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_use_ecparams</name><argument_list>( <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>mbedtls_pk_ec</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call><operator>-&gt;</operator><name>grp</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_sec1_der</name><argument_list>( <argument><expr><call><name>mbedtls_pk_ec</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call>  <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse an encrypted PKCS#8 encoded private key
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS12_C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS5_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pk_parse_key_pkcs8_encrypted_der</name><parameter_list>(
                                    <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>pk</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pwdlen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>decrypted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_asn1_buf</name></type> <name>pbe_alg_oid</name></decl>, <decl><type ref="prev"/><name>pbe_params</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS12_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>mbedtls_cipher_type_t</name></type> <name>cipher_alg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>keylen</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pwdlen</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_REQUIRED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * This function parses the EncryptedPrivatKeyInfo object (PKCS#8)
     *
     *  EncryptedPrivateKeyInfo ::= SEQUENCE {
     *    encryptionAlgorithm  EncryptionAlgorithmIdentifier,
     *    encryptedData        EncryptedData
     *  }
     *
     *  EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
     *
     *  EncryptedData ::= OCTET STRING
     *
     *  The EncryptedData OCTET STRING is a PKCS#8 PrivateKeyInfo
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_alg</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbe_alg_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbe_params</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>len</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Decrypt EncryptedData with appropriate PDE
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS12_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_oid_get_pkcs12_pbe_alg</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pbe_alg_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>md_alg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cipher_alg</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pkcs12_pbe</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pbe_params</name></expr></argument>, <argument><expr><name>MBEDTLS_PKCS12_PBE_DECRYPT</name></expr></argument>,
                                <argument><expr><name>cipher_alg</name></expr></argument>, <argument><expr><name>md_alg</name></expr></argument>,
                                <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH</name></expr> )</condition><block type="pseudo"><block_content>
                <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>decrypted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><call><name>MBEDTLS_OID_CMP</name><argument_list>( <argument><expr><name>MBEDTLS_OID_PKCS12_PBE_SHA1_RC4_128</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbe_alg_oid</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pkcs12_pbe_sha1_rc4_128</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pbe_params</name></expr></argument>,
                                             <argument><expr><name>MBEDTLS_PKCS12_PBE_DECRYPT</name></expr></argument>,
                                             <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument>,
                                             <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Best guess for password mismatch when using RC4. If first tag is</comment>
        <comment type="line">// not MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE</comment>
        <comment type="line">//</comment>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>buf</name> <operator>!=</operator> <operator>(</operator> <name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name> <operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>decrypted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS12_C */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS5_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    if<condition>( <expr><call><name>MBEDTLS_OID_CMP</name><argument_list>( <argument><expr><name>MBEDTLS_OID_PKCS5_PBES2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbe_alg_oid</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pkcs5_pbes2</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pbe_params</name></expr></argument>, <argument><expr><name>MBEDTLS_PKCS5_DECRYPT</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument>,
                                  <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH</name></expr> )</condition><block type="pseudo"><block_content>
                <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>decrypted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS5_C */</comment>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>pwd</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>decrypted</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <call><name>pk_parse_key_pkcs8_unencrypted_der</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */</comment>

<comment type="block">/*
 * Parse a private key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_pk_parse_key</name><parameter_list>( <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>pk</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pwdlen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_pk_info_t</name> <modifier>*</modifier></type><name>pk_info</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PEM_PARSE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_pem_context</name></type> <name>pem</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_pem_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */</comment>
    <if_stmt><if>if<condition>( <expr><name>keylen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>key</name><index>[<expr><name>keylen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pem_read_buffer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument>,
                               <argument><expr><literal type="string">"-----BEGIN RSA PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><literal type="string">"-----END RSA PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pk_info</name> <operator>=</operator> <call><name>mbedtls_pk_info_from_type</name><argument_list>( <argument><expr><name>MBEDTLS_PK_RSA</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_setup</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>pk_info</name></expr></argument>                    )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs1_der</name><argument_list>( <argument><expr><call><name>mbedtls_pk_rsa</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument>,
                                            <argument><expr><name><name>pem</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pem</name><operator>.</operator><name>buflen</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_pem_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PEM_PASSWORD_MISMATCH</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PEM_PASSWORD_REQUIRED</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_REQUIRED</name> <operator>)</operator></expr>;</return></block_content></block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */</comment>
    <if_stmt><if>if<condition>( <expr><name>keylen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>key</name><index>[<expr><name>keylen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pem_read_buffer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument>,
                               <argument><expr><literal type="string">"-----BEGIN EC PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><literal type="string">"-----END EC PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pk_info</name> <operator>=</operator> <call><name>mbedtls_pk_info_from_type</name><argument_list>( <argument><expr><name>MBEDTLS_PK_ECKEY</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_setup</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>pk_info</name></expr></argument>                   )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_sec1_der</name><argument_list>( <argument><expr><call><name>mbedtls_pk_ec</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument>,
                                           <argument><expr><name><name>pem</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pem</name><operator>.</operator><name>buflen</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_pem_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PEM_PASSWORD_MISMATCH</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_MISMATCH</name> <operator>)</operator></expr>;</return></block_content></block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PEM_PASSWORD_REQUIRED</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_PASSWORD_REQUIRED</name> <operator>)</operator></expr>;</return></block_content></block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>

    <comment type="block">/* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */</comment>
    <if_stmt><if>if<condition>( <expr><name>keylen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>key</name><index>[<expr><name>keylen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pem_read_buffer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument>,
                               <argument><expr><literal type="string">"-----BEGIN PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><literal type="string">"-----END PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs8_unencrypted_der</name><argument_list>( <argument><expr><name>pk</name></expr></argument>,
                                                <argument><expr><name><name>pem</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pem</name><operator>.</operator><name>buflen</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_pem_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS12_C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS5_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */</comment>
    <if_stmt><if>if<condition>( <expr><name>keylen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>key</name><index>[<expr><name>keylen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pem_read_buffer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument>,
                               <argument><expr><literal type="string">"-----BEGIN ENCRYPTED PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><literal type="string">"-----END ENCRYPTED PRIVATE KEY-----"</literal></expr></argument>,
                               <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs8_encrypted_der</name><argument_list>( <argument><expr><name>pk</name></expr></argument>,
                                                      <argument><expr><name><name>pem</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pem</name><operator>.</operator><name>buflen</name></name></expr></argument>,
                                                      <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_pem_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>ret</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>pwd</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>pwdlen</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PEM_PARSE_C */</comment>

    <comment type="block">/*
    * At this point we only know it's not a PEM formatted key. Could be any
    * of the known DER encoded private key formats
    *
    * We try the different DER format parsers to see if one passes without
    * error
    */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS12_C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS5_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs8_encrypted_der</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>,
                                                  <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>pwdlen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_PK_PASSWORD_MISMATCH</name></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */</comment>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs8_unencrypted_der</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pk_info</name> <operator>=</operator> <call><name>mbedtls_pk_info_from_type</name><argument_list>( <argument><expr><name>MBEDTLS_PK_RSA</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_setup</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>pk_info</name></expr></argument>                           )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_pkcs1_der</name><argument_list>( <argument><expr><call><name>mbedtls_pk_rsa</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>pk_info</name> <operator>=</operator> <call><name>mbedtls_pk_info_from_type</name><argument_list>( <argument><expr><name>MBEDTLS_PK_ECKEY</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_UNKNOWN_PK_ALG</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_setup</name><argument_list>( <argument><expr><name>pk</name></expr></argument>, <argument><expr><name>pk_info</name></expr></argument>                         )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>pk_parse_key_sec1_der</name><argument_list>( <argument><expr><call><name>mbedtls_pk_ec</name><argument_list>( <argument><expr><operator>*</operator><name>pk</name></expr></argument> )</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_pk_free</name><argument_list>( <argument><expr><name>pk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>

    <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_PK_KEY_INVALID_FORMAT</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a public key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_pk_parse_public_key</name><parameter_list>( <parameter><decl><type><name>mbedtls_pk_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PEM_PARSE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_pem_context</name></type> <name>pem</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_pem_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */</comment>
    <if_stmt><if>if<condition>( <expr><name>keylen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>key</name><index>[<expr><name>keylen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pem_read_buffer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument>,
                <argument><expr><literal type="string">"-----BEGIN PUBLIC KEY-----"</literal></expr></argument>,
                <argument><expr><literal type="string">"-----END PUBLIC KEY-----"</literal></expr></argument>,
                <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Was PEM encoded
         */</comment>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>pem</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>keylen</name> <operator>=</operator> <name><name>pem</name><operator>.</operator><name>buflen</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>ret</name> <operator>!=</operator> <name>MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_pem_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PEM_PARSE_C */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_pk_parse_subpubkey</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>keylen</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PEM_PARSE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_pem_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>pem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PK_PARSE_C */</comment>
</unit>
