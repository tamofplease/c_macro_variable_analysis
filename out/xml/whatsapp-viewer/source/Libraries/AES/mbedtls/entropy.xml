<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/AES/mbedtls/entropy.c"><comment type="block">/*
 *  Entropy accumulator implementation
 *
 *  Copyright (C) 2006-2016, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_CONFIG_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> MBEDTLS_CONFIG_FILE</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_C</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TEST_NULL_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:warning>#<cpp:directive>warning</cpp:directive> <cpp:literal>"**** WARNING!  MBEDTLS_TEST_NULL_ENTROPY defined! "</cpp:literal></cpp:warning>
<cpp:warning>#<cpp:directive>warning</cpp:directive> <cpp:literal>"**** THIS BUILD HAS NO DEFINED ENTROPY SOURCES "</cpp:literal></cpp:warning>
<cpp:warning>#<cpp:directive>warning</cpp:directive> <cpp:literal>"**** THIS BUILD IS *NOT* SUITABLE FOR PRODUCTION USE "</cpp:literal></cpp:warning>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entropy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entropy_poll.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_FS_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_NV_SEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PLATFORM_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_printf</name></cpp:macro>     <cpp:value>printf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PLATFORM_C */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_SELF_TEST */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVEGE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"havege.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Implementation that should never be optimized out by the compiler */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mbedtls_zeroize</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter> )</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt> <while>while<condition>( <expr><name>n</name><operator>--</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTROPY_MAX_LOOP</name></cpp:macro>    <cpp:value>256</cpp:value></cpp:define>     <comment type="block" format="doxygen">/**&lt; Maximum amount to loop before error */</comment>

<function><type><name>void</name></type> <name>mbedtls_entropy_init</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mbedtls_entropy_context</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_mutex_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_SHA512_ACCUMULATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_sha512_starts</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>mbedtls_sha256_starts</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVEGE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_havege_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>havege_data</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TEST_NULL_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mbedtls_null_entropy_poll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_STRONG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_NO_PLATFORM_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mbedtls_platform_entropy_poll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_MIN_PLATFORM</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_STRONG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TIMING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mbedtls_hardclock_poll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_MIN_HARDCLOCK</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_WEAK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVEGE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mbedtls_havege_poll</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>havege_data</name></name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_MIN_HAVEGE</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_STRONG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_HARDWARE_ALT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mbedtls_hardware_poll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_MIN_HARDWARE</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_STRONG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_NV_SEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mbedtls_nv_seed_poll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument>,
                                <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_STRONG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mbedtls_entropy_free</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVEGE_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_havege_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>havege_data</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_mutex_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>mbedtls_zeroize</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_entropy_context</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mbedtls_entropy_add_source</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                        <parameter><decl><type><name>mbedtls_entropy_f_source_ptr</name></type> <name>f_source</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_source</name></decl></parameter>,
                        <parameter><decl><type><name>size_t</name></type> <name>threshold</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strong</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mutex_lock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>source_count</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>index</name> <operator>&gt;=</operator> <name>MBEDTLS_ENTROPY_MAX_SOURCES</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ENTROPY_MAX_SOURCES</name></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>f_source</name>  <operator>=</operator> <name>f_source</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>p_source</name>  <operator>=</operator> <name>p_source</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>threshold</name> <operator>=</operator> <name>threshold</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>strong</name>    <operator>=</operator> <name>strong</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source_count</name></name><operator>++</operator></expr>;</expr_stmt>

<label><name>exit</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mutex_unlock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_THREADING_MUTEX_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Entropy accumulator update
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>entropy_update</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>source_id</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>header</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>tmp</name><index>[<expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>use_len</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>use_len</name> <operator>&gt;</operator> <name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr> )</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_SHA512_ACCUMULATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><call><name>mbedtls_sha512</name><argument_list>( <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>mbedtls_sha256</name><argument_list>( <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>use_len</name> <operator>=</operator> <name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>source_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>use_len</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_SHA512_ACCUMULATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_sha512_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_sha512_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>use_len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>mbedtls_sha256_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_sha256_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>use_len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mbedtls_entropy_update_manual</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mutex_lock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>entropy_update</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_MANUAL</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mutex_unlock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_THREADING_MUTEX_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Run through the different sources to add entropy to our accumulator
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>entropy_gather_internal</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>have_one_strong</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_ENTROPY_MAX_GATHER</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>olen</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>source_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Run through our entropy sources
     */</comment>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>source_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>strong</name> <operator>==</operator> <name>MBEDTLS_ENTROPY_SOURCE_STRONG</name></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>have_one_strong</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>olen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>f_source</name><argument_list>( <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_source</name></expr></argument>,
                        <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_MAX_GATHER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Add if we actually gathered something
         */</comment>
        <if_stmt><if>if<condition>( <expr><name>olen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>entropy_update</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>olen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>+=</operator> <name>olen</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>have_one_strong</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Thread-safe wrapper for entropy_gather_internal()
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_entropy_gather</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mutex_lock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>entropy_gather_internal</name><argument_list>( <argument><expr><name>ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mutex_unlock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_THREADING_MUTEX_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mbedtls_entropy_func</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>mbedtls_entropy_context</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>len</name> <operator>&gt;</operator> <name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_SOURCE_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_NV_SEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Update the NV entropy seed before generating any entropy for outside
     * use.
     */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>initial_entropy_run</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>initial_entropy_run</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_update_nv_seed</name><argument_list>( <argument><expr><name>ctx</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mutex_lock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Always gather extra entropy before a call
     */</comment>
    <do>do
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>count</name><operator>++</operator> <operator>&gt;</operator> <name>ENTROPY_MAX_LOOP</name></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ENTROPY_SOURCE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>entropy_gather_internal</name><argument_list>( <argument><expr><name>ctx</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>source_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
            <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold</name></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block>
    while<condition>( <expr><operator>!</operator> <name>done</name></expr> )</condition>;</do>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_SHA512_ACCUMULATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_sha512_finish</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset accumulator and counters and recycle existing entropy
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_sha512_context</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_sha512_starts</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_sha512_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform second SHA-512 on entropy
     */</comment>
    <expr_stmt><expr><call><name>mbedtls_sha512</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */</comment>
    <expr_stmt><expr><call><name>mbedtls_sha256_finish</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset accumulator and counters and recycle existing entropy
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_sha256_context</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_sha256_starts</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_sha256_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform second SHA-256 on entropy
     */</comment>
    <expr_stmt><expr><call><name>mbedtls_sha256</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */</comment>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>source_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>source</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>output</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mutex_unlock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_THREADING_MUTEX_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_NV_SEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type> <name>mbedtls_entropy_update_nv_seed</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[ <expr><name>MBEDTLS_ENTROPY_MAX_SEED_SIZE</name></expr> ]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Read new seed  and write it to NV */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_func</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_nv_seed_write</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Manually update the remaining stream with a separator value to diverge */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_entropy_update_manual</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ENTROPY_NV_SEED */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_FS_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type> <name>mbedtls_entropy_write_seed_file</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>( <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_func</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>fwrite</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr></argument>, <argument><expr><name>f</name></expr></argument> )</argument_list></call> <operator>!=</operator> <name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mbedtls_entropy_update_seed_file</name><parameter_list>( <parameter><decl><type><name>mbedtls_entropy_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[ <expr><name>MBEDTLS_ENTROPY_MAX_SEED_SIZE</name></expr> ]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>( <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fseek</name><argument_list>( <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>ftell</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fseek</name><argument_list>( <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;</operator> <name>MBEDTLS_ENTROPY_MAX_SEED_SIZE</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>MBEDTLS_ENTROPY_MAX_SEED_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>fread</name><argument_list>( <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>f</name></expr></argument> )</argument_list></call> <operator>!=</operator> <name>n</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fclose</name><argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_entropy_update_manual</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <call><name>mbedtls_entropy_write_seed_file</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>path</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_FS_IO */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TEST_NULL_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Dummy source function
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>entropy_dummy_source</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,
                                 <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>data</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0x2a</literal></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !MBEDTLS_TEST_NULL_ENTROPY */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_HARDWARE_ALT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mbedtls_entropy_source_self_test_gather</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entropy_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>olen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>attempts</name> <init>= <expr><name>buf_len</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>attempts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>entropy_len</name> <operator>&lt;</operator> <name>buf_len</name></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_hardware_poll</name><argument_list>( <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>entropy_len</name></expr></argument>,
            <argument><expr><name>buf_len</name> <operator>-</operator> <name>entropy_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>entropy_len</name> <operator>+=</operator> <name>olen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>attempts</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>entropy_len</name> <operator>&lt;</operator> <name>buf_len</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>mbedtls_entropy_source_self_test_check_bits</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
                                                        <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>set</name><init>= <expr><literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>unset</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>buf_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>set</name> <operator>&amp;=</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>unset</name> <operator>|=</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return<expr><operator>(</operator> <name>set</name> <operator>==</operator> <literal type="number">0xFF</literal> <operator>||</operator> <name>unset</name> <operator>==</operator> <literal type="number">0x00</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A test to ensure hat the entropy sources are functioning correctly
 * and there is no obvious failure. The test performs the following checks:
 *  - The entropy source is not providing only 0s (all bits unset) or 1s (all
 *    bits set).
 *  - The entropy source is not providing values in a pattern. Because the
 *    hardware could be providing data in an arbitrary length, this check polls
 *    the hardware entropy source twice and compares the result to ensure they
 *    are not equal.
 *  - The error code returned by the entropy source is not an error.
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_entropy_source_self_test</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>char</name> <name><name>buf0</name><index>[<expr><literal type="number">2</literal> <operator>*</operator></expr></index></name> sizeof<operator>(</operator> <name>unsigned</name> <name>long</name> <name>long</name> <name>int</name> <operator>)</operator>]</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>char</name> <name><name>buf1</name><index>[<expr><literal type="number">2</literal> <operator>*</operator></expr></index></name> sizeof<operator>(</operator> <name>unsigned</name> <name>long</name> <name>long</name> <name>int</name> <operator>)</operator>]</expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  ENTROPY_BIAS test: "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>buf0</name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf0</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf1</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_source_self_test_gather</name><argument_list>( <argument><expr><name>buf0</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf0</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_source_self_test_gather</name><argument_list>( <argument><expr><name>buf1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf1</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Make sure that the returned values are not all 0 or 1 */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_source_self_test_check_bits</name><argument_list>( <argument><expr><name>buf0</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf0</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_source_self_test_check_bits</name><argument_list>( <argument><expr><name>buf1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf1</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Make sure that the entropy source is not returning values in a
     * pattern */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>memcmp</name><argument_list>( <argument><expr><name>buf0</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf0</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>!=</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ENTROPY_HARDWARE_ALT */</comment>

<comment type="block">/*
 * The actual entropy quality is hard to test, but we can at least
 * test that the functions don't cause errors and write the correct
 * amount of data to buffers.
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_entropy_self_test</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TEST_NULL_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>mbedtls_entropy_context</name></type> <name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>acc</name><index>[<expr><name>MBEDTLS_ENTROPY_BLOCK_SIZE</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !MBEDTLS_TEST_NULL_ENTROPY */</comment>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  ENTROPY test: "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TEST_NULL_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_entropy_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First do a gather to make sure we have default sources */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_gather</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_add_source</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>entropy_dummy_source</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>,
                                      <argument><expr><name>MBEDTLS_ENTROPY_SOURCE_WEAK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_update_manual</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * To test that mbedtls_entropy_func writes correct number of bytes:
     * - use the whole buffer and rely on ASan to detect overruns
     * - collect entropy 8 times and OR the result in an accumulator:
     *   any byte should then be 0 with probably 2^(-64), so requiring
     *   each of the 32 or 64 bytes to be non-zero has a false failure rate
     *   of at most 2^(-58) which is acceptable.
     */</comment>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_func</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

        <for>for<control>( <init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>acc</name><index>[<expr><name>j</name></expr>]</index></name> <operator>|=</operator> <name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>

    <for>for<control>( <init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>acc</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ENTROPY_HARDWARE_ALT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_entropy_source_self_test</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_entropy_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !MBEDTLS_TEST_NULL_ENTROPY */</comment>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>!=</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_SELF_TEST */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ENTROPY_C */</comment>
</unit>
