<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/AES/mbedtls/rsa.c"><comment type="block">/*
 *  The RSA public-key cryptosystem
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */</comment>
<comment type="block">/*
 *  The following sources were referenced in the design of this implementation
 *  of the RSA algorithm:
 *
 *  [1] A method for obtaining digital signatures and public-key cryptosystems
 *      R Rivest, A Shamir, and L Adleman
 *      http://people.csail.mit.edu/rivest/pubs.html#RSA78
 *
 *  [2] Handbook of Applied Cryptography - 1997, Chapter 8
 *      Menezes, van Oorschot and Vanstone
 *
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_CONFIG_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> MBEDTLS_CONFIG_FILE</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_C</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oid.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"md.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PLATFORM_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_printf</name></cpp:macro> <cpp:value>printf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_calloc</name></cpp:macro> <cpp:value>calloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_free</name></cpp:macro>   <cpp:value>free</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Initialize an RSA context
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_rsa_init</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>padding</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>hash_id</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_rsa_context</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_rsa_set_padding</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>hash_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_mutex_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Set padding for an existing RSA context
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_rsa_set_padding</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>padding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hash_id</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>=</operator> <name>padding</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hash_id</name></name> <operator>=</operator> <name>hash_id</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_GENPRIME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
 * Generate an RSA keypair
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_gen_key</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                 <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                 <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nbits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exponent</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>P1</name></decl>, <decl><type ref="prev"/><name>Q1</name></decl>, <decl><type ref="prev"/><name>H</name></decl>, <decl><type ref="prev"/><name>G</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nbits</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>||</operator> <name>exponent</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>nbits</name> <operator>%</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>H</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * find primes P and Q with Q &lt; P so that:
     * GCD( E, (P-1)*(Q-1) ) == 1
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><name>exponent</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_gen_prime</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><name>nbits</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_gen_prime</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><name>nbits</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <name>nbits</name></expr> )</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>mbedtls_mpi_swap</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_gcd</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    while<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>;</do>

    <comment type="block">/*
     * D  = E^-1 mod ((P-1)*(Q-1))
     * DP = D mod (P - 1)
     * DQ = D mod (Q - 1)
     * QP = Q^-1 mod P
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument> , <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DP</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>QP</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <operator>(</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>+</operator> <literal type="number">7</literal> <operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>H</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_rsa_free</name><argument_list>( <argument><expr><name>ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_GEN_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_GENPRIME */</comment>

<comment type="block">/*
 * Check a public RSA key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_check_pubkey</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name><operator>.</operator><name>p</name></name> <operator>||</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name><operator>.</operator><name>p</name></name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name><name>ctx</name><operator>-&gt;</operator><name>N</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name><name>ctx</name><operator>-&gt;</operator><name>E</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal> <operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">128</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&gt;</operator> <name>MBEDTLS_MPI_MAX_BITS</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check a private RSA key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_check_privkey</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>PQ</name></decl>, <decl><type ref="prev"/><name>DE</name></decl>, <decl><type ref="prev"/><name>P1</name></decl>, <decl><type ref="prev"/><name>Q1</name></decl>, <decl><type ref="prev"/><name>H</name></decl>, <decl><type ref="prev"/><name>I</name></decl>, <decl><type ref="prev"/><name>G</name></decl>, <decl><type ref="prev"/><name>G2</name></decl>, <decl><type ref="prev"/><name>L1</name></decl>, <decl><type ref="prev"/><name>L2</name></decl>, <decl><type ref="prev"/><name>DP</name></decl>, <decl><type ref="prev"/><name>DQ</name></decl>, <decl><type ref="prev"/><name>QP</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_rsa_check_pubkey</name><argument_list>( <argument><expr><name>ctx</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name><operator>.</operator><name>p</name></name> <operator>||</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>p</name></name> <operator>||</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name><operator>.</operator><name>p</name></name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>I</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>L1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>L2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>QP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PQ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_gcd</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_gcd</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_div_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>L1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>L2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>G2</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>I</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>L1</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DQ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>QP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Check for a valid PKCS1v2 private key
     */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PQ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DP</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DQ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>QP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>QP</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>L2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>I</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>H</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>I</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>G2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>L1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>L2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>QP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>==</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if contexts holding a public and private key match
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_check_pub_priv</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>pub</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>prv</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_rsa_check_pubkey</name><argument_list>( <argument><expr><name>pub</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_rsa_check_privkey</name><argument_list>( <argument><expr><name>prv</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pub</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pub</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>E</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_KEY_CHECK_FAILED</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do an RSA public key operation
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_public</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>olen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>T</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mutex_lock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_MPI_BAD_INPUT_DATA</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>olen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_exp_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RN</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_write_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>olen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mutex_unlock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_THREADING_MUTEX_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_PUBLIC_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate or update blinding values, see section 10 of:
 *  KOCHER, Paul C. Timing attacks on implementations of Diffie-Hellman, RSA,
 *  DSS, and other systems. In : Advances in Cryptology-CRYPTO'96. Springer
 *  Berlin Heidelberg, 1996. p. 104-113.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rsa_prepare_blinding</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                 <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name><operator>.</operator><name>p</name></name> <operator>!=</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* We already have blinding values, just update them by squaring */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Unblinding value: Vf = random number, invertible mod N */</comment>
    <do>do <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>count</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_RNG_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_fill_random</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_gcd</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>;</do>

    <comment type="block">/* Blinding value: Vi =  Vf^(-e) mod N */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_exp_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RN</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>


<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do an RSA private key operation
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_private</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                 <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                 <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>olen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>T</name></decl>, <decl><type ref="prev"/><name>T1</name></decl>, <decl><type ref="prev"/><name>T2</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure we have private key info, prevent possible misuse */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>P</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>D</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_mutex_lock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_MPI_BAD_INPUT_DATA</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>!=</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Blinding
         * T = T * Vi mod N
         */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>rsa_prepare_blinding</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_RSA_NO_CRT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_exp_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RN</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * faster decryption using the CRT
     *
     * T1 = input ^ dP mod P
     * T2 = input ^ dQ mod Q
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_exp_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DP</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RP</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_exp_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RQ</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * T = (T1 - T2) * (Q^-1 mod P) mod P
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>QP</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * T = T2 + T * Q
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_NO_CRT */</comment>

    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>!=</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Unblind
         * T = T * Vf mod N
         */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>olen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_write_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>olen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mutex_unlock</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_THREADING_MUTEX_ERROR</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_PRIVATE_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
 * Generate and apply the MGF1 operation (from PKCS#1 v2.1) to a buffer.
 *
 * \param dst       buffer to mask
 * \param dlen      length of destination buffer
 * \param src       source of the mask generation
 * \param slen      length of the source buffer
 * \param md_ctx    message digest context to use
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mgf_mask</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
                      <parameter><decl><type><name>size_t</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>mbedtls_md_context_t</name> <modifier>*</modifier></type><name>md_ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>mask</name><index>[<expr><name>MBEDTLS_MD_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>counter</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>use_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>mask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MBEDTLS_MD_MAX_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>counter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>hlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name><name>md_ctx</name><operator>-&gt;</operator><name>md_info</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate and apply dbMask */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>

    <while>while<condition>( <expr><name>dlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>use_len</name> <operator>=</operator> <name>hlen</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>dlen</name> <operator>&lt;</operator> <name>hlen</name></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>use_len</name> <operator>=</operator> <name>dlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>mbedtls_md_starts</name><argument_list>( <argument><expr><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><name>md_ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>slen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><name>md_ctx</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_md_finish</name><argument_list>( <argument><expr><name>md_ctx</name></expr></argument>, <argument><expr><name>mask</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>use_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>^=</operator> <name><name>mask</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><name><name>counter</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>dlen</name> <operator>-=</operator> <name>use_len</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V21 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSAES-OAEP-ENCRYPT function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsaes_oaep_encrypt</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                            <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                            <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>label_len</name></decl></parameter>,
                            <parameter><decl><type><name>size_t</name></type> <name>ilen</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>olen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>output</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_md_info_t</name> <modifier>*</modifier></type><name>md_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_md_context_t</name></type> <name>md_ctx</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V21</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><operator>(</operator><name>mbedtls_md_type_t</name><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hash_id</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>olen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* first comparison checks for overflow */</comment>
    <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>hlen</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>ilen</name> <operator>||</operator> <name>olen</name> <operator>&lt;</operator> <name>ilen</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>hlen</name> <operator>+</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>olen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Generate a random octet string seed */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>f_rng</name><argument_list>( <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hlen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_RNG_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>hlen</name></expr>;</expr_stmt>

    <comment type="block">/* Construct DB */</comment>
    <expr_stmt><expr><call><name>mbedtls_md</name><argument_list>( <argument><expr><name>md_info</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>label_len</name></expr></argument>, <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>hlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>olen</name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>hlen</name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <name>ilen</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>ilen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_md_setup</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>md_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* maskedDB: Apply dbMask to DB */</comment>
    <expr_stmt><expr><call><name>mgf_mask</name><argument_list>( <argument><expr><name>output</name> <operator>+</operator> <name>hlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>olen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hlen</name></expr></argument>,
               <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* maskedSeed: Apply seedMask to seed */</comment>
    <expr_stmt><expr><call><name>mgf_mask</name><argument_list>( <argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hlen</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>hlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>olen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
               <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
            ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>output</name></expr></argument> )</argument_list></call></expr>
            </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>output</name></expr></argument> )</argument_list></call></expr></else></ternary> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V21 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSAES-PKCS1-V1_5-ENCRYPT function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsaes_pkcs1_v15_encrypt</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                 <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ilen</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                                 <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nb_pad</name></decl>, <decl><type ref="prev"/><name>olen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>output</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V15</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// We don't check p_rng because it won't be dereferenced here</comment>
    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>input</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>output</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>olen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* first comparison checks for overflow */</comment>
    <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>+</operator> <literal type="number">11</literal> <operator>&lt;</operator> <name>ilen</name> <operator>||</operator> <name>olen</name> <operator>&lt;</operator> <name>ilen</name> <operator>+</operator> <literal type="number">11</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nb_pad</name> <operator>=</operator> <name>olen</name> <operator>-</operator> <literal type="number">3</literal> <operator>-</operator> <name>ilen</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_RSA_CRYPT</name></expr>;</expr_stmt>

        <while>while<condition>( <expr><name>nb_pad</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>rng_dl</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

            <do>do <block>{<block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>f_rng</name><argument_list>( <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while<condition>( <expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>--</operator><name>rng_dl</name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>;</do>

            <comment type="block">/* Check if RNG failed to generate data */</comment>
            <if_stmt><if>if<condition>( <expr><name>rng_dl</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_RNG_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_RSA_SIGN</name></expr>;</expr_stmt>

        <while>while<condition>( <expr><name>nb_pad</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>ilen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
            ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>output</name></expr></argument> )</argument_list></call></expr>
            </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>output</name></expr></argument> )</argument_list></call></expr></else></ternary> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>

<comment type="block">/*
 * Add the message padding, then do an RSA operation
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_pkcs1_encrypt</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                       <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                       <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ilen</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <switch>switch<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name></expr> )</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V15</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsaes_pkcs1_v15_encrypt</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ilen</name></expr></argument>,
                                                <argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V21</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsaes_oaep_encrypt</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>ilen</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSAES-OAEP-DECRYPT function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsaes_oaep_decrypt</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                            <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                            <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>label_len</name></decl></parameter>,
                            <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,
                            <parameter><decl><type><name>size_t</name></type> <name>output_max_len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ilen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>pad_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"/><name>bad</name></decl>, <decl><type ref="prev"/><name>pad_done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_MPI_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>lhash</name><index>[<expr><name>MBEDTLS_MD_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_md_info_t</name> <modifier>*</modifier></type><name>md_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_md_context_t</name></type> <name>md_ctx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Parameters sanity checks
     */</comment>
    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V21</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ilen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>ilen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">16</literal> <operator>||</operator> <name>ilen</name></expr></argument> &gt;</argument_list></name> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><operator>(</operator><name>mbedtls_md_type_t</name><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hash_id</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>hlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// checking for integer underflow</comment>
    <if_stmt><if>if<condition>( <expr><literal type="number">2</literal> <operator>*</operator> <name>hlen</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>ilen</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * RSA operation
     */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
          ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>
          </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Unmask data and generate lHash
     */</comment>
    <expr_stmt><expr><call><name>mbedtls_md_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_md_setup</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>md_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* Generate lHash */</comment>
    <expr_stmt><expr><call><name>mbedtls_md</name><argument_list>( <argument><expr><name>md_info</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>label_len</name></expr></argument>, <argument><expr><name>lhash</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* seed: Apply seedMask to maskedSeed */</comment>
    <expr_stmt><expr><call><name>mgf_mask</name><argument_list>( <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hlen</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>hlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ilen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
               <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* DB: Apply dbMask to maskedDB */</comment>
    <expr_stmt><expr><call><name>mgf_mask</name><argument_list>( <argument><expr><name>buf</name> <operator>+</operator> <name>hlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ilen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hlen</name></expr></argument>,
               <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check contents, in "constant-time"
     */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* First byte must be 0 */</comment>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>hlen</name></expr>;</expr_stmt> <comment type="block">/* Skip seed */</comment>

    <comment type="block">/* Check lHash */</comment>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>bad</name> <operator>|=</operator> <name><name>lhash</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Get zero-padding len, but always read till end of buffer
     * (minus one, for the 01 byte) */</comment>
    <expr_stmt><expr><name>pad_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pad_done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ilen</name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>hlen</name> <operator>-</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>pad_done</name> <operator>|=</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pad_len</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>pad_done</name> <operator>|</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>-</operator><name>pad_done</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>pad_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>^</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * The only information "leaked" is whether the padding was correct or not
     * (eg, no data is copied if it was not correct). This meets the
     * recommendations in PKCS#1 v2.2: an opponent cannot distinguish between
     * the different error conditions.
     */</comment>
    <if_stmt><if>if<condition>( <expr><name>bad</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>-</operator> <operator>(</operator> <name>p</name> <operator>-</operator> <name>buf</name> <operator>)</operator> <operator>&gt;</operator> <name>output_max_len</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>ilen</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>output</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>olen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V21 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSAES-PKCS1-V1_5-DECRYPT function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsaes_pkcs1_v15_decrypt</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                 <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                                 <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,
                                 <parameter><decl><type><name>size_t</name></type> <name>output_max_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ilen</name></decl>, <decl><type ref="prev"/><name>pad_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"/><name>bad</name></decl>, <decl><type ref="prev"/><name>pad_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_MPI_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V15</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ilen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>ilen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">16</literal> <operator>||</operator> <name>ilen</name></expr></argument> &gt;</argument_list></name> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
          ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>
          </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Check and get padding len in "constant-time"
     */</comment>
    <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* First byte must be 0 */</comment>

    <comment type="block">/* This test does not depend on secret data */</comment>
    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>^</operator> <name>MBEDTLS_RSA_CRYPT</name></expr>;</expr_stmt>

        <comment type="block">/* Get padding len, but always read till end of buffer
         * (minus one, for the 00 byte) */</comment>
        <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ilen</name> <operator>-</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
        <block>{<block_content>
            <expr_stmt><expr><name>pad_done</name>  <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>-</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pad_count</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>pad_done</name> <operator>|</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>-</operator><name>pad_done</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>pad_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Must be zero */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>^</operator> <name>MBEDTLS_RSA_SIGN</name></expr>;</expr_stmt>

        <comment type="block">/* Get padding len, but always read till end of buffer
         * (minus one, for the 00 byte) */</comment>
        <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ilen</name> <operator>-</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
        <block>{<block_content>
            <expr_stmt><expr><name>pad_done</name> <operator>|=</operator> <operator>(</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0xFF</literal> <operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pad_count</name> <operator>+=</operator> <operator>(</operator> <name>pad_done</name> <operator>==</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>pad_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Must be zero */</comment>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>(</operator> <name>pad_count</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bad</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>-</operator> <operator>(</operator> <name>p</name> <operator>-</operator> <name>buf</name> <operator>)</operator> <operator>&gt;</operator> <name>output_max_len</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>ilen</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>output</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>olen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>

<comment type="block">/*
 * Do an RSA operation, then remove the message padding
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_pkcs1_decrypt</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                       <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                       <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,
                       <parameter><decl><type><name>size_t</name></type> <name>output_max_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name></expr> )</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V15</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsaes_pkcs1_v15_decrypt</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>,
                                                <argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>output_max_len</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V21</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsaes_oaep_decrypt</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>olen</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>,
                                           <argument><expr><name>output_max_len</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSASSA-PSS-SIGN function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsassa_pss_sign</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                         <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                         <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                         <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                         <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                         <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>olen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>sig</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>salt</name><index>[<expr><name>MBEDTLS_MD_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl>, <decl><type ref="prev"/><name>hlen</name></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>msb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_md_info_t</name> <modifier>*</modifier></type><name>md_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_md_context_t</name></type> <name>md_ctx</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V21</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>olen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>md_alg</name> <operator>!=</operator> <name>MBEDTLS_MD_NONE</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* Gather length of hash to sign */</comment>
        <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><name>md_alg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>hashlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><operator>(</operator><name>mbedtls_md_type_t</name><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hash_id</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>hlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slen</name> <operator>=</operator> <name>hlen</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>olen</name> <operator>&lt;</operator> <name>hlen</name> <operator>+</operator> <name>slen</name> <operator>+</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>sig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>olen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate salt of length slen */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>f_rng</name><argument_list>( <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>slen</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_RNG_FAILED</name> <operator>+</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Note: EMSA-PSS encoding is over the length of N - 1 bits */</comment>
    <expr_stmt><expr><name>msb</name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>olen</name> <operator>-</operator> <name>hlen</name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>slen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_md_setup</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>md_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate H = Hash( M' ) */</comment>
    <expr_stmt><expr><call><name>mbedtls_md_starts</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>slen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_finish</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compensate for boundary condition when applying mask */</comment>
    <if_stmt><if>if<condition>( <expr><name>msb</name> <operator>%</operator> <literal type="number">8</literal> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* maskedDB: Apply dbMask to DB */</comment>
    <expr_stmt><expr><call><name>mgf_mask</name><argument_list>( <argument><expr><name>sig</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>olen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>msb</name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sig</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0xFF</literal> <operator>&gt;&gt;</operator> <operator>(</operator> <name>olen</name> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <name>msb</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>hlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0xBC</literal></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
            ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call></expr>
            </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call></expr></else></ternary> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V21 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-V1_5-SIGN function
 */</comment>
<comment type="block">/*
 * Do an RSA operation to sign the message digest
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsassa_pkcs1_v15_sign</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                               <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                               <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                               <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nb_pad</name></decl>, <decl><type ref="prev"/><name>olen</name></decl>, <decl><type ref="prev"/><name>oid_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>sig</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig_try</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>verif</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name></type> <name>diff_no_optimize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V15</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>olen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nb_pad</name> <operator>=</operator> <name>olen</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>md_alg</name> <operator>!=</operator> <name>MBEDTLS_MD_NONE</name></expr> )</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_md_info_t</name> <modifier>*</modifier></type><name>md_info</name> <init>= <expr><call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><name>md_alg</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_oid_get_oid_by_md</name><argument_list>( <argument><expr><name>md_alg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_size</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>nb_pad</name> <operator>-=</operator> <literal type="number">10</literal> <operator>+</operator> <name>oid_size</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>hashlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nb_pad</name> <operator>-=</operator> <name>hashlen</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>nb_pad</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>)</operator> <operator>||</operator> <operator>(</operator> <name>nb_pad</name> <operator>&gt;</operator> <name>olen</name> <operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_RSA_SIGN</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>nb_pad</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nb_pad</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>md_alg</name> <operator>==</operator> <name>MBEDTLS_MD_NONE</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * DigestInfo ::= SEQUENCE {
         *   digestAlgorithm DigestAlgorithmIdentifier,
         *   digest Digest }
         *
         * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
         *
         * Digest ::= OCTET STRING
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_ASN1_SEQUENCE</name> <operator>|</operator> <name>MBEDTLS_ASN1_CONSTRUCTED</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator> <literal type="number">0x08</literal> <operator>+</operator> <name>oid_size</name> <operator>+</operator> <name>hashlen</name> <operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_ASN1_SEQUENCE</name> <operator>|</operator> <name>MBEDTLS_ASN1_CONSTRUCTED</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator> <literal type="number">0x04</literal> <operator>+</operator> <name>oid_size</name> <operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_ASN1_OID</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>oid_size</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid_size</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>oid_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_ASN1_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_ASN1_OCTET_STRING</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>hashlen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * In order to prevent Lenstra's attack, make the signature in a
     * temporary buffer and check it before returning it.
     */</comment>
    <expr_stmt><expr><name>sig_try</name> <operator>=</operator> <call><name>mbedtls_calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sig_try</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_MPI_ALLOC_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>verif</name>   <operator>=</operator> <call><name>mbedtls_calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>verif</name> <operator>==</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>sig_try</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_MPI_ALLOC_FAILED</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig_try</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_rsa_public</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sig_try</name></expr></argument>, <argument><expr><name>verif</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compare in constant time just in case */</comment>
    <for>for<control>( <init><expr><name>diff</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>diff</name> <operator>|=</operator> <name><name>verif</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name><name>sig</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>diff_no_optimize</name> <operator>=</operator> <name>diff</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>diff_no_optimize</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_RSA_PRIVATE_FAILED</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig_try</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>sig_try</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>verif</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>

<comment type="block">/*
 * Do an RSA operation to sign the message digest
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_pkcs1_sign</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                    <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                    <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                    <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <switch>switch<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name></expr> )</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V15</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsassa_pkcs1_v15_sign</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>md_alg</name></expr></argument>,
                                              <argument><expr><name>hashlen</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V21</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsassa_pss_sign</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>md_alg</name></expr></argument>,
                                        <argument><expr><name>hashlen</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSASSA-PSS-VERIFY function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsassa_pss_verify_ext</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                               <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                               <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                               <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                               <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>mgf1_hash_id</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>expected_salt_len</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>siglen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>result</name><index>[<expr><name>MBEDTLS_MD_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zeros</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>slen</name></decl>, <decl><type ref="prev"/><name>msb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_md_info_t</name> <modifier>*</modifier></type><name>md_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_md_context_t</name></type> <name>md_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_MPI_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V21</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>siglen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>siglen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">16</literal> <operator>||</operator> <name>siglen</name></expr></argument> &gt;</argument_list></name> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
          ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>
          </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>buf</name><index>[<expr><name>siglen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0xBC</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>md_alg</name> <operator>!=</operator> <name>MBEDTLS_MD_NONE</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* Gather length of hash to sign */</comment>
        <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><name>md_alg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>hashlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><name>mgf1_hash_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>hlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slen</name> <operator>=</operator> <name>siglen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Currently length of salt + padding */</comment>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>zeros</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: EMSA-PSS verification is over the length of N - 1 bits
     */</comment>
    <expr_stmt><expr><name>msb</name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Compensate for boundary condition when applying mask */</comment>
    <if_stmt><if>if<condition>( <expr><name>msb</name> <operator>%</operator> <literal type="number">8</literal> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>siglen</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator> <literal type="number">8</literal> <operator>-</operator> <name>siglen</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <name>msb</name> <operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_md_setup</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>md_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mgf_mask</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>siglen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>siglen</name> <operator>-</operator> <name>hlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0xFF</literal> <operator>&gt;&gt;</operator> <operator>(</operator> <name>siglen</name> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <name>msb</name> <operator>)</operator></expr>;</expr_stmt>

    <while>while<condition>( <expr><name>p</name> <operator>&lt;</operator> <name>buf</name> <operator>+</operator> <name>siglen</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>==</operator> <name>buf</name> <operator>+</operator> <name>siglen</name> <operator>||</operator>
        <operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="number">0x01</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Actual salt len */</comment>
    <expr_stmt><expr><name>slen</name> <operator>-=</operator> <name>p</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>expected_salt_len</name> <operator>!=</operator> <name>MBEDTLS_RSA_SALT_LEN_ANY</name> <operator>&amp;&amp;</operator>
        <name>slen</name> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>expected_salt_len</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Generate H = Hash( M' )
     */</comment>
    <expr_stmt><expr><call><name>mbedtls_md_starts</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>zeros</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_update</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>slen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_md_finish</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mbedtls_md_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>md_ctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>( <argument><expr><name>p</name> <operator>+</operator> <name>slen</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>hlen</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Simplified PKCS#1 v2.1 RSASSA-PSS-VERIFY function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsassa_pss_verify</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                           <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                           <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                           <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                           <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mbedtls_md_type_t</name></type> <name>mgf1_hash_id</name> <init>= <expr><ternary><condition><expr><operator>(</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hash_id</name></name> <operator>!=</operator> <name>MBEDTLS_MD_NONE</name> <operator>)</operator></expr>
                             ?</condition><then> <expr><operator>(</operator><name>mbedtls_md_type_t</name><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hash_id</name></name></expr>
                             </then><else>: <expr><name>md_alg</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <return>return<expr><operator>(</operator> <call><name>mbedtls_rsa_rsassa_pss_verify_ext</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>,
                                       <argument><expr><name>md_alg</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>,
                                       <argument><expr><name>mgf1_hash_id</name></expr></argument>, <argument><expr><name>MBEDTLS_RSA_SALT_LEN_ANY</name></expr></argument>,
                                       <argument><expr><name>sig</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V21 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-v1_5-VERIFY function
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_rsassa_pkcs1_v15_verify</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                 <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                                 <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                                 <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>siglen</name></decl>, <decl><type ref="prev"/><name>asn1_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_md_type_t</name></type> <name>msg_md_alg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_md_info_t</name> <modifier>*</modifier></type><name>md_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_asn1_buf</name></type> <name>oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MBEDTLS_MPI_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PRIVATE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name> <operator>!=</operator> <name>MBEDTLS_RSA_PKCS_V15</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>siglen</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>siglen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">16</literal> <operator>||</operator> <name>siglen</name></expr></argument> &gt;</argument_list></name> <sizeof>sizeof<argument_list>( <argument><expr><name>buf</name></expr></argument> )</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name>mode</name> <operator>==</operator> <name>MBEDTLS_RSA_PUBLIC</name> <operator>)</operator></expr>
          ?</condition><then> <expr><call><name>mbedtls_rsa_public</name><argument_list>(  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr>
          </then><else>: <expr><call><name>mbedtls_rsa_private</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>buf</name></expr></argument> )</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <name>MBEDTLS_RSA_SIGN</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <while>while<condition>( <expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&gt;=</operator> <name>buf</name> <operator>+</operator> <name>siglen</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0xFF</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>siglen</name> <operator>-</operator> <operator>(</operator> <name>p</name> <operator>-</operator> <name>buf</name> <operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>len</name> <operator>==</operator> <name>hashlen</name> <operator>&amp;&amp;</operator> <name>md_alg</name> <operator>==</operator> <name>MBEDTLS_MD_NONE</name></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>md_info</name> <operator>=</operator> <call><name>mbedtls_md_info_from_type</name><argument_list>( <argument><expr><name>md_alg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>md_info</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hashlen</name> <operator>=</operator> <call><name>mbedtls_md_get_size</name><argument_list>( <argument><expr><name>md_info</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Parse the ASN.1 structure inside the PKCS#1 v1.5 structure
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asn1_len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>asn1_len</name> <operator>+</operator> <literal type="number">2</literal> <operator>!=</operator> <name>len</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asn1_len</name></expr></argument>,
            <argument><expr><name>MBEDTLS_ASN1_CONSTRUCTED</name> <operator>|</operator> <name>MBEDTLS_ASN1_SEQUENCE</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>asn1_len</name> <operator>+</operator> <literal type="number">6</literal> <operator>+</operator> <name>hashlen</name> <operator>!=</operator> <name>len</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oid</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OID</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>oid</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>oid</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_oid_get_md_alg</name><argument_list>( <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_md_alg</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>md_alg</name> <operator>!=</operator> <name>msg_md_alg</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * assume the algorithm parameters must be NULL
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asn1_len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_NULL</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_asn1_get_tag</name><argument_list>( <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asn1_len</name></expr></argument>, <argument><expr><name>MBEDTLS_ASN1_OCTET_STRING</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>asn1_len</name> <operator>!=</operator> <name>hashlen</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>( <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashlen</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>hashlen</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>!=</operator> <name>end</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_VERIFY_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>

<comment type="block">/*
 * Do an RSA operation and check the message digest
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_pkcs1_verify</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                      <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                      <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>,
                      <parameter><decl><type><name>mbedtls_md_type_t</name></type> <name>md_alg</name></decl></parameter>,
                      <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashlen</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <switch>switch<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>padding</name></name></expr> )</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V15</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsassa_pkcs1_v15_verify</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>md_alg</name></expr></argument>,
                                                <argument><expr><name>hashlen</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V21</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <case>case <expr><name>MBEDTLS_RSA_PKCS_V21</name></expr>:</case>
            <return>return <expr><call><name>mbedtls_rsa_rsassa_pss_verify</name><argument_list>( <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>md_alg</name></expr></argument>,
                                          <argument><expr><name>hashlen</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>sig</name></expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_RSA_INVALID_PADDING</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the components of an RSA key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_copy</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>src</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>ver</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>ver</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>E</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>E</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>D</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>D</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>DP</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>DP</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>QP</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>QP</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>RN</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>RN</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>RP</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>RP</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>RQ</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>RQ</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>padding</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>padding</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>hash_id</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>hash_id</name></name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_rsa_free</name><argument_list>( <argument><expr><name>dst</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free the components of an RSA key
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_rsa_free</name><parameter_list>( <parameter><decl><type><name>mbedtls_rsa_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vi</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Vf</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RQ</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RP</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>RN</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>QP</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DQ</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>DP</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>P</name></name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>D</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>E</name></name></expr></argument>  )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>N</name></name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_THREADING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>mbedtls_mutex_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Example RSA-1024 keypair, for test purposes
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_N</name></cpp:macro>   <cpp:value>"9292758453063D803DD603D5E777D788" \
                "8ED1D5BF35786190FA2F23EBC0848AEA" \
                "DDA92CA6C3D80B32C4D109BE0F36D6AE" \
                "7130B9CED7ACDF54CFC7555AC14EEBAB" \
                "93A89813FBF3C4F8066D2D800F7C38A8" \
                "1AE31942917403FF4946B0A83D3D3E05" \
                "EE57C6F5F5606FB5D4BC6CD34EE0801A" \
                "5E94BB77B07507233A0BC7BAC8F90F79"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_E</name></cpp:macro>   <cpp:value>"10001"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_D</name></cpp:macro>   <cpp:value>"24BF6185468786FDD303083D25E64EFC" \
                "66CA472BC44D253102F8B4A9D3BFA750" \
                "91386C0077937FE33FA3252D28855837" \
                "AE1B484A8A9A45F7EE8C0C634F99E8CD" \
                "DF79C5CE07EE72C7F123142198164234" \
                "CABB724CF78B8173B9F880FC86322407" \
                "AF1FEDFDDE2BEB674CA15F3E81A1521E" \
                "071513A1E85B5DFA031F21ECAE91A34D"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_P</name></cpp:macro>   <cpp:value>"C36D0EB7FCD285223CFB5AABA5BDA3D8" \
                "2C01CAD19EA484A87EA4377637E75500" \
                "FCB2005C5C7DD6EC4AC023CDA285D796" \
                "C3D9E75E1EFC42488BB4F1D13AC30A57"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_Q</name></cpp:macro>   <cpp:value>"C000DF51A7C77AE8D7C7370C1FF55B69" \
                "E211C2B9E5DB1ED0BF61D0D9899620F4" \
                "910E4168387E3C30AA1E00C339A79508" \
                "8452DD96A9A5EA5D9DCA68DA636032AF"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_DP</name></cpp:macro>  <cpp:value>"C1ACF567564274FB07A0BBAD5D26E298" \
                "3C94D22288ACD763FD8E5600ED4A702D" \
                "F84198A5F06C2E72236AE490C93F07F8" \
                "3CC559CD27BC2D1CA488811730BB5725"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_DQ</name></cpp:macro>  <cpp:value>"4959CBF6F8FEF750AEE6977C155579C7" \
                "D8AAEA56749EA28623272E4F7D0592AF" \
                "7C1F1313CAC9471B5C523BFE592F517B" \
                "407A1BD76C164B93DA2D32A383E58357"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_QP</name></cpp:macro>  <cpp:value>"9AE7FBC99546432DF71896FC239EADAE" \
                "F38D18D2B2F0E2DD275AA977E2BF4411" \
                "F5A3B2A5D33605AEBBCCBA7FEB9F2D2F" \
                "A74206CEC169D74BF5A8C50D6F48EA08"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PT_LEN</name></cpp:macro>  <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSA_PT</name></cpp:macro>  <cpp:value>"\xAA\xBB\xCC\x03\x02\x01\x00\xFF\xFF\xFF\xFF\xFF" \
                "\x11\x22\x33\x0A\x0B\x0C\xCC\xDD\xDD\xDD\xDD\xDD"</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>myrand</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rng_state</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>rng_state</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rng_state</name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rand</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if<condition>( <expr><name>rng_state</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rng_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>arc4random_buf</name><argument_list>( <argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !OpenBSD */</comment>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>

<comment type="block">/*
 * Checkup routine
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_rsa_self_test</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PKCS1_V15</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_rsa_context</name></type> <name>rsa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>rsa_plaintext</name><index>[<expr><name>PT_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>rsa_decrypted</name><index>[<expr><name>PT_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>rsa_ciphertext</name><index>[<expr><name>KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SHA1_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>sha1sum</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>mbedtls_rsa_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument>, <argument><expr><name>MBEDTLS_RSA_PKCS_V15</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rsa</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>KEY_LEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>N</name></name></expr></argument> , <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_N</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>E</name></name></expr></argument> , <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_E</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>D</name></name></expr></argument> , <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_D</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>P</name></name></expr></argument> , <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_P</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>Q</name></name></expr></argument> , <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_Q</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>DP</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_DP</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>DQ</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_DQ</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>rsa</name><operator>.</operator><name>QP</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>RSA_QP</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  RSA key validation: "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_rsa_check_pubkey</name><argument_list>(  <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_rsa_check_privkey</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n  PKCS#1 encryption : "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>( <argument><expr><name>rsa_plaintext</name></expr></argument>, <argument><expr><name>RSA_PT</name></expr></argument>, <argument><expr><name>PT_LEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_rsa_pkcs1_encrypt</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument>, <argument><expr><name>myrand</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>MBEDTLS_RSA_PUBLIC</name></expr></argument>, <argument><expr><name>PT_LEN</name></expr></argument>,
                           <argument><expr><name>rsa_plaintext</name></expr></argument>, <argument><expr><name>rsa_ciphertext</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n  PKCS#1 decryption : "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_rsa_pkcs1_decrypt</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument>, <argument><expr><name>myrand</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>MBEDTLS_RSA_PRIVATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,
                           <argument><expr><name>rsa_ciphertext</name></expr></argument>, <argument><expr><name>rsa_decrypted</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rsa_decrypted</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>( <argument><expr><name>rsa_decrypted</name></expr></argument>, <argument><expr><name>rsa_plaintext</name></expr></argument>, <argument><expr><name>len</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SHA1_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  PKCS#1 data sign  : "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_sha1</name><argument_list>( <argument><expr><name>rsa_plaintext</name></expr></argument>, <argument><expr><name>PT_LEN</name></expr></argument>, <argument><expr><name>sha1sum</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_rsa_pkcs1_sign</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument>, <argument><expr><name>myrand</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>MBEDTLS_RSA_PRIVATE</name></expr></argument>, <argument><expr><name>MBEDTLS_MD_SHA1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><name>sha1sum</name></expr></argument>, <argument><expr><name>rsa_ciphertext</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n  PKCS#1 sig. verify: "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_rsa_pkcs1_verify</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>MBEDTLS_RSA_PUBLIC</name></expr></argument>, <argument><expr><name>MBEDTLS_MD_SHA1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                          <argument><expr><name>sha1sum</name></expr></argument>, <argument><expr><name>rsa_ciphertext</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_SHA1_C */</comment>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_rsa_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>rsa</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>verbose</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_PKCS1_V15 */</comment>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_SELF_TEST */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_RSA_C */</comment>
</unit>
