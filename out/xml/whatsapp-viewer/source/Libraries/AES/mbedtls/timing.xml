<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/AES/mbedtls/timing.c"><comment type="block">/*
 *  Portable interface to the CPU cycle counter
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_CONFIG_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> MBEDTLS_CONFIG_FILE</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PLATFORM_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_printf</name></cpp:macro>     <cpp:value>printf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TIMING_C</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timing.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_TIMING_ALT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>unix</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__unix</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"This module only works on Unix and Windows, see MBEDTLS_TIMING_C in config.h"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>asm</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>asm</name></cpp:macro> <cpp:value>__asm</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EFIX64</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EFI32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winbase.h&gt;</cpp:file></cpp:include>

<struct>struct <name>_hr_time</name>
<block>{
    <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>start</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<struct>struct <name>_hr_time</name>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _WIN32 &amp;&amp; !EFIX64 &amp;&amp; !EFI32 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  \
    <operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call> <operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tsc</name></decl>;</decl_stmt>
    <asm>__asm   rdtsc</asm>
    <asm>__asm   mov  [tsc], eax</asm>
    <return>return<expr><operator>(</operator> <name>tsc</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          ( _MSC_VER &amp;&amp; _M_IX86 ) || __WATCOMC__ */</comment>

<comment type="block">/* some versions of mingw-64 have 32-bit longs even on x84_64 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator>                       \
    <operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>( <argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>)</operator> <operator>&amp;&amp;</operator> <name>__SIZEOF_LONG__</name> <operator>==</operator> <literal type="number">4</literal> <operator>)</operator> <operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>;</decl_stmt>
    <asm>asm <specifier>volatile</specifier>( "rdtsc" : "=a" (lo), "=d" (hi) );</asm>
    <return>return<expr><operator>(</operator> <name>lo</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; __i386__ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>;</decl_stmt>
    <asm>asm <specifier>volatile</specifier>( "rdtsc" : "=a" (lo), "=d" (hi) );</asm>
    <return>return<expr><operator>(</operator> <name>lo</name> <operator>|</operator> <operator>(</operator> <name>hi</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>)</operator> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; ( __amd64__ || __x86_64__ ) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tbl</name></decl>, <decl><type ref="prev"/><name>tbu0</name></decl>, <decl><type ref="prev"/><name>tbu1</name></decl>;</decl_stmt>

    <do>do
    <block>{<block_content>
        <asm>asm <specifier>volatile</specifier>( "mftbu %0" : "=r" (tbu0) );</asm>
        <asm>asm <specifier>volatile</specifier>( "mftb  %0" : "=r" (tbl ) );</asm>
        <asm>asm <specifier>volatile</specifier>( "mftbu %0" : "=r" (tbu1) );</asm>
    </block_content>}</block>
    while<condition>( <expr><name>tbu0</name> <operator>!=</operator> <name>tbu1</name></expr> )</condition>;</do>

    <return>return<expr><operator>(</operator> <name>tbl</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; ( __powerpc__ || __ppc__ ) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:warning>#<cpp:directive>warning</cpp:directive> OpenBSD does not allow access to tick register using software version instead</cpp:warning>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tick</name></decl>;</decl_stmt>
    <asm>asm <specifier>volatile</specifier>( "rdpr %%tick, %0;" : "=&amp;r" (tick) );</asm>
    <return>return<expr><operator>(</operator> <name>tick</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __OpenBSD__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; __sparc64__ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sparc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tick</name></decl>;</decl_stmt>
    <asm>asm <specifier>volatile</specifier>( ".byte 0x83, 0x41, 0x00, 0x00" );</asm>
    <asm>asm <specifier>volatile</specifier>( "mov   %%g1, %0" : "=r" (tick) );</asm>
    <return>return<expr><operator>(</operator> <name>tick</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; __sparc__ &amp;&amp; !__sparc64__ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>      \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__alpha__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>cc</name></decl>;</decl_stmt>
    <asm>asm <specifier>volatile</specifier>( "rpcc %0" : "=r" (cc) );</asm>
    <return>return<expr><operator>(</operator> <name>cc</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; __alpha__ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_HAVE_ASM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>      \
    <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>itc</name></decl>;</decl_stmt>
    <asm>asm <specifier>volatile</specifier>( "mov %0 = ar.itc" : "=r" (itc) );</asm>
    <return>return<expr><operator>(</operator> <name>itc</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; MBEDTLS_HAVE_ASM &amp;&amp;
          __GNUC__ &amp;&amp; __ia64__ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EFIX64</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EFI32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>( <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator> <name><name>offset</name><operator>.</operator><name>QuadPart</name></name> <operator>)</operator> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK &amp;&amp; _MSC_VER &amp;&amp; !EFIX64 &amp;&amp; !EFI32 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HARDCLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_HARDCLOCK</name></cpp:macro></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>hardclock_init</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>tv_init</name></decl>;</decl_stmt>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_hardclock</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv_cur</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>hardclock_init</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>gettimeofday</name><argument_list>( <argument><expr><operator>&amp;</operator><name>tv_init</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hardclock_init</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>( <argument><expr><operator>&amp;</operator><name>tv_cur</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return<expr><operator>(</operator> <operator>(</operator> <name><name>tv_cur</name><operator>.</operator><name>tv_sec</name></name>  <operator>-</operator> <name><name>tv_init</name><operator>.</operator><name>tv_sec</name></name>  <operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal>
          <operator>+</operator> <operator>(</operator> <name><name>tv_cur</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>tv_init</name><operator>.</operator><name>tv_usec</name></name> <operator>)</operator> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_HARDCLOCK */</comment>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>mbedtls_timing_alarmed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EFIX64</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EFI32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_get_timer</name><parameter_list>( <parameter><decl><type><name><name>struct</name> <name>mbedtls_timing_hr_time</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reset</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>delta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>hfreq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>_hr_time</name></name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator>struct <name>_hr_time</name> <operator>*</operator><operator>)</operator> <name>val</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>(  <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>QueryPerformanceFrequency</name><argument_list>( <argument><expr><operator>&amp;</operator><name>hfreq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator> <operator>(</operator> <literal type="number">1000</literal> <operator>*</operator>
        <operator>(</operator> <name><name>offset</name><operator>.</operator><name>QuadPart</name></name> <operator>-</operator> <name><name>t</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>QuadPart</name></name> <operator>)</operator> <operator>)</operator> <operator>/</operator>
           <name><name>hfreq</name><operator>.</operator><name>QuadPart</name></name> <operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>reset</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>start</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>delta</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* It's OK to use a global because alarm() is supposed to be global anyway */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>DWORD</name></type> <name>alarmMs</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>DWORD</name> <name>WINAPI</name></type> <name>TimerProc</name><parameter_list>( <parameter><decl><type><name>LPVOID</name></type> <name>TimerContext</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>TimerContext</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sleep</name><argument_list>( <argument><expr><name>alarmMs</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mbedtls_timing_alarmed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return<expr><operator>(</operator> <name>TRUE</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mbedtls_set_alarm</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>ThreadId</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mbedtls_timing_alarmed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>alarmMs</name> <operator>=</operator> <name>seconds</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>( <argument><expr><call><name>CreateThread</name><argument_list>( <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TimerProc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ThreadId</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* _WIN32 &amp;&amp; !EFIX64 &amp;&amp; !EFI32 */</comment>

<function><type><name>unsigned</name> <name>long</name></type> <name>mbedtls_timing_get_timer</name><parameter_list>( <parameter><decl><type><name><name>struct</name> <name>mbedtls_timing_hr_time</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reset</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>delta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>_hr_time</name></name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator>struct <name>_hr_time</name> <operator>*</operator><operator>)</operator> <name>val</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>( <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>reset</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>tv_sec</name></name>  <operator>=</operator> <name><name>offset</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>offset</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator> <name><name>offset</name><operator>.</operator><name>tv_sec</name></name>  <operator>-</operator> <name><name>t</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>tv_sec</name></name>  <operator>)</operator> <operator>*</operator> <literal type="number">1000</literal>
          <operator>+</operator> <operator>(</operator> <name><name>offset</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>t</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>tv_usec</name></name> <operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>delta</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sighandler</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>mbedtls_timing_alarmed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signal</name><argument_list>( <argument><expr><name>signum</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mbedtls_set_alarm</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>mbedtls_timing_alarmed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signal</name><argument_list>( <argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alarm</name><argument_list>( <argument><expr><name>seconds</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _WIN32 &amp;&amp; !EFIX64 &amp;&amp; !EFI32 */</comment>

<comment type="block">/*
 * Set delays to watch
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_timing_set_delay</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>int_ms</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>fin_ms</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mbedtls_timing_delay_context</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>mbedtls_timing_delay_context</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>int_ms</name></name> <operator>=</operator> <name>int_ms</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fin_ms</name></name> <operator>=</operator> <name>fin_ms</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>fin_ms</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mbedtls_timing_get_timer</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get number of delays expired
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_timing_get_delay</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mbedtls_timing_delay_context</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>mbedtls_timing_delay_context</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>elapsed_ms</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>-&gt;</operator><name>fin_ms</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <operator>-</operator><literal type="number">1</literal> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>elapsed_ms</name> <operator>=</operator> <call><name>mbedtls_timing_get_timer</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>elapsed_ms</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>fin_ms</name></name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <literal type="number">2</literal> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>elapsed_ms</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>int_ms</name></name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !MBEDTLS_TIMING_ALT */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
 * Busy-waits for the given number of milliseconds.
 * Used for testing mbedtls_timing_hardclock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>busy_msleep</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>msec</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>mbedtls_timing_hr_time</name></name></type> <name>hires</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* for busy-waiting */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>long</name></type> <name>j</name></decl>;</decl_stmt> <comment type="block">/* to prevent optimisation */</comment>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mbedtls_timing_get_timer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>hires</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>( <expr><call><name>mbedtls_timing_get_timer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>hires</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>&lt;</operator> <name>msec</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAIL</name></cpp:macro>    <cpp:value>do                      \
{                                       \
    if( verbose != 0 )                  \
        mbedtls_printf( "failed\n" );   \
                                        \
    return( 1 );                        \
} while( 0 )</cpp:value></cpp:define>

<comment type="block">/*
 * Checkup routine
 *
 * Warning: this is work in progress, some tests may not be reliable enough
 * yet! False positives may happen.
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_timing_self_test</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>cycles</name></decl>, <decl><type ref="prev"/><name>ratio</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>millisecs</name></decl>, <decl><type ref="prev"/><name>secs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hardfail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>mbedtls_timing_hr_time</name></name></type> <name>hires</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_timing_delay_context</name></type> <name>ctx</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  TIMING tests note: will take some time!\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  TIMING test #1 (set_alarm / get_timer): "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for<control>( <init><expr><name>secs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>secs</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>secs</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mbedtls_timing_get_timer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>hires</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>mbedtls_set_alarm</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>secs</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><operator>!</operator><name>mbedtls_timing_alarmed</name></expr> )</condition><block type="pseudo"><block_content>
            <empty_stmt>;</empty_stmt></block_content></block></while>

        <expr_stmt><expr><name>millisecs</name> <operator>=</operator> <call><name>mbedtls_timing_get_timer</name><argument_list>( <argument><expr><operator>&amp;</operator><name>hires</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* For some reason on Windows it looks like alarm has an extra delay
         * (maybe related to creating a new thread). Allow some room here. */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>millisecs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">800</literal> <operator>*</operator> <name>secs</name> <operator>||</operator> <name>millisecs</name></expr></argument> &gt;</argument_list></name> <literal type="number">1200</literal> <operator>*</operator> <name>secs</name> <operator>+</operator> <literal type="number">300</literal></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <return>return<expr><operator>(</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  TIMING test #2 (set/get_delay        ): "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for<control>( <init><expr><name>a</name> <operator>=</operator> <literal type="number">200</literal></expr>;</init> <condition><expr><name>a</name> <operator>&lt;=</operator> <literal type="number">400</literal></expr>;</condition> <incr><expr><name>a</name> <operator>+=</operator> <literal type="number">200</literal></expr></incr> )</control>
    <block>{<block_content>
        <for>for<control>( <init><expr><name>b</name> <operator>=</operator> <literal type="number">200</literal></expr>;</init> <condition><expr><name>b</name> <operator>&lt;=</operator> <literal type="number">400</literal></expr>;</condition> <incr><expr><name>b</name> <operator>+=</operator> <literal type="number">200</literal></expr></incr> )</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mbedtls_timing_set_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name> <operator>+</operator> <name>b</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><name>a</name> <operator>-</operator> <name>a</name> <operator>/</operator> <literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>mbedtls_timing_get_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><name>a</name> <operator>/</operator> <literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>mbedtls_timing_get_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><name>b</name> <operator>-</operator> <name>a</name> <operator>/</operator> <literal type="number">8</literal> <operator>-</operator> <name>b</name> <operator>/</operator> <literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>mbedtls_timing_get_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><name>b</name> <operator>/</operator> <literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>mbedtls_timing_get_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>mbedtls_timing_set_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><literal type="number">200</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_timing_get_delay</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument> )</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  TIMING test #3 (hardclock / get_timer): "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Allow one failure for possible counter wrapping.
     * On a 4Ghz 32-bit machine the cycle counter wraps about once per second;
     * since the whole test is about 10ms, it shouldn't happen twice in a row.
     */</comment>
    <expr_stmt><expr><name>hardfail</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>hard_test</name>:</label>
    <if_stmt><if>if<condition>( <expr><name>hardfail</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed (ignored)\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <goto>goto <name>hard_test_done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get a reference ratio cycles/ms */</comment>
    <expr_stmt><expr><name>millisecs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cycles</name> <operator>=</operator> <call><name>mbedtls_timing_hardclock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><name>millisecs</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cycles</name> <operator>=</operator> <call><name>mbedtls_timing_hardclock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>cycles</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ratio</name> <operator>=</operator> <name>cycles</name> <operator>/</operator> <name>millisecs</name></expr>;</expr_stmt>

    <comment type="block">/* Check that the ratio is mostly constant */</comment>
    <for>for<control>( <init><expr><name>millisecs</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>millisecs</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>millisecs</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>cycles</name> <operator>=</operator> <call><name>mbedtls_timing_hardclock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>busy_msleep</name><argument_list>( <argument><expr><name>millisecs</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cycles</name> <operator>=</operator> <call><name>mbedtls_timing_hardclock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>cycles</name></expr>;</expr_stmt>

        <comment type="block">/* Allow variation up to 20% */</comment>
        <if_stmt><if>if<condition>( <expr><name>cycles</name> <operator>/</operator> <name><name>millisecs</name> <argument_list type="generic">&lt; <argument><expr><name>ratio</name> <operator>-</operator> <name>ratio</name> <operator>/</operator> <literal type="number">5</literal> <operator>||</operator>
            <name>cycles</name> <operator>/</operator> <name>millisecs</name></expr></argument> &gt;</argument_list></name> <name>ratio</name> <operator>+</operator> <name>ratio</name> <operator>/</operator> <literal type="number">5</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hardfail</name><operator>++</operator></expr>;</expr_stmt>
            <goto>goto <name>hard_test</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>hard_test_done</name>:</label>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_SELF_TEST */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_TIMING_C */</comment>
</unit>
