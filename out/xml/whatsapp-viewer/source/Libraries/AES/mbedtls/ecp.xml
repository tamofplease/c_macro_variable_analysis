<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/whatsapp-viewer/source/Libraries/AES/mbedtls/ecp.c"><comment type="block">/*
 *  Elliptic curves over GF(p): generic functions
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */</comment>

<comment type="block">/*
 * References:
 *
 * SEC1 http://www.secg.org/index.php?action=secg,docs_secg
 * GECC = Guide to Elliptic Curve Cryptography - Hankerson, Menezes, Vanstone
 * FIPS 186-3 http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
 * RFC 4492 for the related TLS structures and constants
 *
 * [Curve25519] http://cr.yp.to/ecdh/curve25519-20060209.pdf
 *
 * [2] CORON, Jean-S'ebastien. Resistance against differential power analysis
 *     for elliptic curve cryptosystems. In : Cryptographic Hardware and
 *     Embedded Systems. Springer Berlin Heidelberg, 1999. p. 292-302.
 *     &lt;http://link.springer.com/chapter/10.1007/3-540-48059-5_25&gt;
 *
 * [3] HEDABOU, Mustapha, PINEL, Pierre, et B'EN'ETEAU, Lucien. A comb method to
 *     render ECC resistant against Side Channel Attacks. IACR Cryptology
 *     ePrint Archive, 2004, vol. 2004, p. 342.
 *     &lt;http://eprint.iacr.org/2004/342.pdf&gt;
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_CONFIG_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> MBEDTLS_CONFIG_FILE</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_C</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_PLATFORM_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_printf</name></cpp:macro>     <cpp:value>printf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_calloc</name></cpp:macro>    <cpp:value>calloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mbedtls_free</name></cpp:macro>       <cpp:value>free</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARMCC_VERSION</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>)</operator> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><specifier>inline</specifier></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inline</name></cpp:macro> <cpp:value>__inline</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Implementation that should never be optimized out by the compiler */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mbedtls_zeroize</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter> )</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt> <while>while<condition>( <expr><name>n</name><operator>--</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Counts of point addition and doubling, and field multiplications.
 * Used to test resistance of point multiplication to simple timing attacks.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>add_count</name></decl>, <decl><type ref="prev"/><name>dbl_count</name></decl>, <decl><type ref="prev"/><name>mul_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP192R1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP224R1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP256R1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP384R1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP521R1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_BP256R1_ENABLED</name></expr></argument>)</argument_list></call>   <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_BP384R1_ENABLED</name></expr></argument>)</argument_list></call>   <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_BP512R1_ENABLED</name></expr></argument>)</argument_list></call>   <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP192K1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP224K1_ENABLED</name></expr></argument>)</argument_list></call> <operator>||</operator>   \
    <call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP256K1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECP_SHORTWEIERSTRASS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_CURVE25519_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECP_MONTGOMERY</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Curve types: internal for now, might be exposed later
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>ECP_TYPE_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
    <decl><name>ECP_TYPE_SHORT_WEIERSTRASS</name></decl>,    <comment type="block">/* y^2 = x^3 + a x + b      */</comment>
    <decl><name>ECP_TYPE_MONTGOMERY</name></decl>,           <comment type="block">/* y^2 = x^3 + a x^2 + x    */</comment>
}</block></enum></type> <name>ecp_curve_type</name>;</typedef>

<comment type="block">/*
 * List of supported curves:
 *  - internal ID
 *  - TLS NamedCurve ID (RFC 4492 sec. 5.1.1, RFC 7071 sec. 2)
 *  - size in bits
 *  - readable name
 *
 * Curves are listed in order: largest curves first, and for a given size,
 * fastest curves first. This provides the default order for the SSL module.
 *
 * Reminder: update profiles in x509_crt.c when adding a new curves!
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>mbedtls_ecp_curve_info</name></type> <name><name>ecp_supported_curves</name><index>[]</index></name> <init>=
<expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP521R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP521R1</name></expr>,    <expr><literal type="number">25</literal></expr>,     <expr><literal type="number">521</literal></expr>,    <expr><literal type="string">"secp521r1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_BP512R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_BP512R1</name></expr>,      <expr><literal type="number">28</literal></expr>,     <expr><literal type="number">512</literal></expr>,    <expr><literal type="string">"brainpoolP512r1"</literal></expr>   }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP384R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP384R1</name></expr>,    <expr><literal type="number">24</literal></expr>,     <expr><literal type="number">384</literal></expr>,    <expr><literal type="string">"secp384r1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_BP384R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_BP384R1</name></expr>,      <expr><literal type="number">27</literal></expr>,     <expr><literal type="number">384</literal></expr>,    <expr><literal type="string">"brainpoolP384r1"</literal></expr>   }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP256R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP256R1</name></expr>,    <expr><literal type="number">23</literal></expr>,     <expr><literal type="number">256</literal></expr>,    <expr><literal type="string">"secp256r1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP256K1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP256K1</name></expr>,    <expr><literal type="number">22</literal></expr>,     <expr><literal type="number">256</literal></expr>,    <expr><literal type="string">"secp256k1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_BP256R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_BP256R1</name></expr>,      <expr><literal type="number">26</literal></expr>,     <expr><literal type="number">256</literal></expr>,    <expr><literal type="string">"brainpoolP256r1"</literal></expr>   }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP224R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP224R1</name></expr>,    <expr><literal type="number">21</literal></expr>,     <expr><literal type="number">224</literal></expr>,    <expr><literal type="string">"secp224r1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP224K1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP224K1</name></expr>,    <expr><literal type="number">20</literal></expr>,     <expr><literal type="number">224</literal></expr>,    <expr><literal type="string">"secp224k1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP192R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP192R1</name></expr>,    <expr><literal type="number">19</literal></expr>,     <expr><literal type="number">192</literal></expr>,    <expr><literal type="string">"secp192r1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP192K1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_SECP192K1</name></expr>,    <expr><literal type="number">18</literal></expr>,     <expr><literal type="number">192</literal></expr>,    <expr><literal type="string">"secp192k1"</literal></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{ <expr><name>MBEDTLS_ECP_DP_NONE</name></expr>,          <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>,      <expr><name>NULL</name></expr>                }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECP_NB_CURVES</name></cpp:macro>   <cpp:value>sizeof( ecp_supported_curves ) /    \
                        sizeof( ecp_supported_curves[0] )</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>mbedtls_ecp_group_id</name></type> <name><name>ecp_supported_grp_id</name><index>[<expr><name>ECP_NB_CURVES</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * List of supported curves and associated info
 */</comment>
<function><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>mbedtls_ecp_curve_list</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <return>return<expr><operator>(</operator> <name>ecp_supported_curves</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * List of supported curves, group ID only
 */</comment>
<function><type><specifier>const</specifier> <name>mbedtls_ecp_group_id</name> <modifier>*</modifier></type><name>mbedtls_ecp_grp_id_list</name><parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>init_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator> <name>init_done</name></expr> )</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>curve_info</name></decl>;</decl_stmt>

        <for>for<control>( <init><expr><name>curve_info</name> <operator>=</operator> <call><name>mbedtls_ecp_curve_list</name><argument_list>()</argument_list></call></expr>;</init>
             <condition><expr><name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name> <operator>!=</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr>;</condition>
             <incr><expr><name>curve_info</name><operator>++</operator></expr></incr> )</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ecp_supported_grp_id</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>ecp_supported_grp_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>init_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ecp_supported_grp_id</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the curve info for the internal identifier
 */</comment>
<function><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>mbedtls_ecp_curve_info_from_grp_id</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group_id</name></type> <name>grp_id</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>curve_info</name></decl>;</decl_stmt>

    <for>for<control>( <init><expr><name>curve_info</name> <operator>=</operator> <call><name>mbedtls_ecp_curve_list</name><argument_list>()</argument_list></call></expr>;</init>
         <condition><expr><name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name> <operator>!=</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr>;</condition>
         <incr><expr><name>curve_info</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name> <operator>==</operator> <name>grp_id</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>curve_info</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return<expr><operator>(</operator> <name>NULL</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the curve info from the TLS identifier
 */</comment>
<function><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>mbedtls_ecp_curve_info_from_tls_id</name><parameter_list>( <parameter><decl><type><name>uint16_t</name></type> <name>tls_id</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>curve_info</name></decl>;</decl_stmt>

    <for>for<control>( <init><expr><name>curve_info</name> <operator>=</operator> <call><name>mbedtls_ecp_curve_list</name><argument_list>()</argument_list></call></expr>;</init>
         <condition><expr><name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name> <operator>!=</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr>;</condition>
         <incr><expr><name>curve_info</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>curve_info</name><operator>-&gt;</operator><name>tls_id</name></name> <operator>==</operator> <name>tls_id</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>curve_info</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return<expr><operator>(</operator> <name>NULL</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the curve info from the name
 */</comment>
<function><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>mbedtls_ecp_curve_info_from_name</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>curve_info</name></decl>;</decl_stmt>

    <for>for<control>( <init><expr><name>curve_info</name> <operator>=</operator> <call><name>mbedtls_ecp_curve_list</name><argument_list>()</argument_list></call></expr>;</init>
         <condition><expr><name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name> <operator>!=</operator> <name>MBEDTLS_ECP_DP_NONE</name></expr>;</condition>
         <incr><expr><name>curve_info</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>( <argument><expr><name><name>curve_info</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>curve_info</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return<expr><operator>(</operator> <name>NULL</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the type of a curve
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ecp_curve_type</name></type> <name>ecp_get_type</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>X</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ECP_TYPE_NONE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>Y</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ECP_TYPE_MONTGOMERY</name> <operator>)</operator></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ECP_TYPE_SHORT_WEIERSTRASS</name> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (the components of) a point
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_ecp_point_init</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pt</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (the components of) a group
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_ecp_group_init</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>grp</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_ecp_group</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (the components of) a key pair
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_ecp_keypair_init</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>key</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>key</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_group_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>grp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>d</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unallocate (the components of) a point
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_ecp_point_free</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pt</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator> <name><name>pt</name><operator>-&gt;</operator><name>X</name></name> <operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator> <name><name>pt</name><operator>-&gt;</operator><name>Y</name></name> <operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator> <name><name>pt</name><operator>-&gt;</operator><name>Z</name></name> <operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unallocate (the components of) a group
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_ecp_group_free</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>grp</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <literal type="number">1</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>B</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>T</name></name> <operator>!=</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>grp</name><operator>-&gt;</operator><name>T_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>T</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name><name>grp</name><operator>-&gt;</operator><name>T</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_zeroize</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_ecp_group</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unallocate (the components of) a key pair
 */</comment>
<function><type><name>void</name></type> <name>mbedtls_ecp_keypair_free</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>key</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>key</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_group_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>grp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>d</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>Q</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the contents of a point
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_copy</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the contents of a group object
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_group_copy</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>src</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>id</name></name></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set point to zero
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_set_zero</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument> , <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> , <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> , <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Tell if a point is zero
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_is_zero</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <return>return<expr><operator>(</operator> <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two points lazyly
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_point_cmp</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Import a non-zero point from ASCII strings
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_point_read_string</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>radix</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><name>x</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><name>y</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Export a point into unsigned binary data (SEC1 2.3.3)
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_point_write_binary</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>plen</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>format</name> <operator>!=</operator> <name>MBEDTLS_ECP_PF_UNCOMPRESSED</name> <operator>&amp;&amp;</operator>
        <name>format</name> <operator>!=</operator> <name>MBEDTLS_ECP_PF_COMPRESSED</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Common case: P == 0
     */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>buflen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>plen</name> <operator>=</operator> <call><name>mbedtls_mpi_size</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>format</name> <operator>==</operator> <name>MBEDTLS_ECP_PF_UNCOMPRESSED</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>plen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>buflen</name> <operator>&lt;</operator> <operator>*</operator><name>olen</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_write_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>plen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_write_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>plen</name></expr></argument>, <argument><expr><name>plen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>format</name> <operator>==</operator> <name>MBEDTLS_ECP_PF_COMPRESSED</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>plen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>buflen</name> <operator>&lt;</operator> <operator>*</operator><name>olen</name></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x02</literal> <operator>+</operator> <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_write_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>plen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Import a point from unsigned binary data (SEC1 2.3.4)
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_point_read_binary</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ilen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>plen</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x00</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <call><name>mbedtls_ecp_set_zero</name><argument_list>( <argument><expr><name>pt</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>plen</name> <operator>=</operator> <call><name>mbedtls_mpi_size</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x04</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>ilen</name> <operator>!=</operator> <literal type="number">2</literal> <operator>*</operator> <name>plen</name> <operator>+</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>plen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>plen</name></expr></argument>, <argument><expr><name>plen</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Import a point from a TLS ECPoint record (RFC 4492)
 *      struct {
 *          opaque point &lt;1..2^8-1&gt;;
 *      } ECPoint;
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_tls_read_point</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf_start</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We must have at least two bytes (1 for length, at least one for data)
     */</comment>
    <if_stmt><if>if<condition>( <expr><name>buf_len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>data_len</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>buf</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>data_len</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>data_len</name></expr></argument> &gt;</argument_list></name> <name>buf_len</name> <operator>-</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Save buffer start for read_binary and update buf
     */</comment>
    <expr_stmt><expr><name>buf_start</name> <operator>=</operator> <operator>*</operator><name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

    <return>return <expr><call><name>mbedtls_ecp_point_read_binary</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>buf_start</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Export a point as a TLS ECPoint record (RFC 4492)
 *      struct {
 *          opaque point &lt;1..2^8-1&gt;;
 *      } ECPoint;
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_tls_write_point</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>,
                         <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <comment type="block">/*
     * buffer length must be at least one, for our length byte
     */</comment>
    <if_stmt><if>if<condition>( <expr><name>blen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_point_write_binary</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
                    <argument><expr><name>olen</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>blen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * write length to the first byte and update total length
     */</comment>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>olen</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><operator>*</operator><name>olen</name></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set a group from an ECParameters record (RFC 4492)
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_tls_read_group</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>tls_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>curve_info</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We expect at least three bytes (see below)
     */</comment>
    <if_stmt><if>if<condition>( <expr><name>len</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * First byte is curve_type; only named_curve is handled
     */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><operator>(</operator><operator>*</operator><name>buf</name><operator>)</operator><operator>++</operator> <operator>!=</operator> <name>MBEDTLS_ECP_TLS_NAMED_CURVE</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Next two bytes are the namedcurve value
     */</comment>
    <expr_stmt><expr><name>tls_id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>buf</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>tls_id</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tls_id</name> <operator>|=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>buf</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>curve_info</name> <operator>=</operator> <call><name>mbedtls_ecp_curve_info_from_tls_id</name><argument_list>( <argument><expr><name>tls_id</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name><name>curve_info</name><operator>-&gt;</operator><name>grp_id</name></name></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write the ECParameters record corresponding to a group (RFC 4492)
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_tls_write_group</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>,
                         <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blen</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mbedtls_ecp_curve_info</name> <modifier>*</modifier></type><name>curve_info</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>curve_info</name> <operator>=</operator> <call><name>mbedtls_ecp_curve_info_from_grp_id</name><argument_list>( <argument><expr><name><name>grp</name><operator>-&gt;</operator><name>id</name></name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We are going to write 3 bytes (see below)
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>blen</name> <operator>&lt;</operator> <operator>*</operator><name>olen</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * First byte is curve_type, always named_curve
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>buf</name><operator>++</operator> <operator>=</operator> <name>MBEDTLS_ECP_TLS_NAMED_CURVE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Next two bytes are the namedcurve value
     */</comment>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>curve_info</name><operator>-&gt;</operator><name>tls_id</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>curve_info</name><operator>-&gt;</operator><name>tls_id</name></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wrapper around fast quasi-modp functions, with fall-back to mbedtls_mpi_mod_mpi.
 * See the documentation of struct mbedtls_ecp_group.
 *
 * This function is in the critial loop for mbedtls_ecp_mul, so pay attention to perf.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_modp</name><parameter_list>( <parameter><decl><type><name>mbedtls_mpi</name> <modifier>*</modifier></type><name>N</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>modp</name></name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>mbedtls_mpi_mod_mpi</name><argument_list>( <argument><expr><name>N</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* N-&gt;s &lt; 0 is a much faster test, which fails only if N is 0 */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name><name>N</name><operator>-&gt;</operator><name>s</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>)</operator> <operator>||</operator>
        <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><name>N</name></expr></argument> )</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>grp</name><operator>-&gt;</operator><name>pbits</name></name></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name><name>grp</name><operator>-&gt;</operator><name>modp</name></name><argument_list>( <argument><expr><name>N</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* N-&gt;s &lt; 0 is a much faster test, which fails only if N is 0 */</comment>
    <while>while<condition>( <expr><name><name>N</name><operator>-&gt;</operator><name>s</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><name>N</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <while>while<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <comment type="block">/* we known P, N and the result are positive */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_abs</name><argument_list>( <argument><expr><name>N</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fast mod-p functions expect their argument to be in the 0..p^2 range.
 *
 * In order to guarantee that, we need to ensure that operands of
 * mbedtls_mpi_mul_mpi are in the 0..p range. So, after each operation we will
 * bring the result back to this range.
 *
 * The following macros are shortcuts for doing that.
 */</comment>

<comment type="block">/*
 * Reduce a mbedtls_mpi mod p in-place, general case, to use after mbedtls_mpi_mul_mpi
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INC_MUL_COUNT</name></cpp:macro>   <cpp:value>mul_count++;</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INC_MUL_COUNT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD_MUL</name><parameter_list>( <parameter><type><name>N</name></type></parameter> )</parameter_list></cpp:macro>    <cpp:value>do { MBEDTLS_MPI_CHK( ecp_modp( &amp;N, grp ) ); INC_MUL_COUNT } \
                        while( 0 )</cpp:value></cpp:define>

<comment type="block">/*
 * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_sub_mpi
 * N-&gt;s &lt; 0 is a very fast test, which fails only if N is 0
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD_SUB</name><parameter_list>( <parameter><type><name>N</name></type></parameter> )</parameter_list></cpp:macro>                                \
    <cpp:value>while( N.s &lt; 0 &amp;&amp; mbedtls_mpi_cmp_int( &amp;N, 0 ) != 0 )   \
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &amp;N, &amp;N, &amp;grp-&gt;P ) )</cpp:value></cpp:define>

<comment type="block">/*
 * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_add_mpi and mbedtls_mpi_mul_int.
 * We known P, N and the result are positive, so sub_abs is correct, and
 * a bit faster.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD_ADD</name><parameter_list>( <parameter><type><name>N</name></type></parameter> )</parameter_list></cpp:macro>                                \
    <cpp:value>while( mbedtls_mpi_cmp_mpi( &amp;N, &amp;grp-&gt;P ) &gt;= 0 )        \
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &amp;N, &amp;N, &amp;grp-&gt;P ) )</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_SHORTWEIERSTRASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * For curves in short Weierstrass form, we do all the internal operations in
 * Jacobian coordinates.
 *
 * For multiplication, we'll use a comb method with coutermeasueres against
 * SPA, hence timing attacks.
 */</comment>

<comment type="block">/*
 * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
 * Cost: 1N := 1I + 3M + 1S
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_normalize_jac</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>Zi</name></decl>, <decl><type ref="prev"/><name>ZZi</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * X = X / Z^2  mod p
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>,        <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>     )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>ZZi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Y = Y / Z^3  mod p
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>     )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Z = 1
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Normalize jacobian coordinates of an array of (pointers to) points,
 * using Montgomery's trick to perform only one inversion mod P.
 * (See for example Cohen's "A Course in Computational Algebraic Number
 * Theory", Algorithm 10.3.4.)
 *
 * Warning: fails (returning an error) if one of the points is zero!
 * This should never happen, see choice of w in ecp_mul_comb().
 *
 * Cost: 1N(t) := 1I + (6t - 3)M + 1S
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_normalize_jac_many</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                                   <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name><name>T</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>t_len</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name> <modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>u</name></decl>, <decl><type ref="prev"/><name>Zi</name></decl>, <decl><type ref="prev"/><name>ZZi</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>t_len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>ecp_normalize_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>*</operator><name>T</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>c</name> <operator>=</operator> <call><name>mbedtls_calloc</name><argument_list>( <argument><expr><name>t_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_mpi</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call> <operator>)</operator> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_ALLOC_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>u</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * c[i] = Z_0 * ... * Z_i
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>Z</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>t_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Z</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * u = 1 / (Z_0 * ... * Z_n) mod P
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>t_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <name>t_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr> )</control>
    <block>{<block_content>
        <comment type="block">/*
         * Zi = 1 / Z_i mod p
         * u = 1 / (Z_0 * ... * Z_i) mod P
         */</comment>
        <if_stmt><if>if<condition>( <expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>Zi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Z</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>u</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * proceed as in normalize()
         */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>ZZi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>X</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>X</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>X</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Post-precessing: reclaim some memory by shrinking coordinates
         * - not storing Z (always 1)
         * - shrinking other coordinates, but still keeping the same number of
         *   limbs as P, as otherwise it will too likely be regrown too fast.
         */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shrink</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>X</name></expr></argument>, <argument><expr><name><name>grp</name><operator>-&gt;</operator><name>P</name><operator>.</operator><name>n</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shrink</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Y</name></expr></argument>, <argument><expr><name><name>grp</name><operator>-&gt;</operator><name>P</name><operator>.</operator><name>n</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>Z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

<label><name>cleanup</name>:</label>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>u</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Zi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ZZi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>t_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>c</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Conditional point inversion: Q -&gt; -Q = (Q.X, -Q.Y, Q.Z) without leak.
 * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_safe_invert_jac</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                            <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>inv</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nonzero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>mQY</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mQY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mQY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nonzero</name> <operator>=</operator> <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_assign</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mQY</name></expr></argument>, <argument><expr><name>inv</name> <operator>&amp;</operator> <name>nonzero</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mQY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Point doubling R = 2 P, Jacobian coordinates
 *
 * Based on http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2 .
 *
 * We follow the variable naming fairly closely. The formula variations that trade a MUL for a SQR
 * (plus a few ADDs) aren't useful as our bignum implementation doesn't distinguish squaring.
 *
 * Standard optimizations are applied when curve parameter A is one of { 0, -3 }.
 *
 * Cost: 1D := 3M + 4S          (A ==  0)
 *             4M + 4S          (A == -3)
 *             3M + 6S + 1a     otherwise
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_double_jac</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>M</name></decl>, <decl><type ref="prev"/><name>S</name></decl>, <decl><type ref="prev"/><name>T</name></decl>, <decl><type ref="prev"/><name>U</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>dbl_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Special case for A = -3 */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>A</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* M = 3(X + Z^2)(X - Z^2) */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,     <argument><expr><literal type="number">3</literal></expr></argument>       )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* M = 3.X^2 */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,     <argument><expr><literal type="number">3</literal></expr></argument>       )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Optimize away for "koblitz" curves with A = 0 */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <comment type="block">/* M += A.Z^4 */</comment>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* S = 4.X.Y^2 */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_l</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><literal type="number">1</literal></expr></argument>               )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_l</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><literal type="number">1</literal></expr></argument>               )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* U = 8.Y^4 */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_l</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>,  <argument><expr><literal type="number">1</literal></expr></argument>               )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* T = M^2 - 2.S */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* S = M(S - T) - U */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>      )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* U = 2.Y.Z */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_l</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>,  <argument><expr><literal type="number">1</literal></expr></argument>               )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>S</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>U</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>S</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>U</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Addition: R = P + Q, mixed affine-Jacobian coordinates (GECC 3.22)
 *
 * The coordinates of Q must be normalized (= affine),
 * but those of P don't need to. R is not normalized.
 *
 * Special cases: (1) P or Q is zero, (2) R is zero, (3) P == Q.
 * None of these cases can happen as intermediate step in ecp_mul_comb():
 * - at each step, P, Q and R are multiples of the base point, the factor
 *   being less than its order, so none of them is zero;
 * - Q is an odd multiple of the base point, P an even multiple,
 *   due to the choice of precomputed points in the modified comb method.
 * So branches for these cases do not leak secret information.
 *
 * We accept Q-&gt;Z being unset (saving memory in tables) as meaning 1.
 *
 * Cost: 1A := 8M + 3S
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_add_mixed</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>T1</name></decl>, <decl><type ref="prev"/><name>T2</name></decl>, <decl><type ref="prev"/><name>T3</name></decl>, <decl><type ref="prev"/><name>T4</name></decl>, <decl><type ref="prev"/><name>X</name></decl>, <decl><type ref="prev"/><name>Y</name></decl>, <decl><type ref="prev"/><name>Z</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>add_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Trivial cases: P == 0 or Q == 0 (case 1)
     */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><name>R</name></expr></argument>, <argument><expr><name>Q</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>Q</name><operator>-&gt;</operator><name>Z</name><operator>.</operator><name>p</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><name>R</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Make sure Q coordinates are normalized
     */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>Q</name><operator>-&gt;</operator><name>Z</name><operator>.</operator><name>p</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>X</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Y</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Special cases (2) and (3) */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ecp_double_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_set_zero</name><argument_list>( <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>Z</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,    <argument><expr><literal type="number">2</literal></expr></argument>     )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>X</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>X</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>X</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>T3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>T4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Y</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>Y</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Y</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>T4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>X</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Y</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Randomize jacobian coordinates:
 * (X, Y, Z) -&gt; (l^2 X, l^3 Y, l Z) for random l
 * This is sort of the reverse operation of ecp_normalize_jac().
 *
 * This countermeasure was first suggested in [2].
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_randomize_jac</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>,
                <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>ll</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>p_size</name> <init>= <expr><operator>(</operator> <name><name>grp</name><operator>-&gt;</operator><name>pbits</name></name> <operator>+</operator> <literal type="number">7</literal> <operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate l such that 1 &lt; l &lt; p */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_mpi_fill_random</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>p_size</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <while>while<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_r</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if<condition>( <expr><name>count</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_RANDOM_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    while<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition>;</do>

    <comment type="block">/* Z = l * Z */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* X = l^2 * X */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>,         <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>ll</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Y = l^3 * Y */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>,        <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>ll</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check and define parameters used by the comb method (see below for details)
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>MBEDTLS_ECP_WINDOW_SIZE</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>MBEDTLS_ECP_WINDOW_SIZE</name></expr></argument> &gt;</argument_list></name> <literal type="number">7</literal></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"MBEDTLS_ECP_WINDOW_SIZE out of bounds"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* d = ceil( n / w ) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMB_MAX_D</name></cpp:macro>      <cpp:value>( MBEDTLS_ECP_MAX_BITS + 1 ) / 2</cpp:value></cpp:define>

<comment type="block">/* number of precomputed points */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMB_MAX_PRE</name></cpp:macro>    <cpp:value>( 1 &lt;&lt; ( MBEDTLS_ECP_WINDOW_SIZE - 1 ) )</cpp:value></cpp:define>

<comment type="block">/*
 * Compute the representation of m that will be used with our comb method.
 *
 * The basic comb method is described in GECC 3.44 for example. We use a
 * modified version that provides resistance to SPA by avoiding zero
 * digits in the representation as in [3]. We modify the method further by
 * requiring that all K_i be odd, which has the small cost that our
 * representation uses one more K_i, due to carries.
 *
 * Also, for the sake of compactness, only the seven low-order bits of x[i]
 * are used to represent K_i, and the msb of x[i] encodes the the sign (s_i in
 * the paper): it is set if and only if if s_i == -1;
 *
 * Calling conventions:
 * - x is an array of size d + 1
 * - w is the size, ie number of teeth, of the comb, and must be between
 *   2 and 7 (in practice, between 2 and MBEDTLS_ECP_WINDOW_SIZE)
 * - m is the MPI, expected to be odd and such that bitlength(m) &lt;= w * d
 *   (the result will be incorrect if these assumptions are not satisfied)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ecp_comb_fixed</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>d</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>m</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>, <decl><type ref="prev"/><name>adjust</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>d</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First get the classical comb values (except for x_d = 0) */</comment>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>d</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
        <for>for<control>( <init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>w</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>d</name> <operator>*</operator> <name>j</name></expr></argument> )</argument_list></call> <operator>&lt;&lt;</operator> <name>j</name></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

    <comment type="block">/* Now make sure x_1 .. x_d are odd */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>d</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <comment type="block">/* Add carry and update it */</comment>
        <expr_stmt><expr><name>cc</name>   <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>

        <comment type="block">/* Adjust if needed, avoiding branches */</comment>
        <expr_stmt><expr><name>adjust</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x01</literal> <operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name>   <operator>|=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator> <name><name>x</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>adjust</name> <operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <operator>(</operator> <name><name>x</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>adjust</name> <operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>adjust</name> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Precompute points for the comb method
 *
 * If i = i_{w-1} ... i_1 is the binary representation of i, then
 * T[i] = i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + P
 *
 * T must be able to hold 2^{w - 1} elements
 *
 * Cost: d(w-1) D + (2^{w-1} - 1) A + 1 N(w-1) + 1 N(2^{w-1} - 1)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_precompute_comb</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                                <parameter><decl><type><name>mbedtls_ecp_point</name></type> <name><name>T</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
                                <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>d</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>cur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>TT</name><index>[<expr><name>COMB_MAX_PRE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Set T[0] = P and
     * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator> <name>w</name> <operator>-</operator> <literal type="number">1</literal> <operator>)</operator> <operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>cur</name> <operator>=</operator> <name>T</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>T</name> <operator>+</operator> <operator>(</operator> <name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal> <operator>)</operator></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for<control>( <init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>d</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_double_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>cur</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><name><name>TT</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_normalize_jac_many</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>TT</name></expr></argument>, <argument><expr><name>k</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute the remaining ones using the minimal number of additions
     * Be careful to update T[2^l] only after using it!
     */</comment>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator> <name>w</name> <operator>-</operator> <literal type="number">1</literal> <operator>)</operator> <operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>j</name><operator>--</operator></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_add_mixed</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>TT</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_normalize_jac_many</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>TT</name></expr></argument>, <argument><expr><name>k</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select precomputed point: R = sign(i) * T[ abs(i) / 2 ]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_select_comb</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name></type> <name><name>T</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>t_len</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>i</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Ignore the "sign" bit and scale down */</comment>
    <expr_stmt><expr><name>ii</name> <operator>=</operator>  <operator>(</operator> <name>i</name> <operator>&amp;</operator> <literal type="number">0x7Fu</literal> <operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Read the whole table to thwart cache-based timing attacks */</comment>
    <for>for<control>( <init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>t_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_assign</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>X</name></expr></argument>, <argument><expr><name>j</name> <operator>==</operator> <name>ii</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_assign</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>Y</name></expr></argument>, <argument><expr><name>j</name> <operator>==</operator> <name>ii</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Safely invert result if i is "negative" */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_safe_invert_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Core multiplication algorithm for the (modified) comb method.
 * This part is actually common with the basic comb method (GECC 3.44)
 *
 * Cost: d A + d D + 1 R
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_mul_comb_core</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name></type> <name><name>T</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>t_len</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>d</name></decl></parameter>,
                              <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                              <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name></type> <name>Txi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Txi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Start with a non-zero point and randomize its coordinates */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_select_comb</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>t_len</name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_randomize_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while<condition>( <expr><name>i</name><operator>--</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_double_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_select_comb</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Txi</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>t_len</name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_add_mixed</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Txi</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Txi</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Multiplication using the comb method,
 * for curves in short Weierstrass form
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_mul_comb</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
                         <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                         <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>w</name></decl>, <decl><type ref="prev"/><name>m_is_odd</name></decl>, <decl><type ref="prev"/><name>p_eq_g</name></decl>, <decl><type ref="prev"/><name>pre_len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>k</name><index>[<expr><name>COMB_MAX_D</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>T</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>M</name></decl>, <decl><type ref="prev"/><name>mm</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we need N to be odd to trnaform m in an odd number, check now */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Minimize the number of multiplications, that is minimize
     * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )
     * (see costs of the various parts, with 1S = 1M)
     */</comment>
    <expr_stmt><expr><name>w</name> <operator>=</operator> <ternary><condition><expr><name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name> <operator>&gt;=</operator> <literal type="number">384</literal></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * If P == G, pre-compute a bit more, since this may be re-used later.
     * Just adding one avoids upping the cost of the first mul too much,
     * and the memory cost too.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MBEDTLS_ECP_FIXED_POINT_OPTIM</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
    <expr_stmt><expr><name>p_eq_g</name> <operator>=</operator> <operator>(</operator> <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>Y</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name><operator>.</operator><name>X</name></name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p_eq_g</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>w</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>p_eq_g</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Make sure w is within bounds.
     * (The last test is useful only for very small curves in the test suite.)
     */</comment>
    <if_stmt><if>if<condition>( <expr><name>w</name> <operator>&gt;</operator> <name>MBEDTLS_ECP_WINDOW_SIZE</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <name>MBEDTLS_ECP_WINDOW_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>w</name> <operator>&gt;=</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Other sizes that depend on w */</comment>
    <expr_stmt><expr><name>pre_len</name> <operator>=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator> <name>w</name> <operator>-</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name> <operator>+</operator> <name>w</name> <operator>-</operator> <literal type="number">1</literal> <operator>)</operator> <operator>/</operator> <name>w</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Prepare precomputed points: if P == G we want to
     * use grp-&gt;T if already initialized, or initialize it.
     */</comment>
    <expr_stmt><expr><name>T</name> <operator>=</operator> <ternary><condition><expr><name>p_eq_g</name></expr> ?</condition><then> <expr><name><name>grp</name><operator>-&gt;</operator><name>T</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>T</name> <operator>==</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>T</name> <operator>=</operator> <call><name>mbedtls_calloc</name><argument_list>( <argument><expr><name>pre_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>mbedtls_ecp_point</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>T</name> <operator>==</operator> <name>NULL</name></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ECP_ALLOC_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_precompute_comb</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>d</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>p_eq_g</name></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>T</name></name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>T_size</name></name> <operator>=</operator> <name>pre_len</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Make sure M is odd (M = m or M = N - m, since N is odd)
     * using the fact that m * P = - (N - m) * P
     */</comment>
    <expr_stmt><expr><name>m_is_odd</name> <operator>=</operator> <operator>(</operator> <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>, <argument><expr><name>m</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_assign</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument>, <argument><expr><operator>!</operator> <name>m_is_odd</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Go for comb multiplication, R = M * P
     */</comment>
    <expr_stmt><expr><call><name>ecp_comb_fixed</name><argument_list>( <argument><expr><name>k</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_mul_comb_core</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>pre_len</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now get m * P from M * P and normalize it
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_safe_invert_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><operator>!</operator> <name>m_is_odd</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_normalize_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

    <if_stmt><if>if<condition>( <expr><name>T</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>p_eq_g</name></expr> )</condition>
    <block>{<block_content>
        <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pre_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>T</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>mbedtls_free</name><argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>M</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_SHORTWEIERSTRASS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_MONTGOMERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * For Montgomery curves, we do all the internal arithmetic in projective
 * coordinates. Import/export of points uses only the x coordinates, which is
 * internaly represented as X / Z.
 *
 * For scalar multiplication, we'll use a Montgomery ladder.
 */</comment>

<comment type="block">/*
 * Normalize Montgomery x/z coordinates: X = X/Z, Z = 1
 * Cost: 1M + 1I
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_normalize_mxz</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_inv_mod</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Randomize projective x/z coordinates:
 * (X, Z) -&gt; (l X, l Z) for random l
 * This is sort of the reverse operation of ecp_normalize_mxz().
 *
 * This countermeasure was first suggested in [2].
 * Cost: 2M
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_randomize_mxz</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
                <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>p_size</name> <init>= <expr><operator>(</operator> <name><name>grp</name><operator>-&gt;</operator><name>pbits</name></name> <operator>+</operator> <literal type="number">7</literal> <operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate l such that 1 &lt; l &lt; p */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name>mbedtls_mpi_fill_random</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>p_size</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <while>while<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_r</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if<condition>( <expr><name>count</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_RANDOM_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    while<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition>;</do>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>l</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Double-and-add: R = 2P, S = P + Q, with d = X(P - Q),
 * for Montgomery curves in x/z coordinates.
 *
 * http://www.hyperelliptic.org/EFD/g1p/auto-code/montgom/xz/ladder/mladd-1987-m.op3
 * with
 * d =  X1
 * P = (X2, Z2)
 * Q = (X3, Z3)
 * R = (X4, Z4)
 * S = (X5, Z5)
 * and eliminating temporary variables tO, ..., t4.
 *
 * Cost: 5M + 4S
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_double_add_mxz</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                               <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>d</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>A</name></decl>, <decl><type ref="prev"/><name>AA</name></decl>, <decl><type ref="prev"/><name>B</name></decl>, <decl><type ref="prev"/><name>BB</name></decl>, <decl><type ref="prev"/><name>E</name></decl>, <decl><type ref="prev"/><name>C</name></decl>, <decl><type ref="prev"/><name>D</name></decl>, <decl><type ref="prev"/><name>DA</name></decl>, <decl><type ref="prev"/><name>CB</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>A</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>AA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>B</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>BB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>E</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>C</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>D</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>CB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>A</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>A</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>AA</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>A</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>A</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>AA</name></expr></argument>   )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>B</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>B</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>BB</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>B</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>B</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>BB</name></expr></argument>   )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>E</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>AA</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>BB</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>E</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>C</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>C</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>D</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>D</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DA</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>D</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>A</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>DA</name></expr></argument>   )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>CB</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>C</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name>B</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>CB</name></expr></argument>   )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DA</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>CB</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>S</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>S</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DA</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>CB</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>,       <argument><expr><operator>&amp;</operator><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>S</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>AA</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name>BB</name></expr></argument>   )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>E</name></expr></argument>    )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>BB</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>E</name></expr></argument>,      <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>A</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>AA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>B</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>BB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>E</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>C</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>D</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>DA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>CB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Multiplication with Montgomery ladder in x/z coordinates,
 * for curves in Montgomery form
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_mul_mxz</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
                        <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                        <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name></type> <name>RP</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>PX</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Save PX and read from P before writing to R, in case P == R */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RP</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set R to zero in modified x/z coordinates */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* RP.X might be sligtly larger than P, so reduce it */</comment>
    <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name><name>RP</name><operator>.</operator><name>X</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Randomize coordinates of the starting point */</comment>
    <if_stmt><if>if<condition>( <expr><name>f_rng</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_randomize_mxz</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RP</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Loop invariant: R = result so far, RP = R + P */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><name>m</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* one past the (zero-based) most significant bit */</comment>
    <while>while<condition>( <expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         *  if (b) R = 2R + P else R = 2R,
         * which is:
         *  if (b) double_add( RP, R, RP, R )
         *  else   double_add( R, RP, R, RP )
         * but using safe conditional swaps to avoid leaks
         */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_swap</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>RP</name><operator>.</operator><name>X</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_swap</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>RP</name><operator>.</operator><name>Z</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_double_add_mxz</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RP</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>PX</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_swap</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>RP</name><operator>.</operator><name>X</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_safe_cond_swap</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>RP</name><operator>.</operator><name>Z</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_normalize_mxz</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>PX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_MONTGOMERY */</comment>

<comment type="block">/*
 * Multiplication R = m * P
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_mul</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
             <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <comment type="block">/* Common sanity checks */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>P</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_check_privkey</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>m</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_check_pubkey</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_MONTGOMERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_MONTGOMERY</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>ecp_mul_mxz</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_SHORTWEIERSTRASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_SHORT_WEIERSTRASS</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>ecp_mul_comb</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_SHORTWEIERSTRASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Check that an affine point is valid as a public key,
 * short weierstrass curves (SEC1 3.2.3.1)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_check_pubkey_sw</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>YY</name></decl>, <decl><type ref="prev"/><name>RHS</name></decl>;</decl_stmt>

    <comment type="block">/* pt coordinates must be normalized for our checks */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_INVALID_KEY</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>YY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * YY = Y^2
     * RHS = X (X^2 + A) + B = X^3 + A X + B
     */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>YY</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>YY</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>,   <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Special case for A = -3 */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>grp</name><operator>-&gt;</operator><name>A</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>       )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_SUB</name><argument_list>( <argument><expr><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>A</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_mul_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_MUL</name><argument_list>( <argument><expr><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_add_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument>,     <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>B</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>MOD_ADD</name><argument_list>( <argument><expr><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name>YY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ECP_INVALID_KEY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>cleanup</name>:</label>

    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>YY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>RHS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_SHORTWEIERSTRASS */</comment>

<comment type="block">/*
 * R = m * P with shortcuts for m == 1 and m == -1
 * NOT constant-time - ONLY for short Weierstrass!
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mbedtls_ecp_mul_shortcuts</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                                      <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>m</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><name>R</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_copy</name><argument_list>( <argument><expr><name>R</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_sub_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>P</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>R</name><operator>-&gt;</operator><name>Y</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>cleanup</name>:</label>
    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Linear combination
 * NOT constant-time
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_muladd</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name></type> <name>mP</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>!=</operator> <name>ECP_TYPE_SHORT_WEIERSTRASS</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul_shortcuts</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mP</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>P</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul_shortcuts</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>,   <argument><expr><name>n</name></expr></argument>, <argument><expr><name>Q</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_add_mixed</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mP</name></expr></argument>, <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>ecp_normalize_jac</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>R</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>mP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_MONTGOMERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Check validity of a public key for Montgomery curves with x-only schemes
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ecp_check_pubkey_mx</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <comment type="block">/* [Curve25519 p. 5] Just check X is the correct number of bytes */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_size</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>X</name></name></expr></argument> )</argument_list></call> <operator>&gt;</operator> <operator>(</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name> <operator>+</operator> <literal type="number">7</literal> <operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_INVALID_KEY</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_MONTGOMERY */</comment>

<comment type="block">/*
 * Check that a point is valid as a public key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_check_pubkey</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <comment type="block">/* Must use affine coordinates */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>Z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_INVALID_KEY</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_MONTGOMERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_MONTGOMERY</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>ecp_check_pubkey_mx</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>pt</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_SHORTWEIERSTRASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_SHORT_WEIERSTRASS</name></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <call><name>ecp_check_pubkey_sw</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>pt</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that an mbedtls_mpi is valid as a private key
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_check_privkey</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_mpi</name> <modifier>*</modifier></type><name>d</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_MONTGOMERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_MONTGOMERY</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* see [Curve25519] page 5 */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_get_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><name>d</name></expr></argument> )</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name></expr> )</condition><block type="pseudo"><block_content> <comment type="block">/* mbedtls_mpi_bitlen is one-based! */</comment>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_INVALID_KEY</name> <operator>)</operator></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_MONTGOMERY */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_SHORTWEIERSTRASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_SHORT_WEIERSTRASS</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* see SEC1 3.2 */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_INVALID_KEY</name> <operator>)</operator></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return<expr><operator>(</operator> <literal type="number">0</literal> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_SHORTWEIERSTRASS */</comment>

    <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a keypair with configurable base point
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_gen_keypair_base</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>G</name></decl></parameter>,
                     <parameter><decl><type><name>mbedtls_mpi</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter>,
                     <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                     <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n_size</name> <init>= <expr><operator>(</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name> <operator>+</operator> <literal type="number">7</literal> <operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_MONTGOMERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_MONTGOMERY</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* [M225] page 5 */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>b</name></decl>;</decl_stmt>

        <do>do <block>{<block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_fill_random</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><name>n_size</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while<condition>( <expr><call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><name>d</name></expr></argument> )</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

        <comment type="block">/* Make sure the most significant bit is nbits */</comment>
        <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>mbedtls_mpi_bitlen</name><argument_list>( <argument><expr><name>d</name></expr></argument> )</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* mbedtls_mpi_bitlen is one-based */</comment>
        <if_stmt><if>if<condition>( <expr><name>b</name> <operator>&gt;</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_r</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name> <operator>-</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_set_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Make sure the last three bits are unset */</comment>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_set_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_set_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_set_bit</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_MONTGOMERY */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ECP_SHORTWEIERSTRASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    if<condition>( <expr><call><name>ecp_get_type</name><argument_list>( <argument><expr><name>grp</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>ECP_TYPE_SHORT_WEIERSTRASS</name></expr> )</condition>
    <block>{<block_content>
        <comment type="block">/* SEC1 3.2.1: Generate d such that 1 &lt;= n &lt; N */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>rnd</name><index>[<expr><name>MBEDTLS_ECP_MAX_BYTES</name></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/*
         * Match the procedure given in RFC 6979 (deterministic ECDSA):
         * - use the same byte ordering;
         * - keep the leftmost nbits bits of the generated octet string;
         * - try until result is in the desired range.
         * This also avoids any biais, which is especially important for ECDSA.
         */</comment>
        <do>do
        <block>{<block_content>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>f_rng</name><argument_list>( <argument><expr><name>p_rng</name></expr></argument>, <argument><expr><name>rnd</name></expr></argument>, <argument><expr><name>n_size</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_binary</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rnd</name></expr></argument>, <argument><expr><name>n_size</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_shift_r</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">8</literal> <operator>*</operator> <name>n_size</name> <operator>-</operator> <name><name>grp</name><operator>-&gt;</operator><name>nbits</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Each try has at worst a probability 1/2 of failing (the msb has
             * a probability 1/2 of being 0, and then the result will be &lt; N),
             * so after 30 tries failure probability is a most 2**(-30).
             *
             * For most curves, 1 try is enough with overwhelming probability,
             * since N starts with a lot of 1s in binary, but some curves
             * such as secp224k1 are actually very close to the worst case.
             */</comment>
            <if_stmt><if>if<condition>( <expr><operator>++</operator><name>count</name> <operator>&gt;</operator> <literal type="number">30</literal></expr> )</condition><block type="pseudo"><block_content>
                <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_RANDOM_FAILED</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
        while<condition>( <expr><call><name>mbedtls_mpi_cmp_int</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
               <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>N</name></name></expr></argument> )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition>;</do>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ECP_SHORTWEIERSTRASS */</comment>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return></block_content></block></else></if_stmt>

<label><name>cleanup</name>:</label>
    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><name>Q</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate key pair, wrapper for conventional base point
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_gen_keypair</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>,
                             <parameter><decl><type><name>mbedtls_mpi</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_point</name> <modifier>*</modifier></type><name>Q</name></decl></parameter>,
                             <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
                             <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <return>return<expr><operator>(</operator> <call><name>mbedtls_ecp_gen_keypair_base</name><argument_list>( <argument><expr><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>G</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>Q</name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a keypair, prettier wrapper
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_gen_key</name><parameter_list>( <parameter><decl><type><name>mbedtls_ecp_group_id</name></type> <name>grp_id</name></decl></parameter>, <parameter><decl><type><name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f_rng</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p_rng</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator> <name>ret</name> <operator>=</operator> <call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><name>grp_id</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <call><name>mbedtls_ecp_gen_keypair</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>Q</name></name></expr></argument>, <argument><expr><name>f_rng</name></expr></argument>, <argument><expr><name>p_rng</name></expr></argument> )</argument_list></call> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check a public-private key pair
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_check_pub_priv</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>pub</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mbedtls_ecp_keypair</name> <modifier>*</modifier></type><name>prv</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name></type> <name>Q</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_group</name></type> <name>grp</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pub</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>MBEDTLS_ECP_DP_NONE</name> <operator>||</operator>
        <name><name>pub</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name><name>prv</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>id</name></name> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pub</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>X</name></name></expr></argument> )</argument_list></call> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pub</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>Y</name></name></expr></argument> )</argument_list></call> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>pub</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr> )</condition>
    <block>{<block_content>
        <return>return<expr><operator>(</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name> <operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_group_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mbedtls_ecp_mul() needs a non-const group... */</comment>
    <expr_stmt><expr><call><name>mbedtls_ecp_group_copy</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>grp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Also checks d is valid */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>G</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>.</operator><name>X</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>X</name></name></expr></argument> )</argument_list></call> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>.</operator><name>Y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>Y</name></name></expr></argument> )</argument_list></call> <operator>||</operator>
        <call><name>mbedtls_mpi_cmp_mpi</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>Q</name><operator>.</operator><name>Z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prv</name><operator>-&gt;</operator><name>Q</name><operator>.</operator><name>Z</name></name></expr></argument> )</argument_list></call></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_group_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_SELF_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
 * Checkup routine
 */</comment>
<function><type><name>int</name></type> <name>mbedtls_ecp_self_test</name><parameter_list>( <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_group</name></type> <name>grp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_ecp_point</name></type> <name>R</name></decl>, <decl><type ref="prev"/><name>P</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mbedtls_mpi</name></type> <name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>add_c_prev</name></decl>, <decl><type ref="prev"/><name>dbl_c_prev</name></decl>, <decl><type ref="prev"/><name>mul_c_prev</name></decl>;</decl_stmt>
    <comment type="block">/* exponents especially adapted for secp192r1 */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>exponents</name><index>[]</index></name> <init>=
    <expr><block>{
        <expr><literal type="string">"000000000000000000000000000000000000000000000001"</literal></expr>, <comment type="block">/* one */</comment>
        <expr><literal type="string">"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22830"</literal></expr>, <comment type="block">/* N - 1 */</comment>
        <expr><literal type="string">"5EA6F389A38B8BC81E767753B15AA5569E1782E30ABE7D25"</literal></expr>, <comment type="block">/* random */</comment>
        <expr><literal type="string">"400000000000000000000000000000000000000000000000"</literal></expr>, <comment type="block">/* one and zeros */</comment>
        <expr><literal type="string">"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"</literal></expr>, <comment type="block">/* all ones */</comment>
        <expr><literal type="string">"555555555555555555555555555555555555555555555555"</literal></expr>, <comment type="block">/* 101010... */</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_group_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>R</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Use secp192r1 if available, or any available curve */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MBEDTLS_ECP_DP_SECP192R1_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><name>MBEDTLS_ECP_DP_SECP192R1</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_group_load</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><call><name>mbedtls_ecp_curve_list</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>grp_id</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  ECP test #1 (constant op_count, base point G): "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Do a dummy multiplication first to trigger precomputation */</comment>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_lset</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>.</operator><name>G</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>add_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbl_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>mul_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>exponents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>.</operator><name>G</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>( <argument><expr><name>exponents</name></expr></argument> )</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>( <argument><expr><name><name>exponents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>add_c_prev</name> <operator>=</operator> <name>add_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dbl_c_prev</name> <operator>=</operator> <name>dbl_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mul_c_prev</name> <operator>=</operator> <name>mul_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>add_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dbl_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>mul_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>exponents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>grp</name><operator>.</operator><name>G</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>add_count</name> <operator>!=</operator> <name>add_c_prev</name> <operator>||</operator>
            <name>dbl_count</name> <operator>!=</operator> <name>dbl_c_prev</name> <operator>||</operator>
            <name>mul_count</name> <operator>!=</operator> <name>mul_c_prev</name></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed (%u)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"  ECP test #2 (constant op_count, other point): "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* We computed P = 2G last time, use it */</comment>

    <expr_stmt><expr><name>add_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbl_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>mul_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>exponents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>( <argument><expr><name>exponents</name></expr></argument> )</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>( <argument><expr><name><name>exponents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>
    <block>{<block_content>
        <expr_stmt><expr><name>add_c_prev</name> <operator>=</operator> <name>add_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dbl_c_prev</name> <operator>=</operator> <name>dbl_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mul_c_prev</name> <operator>=</operator> <name>mul_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>add_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dbl_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>mul_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_mpi_read_string</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>exponents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MBEDTLS_MPI_CHK</name><argument_list>( <argument><expr><call><name>mbedtls_ecp_mul</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>add_count</name> <operator>!=</operator> <name>add_c_prev</name> <operator>||</operator>
            <name>dbl_count</name> <operator>!=</operator> <name>dbl_c_prev</name> <operator>||</operator>
            <name>mul_count</name> <operator>!=</operator> <name>mul_c_prev</name></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"failed (%u)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"passed\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>cleanup</name>:</label>

    <if_stmt><if>if<condition>( <expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"Unexpected error, return code = %08X\n"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mbedtls_ecp_group_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>grp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>R</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_ecp_point_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>P</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mbedtls_mpi_free</name><argument_list>( <argument><expr><operator>&amp;</operator><name>m</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>verbose</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mbedtls_printf</name><argument_list>( <argument><expr><literal type="string">"\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return<expr><operator>(</operator> <name>ret</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_SELF_TEST */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MBEDTLS_ECP_C */</comment>
</unit>
