<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/lhash_kv.c"><comment type="block">/*
 * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.
 * Copyright (C) 2012-2018, Symisc Systems http://unqlite.org/
 * Copyright (C) 2014, Yuras Shumovich &lt;shumovichy@gmail.com&gt;
 * Version 1.1.6
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://unqlite.org/licensing.html
 */</comment>
 <comment type="block">/* $SymiscID: lhash_kv.c v1.7 Solaris 2013-01-14 12:56 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unqliteInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* 
 * This file implements disk based hashtable using the linear hashing algorithm.
 * This implementation is the one decribed in the paper:
 *  LINEAR HASHING : A NEW TOOL FOR FILE AND TABLE ADDRESSING. Witold Litwin. I. N. Ft. I. A.. 78 150 Le Chesnay, France.
 * Plus a smart extension called Virtual Bucket Table. (contact devel@symisc.net for additional information).
 */</comment>
<comment type="block">/* Magic number identifying a valid storage image */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_MAGIC</name></cpp:macro> <cpp:value>0xFA782DCB</cpp:value></cpp:define>
<comment type="block">/*
 * Magic word to hash to identify a valid hash function.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_WORD</name></cpp:macro> <cpp:value>"chm@symisc"</cpp:value></cpp:define>
<comment type="block">/*
 * Cell size on disk. 
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_CELL_SZ</name></cpp:macro> <cpp:value>(4<comment type="block">/*Hash*/</comment>+4<comment type="block">/*Key*/</comment>+8<comment type="block">/*Data*/</comment>+2<comment type="block">/* Offset of the next cell */</comment>+8<comment type="block">/*Overflow*/</comment>)</cpp:value></cpp:define>
<comment type="block">/*
 * Primary page (not overflow pages) header size on disk.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_PAGE_HDR_SZ</name></cpp:macro> <cpp:value>(2<comment type="block">/* Cell offset*/</comment>+2<comment type="block">/* Free block offset*/</comment>+8<comment type="block">/*Slave page number*/</comment>)</cpp:value></cpp:define>
<comment type="block">/*
 * The maximum amount of payload (in bytes) that can be stored locally for
 * a database entry.  If the entry contains more data than this, the
 * extra goes onto overflow pages.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_MX_PAYLOAD</name><parameter_list>(<parameter><type><name>PageSize</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(PageSize-(L_HASH_PAGE_HDR_SZ+L_HASH_CELL_SZ))</cpp:value></cpp:define>
<comment type="block">/*
 * Maxium free space on a single page.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_MX_FREE_SPACE</name><parameter_list>(<parameter><type><name>PageSize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(PageSize - (L_HASH_PAGE_HDR_SZ))</cpp:value></cpp:define>
<comment type="block">/*
** The maximum number of bytes of payload allowed on a single overflow page.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_OVERFLOW_SIZE</name><parameter_list>(<parameter><type><name>PageSize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(PageSize-8)</cpp:value></cpp:define>
<comment type="block">/* Forward declaration */</comment>
<typedef>typedef <type><name><name>struct</name> <name>lhash_kv_engine</name></name></type> <name>lhash_kv_engine</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>lhpage</name></name></type> <name>lhpage</name>;</typedef>
<comment type="block">/*
 * Each record in the database is identified either in-memory or in
 * disk by an instance of the following structure.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>lhcell</name></name></type> <name>lhcell</name>;</typedef>
<struct>struct <name>lhcell</name>
<block>{
	<comment type="block">/* Disk-data (Big-Endian) */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>   <comment type="block">/* Hash of the key: 4 bytes */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nKey</name></decl>;</decl_stmt>    <comment type="block">/* Key length: 4 bytes */</comment>
	<decl_stmt><decl><type><name>sxu64</name></type> <name>nData</name></decl>;</decl_stmt>   <comment type="block">/* Data length: 8 bytes */</comment>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iNext</name></decl>;</decl_stmt>   <comment type="block">/* Offset of the next cell: 2 bytes */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iOvfl</name></decl>;</decl_stmt>    <comment type="block">/* Overflow page number if any: 8 bytes */</comment>
	<comment type="block">/* In-memory data only */</comment>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>     <comment type="block">/* Page this cell belongs */</comment>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iStart</name></decl>;</decl_stmt>      <comment type="block">/* Offset of this cell */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iDataPage</name></decl>;</decl_stmt>    <comment type="block">/* Data page number when overflow */</comment>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iDataOfft</name></decl>;</decl_stmt>   <comment type="block">/* Offset of the data in iDataPage */</comment>
	<decl_stmt><decl><type><name>SyBlob</name></type> <name>sKey</name></decl>;</decl_stmt>       <comment type="block">/* Record key for fast lookup (Kept in-memory if &lt; 256KB ) */</comment>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pNext</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>         <comment type="block">/* Linked list of the loaded memory cells */</comment>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pNextCol</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPrevCol</name></decl>;</decl_stmt>   <comment type="block">/* Collison chain  */</comment>
}</block>;</struct>
<comment type="block">/*
** Each database page has a header that is an instance of this
** structure.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>lhphdr</name></name></type> <name>lhphdr</name>;</typedef>
<struct>struct <name>lhphdr</name> 
<block>{
  <decl_stmt><decl><type><name>sxu16</name></type> <name>iOfft</name></decl>;</decl_stmt> <comment type="block">/* Offset of the first cell */</comment>
  <decl_stmt><decl><type><name>sxu16</name></type> <name>iFree</name></decl>;</decl_stmt> <comment type="block">/* Offset of the first free block*/</comment>
  <decl_stmt><decl><type><name>pgno</name></type> <name>iSlave</name></decl>;</decl_stmt> <comment type="block">/* Slave page number */</comment>
}</block>;</struct>
<comment type="block">/*
 * Each loaded primary disk page is represented in-memory using
 * an instance of the following structure.
 */</comment>
<struct>struct <name>lhpage</name>
<block>{
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>  <comment type="block">/* KV Storage engine that own this page */</comment>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl>;</decl_stmt>      <comment type="block">/* Raw page contents */</comment>
	<decl_stmt><decl><type><name>lhphdr</name></type> <name>sHdr</name></decl>;</decl_stmt>             <comment type="block">/* Processed page header */</comment>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier><modifier>*</modifier></type><name>apCell</name></decl>;</decl_stmt>         <comment type="block">/* Cell buckets */</comment>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pList</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>   <comment type="block">/* Linked list of cells */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nCell</name></decl>;</decl_stmt>             <comment type="block">/* Total number of cells */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nCellSize</name></decl>;</decl_stmt>         <comment type="block">/* apCell[] size */</comment>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pMaster</name></decl>;</decl_stmt>         <comment type="block">/* Master page in case we are dealing with a slave page */</comment>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pSlave</name></decl>;</decl_stmt>          <comment type="block">/* List of slave pages */</comment>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pNextSlave</name></decl>;</decl_stmt>      <comment type="block">/* Next slave page on the list */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iSlave</name></decl>;</decl_stmt>            <comment type="block">/* Total number of slave pages */</comment>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nFree</name></decl>;</decl_stmt>             <comment type="block">/* Amount of free space available in the page */</comment>
}</block>;</struct>
<comment type="block">/*
 * A Bucket map record which is used to map logical bucket number to real
 * bucket number is represented by an instance of the following structure.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>lhash_bmap_rec</name></name></type> <name>lhash_bmap_rec</name>;</typedef>
<struct>struct <name>lhash_bmap_rec</name>
<block>{
	<decl_stmt><decl><type><name>pgno</name></type> <name>iLogic</name></decl>;</decl_stmt>                   <comment type="block">/* Logical bucket number */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iReal</name></decl>;</decl_stmt>                    <comment type="block">/* Real bucket number */</comment>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pNext</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>  <comment type="block">/* Link to other bucket map */</comment>     
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pNextCol</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPrevCol</name></decl>;</decl_stmt> <comment type="block">/* Collision links */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>lhash_bmap_page</name></name></type> <name>lhash_bmap_page</name>;</typedef>
<struct>struct <name>lhash_bmap_page</name>
<block>{
	<decl_stmt><decl><type><name>pgno</name></type> <name>iNum</name></decl>;</decl_stmt>   <comment type="block">/* Page number where this entry is stored */</comment>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iPtr</name></decl>;</decl_stmt>  <comment type="block">/* Offset to start reading/writing from */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nRec</name></decl>;</decl_stmt>  <comment type="block">/* Total number of records in this page */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iNext</name></decl>;</decl_stmt>  <comment type="block">/* Next map page */</comment>
}</block>;</struct>
<comment type="block">/*
 * An in memory linear hash implemenation is represented by in an isntance
 * of the following structure.
 */</comment>
<struct>struct <name>lhash_kv_engine</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>unqlite_kv_io</name> <modifier>*</modifier></type><name>pIo</name></decl>;</decl_stmt>     <comment type="block">/* IO methods: Must be first */</comment>
	<comment type="block">/* Private fields */</comment>
	<decl_stmt><decl><type><name>SyMemBackend</name></type> <name>sAllocator</name></decl>;</decl_stmt>      <comment type="block">/* Private memory backend */</comment>
	<decl_stmt><decl><type><name>ProcHash</name></type> <name>xHash</name></decl>;</decl_stmt>               <comment type="block">/* Default hash function */</comment>
	<decl_stmt><decl><type><name>ProcCmp</name></type> <name>xCmp</name></decl>;</decl_stmt>                 <comment type="block">/* Default comparison function */</comment>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pHeader</name></decl>;</decl_stmt>        <comment type="block">/* Page one to identify a valid implementation */</comment>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier><modifier>*</modifier></type><name>apMap</name></decl>;</decl_stmt>       <comment type="block">/* Buckets map records */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBuckRec</name></decl>;</decl_stmt>               <comment type="block">/* Total number of bucket map records */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBuckSize</name></decl>;</decl_stmt>              <comment type="block">/* apMap[] size  */</comment>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>        <comment type="block">/* List of bucket map records */</comment>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>       <comment type="block">/* First record*/</comment>
	<decl_stmt><decl><type><name>lhash_bmap_page</name></type> <name>sPageMap</name></decl>;</decl_stmt>     <comment type="block">/* Primary bucket map */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>iPageSize</name></decl>;</decl_stmt>                <comment type="block">/* Page size */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>nFreeList</name></decl>;</decl_stmt>               <comment type="block">/* List of free pages */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>split_bucket</name></decl>;</decl_stmt>            <comment type="block">/* Current split bucket: MUST BE A POWER OF TWO */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>max_split_bucket</name></decl>;</decl_stmt>        <comment type="block">/* Maximum split bucket: MUST BE A POWER OF TWO */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>nmax_split_nucket</name></decl>;</decl_stmt>       <comment type="block">/* Next maximum split bucket (1 &lt;&lt; nMsb): In-memory only */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nMagic</name></decl>;</decl_stmt>                 <comment type="block">/* Magic number to identify a valid linear hash disk database */</comment>
}</block>;</struct>
<comment type="block">/*
 * Given a logical bucket number, return the record associated with it.
 */</comment>
<function><type><specifier>static</specifier> <name>lhash_bmap_rec</name> <modifier>*</modifier></type> <name>lhMapFindBucket</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iLogic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckRec</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pRec</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name><index>[<expr><name>iLogic</name> <operator>&amp;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>iLogic</name></name> <operator>==</operator> <name>iLogic</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>pRec</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pRec</name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such record */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Install a new bucket map record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhMapInstallBucket</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iLogic</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iReal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new instance */</comment>
	<expr_stmt><expr><name>pRec</name> <operator>=</operator> <operator>(</operator><name>lhash_bmap_rec</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhash_bmap_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhash_bmap_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>iLogic</name></name> <operator>=</operator> <name>iLogic</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>iReal</name></name> <operator>=</operator> <name>iReal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name>iLogic</name> <operator>&amp;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
	<comment type="block">/* Link */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>,<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckRec</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckRec</name></name> <operator>&gt;=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>nBuckRec</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allocate a new larger table */</comment>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>lhash_bmap_rec</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhash_bmap_rec</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apNew</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Zero the new table */</comment>
			<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhash_bmap_rec</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Rehash all entries */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<comment type="block">/* Loop one */</comment>
				<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>nBuckRec</name></name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* Install in the new bucket */</comment>
				<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>iLogic</name></name> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				<comment type="block">/* Point to the next entry */</comment>
				<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Release the old table and reflect the change */</comment>
			<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>apMap</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nBuckSize</name></name>  <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Process a raw bucket map record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhMapLoadPage</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>lhash_bmap_page</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zRaw</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPtr</name> <init>= <expr><name>zRaw</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iLogic</name></decl>,<decl><type ref="prev"/><name>iReal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Read the map header */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Mostly page one of the database */</comment>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Start processing */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the logical and real bucket number */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iLogic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iReal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<comment type="block">/* Install the record in the map */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhMapInstallBucket</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>iLogic</name></expr></argument>,<argument><expr><name>iReal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zRaw</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Allocate a new cell instance.
 */</comment>
<function><type><specifier>static</specifier> <name>lhcell</name> <modifier>*</modifier></type> <name>lhNewCell</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <operator>(</operator><name>lhcell</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhcell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhcell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	<return>return <expr><name>pCell</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Discard a cell from the page table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lhCellDiscard</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pMaster</name></name></expr></init></decl>;</decl_stmt>	
	
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPrevCol</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>pPrevCol</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>pNextCol</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>pNextCol</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPrevCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>,<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>--</operator></expr>;</expr_stmt>
	<comment type="block">/* Release the cell */</comment>
	<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Install a cell in the page table.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhInstallCell</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pMaster</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nTableSize</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Must be a power of two */</comment>
		<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier><modifier>*</modifier></type><name>apTable</name></decl>;</decl_stmt>
		<comment type="block">/* Allocate a new cell table */</comment>
		<expr_stmt><expr><name>apTable</name> <operator>=</operator> <operator>(</operator><name>lhcell</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>nTableSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhcell</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apTable</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Zero the new table */</comment>
		<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apTable</name></expr></argument>, <argument><expr><name>nTableSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhcell</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Install it */</comment>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name></name> <operator>=</operator> <name>apTable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name> <operator>=</operator> <name>nTableSize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>,<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&gt;=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allocate a new larger table */</comment>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>lhcell</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhcell</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apNew</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Zero the new table */</comment>
			<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhcell</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Rehash all entries */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<comment type="block">/* Loop one */</comment>
				<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* Install in the new bucket */</comment>
				<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>  )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				<comment type="block">/* Point to the next entry */</comment>
				<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Release the old table and reflect the change */</comment>
			<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name>  <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Private data of lhKeyCmp().
 */</comment>
<struct>struct <name>lhash_key_cmp</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>  <comment type="block">/* Start of the stream */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt> <comment type="block">/* End of the stream */</comment>
	<decl_stmt><decl><type><name>ProcCmp</name></type> <name>xCmp</name></decl>;</decl_stmt>     <comment type="block">/* Comparison function */</comment>
}</block>;</struct>
<comment type="block">/*
 * Comparsion callback for large key &gt; 256 KB
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhKeyCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>lhash_key_cmp</name></name> <modifier>*</modifier></type><name>pCmp</name> <init>= <expr><operator>(</operator>struct <name>lhash_key_cmp</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCmp</name><operator>-&gt;</operator><name>zIn</name></name> <operator>&gt;=</operator> <name><name>pCmp</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pCmp</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pCmp</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Abort comparison */</comment>
		<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Advance the cursor */</comment>
	<expr_stmt><expr><name><name>pCmp</name><operator>-&gt;</operator><name>zIn</name></name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>lhConsumeCellkey</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>offt_only</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * given a key, return the cell associated with it on success. NULL otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>lhcell</name> <modifier>*</modifier></type> <name>lhFindCell</name><parameter_list>(
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,    <comment type="block">/* Target page */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>,      <comment type="block">/* Key length */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter>       <comment type="block">/* Hash of the key */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the corresponding bucket */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>apCell</name><index>[<expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>nCellSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>==</operator> <name>nHash</name> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nKey</name></name> <operator>==</operator> <name>nByte</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Large key (&gt; 256 KB) are not kept in-memory */</comment>
				<decl_stmt><decl><type><name><name>struct</name> <name>lhash_key_cmp</name></name></type> <name>sCmp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
				<comment type="block">/* Fill-in the structure */</comment>
				<expr_stmt><expr><name><name>sCmp</name><operator>.</operator><name>zIn</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sCmp</name><operator>.</operator><name>zEnd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sCmp</name><operator>.</operator><name>zIn</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sCmp</name><operator>.</operator><name>xCmp</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>xCmp</name></name></expr>;</expr_stmt>
				<comment type="block">/* Fetch the key from disk and perform the comparison */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhConsumeCellkey</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>,<argument><expr><name>lhKeyCmp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sCmp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Cell found */</comment>
					<return>return <expr><name>pEntry</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if><if type="elseif">else if <condition>( <expr><call><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name>pKey</name></expr></argument>,<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Cell found */</comment>
				<return>return <expr><name>pEntry</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such entry */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Parse a raw cell fetched from disk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhParseOneCell</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>,<parameter><decl><type><name>lhcell</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iNext</name></decl>,<decl><type ref="prev"/><name>iOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iHash</name></decl>,<decl><type ref="prev"/><name>nKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu64</name></type> <name>nData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Offset this cell is stored */</comment>
	<expr_stmt><expr><name>iOfft</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zRaw</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* 4 byte hash number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>	
	<comment type="block">/* 4 byte key length  */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>	
	<comment type="block">/* 8 byte data length */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* 2 byte offset of the next cell */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform a sanity check */</comment>
	<if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name>iNext</name></expr>]</index></name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>lhNewCell</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name>  <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <name>iHash</name></expr>;</expr_stmt>
	<comment type="block">/* Overflow page if any */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Cell offset */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>iOfft</name></expr>;</expr_stmt>
	<comment type="block">/* Consume the key */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhConsumeCellkey</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>unqliteDataConsumer</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>&gt;</operator> <literal type="number">262144</literal></expr> <comment type="block">/* 256 KB */</comment>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET: 14-32-chm@symisc.net: Key too large for memory */</comment>
		<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally install the cell */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhInstallCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>ppOut</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Compute the total number of free space on a given page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhPageFreeSpace</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhphdr</name> <modifier>*</modifier></type><name>pHdr</name> <init>= <expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iNext</name></decl>,<decl><type ref="prev"/><name>iAmount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pHdr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing, the page is full */</comment>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to first free block */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zRaw</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name><name>pHdr</name><operator>-&gt;</operator><name>iFree</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<comment type="block">/* Offset of the next free block */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<comment type="block">/* Available space on this block */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iAmount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nFree</name> <operator>+=</operator> <name>iAmount</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more free blocks */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next free block*/</comment>
		<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name>iNext</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Corrupt page */</comment>
			<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Save the amount of free space */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <name>nFree</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Given a primary page, load all its cell.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhLoadCells</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhphdr</name> <modifier>*</modifier></type><name>pHdr</name> <init>= <expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Calculate the amount of free space available first */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhPageFreeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pHdr</name><operator>-&gt;</operator><name>iOfft</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing, the page is empty */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to first cell */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name><name>pHdr</name><operator>-&gt;</operator><name>iOfft</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zRaw</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<comment type="block">/* Parse a single cell */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhParseOneCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>zEnd</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more cells */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next cell */</comment>
		<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Corrupt page */</comment>
			<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Given a page, parse its raw headers.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhParsePageHeader</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhphdr</name> <modifier>*</modifier></type><name>pHdr</name> <init>= <expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Offset of the first cell */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>iOfft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<comment type="block">/* Offset of the first free block */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>iFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<comment type="block">/* Slave page number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>iSlave</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate a new page instance.
 */</comment>
<function><type><specifier>static</specifier> <name>lhpage</name> <modifier>*</modifier></type> <name>lhNewPage</name><parameter_list>(
	<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>, <comment type="block">/* KV store which own this instance */</comment>
	<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl></parameter>,       <comment type="block">/* Raw page contents */</comment>
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pMaster</name></decl></parameter>           <comment type="block">/* Master page in case we are dealing with a slave page */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new instance */</comment>
	<expr_stmt><expr><name>pPage</name> <operator>=</operator> <operator>(</operator><name>lhpage</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhpage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhpage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill-in the structure */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name> <operator>=</operator> <name>pEngine</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name> <operator>=</operator> <name>pRaw</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pMaster</name></name> <operator>=</operator> <ternary><condition><expr><name>pMaster</name></expr> ?</condition><then> <expr><name>pMaster</name></expr> <comment type="block">/* Slave page */</comment> </then><else>: <expr><name>pPage</name></expr></else></ternary></expr> <comment type="block">/* Master page */</comment> ;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pMaster</name></name> <operator>!=</operator> <name>pPage</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Slave page, attach it to its master */</comment>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextSlave</name></name> <operator>=</operator> <name><name>pMaster</name><operator>-&gt;</operator><name>pSlave</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMaster</name><operator>-&gt;</operator><name>pSlave</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMaster</name><operator>-&gt;</operator><name>iSlave</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Save this instance for future fast lookup */</comment>
	<expr_stmt><expr><name><name>pRaw</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>pPage</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Load a primary and its associated slave pages from disk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhLoadPage</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>pnum</name></decl></parameter>,<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pMaster</name></decl></parameter>,<parameter><decl><type><name>lhpage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iNest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Aquire the page from the pager first */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>pnum</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pRaw</name><operator>-&gt;</operator><name>pUserData</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* The page is already parsed and loaded in memory. Point to it */</comment>
		<expr_stmt><expr><name>pPage</name> <operator>=</operator> <operator>(</operator><name>lhpage</name> <operator>*</operator><operator>)</operator><name><name>pRaw</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Allocate a new page */</comment>
		<expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>lhNewPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pRaw</name></expr></argument>,<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Process the page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhParsePageHeader</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Load cells */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhLoadCells</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* pPage will be released inside this call */</comment>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iSlave</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iNest</name> <operator>&lt;</operator> <literal type="number">128</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>pMaster</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>pMaster</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Slave page. Not a fatal error if something goes wrong here */</comment>
			<expr_stmt><expr><call><name>lhLoadPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iSlave</name></name></expr></argument>,<argument><expr><name>pMaster</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>iNest</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>ppOut</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Given a cell, Consume its key by invoking the given callback for each extracted chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhConsumeCellkey</name><parameter_list>(
	<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>, <comment type="block">/* Target cell */</comment>
	<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Consumer callback */</comment>
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>, <comment type="block">/* Last argument to xConsumer() */</comment>
	<parameter><decl><type><name>int</name></type> <name>offt_only</name></decl></parameter>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPayload</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Point to the payload area */</comment>
	<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>zRaw</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Best scenario, consume the key directly without any overflow page */</comment>
		<expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <name>L_HASH_CELL_SZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_ABORT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nByte</name></decl>,<decl><type ref="prev"/><name>nData</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOvfl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>data_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgno</name></type> <name>iOvfl</name></decl>;</decl_stmt>
		<comment type="block">/* Overflow page */</comment>
		<expr_stmt><expr><name>iOvfl</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr>;</expr_stmt>
		<comment type="block">/* Total usable bytes in an overflow page */</comment>
		<expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>L_HASH_OVERFLOW_SIZE</name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iOvfl</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nData</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* no more overflow page */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Point to the overflow page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>iOvfl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* Point to the raw content */</comment>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name>data_offset</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Get the data page and offset */</comment>
				<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zPayload</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zPayload</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>offt_only</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Key too large, grab the data offset and return */</comment>
					<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>data_offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Consume the key */</comment>
			<if_stmt><if>if<condition>( <expr><name>nData</name> <operator>&lt;=</operator> <name>nByte</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><name>nData</name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>nData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>nByte</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Next overflow page in the chain */</comment>
			<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unref the page */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Given a cell, Consume its data by invoking the given callback for each extracted chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhConsumeCellData</name><parameter_list>(
	<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>, <comment type="block">/* Target cell */</comment>
	<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Data consumer callback */</comment>
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter> <comment type="block">/* Last argument to xConsumer() */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPayload</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Point to the payload area */</comment>
	<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>zRaw</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Best scenario, consume the data directly without any overflow page */</comment>
		<expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_ABORT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu64</name></type> <name>nData</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOvfl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>fix_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nByte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgno</name></type> <name>iOvfl</name></decl>;</decl_stmt>
		<comment type="block">/* Overflow page where data is stored */</comment>
		<expr_stmt><expr><name>iOvfl</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name></expr>;</expr_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iOvfl</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nData</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* no more overflow page */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Point to the overflow page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>iOvfl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Point to the raw content */</comment>
			<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name>fix_offset</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Point to the data */</comment>
				<expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>-</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>fix_offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zPayload</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
				<comment type="block">/* Total usable bytes in an overflow page */</comment>
				<expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>L_HASH_OVERFLOW_SIZE</name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Consume the data */</comment>
			<if_stmt><if>if<condition>( <expr><name>nData</name> <operator>&lt;=</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nData</name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>nData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>nByte</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Next overflow page in the chain */</comment>
			<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unref the page */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Read the linear hash header (Page one of the database).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_read_header</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pHeader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pHeader</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_bmap_page</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name></name> <operator>=</operator> <name>pHeader</name></expr>;</expr_stmt>
	<comment type="block">/* 4 byte magic number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nMagic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>!=</operator> <name>L_HASH_MAGIC</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Corrupt implementation */</comment>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* 4 byte hash value to identify a valid hash function */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* Sanity check */</comment>
	<if_stmt><if>if<condition>( <expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name>L_HASH_WORD</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>L_HASH_WORD</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nHash</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Different hash function */</comment>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xErr</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="string">"Invalid hash function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* List of free pages */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Current split bucket */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Maximum split bucket */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Next generation */</comment>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Initialiaze the bucket map */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sPageMap</name></name></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNum</name></name> <operator>=</operator> <name><name>pHeader</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
	<comment type="block">/* Next page in the bucket map */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Total number of records in the bucket map (This page only) */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zRaw</name> <operator>-</operator> <name><name>pHeader</name><operator>-&gt;</operator><name>zData</name></name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* Load the map in memory */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhMapLoadPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pMap</name></expr></argument>,<argument><expr><name><name>pHeader</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Load the bucket map chain if any */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<decl_stmt><decl><type><name>pgno</name></type> <name>iNext</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>iNext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more map pages */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the target page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>iNext</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Fill in the structure */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNum</name></name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Load the map in memory */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhMapLoadPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pMap</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a record lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRecordLookup</name><parameter_list>(
	<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>, <comment type="block">/* KV storage engine */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,         <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>,              <comment type="block">/* Key length */</comment>
	<parameter><decl><type><name>lhcell</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCell</name></decl></parameter>           <comment type="block">/* OUT: Target cell on success */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Acquire the first page (hash Header) so that everything gets loaded autmatically */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Compute the hash of the key first */</comment>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract the logical (i.e. not real) page number */</comment>
	<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iBucket</name> <operator>&gt;=</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name> <operator>+</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Low mask */</comment>
		<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Map the logical bucket number to real page number */</comment>
	<expr_stmt><expr><name>pRec</name> <operator>=</operator> <call><name>lhMapFindBucket</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>iBucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* No such entry */</comment>
		<return>return <expr><name>UNQLITE_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Load the master page and it's slave page in-memory  */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhLoadPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>iReal</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* IO error, unlikely scenario */</comment>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Lookup for the cell */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>lhFindCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* No such entry */</comment>
		<return>return <expr><name>UNQLITE_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>ppCell</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ppCell</name> <operator>=</operator> <name>pCell</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Acquire a new page either from the free list or ask the pager
 * for a new one.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhAcquirePage</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Acquire one from the free list */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Point to the next free page */</comment>
			<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Update the database header */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*Magic*/</comment><operator>+</operator><literal type="number">4</literal></expr><comment type="block">/*Hash*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Tell the pager do not journal this page */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xDontJournal</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Return to the caller */</comment>
			<expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
			<comment type="block">/* All done */</comment>
			<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Acquire a new page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target page */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write a bucket map record to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhMapWriteRecord</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iLogic</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iReal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_bmap_page</name> <modifier>*</modifier></type><name>pMap</name> <init>= <expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sPageMap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>-</operator> <literal type="number">16</literal><operator>)</operator></expr> <comment type="block">/* 8 byte logical bucket number + 8 byte real bucket number */</comment> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
		<comment type="block">/* Point to the old page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNum</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Acquire a new page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Reflect the change  */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNum</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <literal type="number">8</literal><comment type="block">/* Next page number */</comment><operator>+</operator><literal type="number">4</literal></expr><comment type="block">/* Total records in the map*/</comment>;</expr_stmt>
		<comment type="block">/* Link this page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>iPage</name></name> <operator>==</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>iPage</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* First page (Hash header) */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOld</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*magic*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*hash*/</comment><operator>+</operator><literal type="number">8</literal><comment type="block">/* Free page */</comment><operator>+</operator><literal type="number">8</literal><comment type="block">/*current split bucket*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Maximum split bucket*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Link the new page */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unref */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Assume the last bucket map page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next bucket map page on the list */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<comment type="block">/* Point to the current map page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNum</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make page writable */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Write the data */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr></argument>,<argument><expr><name>iLogic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr></argument>,<argument><expr><name>iReal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Install the bucket map */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhMapInstallBucket</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>iLogic</name></expr></argument>,<argument><expr><name>iReal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Total number of records */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>iPage</name></name> <operator>==</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>iPage</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Page one: Always writable */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(
				<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*magic*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*hash*/</comment><operator>+</operator><literal type="number">8</literal><comment type="block">/* Free page */</comment><operator>+</operator><literal type="number">8</literal><comment type="block">/*current split bucket*/</comment><operator>+</operator><literal type="number">8</literal><comment type="block">/*Maximum split bucket*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Next map page*/</comment>]</index></name></expr></argument>,
				<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Make page writable */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>nRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Defragment a page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhPageDefragment</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zTmp</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zPtr</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zPayload</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<comment type="block">/* Get a temporary page from the pager. This opertaion never fail */</comment>
	<expr_stmt><expr><name>zTmp</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xTmpPage</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Move the target cells to the beginning */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pMaster</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	<comment type="block">/* Write the slave page number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zTmp</name><index>[<expr><literal type="number">2</literal><comment type="block">/*Offset of the first cell */</comment><operator>+</operator><literal type="number">2</literal></expr><comment type="block">/*Offset of the first free block */</comment>]</index></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iSlave</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zTmp</name><index>[<expr><name>L_HASH_PAGE_HDR_SZ</name></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* Offset to start writing from */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zTmp</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Offset of the first cell */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more cells */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name> <operator>==</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Cell payload if locally stored */</comment>
			<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Move the cell */</comment>
			<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zPtr</name> <operator>-</operator> <name>zTmp</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Offset where this cell start */</comment>
			<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr>;</expr_stmt>
			<comment type="block">/* Write the cell header */</comment>
			<comment type="block">/* 4 byte hash number */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<comment type="block">/* 4 byte ley length */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<comment type="block">/* 8 byte data length */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<comment type="block">/* 2 byte offset of the next cell */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<comment type="block">/* 8 byte overflow page number */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>zPayload</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Local payload */</comment>
				<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Can't happen */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next page */</comment>
		<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Mark the free block */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zPtr</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Block length */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zPtr</name> <operator>-</operator> <name>zTmp</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Offset of the free block */</comment>
		<comment type="block">/* Mark the block */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Offset of the next free block */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Block length */</comment>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Block of length less than 4 bytes are simply discarded */</comment>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Reflect the change */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zTmp</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* Offset of the first cell */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zTmp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Offset of the first free block */</comment>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zTmp</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Allocate nByte bytes of space on a page.
**
** Return the index into pPage-&gt;pRaw-&gt;zData[] of the first byte of
** the new allocation. Or return 0 if there is not enough free
** space on the page to satisfy the allocation request.
**
** If the page contains nBytes of free space but does not contain
** nBytes of contiguous free space, then this routine automatically
** calls defragementPage() to consolidate all free space before 
** allocating the new chunk.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhAllocateSpace</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,<parameter><decl><type><name>sxu64</name></type> <name>nAmount</name></decl></parameter>,<parameter><decl><type><name>sxu16</name> <modifier>*</modifier></type><name>pOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iNext</name></decl>,<decl><type ref="prev"/><name>iBlksz</name></decl>,<decl><type ref="prev"/><name>nByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPrev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>sxu64</name><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>&lt;</operator> <name>nAmount</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother looking for a free chunk */</comment>
		<return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>nAmount</name> <operator>&gt;=</operator> <operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Big chunk need an overflow page for its data */</comment>
		<return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><name>nAmount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPrev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>iBlksz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* Perform the lookup */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Offset of the next free block */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Block size */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iBlksz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iBlksz</name> <operator>&gt;=</operator> <name>nByte</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Got one */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zPrev</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more free blocks, defragment the page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhPageDefragment</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>&gt;=</operator> <name>nByte</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* Free blocks are merged together */</comment>
				<expr_stmt><expr><name>iNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>iBlksz</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPrev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if><else>else<block>{<block_content>
				<return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next free block */</comment>
		<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name>iNext</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Acquire writer lock on this page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Save block offset */</comment>
	<expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zPtr</name> <operator>-</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* Fix pointers */</comment>
	<if_stmt><if>if<condition>( <expr><name>iBlksz</name> <operator>&gt;=</operator> <name>nByte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iBlksz</name> <operator>-</operator> <name>nByte</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBlock</name> <init>= <expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><operator>(</operator><operator>*</operator><name>pOfft</name><operator>)</operator> <operator>+</operator> <name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Create a new block */</comment>
		<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zBlock</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zBlock</name></expr></argument>,<argument><expr><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Offset of the next block */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBlock</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>iBlksz</name><operator>-</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Block size*/</comment>
		<comment type="block">/* Offset of the new block */</comment>
		<expr_stmt><expr><name>iNext</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zPtr</name> <operator>-</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>iBlksz</name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fix offsets */</comment>
	<if_stmt><if>if<condition>( <expr><name>zPrev</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zPrev</name></expr></argument>,<argument><expr><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* First block */</comment>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
		<comment type="block">/* Reflect on the page header */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">2</literal></expr><comment type="block">/* Offset of the first cell1*/</comment>]</index></name></expr></argument>,<argument><expr><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* All done */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>-=</operator> <name>iBlksz</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write the cell header into the corresponding offset.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCellWriteHeader</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Seek to the desired location */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr>;</expr_stmt>
	<comment type="block">/* 4 byte hash number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* 4 byte key length */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* 8 byte data length */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* 2 byte offset of the next cell */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<comment type="block">/* 8 byte overflow page number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Update the page header */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr>;</expr_stmt>
	<comment type="block">/* pEngine-&gt;pIo-&gt;xWrite() has been successfully called on this page */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write local payload.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCellWriteLocalPayload</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeylen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDatalen</name></decl></parameter>
	)</parameter_list>
<block>{<block_content>
	<comment type="block">/* A writer lock have been acquired on this page */</comment>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Seek to the desired location */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name></expr>;</expr_stmt>
	<comment type="block">/* Write the key */</comment>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nKeylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nKeylen</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nDatalen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Write the Data */</comment>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>pData</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nDatalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate as much overflow page we need to store the cell payload.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCellWriteOvflPayload</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeylen</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOvfl</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pFirst</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zRawEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nAvail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Acquire a new overflow page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Acquire a writer lock */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name>pOvfl</name></expr>;</expr_stmt>
	<comment type="block">/* Link */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>=</operator> <name><name>pOvfl</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
	<comment type="block">/* Update the cell header */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal><comment type="block">/*Hash*/</comment> <operator>+</operator> <literal type="number">4</literal><comment type="block">/*Key*/</comment> <operator>+</operator> <literal type="number">8</literal><comment type="block">/*Data*/</comment> <operator>+</operator> <literal type="number">2</literal></expr> <comment type="block">/*Next cell*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Start the write process */</comment>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zPtr</name><index>[<expr><name>nKeylen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next overflow page on the chain */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal><comment type="block">/* Next ovfl page*/</comment> <operator>+</operator> <literal type="number">8</literal> <comment type="block">/* Data page */</comment> <operator>+</operator> <literal type="number">2</literal></expr> <comment type="block">/* Data offset*/</comment>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pOvfl</name></expr>;</expr_stmt>
	<comment type="block">/* Write the key */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zRawEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Acquire a new page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Link */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next overflow page on the chain */</comment>
			<expr_stmt><expr><name>pOvfl</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nAvail</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zRawEnd</name><operator>-</operator><name>zRaw</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nKeylen</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nKeylen</name> <operator>&gt;</operator> <name>nAvail</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nKeylen</name> <operator>=</operator> <name>nAvail</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nKeylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Synchronize pointers */</comment>
		<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <name>nKeylen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nKeylen</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>nKeylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zRaw</name><operator>-</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* Write the data page and its offset */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFirst</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr><comment type="block">/*Next ovfl*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFirst</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal><comment type="block">/*Next ovfl*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Data page*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Write data */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nDatalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu64</name></type> <name>nData</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pData</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more chunks */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nData</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>sxu64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Write this chunk */</comment>
		<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zPtr</name><index>[<expr><name>nData</name></expr>]</index></name></expr>;</expr_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zRawEnd</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Acquire a new page */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>rc</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>rc</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Link */</comment>
				<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next overflow page on the chain */</comment>
				<expr_stmt><expr><name>pOvfl</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nAvail</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zRawEnd</name><operator>-</operator><name>zRaw</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nDatalen</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nDatalen</name> <operator>&gt;</operator> <name>nAvail</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nDatalen</name> <operator>=</operator> <name>nAvail</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nDatalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Synchronize pointers */</comment>
			<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <name>nDatalen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nDatalen</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<comment type="block">/* Unref the overflow page */</comment>
	<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Restore a page to the free list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRestorePage</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Link to the list of free page */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*Magic*/</comment><operator>+</operator><literal type="number">4</literal></expr><comment type="block">/*Hash*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nFreeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Restore cell space and mark it as a free block.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRestoreSpace</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,<parameter><decl><type><name>sxu16</name></type> <name>iOfft</name></decl></parameter>,<parameter><decl><type><name>sxu16</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* At least 4 bytes of freespace must form a valid block */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* pEngine-&gt;pIo-&gt;xWrite() has been successfully called on this page */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name>iOfft</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Mark as a free block */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Offset of the next free block */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Link */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">2</literal></expr><comment type="block">/* offset of the first cell */</comment>]</index></name></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iFree</name></name> <operator>=</operator> <name>iOfft</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>lhcell</name> <modifier>*</modifier></type> <name>lhFindSibeling</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * Unlink a cell.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhUnlinkCell</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nByte</name> <init>= <expr><name>L_HASH_CELL_SZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Bring the link */</comment>
	<expr_stmt><expr><name>pPrev</name> <operator>=</operator> <call><name>lhFindSibeling</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPrev</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPrev</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
		<comment type="block">/* Fix offsets in the page header */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pPrev</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal><comment type="block">/*Hash*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*Key*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Data*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* First entry on this page (either master or slave) */</comment>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
		<comment type="block">/* Update the page header */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Restore cell space */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Discard the cell from the in-memory hashtable */</comment>
	<expr_stmt><expr><call><name>lhCellDiscard</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Remove a cell and its paylod (key + data).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRecordRemove</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<comment type="block">/* Discard overflow pages */</comment>
		<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOvfl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgno</name></type> <name>iNext</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<comment type="block">/* Point to the overflow page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>iNext</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Next page on the chain */</comment>
			<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Restore the page to the free list */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRestorePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Unref */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Unlink the cell */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhUnlinkCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Find cell sibeling.
 */</comment>
<function><type><specifier>static</specifier> <name>lhcell</name> <modifier>*</modifier></type> <name>lhFindSibeling</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pMaster</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt> 
	<while>while<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pPage</name></name> <operator>==</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>iNext</name></name> <operator>==</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Sibeling found */</comment>
			<return>return <expr><name>pEntry</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the previous entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> 
	</block_content>}</block></while>
	<comment type="block">/* Last inserted cell */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Move a cell to a new location with its new data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhMoveLocalCell</name><parameter_list>(
	<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,
	<parameter><decl><type><name>sxu16</name></type> <name>iOfft</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,
	<parameter><decl><type><name>unqlite_int64</name></type> <name>nData</name></decl></parameter>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iKeyOfft</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pSibeling</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pSibeling</name> <operator>=</operator> <call><name>lhFindSibeling</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pSibeling</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Fix link */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pSibeling</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal><comment type="block">/*Hash*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*Key*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Data*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pSibeling</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* First cell, update page header only */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iOfft</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Set the new offset */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>iOfft</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nData</name></expr>;</expr_stmt>
	<comment type="block">/* Write the cell payload */</comment>
	<expr_stmt><expr><call><name>lhCellWriteLocalPayload</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name>iKeyOfft</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Finally write the cell header */</comment>
	<expr_stmt><expr><call><name>lhCellWriteHeader</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Overwrite an existing record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRecordOverwrite</name><parameter_list>(
	<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nByte</name></decl></parameter>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zRawEnd</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zPayload</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOvfl</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pOld</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nAvail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iOvfl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Acquire a writer lock on this page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Local payload, try to deal with the free space issues */</comment>
		<expr_stmt><expr><name>zPayload</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>==</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Best scenario, simply a memcpy operation */</comment>
			<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>pData</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name> <operator>&lt;</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Shorter data, not so ugly */</comment>
			<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>pData</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zPayload</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Update the cell header */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal> <comment type="block">/* Hash */</comment> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* Key */</comment>]</index></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Restore freespace */</comment>
			<expr_stmt><expr><call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name>nByte</name><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>-</operator> <name>nByte</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* New data size */</comment>
			<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>sxu16</name></type> <name>iOfft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
			<comment type="block">/* Check if another chunk is available for this cell */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name>nByte</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Transfer the payload to an overflow page */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCellWriteOvflPayload</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<return>return <expr><name>rc</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Update the cell header */</comment>
				<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal> <comment type="block">/* Hash */</comment> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* Key */</comment>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Restore freespace */</comment>
				<expr_stmt><expr><call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* New data size */</comment>
				<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<decl_stmt><decl><type><name>sxu16</name></type> <name>iOldOfft</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>sxu32</name></type> <name>iOld</name> <init>= <expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></init></decl>;</decl_stmt>
				<comment type="block">/* Space is available, transfer the cell */</comment>
				<expr_stmt><expr><call><name>lhMoveLocalCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Restore cell space */</comment>
				<expr_stmt><expr><call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>iOldOfft</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name>iOld</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the overflow page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Relase all old overflow pages first */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pOld</name> <operator>=</operator> <name>pOvfl</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>iOvfl</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more overflow pages on the chain */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the target page */</comment>
		<if_stmt><if>if<condition>( <expr><name>UNQLITE_OK</name> <operator>!=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>iOvfl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOld</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Not so fatal if something goes wrong here */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Next overflow page to be released */</comment>
		<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pOld</name> <operator>!=</operator> <name>pOvfl</name></expr> )</condition><block>{<block_content> <comment type="block">/* xx: chm is maniac */</comment>
			<comment type="block">/* Restore the page to the free list */</comment>
			<expr_stmt><expr><call><name>lhRestorePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unref */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Point to the data offset */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* The data to be stored */</comment>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zPtr</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Start the overwrite process */</comment>
	<comment type="block">/* Acquire a writer lock */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nLen</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zRawEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Acquire a new page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Link */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next overflow page on the chain */</comment>
			<expr_stmt><expr><name>pOvfl</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nAvail</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zRawEnd</name><operator>-</operator><name>zRaw</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <name>nAvail</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nAvail</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Synchronize pointers */</comment>
		<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Unref the last overflow page */</comment>
	<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Finally, update the cell header */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal> <comment type="block">/* Hash */</comment> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* Key */</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Append data to an existing record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRecordAppend</name><parameter_list>(
	<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nByte</name></decl></parameter>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zRawEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pOvfl</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu64</name></type> <name>nDatalen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nAvail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iOvfl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>nByte</name> <operator>&lt;</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Overflow */</comment>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xErr</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="string">"Append operation will cause data overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_LIMIT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Acquire a writer lock on this page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxu16</name></type> <name>iOfft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
		<comment type="block">/* Local payload, check for a bigger place */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>nByte</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Transfer the payload to an overflow page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCellWriteOvflPayload</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,
				<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>,
				<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,
				<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Update the cell header */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal> <comment type="block">/* Hash */</comment> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* Key */</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Restore freespace */</comment>
			<expr_stmt><expr><call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name><operator>)</operator></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* New data size */</comment>
			<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>sxu16</name></type> <name>iOldOfft</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>iOld</name> <init>= <expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SyBlob</name></type> <name>sWorker</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Copy the old data */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Append the new data */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Space is available, transfer the cell */</comment>
			<expr_stmt><expr><call><name>lhMoveLocalCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>,<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>(</operator><name>unqlite_int64</name><operator>)</operator><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Restore cell space */</comment>
			<expr_stmt><expr><call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>iOldOfft</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>L_HASH_CELL_SZ</name> <operator>+</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>+</operator> <name>iOld</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* All done */</comment>
			<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the overflow page which hold the data */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Next overflow page in the chain */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the end of the chunk */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDatalen</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nAvail</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zRawEnd</name> <operator>-</operator> <name>zRaw</name><operator>)</operator></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zRawEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iOvfl</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Cant happen */</comment>
				<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xErr</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="string">"Corrupt overflow page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>iOvfl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Next overflow page on the chain */</comment>
			<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unref the previous overflow page */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Point to the new chunk */</comment>
			<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nAvail</name> <operator>=</operator> <call><name>L_HASH_OVERFLOW_SIZE</name><argument_list>(<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pOvfl</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>sxu64</name><operator>)</operator><name>nAvail</name> <operator>&gt;</operator> <name>nDatalen</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nDatalen</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>nDatalen</name> <operator>-=</operator> <name>nAvail</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nAvail</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Start the append process */</comment>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zPtr</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Acquire a writer lock */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nLen</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&gt;=</operator> <name>zRawEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Acquire a new page */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Link */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pOvfl</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next overflow page on the chain */</comment>
			<expr_stmt><expr><name>pOvfl</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zRawEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pEngine</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nAvail</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zRawEnd</name><operator>-</operator><name>zRaw</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <name>nAvail</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nAvail</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Synchronize pointers */</comment>
		<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Unref the last overflow page */</comment>
	<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Finally, update the cell header */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <literal type="number">4</literal> <comment type="block">/* Hash */</comment> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* Key */</comment>]</index></name></expr></argument>,<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * A write privilege have been acquired on this page.
 * Mark it as an empty page (No cells).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhSetEmptyPage</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhphdr</name> <modifier>*</modifier></type><name>pHeader</name> <init>= <expr><operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>sHdr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Acquire a writer lock */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Offset of the first cell */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<comment type="block">/* Offset of the first free block */</comment>
	<expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>iFree</name></name> <operator>=</operator> <name>L_HASH_PAGE_HDR_SZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>L_HASH_PAGE_HDR_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<comment type="block">/* Slave page number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Fill the free block */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Offset of the next free block */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><call><name>L_HASH_MX_FREE_SPACE</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nFree</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
	<comment type="block">/* Do not add this page to the hot dirty list */</comment>
	<expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xDontMkHot</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>lhSlaveStore</name><parameter_list>(
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter>,
	<parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter>
	)</parameter_list>;</function_decl>
<comment type="block">/*
 * Store a cell and its payload in a given page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhStoreCell</name><parameter_list>(
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <comment type="block">/* Target page */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>, <comment type="block">/* Payload: Key */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter>, <comment type="block">/* Payload: Data */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter>, <comment type="block">/* Hash of the key */</comment>
	<parameter><decl><type><name>int</name></type> <name>auto_append</name></decl></parameter> <comment type="block">/* Auto append a slave page if full */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iNeedOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Need overflow page for this cell and its payload*/</comment>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Acquire a writer lock on this page first */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Check for a free block  */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name><operator>+</operator><name>nKeyLen</name><operator>+</operator><name>nDataLen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Check for a free block to hold a single cell only (without payload) */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name>auto_append</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* A split must be done */</comment>
				<return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Store this record in a slave page */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhSlaveStore</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>iNeedOvfl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a new cell instance */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>lhNewCell</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xErr</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="string">"KV store is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fill-in the structure */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>nOfft</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <name>nKeyLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <operator>(</operator><name>sxu64</name><operator>)</operator><name>nDataLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <name>nHash</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nKeyLen</name> <operator>&lt;</operator> <literal type="number">262144</literal></expr> <comment type="block">/* 256 KB */</comment> )</condition><block>{<block_content>
		<comment type="block">/* Keep the key in-memory for fast lookup */</comment>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Link the cell */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhInstallCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Write the payload */</comment>
	<if_stmt><if>if<condition>( <expr><name>iNeedOvfl</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCellWriteOvflPayload</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>lhCellDiscard</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>lhCellWriteLocalPayload</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Finally, Write the cell header */</comment>
	<expr_stmt><expr><call><name>lhCellWriteHeader</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Find a slave page capable of hosting the given amount.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhFindSlavePage</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,<parameter><decl><type><name>sxu64</name></type> <name>nAmount</name></decl></parameter>,<parameter><decl><type><name>sxu16</name> <modifier>*</modifier></type><name>pOfft</name></decl></parameter>,<parameter><decl><type><name>lhpage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSlave</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pMaster</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pMaster</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pSlave</name> <init>= <expr><name><name>pMaster</name><operator>-&gt;</operator><name>pSlave</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>iOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Look for an already attached slave page */</comment>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pMaster</name><operator>-&gt;</operator><name>iSlave</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Find a free chunk big enough */</comment>
		<decl_stmt><decl><type><name>sxu16</name></type> <name>size</name> <init>= <expr><name>L_HASH_CELL_SZ</name> <operator>+</operator> <name>nAmount</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pSlave</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* A space for cell header only */</comment>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <name>L_HASH_CELL_SZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pSlave</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* All done */</comment>
			<if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <name>iOfft</name></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRestoreSpace</name><argument_list>(<argument><expr><name>pSlave</name></expr></argument>, <argument><expr><name>iOfft</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>ppSlave</name> <operator>=</operator> <name>pSlave</name></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next slave page */</comment>
		<expr_stmt><expr><name>pSlave</name> <operator>=</operator> <name><name>pSlave</name><operator>-&gt;</operator><name>pNextSlave</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Acquire a new slave page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Last slave page */</comment>
	<expr_stmt><expr><name>pSlave</name> <operator>=</operator> <name><name>pMaster</name><operator>-&gt;</operator><name>pSlave</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pSlave</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* First slave page */</comment>
		<expr_stmt><expr><name>pSlave</name> <operator>=</operator> <name>pMaster</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Initialize the page */</comment>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>lhNewPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pRaw</name></expr></argument>,<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Mark as an empty page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhSetEmptyPage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Look for a free block */</comment>
		<if_stmt><if>if<condition>( <expr><name>UNQLITE_OK</name> <operator>!=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name><operator>+</operator><name>nAmount</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Cell header only */</comment>
			<expr_stmt><expr><call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Never fail */</comment>
		</block_content>}</block></if></if_stmt>	
		<expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <name>iOfft</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Link this page to the previous slave page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pSlave</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Reflect in the page header */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSlave</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">2</literal><comment type="block">/*Cell offset*/</comment><operator>+</operator><literal type="number">2</literal></expr><comment type="block">/*Free block offset*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSlave</name><operator>-&gt;</operator><name>sHdr</name><operator>.</operator><name>iSlave</name></name> <operator>=</operator> <name><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppSlave</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* pNew will be released in this call */</comment>
	<return>return <expr><name>rc</name></expr>;</return>

</block_content>}</block></function>
<comment type="block">/*
 * Perform a store operation in a slave page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhSlaveStore</name><parameter_list>(
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <comment type="block">/* Master page */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>, <comment type="block">/* Payload: key */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter>, <comment type="block">/* Payload: data */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter> <comment type="block">/* Hash of the key */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pSlave</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Find a slave page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhFindSlavePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>nKeyLen</name> <operator>+</operator> <name>nDataLen</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pSlave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the insertion in the slave page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhStoreCell</name><argument_list>(<argument><expr><name>pSlave</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Transfer a cell to a new page (either a master or slave).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhTransferCell</name><parameter_list>(<parameter><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pTarget</name></decl></parameter>,<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Check for a free block to hold a single cell only */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAllocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Store in a slave page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhFindSlavePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>L_HASH_CELL_SZ</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a new cell instance */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>lhNewCell</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fill-in the structure */</comment>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>nOfft</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name>  <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name>   <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name>  <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>iOvfl</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataOfft</name></name> <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>iDataOfft</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iDataPage</name></name> <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>iDataPage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobDup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTarget</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Link the cell */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhInstallCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally, Write the cell header */</comment>
	<expr_stmt><expr><call><name>lhCellWriteHeader</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a page split.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhPageSplit</name><parameter_list>(
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>,      <comment type="block">/* Page to be split */</comment>
	<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>,      <comment type="block">/* New page */</comment>
	<parameter><decl><type><name>pgno</name></type> <name>split_bucket</name></decl></parameter>, <comment type="block">/* Current split bucket */</comment>
	<parameter><decl><type><name>pgno</name></type> <name>high_mask</name></decl></parameter>     <comment type="block">/* High mask (Max split bucket - 1) */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyBlob</name></type> <name>sWorker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt> 
	<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pOld</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the split */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	<for>for<control>( <init>;</init><condition>;</condition> <incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more cells */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Obtain the new logical bucket */</comment>
		<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <name>high_mask</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator>  <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iBucket</name> <operator>!=</operator> <name>split_bucket</name></expr>)</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pCell</name><operator>-&gt;</operator><name>iOvfl</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Transfer the cell only */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhTransferCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Transfer the cell and its payload */</comment>
				<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Consume the key */</comment>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhConsumeCellkey</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>unqliteDataConsumer</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
						<goto>goto <name>fail</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Consume the data (Very small data &lt; 65k) */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhConsumeCellData</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>unqliteDataConsumer</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<goto>goto <name>fail</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Perform the transfer */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhStoreCell</name><argument_list>(
					<argument><expr><name>pNew</name></expr></argument>,
					<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>,
					<argument><expr><literal type="number">1</literal></expr></argument>
					)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<goto>goto <name>fail</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Discard the cell from the old page */</comment>
			<expr_stmt><expr><call><name>lhUnlinkCell</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next cell */</comment>
		<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* All done */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform the infamous linear hash split operation.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhSplit</name><parameter_list>(<parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pTarget</name></decl></parameter>,<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRetry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pTarget</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pOld</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Get the real page number of the bucket to split */</comment>
	<expr_stmt><expr><name>pRec</name> <operator>=</operator> <call><name>lhMapFindBucket</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Can't happen */</comment>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Load the page to be split */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhLoadPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>iReal</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pOld</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Request a new page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Initialize the page */</comment>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>lhNewPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Mark as an empty page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhSetEmptyPage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Install and write the logical map record */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhMapWriteRecord</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,
		<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name> <operator>+</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name></expr></argument>,
		<argument><expr><name><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pTarget</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name> <operator>==</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pRetry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the split */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhPageSplit</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>,<argument><expr><name>pNew</name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Update the database header */</comment>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* Acquire a writer lock on the first page */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name> <operator>&gt;=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Increment the generation number */</comment>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If this happen to your installation, please tell us &lt;chm@symisc.net&gt; */</comment>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xErr</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="string">"Database page (64-bit integer) limit reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_LIMIT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Reflect in the page header */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*Magic*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*Hash*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Free list*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*Magic*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*Hash*/</comment><operator>+</operator><literal type="number">8</literal><comment type="block">/*Free list*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Split bucket*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Modify only the split bucket */</comment>
		<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal><comment type="block">/*Magic*/</comment><operator>+</operator><literal type="number">4</literal><comment type="block">/*Hash*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/*Free list*/</comment>]</index></name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Store a record in the target page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhRecordInstall</name><parameter_list>(
	  <parameter><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <comment type="block">/* Target page */</comment>
	  <parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter>,   <comment type="block">/* Hash of the key */</comment>
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>,          <comment type="block">/* Payload: Key */</comment>
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter> <comment type="block">/* Payload: Data */</comment>
	  )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhStoreCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_FULL</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>do_retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Split */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhSplit</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>do_retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>do_retry</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Re-calculate logical bucket number */</comment>
				<return>return <expr><name>SXERR_RETRY</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Perform the store */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhStoreCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Insert a record (Either overwrite or append operation) in our database.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lh_record_insert</name><parameter_list>(
	  <parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pKv</name></decl></parameter>,         <comment type="block">/* KV store */</comment>
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>, <comment type="block">/* Payload: Key */</comment>
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter>, <comment type="block">/* Payload: data */</comment>
	  <parameter><decl><type><name>int</name></type> <name>is_append</name></decl></parameter> <comment type="block">/* True for an append operation */</comment>
	  )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name>pKv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iCnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* Acquire the first page (DB hash Header) so that everything gets loaded autmatically */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Compute the hash of the key first */</comment>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name>pKey</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>retry</name>:</label>
	<comment type="block">/* Extract the logical bucket number */</comment>
	<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iBucket</name> <operator>&gt;=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name> <operator>+</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Low mask */</comment>
		<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Map the logical bucket number to real page number */</comment>
	<expr_stmt><expr><name>pRec</name> <operator>=</operator> <call><name>lhMapFindBucket</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>iBucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Request a new page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhAcquirePage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Initialize the page */</comment>
		<expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>lhNewPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Mark as an empty page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhSetEmptyPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* pPage will be released during this call */</comment>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Store the cell */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhStoreCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Install and write the logical map record */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhMapWriteRecord</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>iBucket</name></expr></argument>,<argument><expr><name><name>pRaw</name><operator>-&gt;</operator><name>iPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name>pRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Load the page */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhLoadPage</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>iReal</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* IO error, unlikely scenario */</comment>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Do not add this page to the hot dirty list */</comment>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xDontMkHot</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Lookup for the cell */</comment>
		<expr_stmt><expr><name>pCell</name> <operator>=</operator> <call><name>lhFindCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nKeyLen</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pCell</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Create the record */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRecordInstall</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>nHash</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_RETRY</name> <operator>&amp;&amp;</operator> <name>iCnt</name><operator>++</operator> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>is_append</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Append operation */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRecordAppend</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Overwrite old value */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRecordOverwrite</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Replace method.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_kv_replace</name><parameter_list>(
	  <parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pKv</name></decl></parameter>,
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nKeyLen</name></decl></parameter>,
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter>
	  )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lh_record_insert</name><argument_list>(<argument><expr><name>pKv</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Append method.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_kv_append</name><parameter_list>(
	  <parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pKv</name></decl></parameter>,
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nKeyLen</name></decl></parameter>,
	  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name></type> <name>nDataLen</name></decl></parameter>
	  )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lh_record_insert</name><argument_list>(<argument><expr><name>pKv</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nKeyLen</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>,<argument><expr><name>nDataLen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write the hash header (Page one).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_write_header</name><parameter_list>(<parameter><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pHeader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pHeader</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_bmap_page</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pHeader</name></name> <operator>=</operator> <name>pHeader</name></expr>;</expr_stmt>
	<comment type="block">/* 4 byte magic number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>nMagic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* 4 byte hash value to identify a valid hash function */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name>L_HASH_WORD</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>L_HASH_WORD</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* List of free pages: Empty */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Current split bucket */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Maximum split bucket */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>max_split_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Initialiaze the bucket map */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sPageMap</name></name></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNum</name></name> <operator>=</operator> <name><name>pHeader</name><operator>-&gt;</operator><name>iPage</name></name></expr>;</expr_stmt>
	<comment type="block">/* Next page in the bucket map */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Total number of records in the bucket map */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zRaw</name> <operator>-</operator> <name><name>pHeader</name><operator>-&gt;</operator><name>zData</name></name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
 </block_content>}</block></function>
<comment type="block">/*
 * Exported: xOpen() method.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_kv_open</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>dbSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name>pEngine</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>dbSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* A new database, create the header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Acquire a writer lock */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Write the hash header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhash_write_header</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>,<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Acquire the page one of the database */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Read the database header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhash_read_header</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>,<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Release a master or slave page. (xUnpin callback).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lhash_page_release</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>lhpage</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pNext</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pCell</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Drop in-memory cells */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nCell</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Release the cell instance */</comment>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the cell table */</comment>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>apCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally, release the whole page */</comment>
	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEngine</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRaw</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Default hash function (DJB).
 */</comment>
<function><type><specifier>static</specifier> <name>sxu32</name></type> <name>lhash_bin_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nH</name> <init>= <expr><literal type="number">5381</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">2048</literal></expr> <comment type="block">/* 2K */</comment> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <literal type="number">2048</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>	
	<return>return <expr><name>nH</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Exported: xInit() method.
 * Initialize the Key value storage engine.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_kv_init</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iPageSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name>pEngine</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* This structure is always zeroed, go to the initialization directly */</comment>
	<expr_stmt><expr><call><name>SyMemBackendInitFromParent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><call><name>unqliteExportMemBackend</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//#if defined(UNQLITE_ENABLE_THREADS)</comment>
<comment type="line">//	/* Already protected by the upper layers */</comment>
<comment type="line">//	SyMemBackendDisbaleMutexing(&amp;pHash-&gt;sAllocator);</comment>
<comment type="line">//#endif</comment>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>=</operator> <name>iPageSize</name></expr>;</expr_stmt>
	<comment type="block">/* Default hash function */</comment>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>xHash</name></name> <operator>=</operator> <name>lhash_bin_hash</name></expr>;</expr_stmt>
	<comment type="block">/* Default comparison function */</comment>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <name>SyMemcmp</name></expr>;</expr_stmt>
	<comment type="block">/* Allocate a new record map */</comment>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apMap</name></name> <operator>=</operator> <operator>(</operator><name>lhash_bmap_rec</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>,<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>lhash_bmap_rec</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>apMap</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the table */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>apMap</name></name></expr></argument>,<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>nBuckSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lhash_bmap_rec</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Linear hashing components */</comment>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>split_bucket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Logical not real bucket number */</comment>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>max_split_bucket</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nmax_split_nucket</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>L_HASH_MAGIC</name></expr>;</expr_stmt>
	<comment type="block">/* Install the cache unpin and reload callbacks */</comment>
	<expr_stmt><expr><call><name><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xSetUnpin</name></name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>lhash_page_release</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xSetReload</name></name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><name>lhash_page_release</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>SyMemBackendRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Exported: xRelease() method.
 * Release the Key value storage engine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lhash_kv_release</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name>pEngine</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Release the private memory backend */</comment>
	<expr_stmt><expr><call><name>SyMemBackendRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 *  Exported: xConfig() method.
 *  Configure the linear hash KV store.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhash_kv_config</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name>pEngine</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
	<case>case <expr><name>UNQLITE_KV_CONFIG_HASH_FUNC</name></expr>:</case> <block>{<block_content>
		<comment type="block">/* Default hash function */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>nBuckRec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Locked operation */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_LOCKED</name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>ProcHash</name></type> <name>xHash</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>ProcHash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name>xHash</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>xHash</name></name> <operator>=</operator> <name>xHash</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
									  </block_content>}</block>
	<case>case <expr><name>UNQLITE_KV_CONFIG_CMP_FUNC</name></expr>:</case> <block>{<block_content>
		<comment type="block">/* Default comparison function */</comment>
		<decl_stmt><decl><type><name>ProcCmp</name></type> <name>xCmp</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>ProcCmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>xCmp</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>xCmp</name></name>  <operator>=</operator> <name>xCmp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
									 </block_content>}</block>
	<default>default:</default>
		<comment type="block">/* Unknown OP */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_UNKNOWN</name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Each public cursor is identified by an instance of this structure.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>lhash_kv_cursor</name></name></type> <name>lhash_kv_cursor</name>;</typedef>
<struct>struct <name>lhash_kv_cursor</name>
<block>{
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pStore</name></decl>;</decl_stmt> <comment type="block">/* Must be first */</comment>
	<comment type="block">/* Private fields */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>iState</name></decl>;</decl_stmt>           <comment type="block">/* Current state of the cursor */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>is_first</name></decl>;</decl_stmt>         <comment type="block">/* True to read the database header */</comment>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>        <comment type="block">/* Current cell we are processing */</comment>
	<decl_stmt><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl>;</decl_stmt>   <comment type="block">/* Raw disk page */</comment>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt> <comment type="block">/* Logical to real bucket map */</comment>
}</block>;</struct>
<comment type="block">/* 
 * Possible state of the cursor
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_CURSOR_STATE_NEXT_PAGE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Next page in the list */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_CURSOR_STATE_CELL</name></cpp:macro>      <cpp:value>2</cpp:value></cpp:define> <comment type="block">/* Processing Cell */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HASH_CURSOR_STATE_DONE</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define> <comment type="block">/* Cursor does not point to anything */</comment>
<comment type="block">/*
 * Initialize the cursor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lhInitCursor</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	 <decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pStore</name></name></expr></init></decl>;</decl_stmt>
	 <decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pPtr</name></expr></init></decl>;</decl_stmt>
	 <comment type="block">/* Init */</comment>
	 <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_NEXT_PAGE</name></expr>;</expr_stmt>
	 <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	 <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	 <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRaw</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	 <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>is_first</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Point to the next page on the database.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorNextPage</name><parameter_list>(<parameter><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>pRec</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_DONE</name></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_DONE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>iState</name></name> <operator>==</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pRaw</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Unref this page */</comment>
			<expr_stmt><expr><call><name><name>pCur</name><operator>-&gt;</operator><name>pStore</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pRaw</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Advance the map cursor */</comment>
		<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Not a bug, reverse link */</comment>
		<comment type="block">/* Load the next page on the list */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhLoadPage</name><argument_list>(<argument><expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pStore</name></name></expr></argument>,<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>iReal</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Reflect the change */</comment>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_CELL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRaw</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Empty page, discard this page and continue */</comment>
		<expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Point to the previous page on the database.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorPrevPage</name><parameter_list>(<parameter><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_bmap_rec</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhpage</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>pRec</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pRec</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_DONE</name></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_DONE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>iState</name></name> <operator>==</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pRaw</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Unref this page */</comment>
			<expr_stmt><expr><call><name><name>pCur</name><operator>-&gt;</operator><name>pStore</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pRaw</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Advance the map cursor */</comment>
		<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> <comment type="block">/* Not a bug, reverse link */</comment>
		<comment type="block">/* Load the previous page on the list */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhLoadPage</name><argument_list>(<argument><expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pStore</name></name></expr></argument>,<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>iReal</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Reflect the change */</comment>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_CELL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRaw</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Discard this page and continue */</comment>
		<expr_stmt><expr><call><name><name>pPage</name><operator>-&gt;</operator><name>pHash</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pRaw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Is a valid cursor.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorValid</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pPtr</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>==</operator> <name>L_HASH_CURSOR_STATE_CELL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Point to the first record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorFirst</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pStore</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>is_first</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Read the database header first */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>is_first</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the first map record */</comment>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<comment type="block">/* Load the cells */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCursorNextPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Point to the last record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorLast</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhash_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pStore</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>is_first</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Read the database header first */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>is_first</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the last map record */</comment>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	<comment type="block">/* Load the cells */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCursorPrevPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Reset the cursor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lhCursorReset</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>lhCursorFirst</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Point to the next record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorNext</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Load the cells of the next page  */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCursorNextPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Load the cells of the next page  */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCursorNextPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Point to the previous record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorPrev</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Load the cells of the previous page  */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCursorPrevPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Load the cells of the previous page  */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhCursorPrevPage</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return key length.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorKeyLength</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid state */</comment>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target cell */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<comment type="block">/* Return key length */</comment>
	<expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pCell</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return data length.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorDataLength</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,<parameter><decl><type><name>unqlite_int64</name> <modifier>*</modifier></type><name>pLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid state */</comment>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target cell */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<comment type="block">/* Return data length */</comment>
	<expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <operator>(</operator><name>unqlite_int64</name><operator>)</operator><name><name>pCell</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Consume the key.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorKey</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid state */</comment>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target cell */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Consume the key directly */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Very large key */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhConsumeCellkey</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>xConsumer</name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Consume the data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorData</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid state */</comment>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target cell */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<comment type="block">/* Consume the data */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhConsumeCellData</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>,<argument><expr><name>xConsumer</name></expr></argument>,<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Find a partiuclar record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorSeek</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Perform a lookup */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRecordLookup</name><argument_list>(<argument><expr><operator>(</operator><name>lhash_kv_engine</name> <operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pStore</name></name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_DONE</name></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>L_HASH_CURSOR_STATE_CELL</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Remove a particular record.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lhCursorDelete</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lhash_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lhash_kv_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lhcell</name> <modifier>*</modifier></type><name>pCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>L_HASH_CURSOR_STATE_CELL</name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid state */</comment>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target cell  */</comment>
	<expr_stmt><expr><name>pCell</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name></expr>;</expr_stmt>
	<comment type="block">/* Point to the next entry */</comment>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCell</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the deletion */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lhRecordRemove</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Export the linear-hash storage engine.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <specifier>const</specifier> <name>unqlite_kv_methods</name> <modifier>*</modifier></type> <name>unqliteExportDiskKvStorage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unqlite_kv_methods</name></type> <name>sDiskStore</name> <init>= <expr><block>{
		<expr><literal type="string">"hash"</literal></expr>,                     <comment type="block">/* zName */</comment>
		<expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhash_kv_engine</name></expr></argument>)</argument_list></sizeof></expr>,    <comment type="block">/* szKv */</comment>
		<expr><sizeof>sizeof<argument_list>(<argument><expr><name>lhash_kv_cursor</name></expr></argument>)</argument_list></sizeof></expr>,    <comment type="block">/* szCursor */</comment>
		<expr><literal type="number">1</literal></expr>,                          <comment type="block">/* iVersion */</comment>
		<expr><name>lhash_kv_init</name></expr>,              <comment type="block">/* xInit */</comment>
		<expr><name>lhash_kv_release</name></expr>,           <comment type="block">/* xRelease */</comment>
		<expr><name>lhash_kv_config</name></expr>,            <comment type="block">/* xConfig */</comment>
		<expr><name>lhash_kv_open</name></expr>,              <comment type="block">/* xOpen */</comment>
		<expr><name>lhash_kv_replace</name></expr>,           <comment type="block">/* xReplace */</comment>
		<expr><name>lhash_kv_append</name></expr>,            <comment type="block">/* xAppend */</comment>
		<expr><name>lhInitCursor</name></expr>,               <comment type="block">/* xCursorInit */</comment>
		<expr><name>lhCursorSeek</name></expr>,               <comment type="block">/* xSeek */</comment>
		<expr><name>lhCursorFirst</name></expr>,              <comment type="block">/* xFirst */</comment>
		<expr><name>lhCursorLast</name></expr>,               <comment type="block">/* xLast */</comment>
		<expr><name>lhCursorValid</name></expr>,              <comment type="block">/* xValid */</comment>
		<expr><name>lhCursorNext</name></expr>,               <comment type="block">/* xNext */</comment>
		<expr><name>lhCursorPrev</name></expr>,               <comment type="block">/* xPrev */</comment>
		<expr><name>lhCursorDelete</name></expr>,             <comment type="block">/* xDelete */</comment>
		<expr><name>lhCursorKeyLength</name></expr>,          <comment type="block">/* xKeyLength */</comment>
		<expr><name>lhCursorKey</name></expr>,                <comment type="block">/* xKey */</comment>
		<expr><name>lhCursorDataLength</name></expr>,         <comment type="block">/* xDataLength */</comment>
		<expr><name>lhCursorData</name></expr>,               <comment type="block">/* xData */</comment>
		<expr><name>lhCursorReset</name></expr>,              <comment type="block">/* xReset */</comment>
		<expr><literal type="number">0</literal></expr>                           <comment type="block">/* xRelease */</comment>                        
	}</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>&amp;</operator><name>sDiskStore</name></expr>;</return>
</block_content>}</block></function>
</unit>
