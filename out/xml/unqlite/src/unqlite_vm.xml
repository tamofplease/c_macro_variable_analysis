<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/unqlite_vm.c"><comment type="block">/*
 * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.
 * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/
 * Version 1.1.6
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://unqlite.org/licensing.html
 */</comment>
 <comment type="block">/* $SymiscID: unqlite_vm.c v1.0 Win7 2013-01-29 23:37 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unqliteInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* This file deals with low level stuff related to the unQLite Virtual Machine */</comment>

<comment type="block">/* Record ID as a hash value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COL_RECORD_HASH</name><parameter_list>(<parameter><type><name>RID</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RID)</cpp:value></cpp:define>
<comment type="block">/*
 * Fetch a record from a given collection.
 */</comment>
<function><type><specifier>static</specifier> <name>unqlite_col_record</name> <modifier>*</modifier></type> <name>CollectionCacheFetchRecord</name><parameter_list>(
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>      <comment type="block">/* Unique record ID */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name><index>[<expr><call><name>COL_RECORD_HASH</name><argument_list>(<argument><expr><name>nId</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nId</name></name> <operator>==</operator> <name>nId</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Record found */</comment>
			<return>return <expr><name>pEntry</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>

	</block_content>}</block></for>
	<comment type="block">/* No such record */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Install a freshly created record in a given collection. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionCacheInstallRecord</name><parameter_list>(
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>,     <comment type="block">/* Unique record ID */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>  <comment type="block">/* JSON value */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier></type><name>pRecord</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<comment type="block">/* Fetch the record first */</comment>
	<expr_stmt><expr><name>pRecord</name> <operator>=</operator> <call><name>CollectionCacheFetchRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRecord</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Record already installed, overwrite its old value  */</comment>
		<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pRecord</name><operator>-&gt;</operator><name>sValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a new instance */</comment>
	<expr_stmt><expr><name>pRecord</name> <operator>=</operator> <operator>(</operator><name>unqlite_col_record</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRecord</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pRecord</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pJx9Vm</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pRecord</name><operator>-&gt;</operator><name>sValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pRecord</name><operator>-&gt;</operator><name>sValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRecord</name><operator>-&gt;</operator><name>nId</name></name> <operator>=</operator> <name>nId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRecord</name><operator>-&gt;</operator><name>pCol</name></name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
	<comment type="block">/* Install in the corresponding bucket */</comment>
	<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <call><name>COL_RECORD_HASH</name><argument_list>(<argument><expr><name>nId</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRecord</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pRecord</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pRecord</name></expr>;</expr_stmt>
	<comment type="block">/* Link */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>,<argument><expr><name>pRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name> <operator>&gt;=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allocate a new larger table */</comment>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>unqlite_col_record</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col_record</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apNew</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Zero the new table */</comment>
			<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col_record</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Rehash all entries */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<comment type="block">/* Loop one */</comment>
				<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* Install in the new bucket */</comment>
				<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <call><name>COL_RECORD_HASH</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nId</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>  )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				<comment type="block">/* Point to the next entry */</comment>
				<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Release the old table and reflect the change */</comment>
			<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Remove a record from the collection table.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionCacheRemoveRecord</name><parameter_list>(
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>      <comment type="block">/* Unique record ID */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier></type><name>pRecord</name></decl>;</decl_stmt>
	<comment type="block">/* Fetch the record first */</comment>
	<expr_stmt><expr><name>pRecord</name> <operator>=</operator> <call><name>CollectionCacheFetchRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRecord</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* No such record */</comment>
		<return>return <expr><name>UNQLITE_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pRecord</name><operator>-&gt;</operator><name>pPrevCol</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pRecord</name><operator>-&gt;</operator><name>pPrevCol</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pRecord</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name> <init>= <expr><call><name>COL_RECORD_HASH</name><argument_list>(<argument><expr><name>nId</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name><name>pRecord</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pRecord</name><operator>-&gt;</operator><name>pNextCol</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pRecord</name><operator>-&gt;</operator><name>pNextCol</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <name><name>pRecord</name><operator>-&gt;</operator><name>pPrevCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Unlink */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>,<argument><expr><name>pRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name><operator>--</operator></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Discard a collection and its records.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionCacheRelease</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier></type><name>pNext</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pRec</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Discard all records */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRec</name><operator>-&gt;</operator><name>sValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Point to the next record */</comment>
		<expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Install a freshly created collection in the unqlite VM.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteVmInstallCollection</name><parameter_list>(
	<parameter><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>,  <comment type="block">/* Target VM */</comment>
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter> <comment type="block">/* Collection to install */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name></decl>;</decl_stmt>
	<comment type="block">/* Hash the collection name */</comment>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <call><name>SyBinHash</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Install it in the corresponding bucket */</comment>
	<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pVm</name><operator>-&gt;</operator><name>iColSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pVm</name><operator>-&gt;</operator><name>apCol</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pVm</name><operator>-&gt;</operator><name>apCol</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>apCol</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>apCol</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
	<comment type="block">/* Link to the list of active collections */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>iCol</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pVm</name><operator>-&gt;</operator><name>iCol</name></name> <operator>&gt;=</operator> <name><name>pVm</name><operator>-&gt;</operator><name>iColSize</name></name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pVm</name><operator>-&gt;</operator><name>iCol</name></name> <operator>&lt;</operator> <literal type="number">10000</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Grow the hashtable */</comment>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pVm</name><operator>-&gt;</operator><name>iColSize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>unqlite_col</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apNew</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Zero the new table */</comment>
			<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Rehash all entries */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pVm</name><operator>-&gt;</operator><name>pCol</name></name></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<comment type="block">/* Loop one */</comment>
				<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pVm</name><operator>-&gt;</operator><name>iCol</name></name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* Install in the new bucket */</comment>
				<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>  )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCol</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				<comment type="block">/* Point to the next entry */</comment>
				<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Release the old table and reflect the change */</comment>
			<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pVm</name><operator>-&gt;</operator><name>apCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>apCol</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>iColSize</name></name>  <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Fetch a collection from the target VM.
 */</comment>
<function><type><specifier>static</specifier> <name>unqlite_col</name> <modifier>*</modifier></type> <name>unqliteVmFetchCollection</name><parameter_list>(
	<parameter><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>, <comment type="block">/* Target VM */</comment>
	<parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>  <comment type="block">/* Lookup name */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pVm</name><operator>-&gt;</operator><name>iCol</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name>SyBinHash</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the lookup */</comment>
	<expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pVm</name><operator>-&gt;</operator><name>apCol</name><index>[<expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator> <name><name>pVm</name><operator>-&gt;</operator><name>iColSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pCol</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nHash</name> <operator>==</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;&amp;</operator> <call><name>SyStringCmp</name><argument_list>(<argument><expr><name>pName</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>,<argument><expr><name>SyMemcmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Collection found */</comment>
			<return>return <expr><name>pCol</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such collection */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write and/or alter collection binary header.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionSetHeader</name><parameter_list>(
	<parameter><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl></parameter>, <comment type="block">/* Underlying KV storage engine */</comment>
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,          <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>iRec</name></decl></parameter>,             <comment type="block">/* Last record ID */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>iTotal</name></decl></parameter>,           <comment type="block">/* Total number of records in this collection */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pSchema</name></decl></parameter>          <comment type="block">/* Collection schema */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pHeader</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sHeader</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pEngine</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Default storage engine */</comment>
		<expr_stmt><expr><name>pEngine</name> <operator>=</operator> <call><name>unqlitePagerGetKvEngine</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pCreate</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sCreation</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Creation time */</comment>
		<decl_stmt><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>iDos</name></decl>;</decl_stmt>
		<comment type="block">/* Magic number */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppendBig16</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>,<argument><expr><name>UNQLITE_COLLECTION_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Initial record ID */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppendBig64</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Total records in the collection */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppendBig64</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pVfs</name> <operator>=</operator> <operator>(</operator><name>unqlite_vfs</name> <operator>*</operator><operator>)</operator><call><name>unqliteExportBuiltinVfs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Creation time of the collection */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Get the creation time */</comment>
			<expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>,<argument><expr><name>pCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Zero the structure */</comment>
			<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pCreate</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Sytm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Convert to DOS time */</comment>
		<expr_stmt><expr><call><name>SyTimeFormatToDos</name><argument_list>(<argument><expr><name>pCreate</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iDos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppendBig32</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>,<argument><expr><name>iDos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Offset to start writing collection schema */</comment>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nSchemaOfft</name></name> <operator>=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iWrite</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBinary</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Header update */</comment>
		<if_stmt><if>if<condition>( <expr><name>iRec</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Update record ID */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBinary</name><index>[<expr><literal type="number">2</literal></expr><comment type="block">/* Magic number*/</comment>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu64</name><operator>)</operator><name>iRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>iWrite</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>iTotal</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Total records */</comment>
			<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBinary</name><index>[<expr><literal type="number">2</literal><comment type="block">/* Magic number*/</comment><operator>+</operator><literal type="number">8</literal></expr><comment type="block">/* Record ID*/</comment>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu64</name><operator>)</operator><name>iTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>iWrite</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>pSchema</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Collection Schema */</comment>
			<expr_stmt><expr><call><name>SyBlobTruncate</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nSchemaOfft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Encode the schema to FastJson */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>FastJsonEncode</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>,<argument><expr><name>pHeader</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Copy the collection schema */</comment>
			<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>iWrite</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iWrite</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pId</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Reflect the disk and/or in-memory image */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xReplace</name></name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,
			<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pId</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pId</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>,
			<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"Cannot save collection '%z' header in the underlying storage engine"</literal></expr></argument>,
				<argument><expr><name>pId</name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Load a binary collection from disk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionLoadHeader</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pHeader</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sHeader</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nMagic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iDos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Read the binary header */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_data_callback</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>,<argument><expr><name>unqliteDataConsumer</name></expr></argument>,<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform a sanity check */</comment>
	<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><literal type="number">2</literal> <comment type="block">/* magic */</comment> <operator>+</operator> <literal type="number">8</literal> <comment type="block">/* record_id */</comment> <operator>+</operator> <literal type="number">8</literal> <comment type="block">/* total_records */</comment><operator>+</operator> <literal type="number">4</literal> <comment type="block">/* DOS creation time*/</comment><operator>)</operator></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zRaw</name><index>[<expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the magic number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nMagic</name> <operator>!=</operator> <name>UNQLITE_COLLECTION_MAGIC</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* sizeof(sxu16) */</comment>
	<comment type="block">/* Extract the record ID */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu64</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* sizeof(sxu64) */</comment>
	<comment type="block">/* Total records in the collection */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu64</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract the collection creation date (DOS) */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* sizeof(sxu64) */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iDos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyDosTimeFormat</name><argument_list>(<argument><expr><name>iDos</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sCreation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* Check for a collection schema */</comment>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nSchemaOfft</name></name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zRaw</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zRaw</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Decode the FastJson value */</comment>
		<expr_stmt><expr><call><name>FastJsonDecode</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zRaw</name><operator>)</operator></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sSchema</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Load or create a binary collection.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteVmLoadCollection</name><parameter_list>(
	<parameter><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>,    <comment type="block">/* Target VM */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,  <comment type="block">/* Collection name */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>,        <comment type="block">/* zName length */</comment>
	<parameter><decl><type><name>int</name></type> <name>iFlag</name></decl></parameter>,          <comment type="block">/* Control flag */</comment>
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter> <comment type="block">/* OUT: in-memory collection */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SXERR_MEM</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Point to the underlying KV store */</comment>
	<expr_stmt><expr><name>pEngine</name> <operator>=</operator> <call><name>unqlitePagerGetKvEngine</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
	<comment type="block">/* Allocate a new cursor */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteInitCursor</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>iFlag</name> <operator>&amp;</operator> <name>UNQLITE_VM_COLLECTION_CREATE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Seek to the desired location */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xSeek</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zName</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr></argument>,<argument><expr><name>UNQLITE_CURSOR_MATCH_EXACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iFlag</name> <operator>&amp;</operator> <name>UNQLITE_VM_COLLECTION_EXISTS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><literal type="string">"Collection '%.*s' not defined in the underlying database"</literal></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unqliteReleaseCursor</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><operator>(</operator><name>iFlag</name> <operator>&amp;</operator> <name>UNQLITE_VM_COLLECTION_EXISTS</name><operator>)</operator></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>unqliteReleaseCursor</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a new instance */</comment>
	<expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>(</operator><name>unqlite_col</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCol</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sHeader</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name></name> <operator>=</operator> <name>pVm</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name>pCursor</name></expr>;</expr_stmt>
	<comment type="block">/* Duplicate collection name */</comment>
	<expr_stmt><expr><name>zDup</name> <operator>=</operator> <call><name>SyMemBackendStrDup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zDup</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt> <comment type="block">/* Must be a power of two */</comment>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name> <operator>=</operator> <operator>(</operator><name>unqlite_col_record</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col_record</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the table */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nRecSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_col_record</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>,<argument><expr><name>zDup</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>pJx9Vm</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iFlag</name> <operator>&amp;</operator> <name>UNQLITE_VM_COLLECTION_CREATE</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Create a new collection */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xReplace</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Read-only KV engine: Generate an error message and return */</comment>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,
				<argument><expr><literal type="string">"Cannot create new collection '%z' due to a read-only Key/Value storage engine"</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_ABORT</name></expr>;</expr_stmt> <comment type="block">/* Abort VM execution */</comment>
			<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Write the collection header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionSetHeader</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_ABORT</name></expr>;</expr_stmt> <comment type="block">/* Abort VM execution */</comment>
			<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Read the collection header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionLoadHeader</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><literal type="string">"Corrupt collection '%z' header"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Finally install the collection */</comment>
	<expr_stmt><expr><call><name>unqliteVmInstallCollection</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<if_stmt><if>if<condition>( <expr><name>ppOut</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>unqliteReleaseCursor</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zDup</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><name>zDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pCol</name><operator>-&gt;</operator><name>apRecord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Fetch a collection.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>unqlite_col</name> <modifier>*</modifier></type> <name>unqliteCollectionFetch</name><parameter_list>(
	<parameter><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>, <comment type="block">/* Target VM */</comment>
	<parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>, <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>int</name></type> <name>iFlag</name></decl></parameter>        <comment type="block">/* Control flag */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Check if the collection is already loaded in memory */</comment>
	<expr_stmt><expr><name>pCol</name> <operator>=</operator> <call><name>unqliteVmFetchCollection</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Already loaded in memory*/</comment>
		<return>return <expr><name>pCol</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>iFlag</name> <operator>&amp;</operator> <name>UNQLITE_VM_AUTO_LOAD</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Ask the storage engine for the collection */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteVmLoadCollection</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return to the caller */</comment>
	<return>return <expr><ternary><condition><expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> ?</condition><then> <expr><name>pCol</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return the unique ID of the last inserted record.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>jx9_int64</name></type> <name>unqliteCollectionLastRecordId</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return the current record ID.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>jx9_int64</name></type> <name>unqliteCollectionCurrentRecordId</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>pCol</name><operator>-&gt;</operator><name>nCurid</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return the total number of records in a given collection. 
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>jx9_int64</name></type> <name>unqliteCollectionTotalRecords</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Reset the record cursor.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>void</name></type> <name>unqliteCollectionResetRecordCursor</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nCurid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Fetch a record by its unique ID.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionFetchRecordById</name><parameter_list>(
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>,     <comment type="block">/* Unique record ID */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>  <comment type="block">/* OUT: record value */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_col_record</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>jx9_value_null</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform a cache lookup first */</comment>
	<expr_stmt><expr><name>pRec</name> <operator>=</operator> <call><name>CollectionCacheFetchRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pRec</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Copy record value */</comment>
		<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRec</name><operator>-&gt;</operator><name>sValue</name></name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Reset the working buffer */</comment>
	<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Generate the unique ID */</comment>
	<expr_stmt><expr><call><name>SyBlobFormat</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><literal type="string">"%z_%qd"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reset the cursor */</comment>
	<expr_stmt><expr><call><name>unqlite_kv_cursor_reset</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Seek the cursor to the desired location */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_seek</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>,
		<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>UNQLITE_CURSOR_MATCH_EXACT</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Consume the binary JSON */</comment>
	<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unqlite_kv_cursor_data_callback</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>,<argument><expr><name>unqliteDataConsumer</name></expr></argument>,<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
			<argument><expr><literal type="string">"Empty record '%qd'"</literal></expr></argument>,<argument><expr><name>nId</name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_value_null</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Decode the binary JSON */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>FastJsonDecode</name><argument_list>(<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>pValue</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Install the record in the cache */</comment>
			<expr_stmt><expr><call><name>CollectionCacheInstallRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Fetch the next record from a given collection.
 */</comment> 
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionFetchNextRecord</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>nCurid</name></name> <operator>&gt;=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more records, reset the record cursor ID */</comment>
			<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nCurid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* Return to the caller */</comment>
			<return>return <expr><name>SXERR_EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteCollectionFetchRecordById</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nCurid</name></name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Increment the record ID */</comment>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nCurid</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Lookup result */</comment>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name> <operator>||</operator> <name>rc</name> <operator>!=</operator> <name>UNQLITE_NOTFOUND</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Judge a collection whether exists
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteExistsCollection</name><parameter_list>(
    <parameter><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>, <comment type="block">/* Target VM */</comment>
    <parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>  <comment type="block">/* Collection name */</comment>
    )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <comment type="block">/* Perform a lookup first */</comment>
    <expr_stmt><expr><name>pCol</name> <operator>=</operator> <call><name>unqliteVmFetchCollection</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Already loaded in memory*/</comment>
        <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteVmLoadCollection</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>,<argument><expr><name>UNQLITE_VM_COLLECTION_EXISTS</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Create a new collection.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCreateCollection</name><parameter_list>(
	<parameter><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>, <comment type="block">/* Target VM */</comment>
	<parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>  <comment type="block">/* Collection name */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Perform a lookup first */</comment>
	<expr_stmt><expr><name>pCol</name> <operator>=</operator> <call><name>unqliteCollectionFetch</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name>pName</name></expr></argument>,<argument><expr><name>UNQLITE_VM_AUTO_LOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_EXISTS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Now, safely create the collection */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteVmLoadCollection</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>,<argument><expr><name>UNQLITE_VM_COLLECTION_CREATE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Set a schema (JSON object) for a given collection.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionSetSchema</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Must be a JSON object */</comment>
		<return>return <expr><name>SXERR_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionSetHeader</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>pCol</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a store operation on a given collection.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionStore</name><parameter_list>(
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>  <comment type="block">/* JSON value to be stored */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>	
	<comment type="block">/* Point to the underlying KV store */</comment>
	<expr_stmt><expr><name>pEngine</name> <operator>=</operator> <call><name>unqlitePagerGetKvEngine</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name> <operator>&gt;=</operator> <name>SXI64_HIGH</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Collection limit reached. No more records */</comment>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"Collection '%z': Records limit reached"</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_LIMIT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xReplace</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"Cannot store record into collection '%z' due to a read-only Key/Value storage engine"</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_READ_ONLY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Reset the working buffer */</comment>
	<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>jx9_value</name></type> <name>sId</name></decl>;</decl_stmt>
		<comment type="block">/* If the given type is a JSON object, then add the special __id field */</comment>
		<expr_stmt><expr><call><name>jx9MemObjInitFromInt</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pJx9Vm</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sId</name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><literal type="string">"__id"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>sId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Prepare the unique ID for this record */</comment>
	<expr_stmt><expr><call><name>SyBlobFormat</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><literal type="string">"%z_%qd"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nKeyLen</name> <operator>=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nKeyLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Turn to FastJson */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>FastJsonEncode</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally perform the insertion */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xReplace</name></name><argument_list>(
		<argument><expr><name>pEngine</name></expr></argument>,
		<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,
		<argument><expr><call><name>SyBlobDataAt</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call><operator>-</operator><name>nKeyLen</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Save the value in the cache */</comment>
		<expr_stmt><expr><call><name>CollectionCacheInstallRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Increment the unique __id */</comment>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Reflect the change */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionSetHeader</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"IO error while storing record into collection '%z'"</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a update operation on a given collection.
 */</comment>
 <function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionUpdate</name><parameter_list>(
                           <parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <comment type="block">/* Target collection */</comment>
                           <parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>,     <comment type="block">/* Record ID */</comment>
                           <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>  <comment type="block">/* JSON value to be stored */</comment>
)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <comment type="block">/* Point to the underlying KV store */</comment>
    <expr_stmt><expr><name>pEngine</name> <operator>=</operator> <call><name>unqlitePagerGetKvEngine</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name> <operator>&gt;=</operator> <name>SXI64_HIGH</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Collection limit reached. No more records */</comment>
        <expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
                              <argument><expr><literal type="string">"Collection '%z': Records limit reached"</literal></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
                              )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>UNQLITE_LIMIT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xReplace</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
                              <argument><expr><literal type="string">"Cannot store record into collection '%z' due to a read-only Key/Value storage engine"</literal></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
                              )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>UNQLITE_READ_ONLY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Reset the working buffer */</comment>
    <expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Prepare the unique ID for this record */</comment>
    <expr_stmt><expr><call><name>SyBlobFormat</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><literal type="string">"%z_%qd"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>, <argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset the cursor */</comment>
    <expr_stmt><expr><call><name>unqlite_kv_cursor_reset</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Seek the cursor to the desired location */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_seek</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>,
                                <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>UNQLITE_CURSOR_MATCH_EXACT</name></expr></argument>
                                )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
                              <argument><expr><literal type="string">"No record to update in collection '%z'"</literal></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
                              )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>jx9_value</name></type> <name>sId</name></decl>;</decl_stmt>
        <comment type="block">/* If the given type is a JSON object, then add the special __id field */</comment>
        <expr_stmt><expr><call><name>jx9MemObjInitFromInt</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pJx9Vm</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sId</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><literal type="string">"__id"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>sId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>nKeyLen</name> <operator>=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nKeyLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Turn to FastJson */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>FastJsonEncode</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Finally perform the insertion */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xReplace</name></name><argument_list>(
                            <argument><expr><name>pEngine</name></expr></argument>,
                            <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>,
                            <argument><expr><call><name>SyBlobDataAt</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call><operator>-</operator><name>nKeyLen</name></expr></argument>
                            )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Save the value in the cache */</comment>
        <expr_stmt><expr><call><name>CollectionCacheInstallRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
                              <argument><expr><literal type="string">"IO error while storing record into collection '%z'"</literal></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
                              )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Array walker callback (Refer to jx9_array_walk()).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CollectionRecordArrayWalker</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>(</operator><name>unqlite_col</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Perform the insertion */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionStore</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a store operation on a given collection.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionPut</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iFlag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Iterate over the array and store its members in the collection */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9_array_walk</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><name>CollectionRecordArrayWalker</name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>iFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionStore</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Drop a record from a given collection.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionDropRecord</name><parameter_list>(
	<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,  <comment type="block">/* Target collection */</comment>
	<parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>,      <comment type="block">/* Unique ID of the record to be droped */</comment>
	<parameter><decl><type><name>int</name></type> <name>wr_header</name></decl></parameter>,      <comment type="block">/* True to alter collection header */</comment>
	<parameter><decl><type><name>int</name></type> <name>log_err</name></decl></parameter>         <comment type="block">/* True to log error */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>		
	<comment type="block">/* Reset the working buffer */</comment>
	<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Prepare the unique ID for this record */</comment>
	<expr_stmt><expr><call><name>SyBlobFormat</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>,<argument><expr><literal type="string">"%z_%qd"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reset the cursor */</comment>
	<expr_stmt><expr><call><name>unqlite_kv_cursor_reset</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Seek the cursor to the desired location */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_seek</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>,
		<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>UNQLITE_CURSOR_MATCH_EXACT</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Remove the record from the storage engine */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_delete_entry</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Finally, Remove the record from the cache */</comment>
	<expr_stmt><expr><call><name>unqliteCollectionCacheRemoveRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>wr_header</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Relect in the collection header */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionSetHeader</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>pCol</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>nTotRec</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_NOTIMPLEMENTED</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>log_err</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"Cannot delete record from collection '%z' due to a read-only Key/Value storage engine"</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Update a given record with new data
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteCollectionUpdateRecord</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,<parameter><decl><type><name>jx9_int64</name></type> <name>nId</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iFlag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* Iterate over the array and store its members in the collection */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9_array_walk</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>,<argument><expr><name>CollectionRecordArrayWalker</name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>iFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CollectionUpdate</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>,<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Drop a collection from the KV storage engine and the underlying
 * unqlite VM.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteDropCollection</name><parameter_list>(<parameter><decl><type><name>unqlite_col</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_vm</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>nId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Reset the cursor */</comment>
	<expr_stmt><expr><call><name>unqlite_kv_cursor_reset</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Seek the cursor to the desired location */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_seek</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>,
		<argument><expr><call><name>SyStringData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyStringLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>UNQLITE_CURSOR_MATCH_EXACT</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Remove the record from the storage engine */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_cursor_delete_entry</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"Cannot remove collection '%z' due to a read-only Key/Value storage engine"</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Drop collection records */</comment>
	<for>for<control>( <init><expr><name>nId</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>nId</name> <operator>&lt;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>nLastid</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>nId</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteCollectionDropRecord</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><name>nId</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>CollectionCacheRelease</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>SyStringData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>sName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unqliteReleaseCursor</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Unlink */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>pPrevCol</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pPrevCol</name><operator>-&gt;</operator><name>pNextCol</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pVm</name><operator>-&gt;</operator><name>iColSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>apCol</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>pNextCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>pNextCol</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pNextCol</name><operator>-&gt;</operator><name>pPrevCol</name></name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>pPrevCol</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pVm</name><operator>-&gt;</operator><name>iCol</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAlloc</name></name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
